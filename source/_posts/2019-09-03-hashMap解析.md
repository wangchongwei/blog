---
title: hashMap解析
date: 2019-09-03 14:01:51
tags: java
---

# HashMap源码分析

### Hash内部类Node：
Node(节点)，链表中的节点，当HashMap数据少于6条时，为链表结构，Node为其中的节点。
链表数据结构，每一个节点都记录下一个节点的地址。
在Node的构造函数中，直接包含了下一个节点，
```
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        // 将下一个节点作为入参放入构造函数中
        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    ....

```

获取某个节点
```

 public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab;
        Node<K,V> first, e;
        int n;
        K k;
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                // 当为树结构的时候
                if (first instanceof TreeNode)
                // 获取树形结构中某个节点
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                // 遍历链表结构    
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }

```




HashMap底部是数组，数组中存放链表，当链表长度大于6时，转为红黑树


put：初始化table[],使用时再初始化，避免内存。

根据k获取hash，hash & length 获取 index，放入数组指定下标的链表，链表超长6时，转为红黑树

hash & length 使用位运算符，因为位运算符快，cpu指令就是基于位运算符，

扩容：hashmap的初识容量是16，每次扩容 * 2， 为何容量取 2的次方，因为这样在位运算时，让每一位都能使用到，效率最高，而且这样保证位运算结果与取模结果一致。

加载因子：默认0.75，因为大量测试表面。0。6-0.75最佳，0.75保证在该范围内存使用率最高。
加载因子过大时，会让hash碰撞概率增加，降低hashmap使用效率。

hashmap使用缺点：内存使用率最高也只有75%， hash碰撞，极端情况退化为单链表。用空间换时间。

可以使用其他数据类型替代：
SparseArray： 双数组结构，key，value分别使用数组存储， 但SparseArray的key只能为int，
有序，通过二分查找来定位元素。
用时间换空间。
缺点： key值只能是int类型

ArrayMap：sdk 19引入，双数组结果，key值可以为任何类型，根据key获取hash，就和SparseArray类型一致了。
Bundle内部就是使用ArrayMap




