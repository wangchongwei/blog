---
title: androidæ¶ˆæ¯æœºåˆ¶
date: 2020-11-24 11:09:22
tags: android
---

# android æ¶ˆæ¯æœºåˆ¶

åœ¨ andorid ä¸­ï¼Œç³»ç»Ÿçš„è¡Œä¸ºã€ç”¨æˆ·çš„è¾“å…¥ç­‰äº‹ä»¶éƒ½ä¼šè¢«åŒ…è£…ä¸ºä¸€ä¸ªæ¶ˆæ¯ï¼Œ
è¿›è¡Œæ¶ˆæ¯å‘é€ã€å¤„ç†

å…³äºæ¶ˆæ¯çš„å¤„ç†ï¼Œå°±ç¦»ä¸å¼€ Handlerã€Messageã€Loop
åœ¨å¹³æ—¶ä½¿ç”¨æ—¶ï¼ŒHandler å¤šç”¨äºå¤šçº¿ç¨‹ä¹‹é—´é€šä¿¡ã€‚

- é‚£ä¹ˆ Handler å¦‚ä½•å®ç°å¤šçº¿ç¨‹é€šä¿¡ï¼Ÿ
- å¤šçº¿ç¨‹ä¹‹é—´ä¸ºä½•ä¸ä¼šäº’ç›¸å¹²æ‰°ï¼Ÿ
- ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ç”¨ wait/notifyï¼Ÿ

## Handler å¤šçº¿ç¨‹é€šä¿¡

å…ˆçœ‹ä¸€ä¸‹æ™®é€šä½¿ç”¨æ¡ˆä¾‹

```java
public class MyActiivty extends Activity {

    private Handler myHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
                if(msg.what=100) {
                    // TODO
                }
            }
        };
    }

    static class MyThread extends Thread {
        @Overtide
        public void run() {
            super.run();
            Message message = Message.obtain();
            message.what = 100;
            myHandler.sendMessage();
        }
    }

}
```

ä¸Šé¢å°±æ˜¯ä¸€ä¸ªç®€å•çš„åœ¨å­çº¿ç¨‹å‘é€æ¶ˆæ¯ï¼Œå›åˆ°ä¸»çº¿ç¨‹å¤„ç†æ¶ˆæ¯çš„è¿‡ç¨‹ï¼Œ
é€šè¿‡åœ¨å­çº¿ç¨‹æ„é€ ä¸€ä¸ª message å¯¹è±¡ï¼Œåœ¨ä¸»çº¿ç¨‹ä¸­è·å–åˆ°è¯¥ message å¯¹è±¡ï¼Œæ¥å¤„ç†æ¶ˆæ¯ã€‚
--------------------------------------------
> æ‰€ä»¥å…¶å® Handler å¤„ç†å¤šçº¿ç¨‹é€šä¿¡æ˜¯é€šè¿‡å…±äº« Message å¯¹è±¡å†…å­˜æ¥å®ç°çš„ã€‚
> å†…å­˜æ˜¯ä¸åŒºåˆ†çº¿ç¨‹çš„ï¼Œè¿™ç§é€šä¿¡åŸç†å°±æ˜¯åœ¨å­çº¿ç¨‹ä¸ä¸»çº¿ç¨‹å…±äº« message å†…å­˜

> æ‰€ä»¥ é‚£ä¹ˆ Handler å¦‚ä½•å®ç°å¤šçº¿ç¨‹é€šä¿¡ï¼Ÿ
> é€šè¿‡ å†…å­˜å…±äº« å®ç°ã€‚

åœ¨å¤šçº¿ç¨‹æ—¶ï¼ŒHandler åˆæ˜¯å¦‚ä½•ä¿è¯æ¶ˆæ¯å¦‚ä½•åœ¨æ­£ç¡®çš„çº¿ç¨‹å‘é€çš„å‘¢ï¼Œæˆ–è€…è¯´æ˜¯å¦‚ä½•ä¿è¯æ‰§è¡Œçš„çº¿ç¨‹æ˜¯æ­£ç¡®çš„äº†ã€‚
è¿™å°±è¦å¼•å…¥æˆ‘ä»¬çš„ Loopã€æ¶ˆæ¯é˜Ÿåˆ—æ¦‚å¿µäº†ã€‚

handler å¤„ç†æ¶ˆæ¯æ¨¡å‹:

<img src='../../../images/looper.png' style="zoom:60%" />

handler è´Ÿè´£å‘é€ã€å¤„ç†æ¶ˆæ¯
looper è´Ÿè´£ä¸€ç›´è½®è¯¢æ¶ˆæ¯
messageQueue æ¶ˆæ¯é˜Ÿåˆ—ï¼Œè´Ÿè´£å­˜æ”¾ã€å–å‡ºæ¶ˆæ¯


ä»¥ä¸‹ä»¥API 31ä¸ºä¾‹

## Handler

æ¶ˆæ¯çš„å‘é€ã€å¤„ç†

### æ¶ˆæ¯çš„å‘é€

å‡ ä¸ªpublicçš„å‘é€æ¶ˆæ¯çš„å‡½æ•°
* sendMessage
* sendMessageDelayed
* sendMessageAtTime
* sendMessageAtFrontOfQueue

sendEmptyMessage*** å‡½æ•°ä¸è¿›è¡Œé¢å¤–è®²è§£ï¼Œ

```java
    public final boolean sendMessage(@NonNull Message msg) {
        return sendMessageDelayed(msg, 0);
    }

    public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {
        if (delayMillis < 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

    public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
            this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }

    private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
        long uptimeMillis) {
        // è®¾ç½®messageçš„targetä¸ºå½“å‰çš„handlerå®ä¾‹
        msg.target = this;
        msg.workSourceUid = ThreadLocalWorkSource.getUid();

        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
```
* é€šè¿‡ sendMessage å‘é€æ¶ˆæ¯æ—¶ï¼Œè°ƒç”¨é“¾å¦‚ä¸‹ï¼Œæ­¤æ—¶ uptimeMillis = 0 
sendMessage ->  sendMessageDelayed -> sendMessageAtTime -> enqueueMessage -> queue.enqueueMessage

* é€šè¿‡ sendMessageDelayed å‘é€æ¶ˆæ¯æ—¶ï¼Œå¯ä»¥æŒ‡å®šæ¶ˆæ¯å»¶è¿Ÿçš„æ—¶é—´ (delayMillis)ï¼Œå•ä½ä¸ºæ¯«ç§’ï¼Œ æ­¤æ—¶ uptimeMillis = å½“å‰æ—¶é—´æˆ³ + delayMillis
sendMessageDelayed -> sendMessageAtTime -> enqueueMessage -> queue.enqueueMessage

* é€šè¿‡sendMessageAtTimeï¼Œä¸ sendMessageDelayed ç±»ä¼¼ï¼Œä¸è¿‡ä¸ä¼šè‡ªåŠ¨åŠ å½“å‰æ—¶é—´æˆ³ï¼Œéœ€è¦è‡ªå·±å¤„ç†ã€‚ä¸€èˆ¬æ˜¯ä½¿ç”¨æŸä¸ªæ—¶é—´çš„æ—¶é—´æˆ³

* sendMessageAtFrontOfQueue


```java
    public final boolean sendMessageAtFrontOfQueue(@NonNull Message msg) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, 0);
    }
```
çœ‹å‡½æ•°å­—é¢æ„æ€ï¼Œå‘é€æ¶ˆæ¯åˆ°æ¶ˆæ¯é˜Ÿåˆ—çš„é˜Ÿå¤´
ä¸Šé¢çš„å‡½æ•°å¯ä»¥çœ‹å‡ºï¼Œä¸ sendMessageAtTime å‡½æ•°é€»è¾‘ä¸€è‡´ï¼Œåªæ˜¯å°† uptimeMillis = 0
åé¢ä¼šè®²ä¸ºä½• uptimeMillis = 0æ—¶ï¼Œå¯ä»¥å°†æ¶ˆæ¯ç½®ä¸ºé˜Ÿå¤´


### æ¶ˆæ¯çš„å¤„ç†

ä¼šæ‰§è¡Œ dispatchMessage
```java
    public void dispatchMessage(@NonNull Message msg) {
        // å¦‚æœmessageè®¾ç½®äº†callbackï¼Œåˆ™ä¼šè®©messageçš„callbackå¤„ç†è¯¥æ¶ˆæ¯
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            
            if (mCallback != null) {
                // å¦‚æœhangdlerè®¾ç½®äº†callbackï¼Œå¹¶ä¸”ç»è¿‡callbackå‡½æ•°å¤„ç†è¯¥æ¶ˆæ¯è¿”å›trueï¼Œåˆ™ä¸ç»§ç»­æ‰§è¡Œ
                // åƒæˆ‘ä»¬è‡ªå·±å®ä¾‹è¯handlerï¼Œå‚æ•°é‡Œä¼ å…¥çš„å°±æ˜¯callbackåŒ¿åå†…éƒ¨ç±»
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            // hangdlerçš„handleMesså‡½æ•°å¤„ç†ï¼Œä¸€èˆ¬åªæœ‰åœ¨è‡ªå®šä¹‰è‡ªå·±çš„Handlerï¼Œç»§æ‰¿Handlerï¼Œé‡å†™handlerå‡½æ•°æ‰ä¼šç”¨åˆ°
            handleMessage(msg);
        }
    }
```

#### ä¸ç»è¿‡MessageQueueç›´æ¥å¤„ç†æ¶ˆæ¯

* executeOrSendMessage
```java
    public final boolean executeOrSendMessage(@NonNull Message msg) {
        if (mLooper == Looper.myLooper()) {
            dispatchMessage(msg);
            return true;
        }
        return sendMessage(msg);
    }
```
å½“handlerç»‘å®šçš„looperæ˜¯å½“å‰è¿è¡Œçº¿ç¨‹çš„looperæ—¶ï¼Œåˆ™ä¼šç›´æ¥å¤„ç†è¯¥æ¶ˆæ¯ï¼Œå¦åˆ™è¿˜æ˜¯ä¼šå‘é€æ¶ˆæ¯åˆ° MessageQueue


### å¼‚æ­¥Handler

åœ¨Handlerä¸­çš„æ„é€ å‡½æ•°ä¸­ï¼Œæœ‰ä¸¤ä¸ªæ„é€ å‡½æ•°

* Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async)

* Handler(@Nullable Callback callback, boolean async)

ä¼ å…¥çš„ async å³æ˜¯æ ‡è¯†è¯¥handlerå‘é€çš„æ¶ˆæ¯æ˜¯åŒæ­¥è¿˜æ˜¯å¼‚æ­¥ã€‚

ä½†è¿™ä¸¤ä¸ªæ„é€ å‡½æ•°éƒ½é€‚ç”¨ @UnsupportedAppUsage æ ‡è¯†ï¼Œä¸èƒ½è¢«å¤–éƒ¨è°ƒç”¨ã€‚

æ‰€ä»¥åœ¨æˆ‘ä»¬è‡ªå·±çš„ä»£ç ä¸­ï¼ŒHandleréƒ½æ˜¯åŒæ­¥çš„ï¼Œåªæœ‰åœ¨ framework ä¸­ï¼Œå­˜åœ¨å¼‚æ­¥





## Message

ä¸Šé¢è®²äº†æ¶ˆæ¯æœºåˆ¶ä¸­çš„ Handler
ç°åœ¨æˆ‘ä»¬å†è®²ä¸€ä¸‹æ¶ˆæ¯çš„æœ¬ä½“ Message

Messageä½œä¸ºæ¶ˆæ¯æ•°æ®çš„è½½ä½“ï¼Œæœ¬èº«çš„æ•°æ®ç»“æ„ä¸ºé“¾è¡¨ï¼Œè€Œä¸”æ˜¯åªæœ‰ next æŒ‡é’ˆï¼Œæ‰€ä»¥æ˜¯ä¸ªå•é“¾è¡¨ã€‚

### å¼‚æ­¥æ¶ˆæ¯

Handlerä¸­æœ‰ä¸€ä¸ªåŒå¼‚æ­¥çš„æ ‡è¯†ï¼Œä½†æœ€ç»ˆå…¶å®ä½œç”¨ä¸Messageèº«ä¸Šï¼Œå¼‚æ­¥çš„Handlerä¸­å‘é€çš„æ¶ˆæ¯messageä¹Ÿéƒ½ä¸ºå¼‚æ­¥æ¶ˆæ¯ï¼ŒåŒæ­¥çš„Handlerå‘é€çš„æ¶ˆæ¯messageä¹Ÿéƒ½ä¸ºåŒæ­¥æ¶ˆæ¯

Messageä¸­æœ‰ä¸€ä¸ªå±æ€§ï¼Œflagï¼Œæ ‡è¯†æ¶ˆæ¯æ˜¯å±äºåŒæ­¥æ¶ˆæ¯è¿˜æ˜¯å¼‚æ­¥æ¶ˆæ¯

é€šè¿‡ä»¥ä¸‹å‡½æ•°ä¹Ÿèƒ½è®¾ç½®æ¶ˆæ¯ä¸ºåŒæ­¥æˆ–å¼‚æ­¥ï¼š
* setAsynchronous è®¾ç½®æ¶ˆæ¯
* isAsynchronous è·å–æ¶ˆæ¯æ˜¯åŒæ­¥è¿˜æ˜¯å¼‚æ­¥



### äº«å…ƒæ¨¡å¼

Message ä¸­æ²¡æœ‰ä»€ä¹ˆå¤æ‚æ“ä½œï¼Œéƒ½æ˜¯ä¸€äº›èµ‹å€¼å‡½æ•°
æœ‰ä¸¤ä¸ªåœ°æ–¹å¯ä»¥æ³¨æ„ä¸‹

```java
public void recycle() {
    if (isInUse()) {
        if (gCheckRecycle) {
            throw new IllegalStateException("This message cannot be recycled because it "
                    + "is still in use.");
        }
        return;
    }
    recycleUnchecked();
}
void recycleUnchecked() {
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = UID_NONE;
    workSourceUid = UID_NONE;
    when = 0;
    target = null;
    callback = null;
    data = null;

    synchronized (sPoolSync) {
        if (sPoolSize < MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}

```

Message çš„å›æ”¶å‡½æ•°ä¸æ˜¯å°†å¯¹è±¡ç½®ä¸ºç©ºï¼Œè€Œæ˜¯å°† Message ä¸­çš„å˜é‡éƒ½è¿˜åŸä¸ºé»˜è®¤å€¼ã€‚

```java
public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            m.flags = 0; // clear in-use flag
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}
```

Message è¿˜æä¾› obtain å‡½æ•°ï¼Œä¸ä¼šç›´æ¥ new ä¸€ä¸ª Message å¯¹è±¡ï¼Œè€Œæ˜¯å…±äº«ä¹‹å‰çš„å¯¹è±¡ï¼Œæ”¹å˜å¯¹è±¡çš„å†…éƒ¨å±æ€§ã€‚

æ‰€ä»¥æˆ‘ä»¬åœ¨å®é™…ä½¿ç”¨ä¸­éƒ½æ˜¯ä½¿ç”¨ Message.obtain()æ¥æ„å»º message å¯¹è±¡ï¼Œè€Œä¸æ˜¯ä¸€ç›´ä½¿ç”¨ new ï¼Œè¿™æ ·å¯ä»¥é¿å…é¢‘ç¹çš„ç”Ÿæˆã€å›æ”¶ï¼Œé¿å…å†…å­˜æŠ–åŠ¨ã€‚

è¿™ç§è®¾è®¡è¢«æˆä¸º _ äº«å…ƒè®¾è®¡æ¨¡å¼ _


## Looper

è®²åˆ° looper è´Ÿè´£ä¸€ç›´è½®è¯¢æ¶ˆæ¯ï¼Œä½†æ˜¯å¥½åƒåœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œéƒ½æ²¡æœ‰ä½¿ç”¨åˆ° looperã€‚

å…¶å®æ˜¯åœ¨ä¸»çº¿ç¨‹ä¸­ï¼Œç³»ç»Ÿå·²ç»é»˜è®¤ä¸ºæˆ‘ä»¬åˆ›å»ºäº† looperï¼Œ
åœ¨ ActivityThread.java çš„ main æ–¹æ³•ä¸­ï¼ˆActivityThread å³ä¸ºä¸»çº¿ç¨‹ï¼‰

```java
public static void main(String[] args) {
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain");

        // Install selective syscall interception
        AndroidOs.install();

        // CloseGuard defaults to true and can be quite spammy.  We
        // disable it here, but selectively enable it later (via
        // StrictMode) on debug builds, but using DropBox, not logs.
        CloseGuard.setEnabled(false);

        Environment.initForCurrentUser();

        // Make sure TrustedCertificateStore looks in the right place for CA certificates
        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
        TrustedCertificateStore.setDefaultUserDirectory(configDir);

        Process.setArgV0("<pre-initialized>");

        Looper.prepareMainLooper();

        // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.
        // It will be in the format "seq=114"
        long startSeq = 0;
        if (args != null) {
            for (int i = args.length - 1; i >= 0; --i) {
                if (args[i] != null && args[i].startsWith(PROC_START_SEQ_IDENT)) {
                    startSeq = Long.parseLong(
                            args[i].substring(PROC_START_SEQ_IDENT.length()));
                }
            }
        }
        ActivityThread thread = new ActivityThread();
        thread.attach(false, startSeq);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        if (false) {
            Looper.myLooper().setMessageLogging(new
                    LogPrinter(Log.DEBUG, "ActivityThread"));
        }

        // End of event ActivityThreadMain.
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        Looper.loop();

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè°ƒç”¨äº† Loop.prepareMainLooper()ã€Looper.loop()å‡½æ•°ï¼Œ
è€Œä¸”åœ¨ Looper.loop()åé¢å°±æŠ›å‡ºå¼‚å¸¸ï¼Œ
ä¹Ÿå°±æ˜¯è¯´ä¸»çº¿ç¨‹ä¸­ loop ä¸€æ—¦åœæ­¢è½®è¯¢ï¼Œåˆ™ä¼šæŠ›å‡ºå¼‚å¸¸é—ªé€€ã€‚æ­£å¸¸æƒ…å†µæ—¶ï¼Œloop å°±æ˜¯ä¸€ç›´åœ¨è½®è¯¢ã€‚

æŸ¥çœ‹ Looper çš„è¿™ä¸¤ä¸ªå‡½æ•°

### prepareMainLooper

```java

    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }
```
* prepareMainLooper å…¶å®ä¹Ÿæ˜¯ä¸€ä¸ª prepare çš„è¿‡ç¨‹ï¼Œåªæ˜¯è¿™ä¸ªæ˜¯é’ˆå¯¹ä¸»çº¿ç¨‹è€Œå·² 


åœ¨ prepareMainLooper ä¸­å¯ä»¥çœ‹åˆ°ï¼Œä¸å…è®¸è°ƒç”¨ä¸¤æ¬¡ï¼Œå¦åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚


### prepare

æˆ‘ä»¬çœ‹ä¸€ä¸‹ myLooper å‡½æ•°

```java
public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}
```
è¯´æ˜ looper æ˜¯å­˜æ”¾åœ¨ ThreadLocal ä¸­çš„ã€‚è¿™æ ·ä¿è¯äº† looper çš„çº¿ç¨‹å”¯ä¸€æ€§
å…³äº ThreadLocalï¼Œåœ¨ä¹‹å‰å·²ç»å¤§è‡´è®²è¿‡äº†ã€‚
ThreadLocal è®²è§£ï¼ˆhttps://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.htmlï¼‰
åœ¨æ¯ä¸€ä¸ªçº¿ç¨‹ï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªå¯¹åº”ä¸”å”¯ä¸€çš„å€¼

æˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹ prepare å‡½æ•°


```java
public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

```

å¯ä»¥çœ‹åˆ°ä¸ prepareMainLooper çš„ä¸åŒï¼Œå› ä¸º prepareMainLooper æ˜¯åœ¨ä¸»çº¿ç¨‹è°ƒç”¨ï¼Œè€Œä¸»çº¿ç¨‹åªæœ‰ä¸€ä¸ªï¼Œ
æ‰€ä»¥ç›´æ¥ä½¿ç”¨ sMainLooper æ¥ä¿å­˜ä¸»çº¿ç¨‹çš„ looperï¼Œè€Œä¸”ä¸»çº¿ç¨‹ä¸­ prepare(false)ï¼›æ ‡ç¤ºä¸å…è®¸ looper é€€å‡ºã€‚

è€Œåœ¨å­çº¿ç¨‹æ—¶ï¼Œå°±æ˜¯å°† looper å¯¹è±¡ä¿å­˜åˆ° sThreadLocal ä¸­ï¼ŒsThreadLocal.get()ä¸ä¸º null æ—¶ï¼Œä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
ä¹Ÿå°±æ˜¯è¯´å­çº¿ç¨‹ä¸­ prepare åªå…è®¸è°ƒç”¨ä¸€æ¬¡ï¼Œä¿è¯äº†æ¯ä¸ªçº¿ç¨‹ä¸­çš„ looper å¯¹è±¡å”¯ä¸€æ€§

ç„¶åçœ‹åˆ°å­çº¿ç¨‹å’Œä¸»çº¿ç¨‹çš„å¦ä¸€ä¸ªå·®å¼‚ prepare(false) && prepare(true)
å› ä¸º andoridï¼Œæ‰€æœ‰äº‹ä»¶å¦‚ï¼šç”¨æˆ·çš„æ“ä½œã€ui çš„æ¸²æŸ“ç­‰éƒ½æ˜¯ä½œä¸ºæ¶ˆæ¯å‘é€çš„ï¼Œè€Œè¿™äº›éƒ½æ˜¯åœ¨ä¸»çº¿ç¨‹æ“ä½œçš„ï¼Œæ‰€ä»¥åœ¨ä¸»çº¿ç¨‹ä¸­æ˜¯ä¸å…è®¸é€€å‡º loop å¾ªç¯ï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸ã€‚

è€Œåœ¨å­çº¿ç¨‹ä¸­ prepare(true)ï¼Œå…è®¸é€€å‡ºï¼Œå…¶å®åœ¨å­çº¿ç¨‹ä¸­æ–°å»º handlerã€looper æ—¶ï¼Œå½“æˆ‘ä»¬ä¸éœ€è¦å†ä½¿ç”¨ï¼Œéœ€è¦ç»ˆæ­¢ loop å¾ªç¯ã€‚
æ­¤æ—¶éœ€è¦è°ƒç”¨ï¼š

```
public void quitSafely() {
    mQueue.quit(true);
}
```

### loop

```java
public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        if (me.mInLoop) {
            Slog.w(TAG, "Loop again would have the queued messages be executed"
                    + " before this one completed.");
        }

        me.mInLoop = true;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        // Allow overriding a threshold with a system prop. e.g.
        // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
        final int thresholdOverride =
                SystemProperties.getInt("log.looper."
                        + Process.myUid() + "."
                        + Thread.currentThread().getName()
                        + ".slow", 0);

        me.mSlowDeliveryDetected = false;

        for (;;) {
            if (!loopOnce(me, ident, thresholdOverride)) {
                return;
            }
        }
}
```

loop å‡½æ•°ä¸­ï¼Œé¦–å…ˆè·å–é€šè¿‡ myLooper()å‡½æ•°è·å– looper å¯¹è±¡ï¼Œå¦‚æœ looper å¯¹è±¡ä¸ºç©ºï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ï¼Œæç¤ºå¿…é¡»åœ¨å½“å‰çº¿ç¨‹å…ˆæ‰§è¡Œ Looper.prepare()
ç„¶åè·å– looper å¯¹è±¡æŒæœ‰çš„ messageQueueï¼Œ

åœ¨API 31ä¸­ï¼Œä¸ä¹‹å‰çš„æºç ç•¥æœ‰æ”¹åŠ¨ï¼Œæ–°å¢äº†å‡½æ•° loopOnce

ç„¶åå°±æ˜¯ for(;;)æ— é™å¾ªç¯ï¼Œè°ƒç”¨ loopOnce å‡½æ•°

### loopOnce

```java
private static boolean loopOnce(final Looper me,
            final long ident, final int thresholdOverride) {
        // è°ƒç”¨ me.mQueue.next() è·å–åˆ°ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œå¯èƒ½ä¼šé˜»å¡
        Message msg = me.mQueue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return false;
        }

        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " "
                    + msg.callback + ": " + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;

        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);

        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;

        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }

        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            // è°ƒç”¨handlerçš„dispatchMessage
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (me.mSlowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    me.mSlowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery",
                        msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    me.mSlowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }

        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x"
                    + Long.toHexString(ident) + " to 0x"
                    + Long.toHexString(newIdent) + " while dispatching to "
                    + msg.target.getClass().getName() + " "
                    + msg.callback + " what=" + msg.what);
        }

        msg.recycleUnchecked();

        return true;
    }
```
è¿™é‡Œé¢æ³¨æ„ä¸¤å¥ï¼š

* Message msg = me.mQueue.next(); // might block
  - é€šè¿‡ mQueue å–å‡ºä¸‹ä¸€æ¡ messageï¼Œ è¿™ä¸ªè¿‡ç¨‹å¯èƒ½ä¼šé˜»å¡
* msg.target.dispatchMessage(msg);
  - å°†å–å‡ºçš„æ¶ˆæ¯å‘é€ç»™ handler.dispatchMessage è¿›è¡Œå¤„ç†


æœ€åæ‰§è¡Œ msg.recycleUnchecked()ï¼Œç›¸å½“äºä¸€ä¸ªå›æ”¶åˆ©ç”¨ã€‚







## MessageQueue

åœ¨ä¸Šé¢ä¸­å·²ç»è®²è¿‡ Looperï¼Œlooper ä¸­æŒæœ‰ä¸€ä¸ª messageQueue
final MessageQueue queue = me.mQueue;
mQueue åœ¨ Looper çš„ç§æœ‰æ„é€ å‡½æ•°ä¸­è¢«åˆå§‹åŒ–

æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹ MessageQueue

ç›´é¢ç¿»è¯‘ä¸º æ¶ˆæ¯é˜Ÿåˆ—ï¼Œé˜Ÿåˆ—æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼ŒFIFOï¼Œå…ˆè¿›å…ˆå‡º
ä½†è¿™é‡Œçš„å…¶å®ä¸æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼Œåªæ˜¯å¯¹ Message çš„ç®¡ç†ï¼Œå¤„ç†å­˜ã€å– æ¶ˆæ¯ï¼Œ
èµ·åˆ°ä¸€ä¸ªç±»ä¼¼é˜Ÿåˆ—çš„åŠŸèƒ½ï¼Œå¯¹æ¶ˆæ¯ä¸»ä½“è¿›è¡Œç®¡ç†

ä¹‹å‰è¯´äº†ï¼ŒMessageQueue ä¸»è¦ç”¨äºå­˜æ”¾ã€å–å‡ºæ¶ˆæ¯ã€‚
åœ¨ Looper ä¸­ä¸»è¦ç”¨åˆ°äº† messagequeue çš„ next å‡½æ•°ï¼Œç”¨äºå–å‡ºä¸‹ä¸€æ¡æ¶ˆæ¯

æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹å­˜æ”¾æ¶ˆæ¯

### enqueueMessage

```java
boolean enqueueMessage(Message msg, long when) {
    if (msg.target == null) {
        throw new IllegalArgumentException("Message must have a target.");
    }
    if (msg.isInUse()) {
        // æ¶ˆæ¯ä¸èƒ½é‡å¤å…¥é˜Ÿ
        throw new IllegalStateException(msg + " This message is already in use.");
    }

    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(
                    msg.target + " sending message to a Handler on a dead thread");
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }
        // å°†æ¶ˆæ¯ç½®ä¸ºä½¿ç”¨
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        // é€šè¿‡ handler.sendMessage å‘é€çš„æ¶ˆæ¯ä¸»ä½“ï¼Œwhen = 0
        // æ­¤æ—¶è¯¥æ¶ˆæ¯ä¼šè¢«æ”¾ç½®åˆ°é“¾è¡¨çš„è¡¨å¤´ä½ç½®
        // è¿™é‡Œä¹Ÿå°±æ˜¯ä¸ºä½• sendMessageAtFrontOfQueue ä¼ å…¥çš„ when æ˜¯0ï¼Œä¼šè¢«æ”¾ç½®åœ¨é“¾è¡¨çš„å¤´éƒ¨ä½ç½®
        // when < p.when æ—¶ï¼Œ msg -> p , æ—¶é—´æ˜¯å‡åº
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.

            // å½“å‰è¢«é˜»å¡ï¼Œä¸”å½“å‰çš„æ¶ˆæ¯æœªç»‘å®štarget(handler), ä¸” ä¼ å…¥çš„msgä¸ºå¼‚æ­¥æ¶ˆæ¯æ—¶ï¼Œéœ€è¦å”¤èµ·çº¿ç¨‹
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (;;) {
                // å–åˆ°é“¾è¡¨ä¸­é“¾å°¾æˆ–è€…p.whenæ¯”å½“å‰whenè¦å¤§çš„æ¶ˆæ¯
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    // å¦‚æœéœ€è¦å”¤èµ·çº¿ç¨‹ï¼Œä¸” ç°æœ‰ï¼ˆä¸åŒ…æ‹¬æœ€æ–°çš„msgï¼‰çš„æ¶ˆæ¯é“¾è¡¨ä¸­å­˜åœ¨å¼‚æ­¥æ¶ˆæ¯ã€‚åˆ™ä¸å”¤èµ·çº¿ç¨‹
                    needWake = false;
                }
            }
            // è·³å‡ºå¾ªç¯ä¹‹å
            // å°†ä¼ å…¥çš„ msg æ’å…¥åˆ° prev ã€pä¹‹é—´ã€‚
            // prev -> msg -> p ï¼ˆæŒ‰ç…§whené™åºæ’åºï¼‰ æ­¤å¤„æœ‰ä¸€ä¸ªç–‘é—®ğŸ¤”ï¸ï¼Œæ­¤å¤„æ—¶é—´æ˜¯é™åºï¼Œä¸Šé¢çš„æ—¶é—´ä¸ºä½•æ˜¯å‡åº
            // æ­¤å¤„ä¼ å…¥çš„msg è‚¯å®šæ˜¯å¼‚æ­¥æ¶ˆæ¯
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}

```

å¦‚æœå½“å‰çº¿ç¨‹å·²ç»é€€å‡ºï¼ŒmQuitting ä¸º trueï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚


æ³¨æ„è¿™æ®µä»£ç 
```java
msg.when = when;
Message p = mMessages;
boolean needWake;
if (p == null || when == 0 || when < p.when) {
    // New head, wake up the event queue if blocked.
    msg.next = p;
    mMessages = msg;
    needWake = mBlocked;
}
```

> å½“å…¨å±€å˜é‡ mMessages ä¸ºç©ºï¼Œå³ä»£è¡¨æ¶ˆæ¯é˜Ÿåˆ—ä¸­ä¸å­˜åœ¨æ¶ˆæ¯äº†
> æˆ–è€…å½“å‰ä¼ å…¥çš„ when ä¸º 0ï¼Œ é€šè¿‡handler.sendMessage å‘é€çš„æ¶ˆæ¯ ä¼ å…¥çš„whenéƒ½ä¸º0
> æˆ–è€…å½“å‰ when å°äºå…¨å±€å˜é‡ mMessages.when, å³æ—¶é—´åœ¨å‰
å…¶å®åˆ¤æ–­çš„æ˜¯ä¸¤ç§çŠ¶æ€ï¼Œ1:messageQueue é˜Ÿåˆ—ä¸ºç©º 2:æ·»åŠ çš„æ¶ˆæ¯æ‰§è¡Œæ—¶é—´åœ¨å‰
æ­¤æ—¶å°†è¯¥æ¶ˆæ¯ç½®äºé“¾å¤´ï¼Œ
needWake = mBlockedï¼›
å¦‚æœ mBlocked ä¸º trueï¼ŒneedWake ä¹Ÿä¸º trueï¼Œå°±æ˜¯å¦‚æœä¹‹å‰é˜»å¡åˆ™å”¤é†’ï¼Œåä¹‹æ— éœ€å”¤é†’

å†çœ‹ä¸æ»¡è¶³ä¸Šé¢æƒ…å†µä¸‹æ—¶,å³æ¶ˆæ¯é˜Ÿåˆ—ä¸­å·²æ·»åŠ è¿‡æ¶ˆæ¯ï¼Œè€Œä¸”è¦æ·»åŠ çš„æ¶ˆæ¯.when åœ¨ä¸Šä¸€æ¬¡æ·»åŠ çš„æ¶ˆæ¯ä¹‹å

```java
else {
    // Inserted within the middle of the queue.  Usually we don't have to wake
    // up the event queue unless there is a barrier at the head of the queue
    // and the message is the earliest asynchronous message in the queue.
    needWake = mBlocked && p.target == null && msg.isAsynchronous();
    Message prev;
    for (;;) {
        prev = p;
        p = p.next;
        if (p == null || when < p.when) {
            break;
        }
        if (needWake && p.isAsynchronous()) {
            needWake = false;
        }
    }
    msg.next = p; // invariant: p == prev.next
    prev.next = msg;
}
```

for å¾ªç¯ï¼Œéå†é“¾è¡¨ï¼Œå½“æ‰¾åˆ°èŠ‚ç‚¹ä¸º null å³éå†å®Œ || ä¼ å…¥çš„ when å°äºéå†èŠ‚ç‚¹çš„ whenï¼ˆå³ä¼ å…¥æ¶ˆæ¯çš„æ—¶é—´åœ¨éå†èŠ‚ç‚¹æ—¶é—´ä¹‹å‰æ—¶ï¼‰
ç»ˆæ­¢å¾ªç¯ï¼Œå°† msg.next -> p
åŸæ¥
prev.next -> n.next -> ... -> n.next -> p -> ...
ç°åœ¨
prev.next -> n.next -> ... -> n.next -> msg.next -> p -> ...

ä¹Ÿå°±æ˜¯è¯´ï¼Œmessage é“¾è¡¨æ˜¯æŒ‰ç…§ when æ’åºçš„ï¼Œwhen è¶Šå°ï¼Œåœ¨è¶Šé è¿‘é“¾å¤´
ä¸ºä½•è¦æ ¹æ® when æ’åºäº†ï¼Œå…¶å®æ˜¯å› ä¸º message æ‰§è¡Œæ—¶é—´æ˜¯è¦æŒ‰æ—¶é—´æ’åºï¼Œè¦æ‰§è¡Œæ—¶é—´è¶Šå°ï¼Œä»£è¡¨æ—¶é—´è¶Šæ—©ï¼Œæ‰€ä»¥æ”¾åœ¨é“¾å¤´

ä»¥ä¸Šæ˜¯æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå…¥é˜Ÿå‡½æ•°ï¼Œå†çœ‹ä¸€ä¸‹å‡ºé˜Ÿå‡½æ•°

### next

```java
@UnsupportedAppUsage
Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // è¿™é‡Œä»£è¡¨åŒæ­¥å±éšœ å–å‡ºå¼‚æ­¥æ¶ˆæ¯ msg
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // æ¶ˆæ¯çš„æ‰§è¡Œæ—¶é—´è¿˜æœªåˆ°ï¼Œéœ€è¦ä¼‘çœ æ­¤æ—¶é—´å·®ï¼Œé˜»å¡
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // åœ¨é“¾è¡¨ä¸­åˆ é™¤ msg èŠ‚ç‚¹ï¼Œå¹¶è¿”å› msg
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // msg == null æ— éœ€ä¼‘çœ 
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0
                    && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        // message é“¾è¡¨ä¸ºç©ºï¼Œæ— æ¶ˆæ¯ï¼Œæ­¤æ—¶å¯ä»¥æ‰§è¡Œ idleHandler ä»»åŠ¡
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, "IdleHandler threw exception", t);
            }

            if (!keep) {
                synchronized (this) {
                    // idleHandler æ‰§è¡Œä¸€ä¸ªåˆ™ç§»é™¤ä¸€ä¸ª
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}

```
æ¥ä¸‹æ¥ä¸€æ®µæ®µä»£ç åˆ†æ

```java
if (msg != null && msg.target == null) {
    // Stalled by a barrier.  Find the next asynchronous message in the queue.
    do {
        prevMsg = msg;
        msg = msg.next;
    } while (msg != null && !msg.isAsynchronous());
}
```

è¿™ä¸€å—è®¾è®¡åˆ°æ¶ˆæ¯çš„åŒæ­¥å±éšœï¼Œæ”¾åˆ°ä¸‹é¢å†å°†ï¼Œæˆ‘ä»¬å…ˆåªçœ‹å‡ºé˜Ÿæ—¶çš„é€»è¾‘
next å‡½æ•°å°±æ˜¯å–å‡ºä¸‹ä¸€æ¡æ¶ˆæ¯ã€‚
å¼€å¯ for å¾ªç¯

```java
if (nextPollTimeoutMillis != 0) {
    Binder.flushPendingCommands();
}
```

å¦‚æœ nextPollTimeoutMillis ä¸ç­‰äº 0 æ—¶ï¼Œä¼šé˜»å¡ã€‚

```java
    final long now = SystemClock.uptimeMillis();
    Message prevMsg = null;
    Message msg = mMessages;
    if (msg != null && msg.target == null) {
        // è¿™é‡Œä»£è¡¨åŒæ­¥å±éšœ å–å‡ºå¼‚æ­¥æ¶ˆæ¯ msg
        // Stalled by a barrier.  Find the next asynchronous message in the queue.
        do {
            prevMsg = msg;
            msg = msg.next;
        } while (msg != null && !msg.isAsynchronous());
    }
    if (msg != null) {
        if (now < msg.when) {
            // æ¶ˆæ¯çš„æ‰§è¡Œæ—¶é—´è¿˜æœªåˆ°ï¼Œéœ€è¦ä¼‘çœ æ­¤æ—¶é—´å·®ï¼Œé˜»å¡
            // Next message is not ready.  Set a timeout to wake up when it is ready.
            nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
        } else {
            // åœ¨é“¾è¡¨ä¸­åˆ é™¤ msg èŠ‚ç‚¹ï¼Œå¹¶è¿”å› msg
            // Got a message.
            mBlocked = false;
            if (prevMsg != null) {
                prevMsg.next = msg.next;
            } else {
                mMessages = msg.next;
            }
            msg.next = null;
            if (DEBUG) Log.v(TAG, "Returning message: " + msg);
            msg.markInUse();
            return msg;
        }
    } else {
        // msg == null æ— éœ€ä¼‘çœ 
        // No more messages.
        nextPollTimeoutMillis = -1;
    }
```

å½“å½“å‰ message ä¸ä¸ºç©ºæ—¶ï¼š
å¦‚æœå½“å‰æ—¶é—´å°äº msg.whenï¼Œå³æ²¡åˆ°æ‰§è¡Œæ—¶é—´ï¼Œåˆ™é˜»å¡çº¿ç¨‹åˆ° msg.when æ—¶é—´
å°† msg.next èµ‹å€¼ç»™å…¨å±€å˜é‡ mMessagesï¼Œå†å°† msg.next æŒ‡å‘ null
ç„¶åè¿”å› msg è¿™ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æ­¤ä¸ä¼šè¿”å›ä¸€ä¸ªé“¾è¡¨

å¦‚æœ msg ä¸ºç©ºï¼Œè¯´æ˜é˜Ÿåˆ—ä¸ºç©ºï¼Œæ²¡æœ‰æ¶ˆæ¯ï¼Œæ­¤æ—¶èµ‹å€¼ nextPollTimeoutMillis = -1;ä¸‹ä¸€æ¬¡å¾ªç¯æ—¶ï¼Œå°±ä¼šé˜»å¡ã€‚

- MessageQueue æ·»åŠ æ¶ˆæ¯ã€å–å‡ºæ¶ˆæ¯æ˜¯çº¿ç¨‹å®‰å…¨çš„å—ï¼Ÿ
  æ˜¯ï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚
- å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨çš„ï¼Ÿ
  é€šè¿‡é”ï¼Œå­˜æ”¾æ¶ˆæ¯ä»¥åŠå–å‡ºæ¶ˆæ¯æ—¶éƒ½æœ‰è®¾ç½® synchronized (this)ï¼Œ
  synchronized åé¢ä¿®é¥°çš„æ˜¯ thisï¼ŒåŒä¸€ä¸ªå¯¹è±¡åœ¨å¤šçº¿ç¨‹ç¯å¢ƒè°ƒç”¨å‡½æ•°æ—¶ï¼Œåªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹è·å–åˆ°é”ï¼Œè¿›è¡Œæ“ä½œã€‚
  synchronized æ˜¯å†…ç½®é”ï¼ŒJVM å·²ç»å†…ç½®å¤„ç†äº†é”çš„è·å–ä»¥åŠé‡Šæ”¾

- ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ç”¨ wait/notifyï¼Ÿ
  åœ¨ä¸Šè¿°ä»£ç å¯ä»¥çœ‹åˆ°ä½¿ç”¨äº†é˜»å¡ã€é”ï¼Œé˜»å¡æ˜¯ç›´æ¥è°ƒç”¨ native å‡½æ•°æ¥é˜»å¡ï¼Œ
  å…¶å®åœ¨å†…éƒ¨å·²ç»ä½¿ç”¨äº† wait/notifyã€‚



## Message åŒæ­¥å±éšœ

ä¸Šé¢è®²çš„æ¶ˆæ¯ message é“¾è¡¨æ˜¯æ ¹æ® when æ—¶é—´æ’åºï¼Œé‚£å¦‚æœæœ‰ç´§æ€¥çš„æ¶ˆæ¯å¿…é¡»é©¬ä¸Šå¤„ç†å‘¢ï¼Œè¿™ä¸ªæ—¶å€™ä¸å¯èƒ½ç­‰å…¶ä»–å…ˆæ‰§è¡Œè€Œå¿…é¡»æ˜¯é©¬ä¸Šæ‰§è¡Œçš„äº‹ä»¶æ—¶ï¼Œæ€ä¹ˆåŠï¼Ÿ

è¿™ä¸ªæ—¶å€™å°±å¯ä»¥ç”¨åˆ° åŒæ­¥å±éšœã€‚

åœ¨ MessageQueue ä¸­å…·å¤‡ä¸¤ä¸ªå‡½æ•°ï¼špostSyncBarrierã€removeSyncBarrier
è®¾ç½®ä¸ç§»é™¤åŒæ­¥å±éšœï¼Œæ³¨æ„è¿™ä¸¤ä¸ªæ–¹æ³•éƒ½æ˜¯ hideï¼Œä¾›ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨ï¼Œæƒ³è‡ªå·±è°ƒç”¨åªèƒ½é€šè¿‡åå°„ï¼Œ
è€Œä¸”åœ¨æ–°ç‰ˆæœ¬åå°„ä½¿ç”¨ä¼šæŠ¥é”™ã€‚

### postSyncBarrier

```java
private int postSyncBarrier(long when) {
        // Enqueue a new sync barrier token.
        // We don't need to wake the queue because the purpose of a barrier is to stall it.
        synchronized (this) {
            final int token = mNextBarrierToken++;
            final Message msg = Message.obtain();
            msg.markInUse();
            msg.when = when;
            msg.arg1 = token;

            Message prev = null;
            Message p = mMessages;
            if (when != 0) {
                while (p != null && p.when <= when) {
                    prev = p;
                    p = p.next;
                }
            }
            if (prev != null) { // invariant: p == prev.next
                msg.next = p;
                prev.next = msg;
            } else {
                msg.next = p;
                mMessages = msg;
            }
            return token;
        }
    }
```

æ„å»ºä¸€ä¸ª Message å¯¹è±¡ msgï¼Œéå†å½“å‰ message é“¾è¡¨ï¼Œå°†è¯¥ msg æ’å…¥åˆ°ä¸€ä¸ª when å¤§äºä¼ å…¥ when çš„èŠ‚ç‚¹åï¼Œ
å¹¶æ³¨æ„ msg çš„ target ä¸º nullï¼›
ç„¶åå°±ä¸ä¸Šé¢è®²åˆ°çš„ next å‡½æ•°ä¸­ä»£ç å‘¼åº”ã€‚

```java
 if (msg != null && msg.target == null) {
    // Stalled by a barrier.  Find the next asynchronous message in the queue.
    do {
        prevMsg = msg;
        msg = msg.next;
    } while (msg != null && !msg.isAsynchronous());
}
```

æ­¤æ—¶ä¼šéå†è·å–åˆ°æœ€åä¸€æ¡å¼‚æ­¥æ¶ˆæ¯ï¼Œmsgï¼Œ && prevMsg.next = msg;

```java
if (msg != null) {
    if (now < msg.when) {
        // Next message is not ready.  Set a timeout to wake up when it is ready.
        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
    } else {
        // Got a message.
        mBlocked = false;
        if (prevMsg != null) {
            prevMsg.next = msg.next;
        } else {
            mMessages = msg.next;
        }
        msg.next = null;
        if (DEBUG) Log.v(TAG, "Returning message: " + msg);
        msg.markInUse();
        return msg;
    }
}
```

æ­¤å¤„å°±æ˜¯åœ¨é“¾è¡¨ä¸­ç§»é™¤ msg èŠ‚ç‚¹ï¼Œå¹¶ return msg å¯¹è±¡ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è®¾ç½®æ¶ˆæ¯å±éšœæ—¶ï¼Œä¼šåœ¨ Message é“¾è¡¨ä¸­ä»åå‘å‰å–å‡ºå¼‚æ­¥æ¶ˆæ¯ï¼Œç›´è‡³ç§»é™¤åŒæ­¥å±éšœ

### removeSyncBarrier

ç§»é™¤åŒæ­¥å±éšœ

### IdleHandler

åœ¨ä¸Šé¢è®²åˆ°çš„ MessageQueue ä¸­çš„ next å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€æ®µä»£ç 

```java
  for (int i = 0; i < pendingIdleHandlerCount; i++) {
      final IdleHandler idler = mPendingIdleHandlers[i];
      mPendingIdleHandlers[i] = null; // release the reference to the handler

      boolean keep = false;
      try {
          keep = idler.queueIdle();
      } catch (Throwable t) {
          Log.wtf(TAG, "IdleHandler threw exception", t);
      }

      if (!keep) {
          synchronized (this) {
              mIdleHandlers.remove(idler);
          }
      }
  }
```

å½“é˜Ÿåˆ— MessageQueue ä¸ºç©ºæˆ–è€… æœªåˆ°æ¶ˆæ¯çš„æ‰§è¡Œæ—¶é—´æ—¶ï¼Œæ­¤æ—¶ä¼šä» mPendingIdleHandlers æ•°ç»„ä¸­ï¼Œå–å‡º IdleHandler å¯¹è±¡ï¼Œè¿›è¡Œæ‰§è¡Œ queueIdle å‡½æ•°ã€‚
å¦‚æœ queueIdle è¿”å›ç»“æœä¸º trueï¼Œä»£è¡¨å¯ä»¥é‡å¤æ‰§è¡Œï¼Œè¿”å›ä¸º falseï¼Œåˆ™æ‰§è¡Œä¸€æ¬¡ä¼šå°†è¯¥ä»»åŠ¡ç§»é™¤ã€‚

IdleHandler ç›¸å½“äºé—²æ—¶ä»»åŠ¡ï¼Œåªæœ‰åœ¨ç©ºé—²æ—¶æ‰ä¼šæ‰§è¡Œã€‚

#### å¸¸è§é¢è¯•æé—®ï¼š

- å¦‚ä½•åœ¨é¡µé¢ç»˜åˆ¶å®Œæˆåæ‰§è¡Œä¸€ä¸ªä»»åŠ¡
  æ­¤æ—¶å°±å¯ä»¥ä½¿ç”¨ IdleHandlerï¼Œå› ä¸ºè°ƒç”¨åˆ° IdleHandler ä¸­çš„ queueIdle å‡½æ•°æ—¶ï¼Œä¿è¯æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„ Message éƒ½è¢«æ¶ˆè´¹äº†ã€‚

## æ€»ç»“

handler æ¶ˆæ¯æœºåˆ¶å¤§æ¦‚æµç¨‹ï¼š
ç”Ÿæˆ Looper å¯¹è±¡ï¼Œç”Ÿæˆ Handler å¯¹è±¡ï¼ŒLopper.looper å¾ªç¯
åœ¨ Handler æ„é€ å‡½æ•°å†…ï¼Œè·å–åˆ°ä¸Šé¢ç”Ÿæˆçš„ looper å¯¹è±¡ï¼Œé€šè¿‡ ThreadLocal ä¿å­˜åˆ°å¯¹åº”çš„çº¿ç¨‹ï¼Œä¸ MessageQueue ç»‘å®š
åœ¨éœ€è¦å‘é€æ¶ˆæ¯çš„åœ°æ–¹è°ƒç”¨ handler.sendMessage(),åœ¨ sendMessage æ—¶ï¼Œå°† message ä¸ handler ç»‘å®šï¼Œå°† message.target èµ‹å€¼ä¸ºå½“å‰ handler
åŒæ—¶ï¼ŒsendMessage æ—¶ï¼Œè°ƒç”¨ messageQueue.enqueueMessage å°† message æ”¾å…¥æ¶ˆæ¯é˜Ÿåˆ—ã€‚
åŒæ—¶ï¼ŒLooper.loop()åœ¨å¾ªç¯ä¸€ç›´å–å‡ºæ¶ˆæ¯ messageï¼Œç„¶åé€šè¿‡ message.target è·å–åˆ° handler å¯¹è±¡ï¼Œæœ€ç»ˆå›è°ƒåˆ° handler.handlerMessage å‡½æ•°ã€‚

è¿™æ ·æ¶ˆæ¯ä»äº§ç”Ÿåˆ°å¤„ç†æµç¨‹å°±èµ°å®Œäº†ã€‚

### æ€»ç»“æé—®ï¼š

- Looper.loop()ä¸€ç›´åœ¨å¾ªç¯ï¼Œä¸ºä»€ä¹ˆä¸ä¼šå¯¼è‡´åº”ç”¨å¡æ­»(ANR)?

ç­”ï¼šloop()å¾ªç¯ä¸ ANR æ˜¯ä¸¤ä¸ªä¸ç›¸å…³çš„äº‹æƒ…ï¼Œloop åªæ˜¯å¾ªç¯äº‹ä»¶ï¼ŒANR æ˜¯å¤„ç†äº‹ä»¶è€—æ—¶ï¼Œå¯¼è‡´æ— æ³•å“åº”ç”¨æˆ·çš„ä¸‹ä¸€æ¬¡è¾“å…¥ã€‚
ç³»ç»Ÿçš„ ANR å¼¹çª—éƒ½æ˜¯é€šè¿‡æ¶ˆæ¯æœºåˆ¶å‘é€ï¼Œå¹¶å¼¹å‡ºæç¤ºçª—çš„ã€‚

- fragment ç”Ÿå‘½å‘¨æœŸ

- Handler å†…å­˜æ³„æ¼
  åŸç†ï¼š

- postDelay çš„ Message æ€ä¹ˆå¤„ç†

å½“è°ƒç”¨ Handler çš„ sendMessageDelayed æ—¶ï¼Œä¼šè°ƒç”¨ sendMessageAtTime -> enqueueMessage -> MessageQueue.enqueueMessage

è€Œåœ¨ MessageQueue çš„ enqueueMessage ä¸­ã€‚

## æ±‡æ€»æ€»ç»“

è°ƒç”¨ Looper.prepare ä¼šå¾€ ThreadLocal ä¸­å­˜æ”¾ä¸€ä¸ªæ–°çš„ Looper å¯¹è±¡ï¼Œ
æ–°å»º Handler æ—¶ï¼Œä¼šè·å–å½“å‰çº¿ç¨‹çš„ looper å¯¹è±¡ï¼Œå¦‚æœæ— åˆ™æŠ¥é”™ã€‚
è·å–åˆ° looper å°±å°†å½“å‰çš„ handler ä¸å½“å‰çº¿ç¨‹çš„ looper å…³è”ã€‚
è€Œ looper ä¸­æœ‰ä¸€ä¸ª MessageQueue æ¶ˆæ¯é˜Ÿåˆ—å®ä¾‹ mQueue

handler ä¸ mQueue å°±é€šè¿‡ Looper å…³è”èµ·æ¥

Handler ----> Looper <------- MessageQueue

handler çš„ sendMessage è°ƒç”¨é“¾å¦‚ä¸‹ï¼š

handler.sendMessage ---> sendMessageDelayed ---> sendMessageAtTime ---> enqueueMessage ---> MessageQueue.enqueueMessage

åœ¨ enqueueMessage ä¸­ï¼Œä¼ å…¥çš„ when æ˜¯åœ¨ sendMessageAtTime ä¼ å…¥çš„ç³»ç»Ÿå½“å‰æ—¶é—´ï¼Œæ­¤æ—¶ä¼šéå†é“¾è¡¨ï¼Œä»¥æ—¶é—´æ’åºï¼Œå°†æ–°æ¥çš„ message æ”¾å…¥é“¾è¡¨ã€‚

Message çš„æ•°æ®ç»“æ„æ˜¯é“¾è¡¨

target å°±æ˜¯å¤„ç† message çš„ handlerã€when å°±æ˜¯æ¶ˆæ¯å‘é€çš„æ—¶é—´ï¼Œæ­£å¸¸æƒ…å†µé“¾è¡¨å°±æ˜¯æ ¹æ® when æ’åˆ—çš„ï¼Œ è¶Šå°åœ¨é“¾å¤´ï¼Œæ—¶é—´æˆ³è¶Šå¤§çš„è¶Šé è¿‘å½“å‰æ—¶é—´ã€‚
ä¹Ÿå°±æ˜¯è¯´ Message ä¸­çš„é“¾è¡¨ï¼Œæ­£å¸¸æƒ…å†µæ˜¯æŒ‰æ—¶é—´å…ˆåé¡ºåºæ¥çš„ ä»¥å‰---->ç°åœ¨

æ¶ˆæ¯æœºåˆ¶å°±æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç”Ÿäº§è€…ã€æ¶ˆè´¹è€…æ¨¡å¼ï¼Œä¸Šè¿°çš„éƒ¨åˆ†å°±æ˜¯ç”Ÿäº§è€…éƒ¨åˆ†ï¼Œå¾€æ¶ˆæ¯é˜Ÿåˆ—ä¸­æ”¾å…¥æ¶ˆæ¯ã€‚

å†åˆ°æ¶ˆè´¹è€…éƒ¨åˆ†ï¼ŒLoop.loop()

æ— é™å¾ªç¯ï¼Œå¾€ messageQueue é˜Ÿåˆ—ä¸­å–æ•°æ®ï¼Œ
Looper.loop ---> MessageQueue.next
åœ¨ Message.next å‡½æ•°ä¸­ï¼Œä¼šå»åˆ¤æ–­æ˜¯å¦å­˜åœ¨æ¶ˆæ¯å±éšœï¼Œå¦‚æœæœ‰ï¼Œåˆ™å–å‡ºé‡Œé¢çš„åŒæ­¥æ¶ˆæ¯ï¼Œä¼˜å…ˆå¤„ç†è¯¥æ¶ˆæ¯
