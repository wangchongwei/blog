---
title: java wait方法
date: 2020-08-27 17:26:45
tags: java
---
# wait()、notify()、notifyAll()

wait()、notify()、notifyAll()这三个函数都是Object类中的方法，而Object类是所有类的父类，所以所有对象实例都有该方法.


wait():阻塞当前之前直到该对象(调用wait函数的对象)在另一个线程调用了notify()或者notifyAll();
notify():唤醒单个线程
notifyAll():唤醒所有线程


这三个方法，都是Java语言提供的实现线程间阻塞(Blocking)和控制进程内调度(inter-process communication)的底层机制。在解释如何使用前，先说明一下两点：

1. 正如Java内任何对象都能成为锁(Lock)一样，任何对象也都能成为条件队列(Condition queue)。而这个对象里的wait(), notify()和notifyAll()则是这个条件队列的固有(intrinsic)的方法。

2. 一个对象的固有锁和它的固有条件队列是相关的，为了调用对象X内条件队列的方法，你必须获得对象X的锁。这是因为等待状态条件的机制和保证状态连续性的机制是紧密的结合在一起的。

```
class TestWait {

    public static void main(String[]args) {
        TestWaitBean bean = new TestWaitBean("bean");
        System.out.println("init bean");
        System.out.println("invoke bean wait");
        try {
            bean.wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("wait finished");
        }
    }

    static class TestWaitBean {
        String name;
        public TestWaitBean(String name) {
            this.name = name;
        }
    }
}
```
上述代码运行后会抛出异常java.lang.IllegalMonitorStateException
因为未获取对象bean的锁，就去调用bean.wait()


修改一下代码，实现一个简单的阻塞、唤醒

```
class TestWait {

    public static void main(String[]args) {
        TestWaitBean bean = new TestWaitBean("bean");
        System.out.println("init bean");
        System.out.println("invoke bean wait");
        WeakUpThread thread = new WeakUpThread(bean);
        thread.start();
        synchronized (bean) {
            try {
                bean.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println("wait finished");
            }
        }
    }

    static class TestWaitBean {
        String name;
        public TestWaitBean(String name) {
            this.name = name;
        }
    }


    static class WeakUpThread extends Thread {
        Object lock;
        public WeakUpThread(Object lock) {
            this.lock = lock;
        }
        @Override
        public void run() {
            super.run();
            synchronized (lock) {
                try {
                    System.out.println("Current Thread is sleep 2000ms" );
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    System.out.println(" weakUp!!!");
                    lock.notify();
                }
            }
        }
    }
}
```





注意：
* 不管是调用wait，还是notify、notifyAll，都要是在同步修饰的代码块或者方法中，即必须先获取对象锁，在调用对象方法










