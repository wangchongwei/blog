<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="blog"><title>android消息机制 | Watch And Learn</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">android消息机制</h1><a id="logo" href="/.">Watch And Learn</a><p class="description">Plan</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">android消息机制</h1><div class="post-meta"><a href="/blog/2020/11/android消息机制.html#comments" class="comment-count"></a><p><span class="date">Nov 24, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><p>在andorid中，系统的行为、用户的输入等事件都会被包装为一个消息，<br>进行消息发送、处理</p>
<p>关于消息的处理，就离不开Handler、Message、Loop<br>在平时使用时，Handler多用于多线程之间通信。</p>
<ul>
<li>那么Handler如何实现多线程通信？</li>
<li>多线程之间为何不会互相干扰？</li>
<li>为什么不使用用wait/notify？</li>
</ul>
<h2 id="Handler多线程通信"><a href="#Handler多线程通信" class="headerlink" title="Handler多线程通信"></a>Handler多线程通信</h2><p>先看一下普通使用案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyActiivty extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private Handler myHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">                if(msg.what=100) &#123;</span><br><span class="line">                    // TODO</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyThread extends Thread() &#123;</span><br><span class="line">        @Overtide</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            Message message = Message.obtain();</span><br><span class="line">            message.what = 100;</span><br><span class="line">            myHandler.sendMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单的在子线程发送消息，回到主线程处理消息的过程，<br>通过在子线程构造一个message对象，在主线程中获取到该message对象，来处理消息。</p>
<p>所以其实Handler处理多线程通信是通过共享Message对象内存来实现的。<br>内存是不区分线程的，这种通信原理就是在子线程与主线程共享message内存</p>
<p>所以 那么Handler如何实现多线程通信？<br>通过 内存共享 实现。</p>
<p>在多线程时，Handler又是如何保证消息如何在正确的线程发送的呢，或者说是如何保证执行的线程是正确的了。<br>这就要引入我们的Loop、消息队列概念了。</p>
<p>handler处理消息模型:</p>
<p><img src="../../../images/looper.png" style="zoom:20%"></p>
<p>handler负责发送、处理消息<br>looper负责一直轮询消息<br>messageQueue消息队列，负责存放、取出消息</p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>讲到looper负责一直轮询消息，但是好像在上面的代码中，都没有使用到looper。</p>
<p>其实是在主线程中，系统已经默认为我们创建了looper，<br>在ActivityThread.java的main方法中（ActivityThread即为主线程）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">        // Install selective syscall interception</span><br><span class="line">        AndroidOs.install();</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">        // It will be in the format &quot;seq=114&quot;</span><br><span class="line">        long startSeq = 0;</span><br><span class="line">        if (args != null) &#123;</span><br><span class="line">            for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，调用了Loop.prepareMainLooper()、Looper.loop()函数，<br>而且在Looper.loop()后面就抛出异常，<br>也就是说主线程中loop一旦停止轮询，则会抛出异常闪退。正常情况时，loop就是一直在轮询。</p>
<p>查看Looper的这两个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在prepareMainLooper中可以看到，不允许调用两次，否则会抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Run the message queue in this thread. Be sure to call</span><br><span class="line">    * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line">    */</span><br><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    // Allow overriding a threshold with a system prop. e.g.</span><br><span class="line">    // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos;</span><br><span class="line">    final int thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(&quot;log.looper.&quot;</span><br><span class="line">                    + Process.myUid() + &quot;.&quot;</span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + &quot;.slow&quot;, 0);</span><br><span class="line"></span><br><span class="line">    boolean slowDeliveryDetected = false;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        // Make sure the observer won&apos;t change while processing a transaction.</span><br><span class="line">        final Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">        if (thresholdOverride &gt; 0) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);</span><br><span class="line">        final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);</span><br><span class="line"></span><br><span class="line">        final boolean needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">        final boolean needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        final long dispatchEnd;</span><br><span class="line">        Object token = null;</span><br><span class="line">        if (observer != null) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSlowDelivery) &#123;</span><br><span class="line">            if (slowDeliveryDetected) &#123;</span><br><span class="line">                if ((dispatchStart - msg.when) &lt;= 10) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Drained&quot;);</span><br><span class="line">                    slowDeliveryDetected = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    // Once we write a slow delivery log, suppress until the queue drains.</span><br><span class="line">                    slowDeliveryDetected = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loop函数中，首先获取通过myLooper()函数获取looper对象，如果looper对象为空，则抛出异常，提示必须在当前线程先执行Looper.prepare()<br>然后获取looper对象持有的messageQueue，<br>然后就是for(;;)无限循环，获取messageQueue下一条消息<br>获取到message后调用msg.target.dispatchMessage(msg);<br>将这条消息发送出去。<br>最后执行msg.recycleUnchecked()，相当于一个回收利用。</p>
<p>我们看一下myLooper函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明looper是存放在ThreadLocal中的。<br>关于ThreadLocal，在之前已经大致讲过了。<br>ThreadLocal讲解（<a href="https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）" target="_blank" rel="noopener">https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）</a><br>在每一个线程，都存在一个对应且唯一的值</p>
<p>我们可以看一下prepare函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到与prepareMainLooper的不同，因为prepareMainLooper是在主线程调用，而主线程只有一个，<br>所以直接使用sMainLooper来保存主线程的looper，而且主线程中prepare(false)；标示不允许looper退出。</p>
<p>而在子线程时，就是将looper对象保存到sThreadLocal中，sThreadLocal.get()不为null时，会抛出异常。<br>也就是说子线程中prepare只允许调用一次，保证了每个线程中的looper对象唯一性</p>
<p>然后看到子线程和主线程的另一个差异prepare(false) &amp;&amp; prepare(true)<br>因为andorid，所有事件如：用户的操作、ui的渲染等都是作为消息发送的，而这些都是在主线程操作的，所以在主线程中是不允许退出loop循环，否则抛出异常。</p>
<p>而在子线程中prepare(true)，允许退出，其实在子线程中新建handler、looper时，当我们不需要再使用，需要终止loop循环。<br>此时需要调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>在上面中已经讲过Looper，looper中持有一个messageQueue<br>final MessageQueue queue = me.mQueue;<br>mQueue 在Looper的私有构造函数中被初始化</p>
<p>接下来我们看一下MessageQueue<br>队列是一种数据结果，FIFO先进先出<br>MessageQueue 是一个消息队列，默认也是先进先出，有序执行</p>
<p>之前说了，MessageQueue主要用于存放、取出消息。<br>在Looper中主要用到了messagequeue的next函数，用于取出下一条消息</p>
<p>我们先看一下存放消息</p>
<h3 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    if (msg.target == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (msg.isInUse()) &#123;</span><br><span class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = new IllegalStateException(</span><br><span class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">            // New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">            // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">            // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; // invariant: p == prev.next</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前线程已经退出，mQuitting为true，则抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msg.when = when;</span><br><span class="line">Message p = mMessages;</span><br><span class="line">boolean needWake;</span><br><span class="line">if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">    // New head, wake up the event queue if blocked.</span><br><span class="line">    msg.next = p;</span><br><span class="line">    mMessages = msg;</span><br><span class="line">    needWake = mBlocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当全局变量mMessages为空，或者当前传入的when为0， 或者当前when小于全局变量mMessages.when(即时间在前)<br>其实判断的是两种状态，1:messageQueue队列为空 2:添加的消息执行时间在前<br>此时将该消息置于队首，<br>needWake = mBlocked；<br>如果mBlocked为true，needWake也为true，就是如果之前阻塞则唤醒，反之无需唤醒</p>
<p>再看不满足上面情况下时,即消息队列中已添加过消息，而且要添加的消息.when在上一次添加的消息之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">    // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">    // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">    needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">    Message prev;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        if (p == null || when &lt; p.when) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">            needWake = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.next = p; // invariant: p == prev.next</span><br><span class="line">    prev.next = msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for循环，遍历链表，当找到节点为null即遍历完 || 传入的when小于遍历节点的when（即传入消息的时间在遍历节点时间之前时）<br>终止循环，将msg.next -&gt; p<br>原来<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; p -&gt; …<br>现在<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; msg.next -&gt; p -&gt; …</p>
<p>也就是说，message链表是按照when排序的，when越小，在越靠近链头<br>为何要根据when排序了，其实是因为message执行时间是要按时间排序，要执行时间越小，代表时间越早，所以放在链头</p>
<p>以上是消息队列，入队函数，再看一下出队函数</p>
<h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">Message next() &#123;</span><br><span class="line">    // Return here if the message loop has already quit and been disposed.</span><br><span class="line">    // This can happen if the application tries to restart a looper after quit</span><br><span class="line">    // which is not supported.</span><br><span class="line">    final long ptr = mPtr;</span><br><span class="line">    if (ptr == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Got a message.</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // No more messages.</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process the quit message now that all pending messages have been handled.</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If first time idle, then get the number of idlers to run.</span><br><span class="line">            // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">            // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                mBlocked = true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Run the idle handlers.</span><br><span class="line">        // We only ever reach this code block during the first iteration.</span><br><span class="line">        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">            boolean keep = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">        pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">        // While calling an idle handler, a new message could have been delivered</span><br><span class="line">        // so go back and look again for a pending message without waiting.</span><br><span class="line">        nextPollTimeoutMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一段代码可以先不看，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">    do &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一块设计到消息的同步屏障，放到下面再将，我们先只看出队时的逻辑<br>next函数就是取出下一条消息。<br>开启for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">    Binder.flushPendingCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果nextPollTimeoutMillis不等于0时，会阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final long now = SystemClock.uptimeMillis();</span><br><span class="line">Message prevMsg = null;</span><br><span class="line">Message msg = mMessages;</span><br><span class="line">if (msg != null) &#123;</span><br><span class="line">    if (now &lt; msg.when) &#123;</span><br><span class="line">        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Got a message.</span><br><span class="line">        mBlocked = false;</span><br><span class="line">        if (prevMsg != null) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = null;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // No more messages.</span><br><span class="line">    nextPollTimeoutMillis = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当当前message不为空时：<br>如果当前时间小于msg.when，即没到执行时间，则阻塞线程到msg.when时间<br>将msg.next赋值给全局变量mMessages，再将msg.next指向null<br>然后返回msg这一个节点，如此不会返回一个链表</p>
<p>如果msg为空，说明队列为空，没有消息，此时赋值nextPollTimeoutMillis = -1;下一次循环时，就会阻塞。</p>
<ul>
<li>MessageQueue 添加消息、取出消息是线程安全的吗？<br>是，是线程安全的。</li>
<li><p>如何保证线程安全的？<br>通过锁，存放消息以及取出消息时都有设置synchronized (this)，<br>synchronized 后面修饰的是this，同一个对象在多线程环境调用函数时，只会有一个线程获取到锁，进行操作。<br>synchronized 是内置锁，JVM已经内置处理了锁的获取以及释放</p>
</li>
<li><p>为什么不使用用wait/notify？<br>在上述代码可以看到使用了阻塞、锁，阻塞是直接调用native 函数来阻塞，<br>其实在内部已经使用了wait/notify。</p>
</li>
</ul>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>上面讲了消息机制中的Handler、Looper、MessageQueue；<br>现在我们再讲一下消息的本体Message</p>
<p>首先通过我们在上面的分析，可以知道Message在数据结构上看，是一个链表，而且是只有next指针，所以是个单链表。<br>Message中没有什么复杂操作，都是一些赋值函数<br>有两个地方可以注意下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123;</span><br><span class="line">        if (gCheckRecycle) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</span><br><span class="line">                    + &quot;is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    // Mark the message as in use while it remains in the recycled object pool.</span><br><span class="line">    // Clear out all other details.</span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = 0;</span><br><span class="line">    arg1 = 0;</span><br><span class="line">    arg2 = 0;</span><br><span class="line">    obj = null;</span><br><span class="line">    replyTo = null;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = 0;</span><br><span class="line">    target = null;</span><br><span class="line">    callback = null;</span><br><span class="line">    data = null;</span><br><span class="line"></span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = this;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Message的回收函数不是将对象置为空，而是将Message中的变量都还原为默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool != null) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = null;</span><br><span class="line">            m.flags = 0; // clear in-use flag</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message还提供obtain函数，不会直接new 一个Message对象，而是共享之前的对象，改变对象的内部属性。</p>
<p>所以我们在实际使用中都是使用Message.obtain()来构建message对象，而不是一直使用new ，这样可以避免频繁的生成、回收，避免内存抖动。</p>
<p>这种设计被成为 <em> 享元设计模式 </em></p>
<h2 id="Message-同步屏障"><a href="#Message-同步屏障" class="headerlink" title="Message 同步屏障"></a>Message 同步屏障</h2><p>上面讲的消息message链表是根据when时间排序，那如果有紧急的消息必须马上处理呢，这个时候不可能等其他先执行而必须是马上执行的事件时，怎么办？</p>
<p>这个时候就可以用到 同步屏障。</p>
<p>在MessageQueue中具备两个函数：postSyncBarrier、removeSyncBarrier<br>设置与移除同步屏障，注意这两个方法都是hide，供系统内部使用，想自己调用只能通过反射，<br>而且在新版本反射使用会报错。</p>
<h3 id="postSyncBarrier"><a href="#postSyncBarrier" class="headerlink" title="postSyncBarrier"></a>postSyncBarrier</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">        // Enqueue a new sync barrier token.</span><br><span class="line">        // We don&apos;t need to wake the queue because the purpose of a barrier is to stall it.</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            final int token = mNextBarrierToken++;</span><br><span class="line">            final Message msg = Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">            Message prev = null;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            if (when != 0) &#123;</span><br><span class="line">                while (p != null &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (prev != null) &#123; // invariant: p == prev.next</span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            return token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构建一个Message对象msg，遍历当前message链表，将该msg插入到一个when大于传入when的节点后，<br>并注意msg的target为null；<br>然后就与上面讲到的next函数中代码呼应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">    do &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时会遍历获取到最后一条异步消息，msg， &amp;&amp; prevMsg.next = msg;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (msg != null) &#123;</span><br><span class="line">    if (now &lt; msg.when) &#123;</span><br><span class="line">        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Got a message.</span><br><span class="line">        mBlocked = false;</span><br><span class="line">        if (prevMsg != null) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = null;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处就是在链表中移除msg节点，并return msg对象。<br>也就是说，当设置消息屏障时，会在Message链表中从后向前取出异步消息，直至移除同步屏障</p>
<h3 id="removeSyncBarrier"><a href="#removeSyncBarrier" class="headerlink" title="removeSyncBarrier"></a>removeSyncBarrier</h3><p>移除同步屏障</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>handler消息机制大概流程：<br>生成Looper对象，生成Handler对象，Lopper.looper循环<br>在Handler构造函数内，获取到上面生成的looper对象，通过ThreadLocal保存到对应的线程，与MessageQueue绑定<br>在需要发送消息的地方调用handler.sendMessage(),在sendMessage时，将message与handler绑定，将message.target赋值为当前handler<br>同时，sendMessage时，调用messageQueue.enqueueMessage将message放入消息队列。<br>同时，Looper.loop()在循环一直取出消息message，然后通过message.target获取到handler对象，最终回调到handler.handlerMessage函数。</p>
<p>这样消息从产生到处理流程就走完了。</p>
<h3 id="总结提问："><a href="#总结提问：" class="headerlink" title="总结提问："></a>总结提问：</h3><ul>
<li>Looper.loop()一直在循环，为什么不会导致应用卡死(ANR)?</li>
</ul>
<p>答：loop()循环与ANR是两个不相关的事情，loop只是循环事件，ANR是处理事件耗时，导致无法响应用户的下一次输入。<br>系统的ANR弹窗都是通过消息机制发送，并弹出提示窗的。</p>
<ul>
<li>fragment生命周期</li>
</ul>
<ul>
<li>Handler内存泄漏<br>原理：</li>
</ul>
<ul>
<li>postDelay的Message怎么处理</li>
</ul>
<p>当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage</p>
<p>而在MessageQueue的enqueueMessage中。</p>
</div><div class="tags"><a href="/tags/android/">android</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/blog/2020/12/注解.html" class="pre">注解</a><a href="/blog/2020/11/APT注解处理器.html" class="next">APT注解处理器</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MTc1MS8xODI5Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler多线程通信"><span class="toc-text">Handler多线程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Looper"><span class="toc-text">Looper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MessageQueue"><span class="toc-text">MessageQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#enqueueMessage"><span class="toc-text">enqueueMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next"><span class="toc-text">next</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Message"><span class="toc-text">Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Message-同步屏障"><span class="toc-text">Message 同步屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#postSyncBarrier"><span class="toc-text">postSyncBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeSyncBarrier"><span class="toc-text">removeSyncBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结提问："><span class="toc-text">总结提问：</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2021/04/c-基础-五.html">c++基础 五</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/04/NDK-C-基础-四.html">NDK C++基础 四</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/android-aidl.html">android aidl</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/andorid-MVC.html">andorid MVC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/NDK-c-基础-三.html">NDK-c++基础 三</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/android-SharedPreferences.html">android SharedPreferences</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/android-应用启动流程.html">android 应用启动流程</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/NDK-c语言基础-二.html">NDK c语言基础 二</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/JMM-java内存模型.html">JMM java内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2021/03/NDK-c语言基础-一.html">NDK c语言基础 (一)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/vscode/">vscode</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/vscode/" style="font-size: 15px;">vscode</a> <a href="/tags/facebook/" style="font-size: 15px;">facebook</a> <a href="/tags/react-spring/" style="font-size: 15px;">react+spring</a> <a href="/tags/flutter/" style="font-size: 15px;">flutter</a> <a href="/tags/react-native/" style="font-size: 15px;">react-native</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/wechatApp/" style="font-size: 15px;">wechatApp</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/andorid/" style="font-size: 15px;">andorid</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/c语言/" style="font-size: 15px;">c语言</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://subblogzhaoxunyongm70.lofter.com/" title="lofter" target="_blank">lofter</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">About</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">justin.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?0af0c9cfcd648be735ccf119d51ae564";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>