{"meta":{"title":"Happy To Try","subtitle":"Plan","description":"Please description","author":"justin","url":"hexo"},"pages":[{"title":"关于","date":"2016-12-25T07:58:56.000Z","updated":"2019-07-05T09:18:33.220Z","comments":false,"path":"about/index.html","permalink":"hexo/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-01-01T06:52:00.000Z","updated":"2019-04-19T02:04:38.000Z","comments":false,"path":"categories/index.html","permalink":"hexo/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-01-01T06:50:50.000Z","updated":"2019-04-19T02:04:38.000Z","comments":false,"path":"tags/index.html","permalink":"hexo/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"okhttp(二) 拦截器","slug":"okhttp-二-拦截器","date":"2021-01-13T10:29:12.000Z","updated":"2021-01-20T01:16:55.400Z","comments":true,"path":"blog/2021/01/okhttp-二-拦截器.html","link":"","permalink":"hexo/blog/2021/01/okhttp-二-拦截器.html","excerpt":"","text":"okhttp(二) 拦截器在前文中讲到了okhttp中的分发器 接下来讲okhttp中的拦截器 在上文中讲到，同步执行excuet时，会通过 getResponseWithInterceptorChain 获取response，在异步enqueue后，后面会调用AsyncCall中execute，而里面也是通过getResponseWithInterceptorChain 来获取response。 调用的都是RealCall中的getResponseWithInterceptorChain函数。 getResponseWithInterceptorChain1234567891011121314151617181920Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); //自定义拦截器加入到集合 interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 一个数组，添加各个拦截器，然后初始化一个 Interceptor.Chain 对象，注意第2、3、4个参数都是null，而第5个参数是index：0然后调用proceed函数 RealInterceptorChain.javaRealInterceptorChain 实现 Interceptor接口中的Chain接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors; private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; private final int index; private final Request request; private final Call call; private final EventListener eventListener; private final int connectTimeout; private final int readTimeout; private final int writeTimeout; private int calls; public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call, EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; this.call = call; this.eventListener = eventListener; this.connectTimeout = connectTimeout; this.readTimeout = readTimeout; this.writeTimeout = writeTimeout; &#125; @Override public Connection connection() &#123; return connection; &#125; @Override public int connectTimeoutMillis() &#123; return connectTimeout; &#125; @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, millis, readTimeout, writeTimeout); &#125; @Override public int readTimeoutMillis() &#123; return readTimeout; &#125; @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, millis, writeTimeout); &#125; @Override public int writeTimeoutMillis() &#123; return writeTimeout; &#125; @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, readTimeout, millis); &#125; public StreamAllocation streamAllocation() &#123; return streamAllocation; &#125; public HttpCodec httpStream() &#123; return httpCodec; &#125; @Override public Call call() &#123; return call; &#125; public EventListener eventListener() &#123; return eventListener; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must retain the same host and port&quot;); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must call proceed() exactly once&quot;); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptor + &quot; must call proceed() exactly once&quot;); &#125; // Confirm that the intercepted response isn&apos;t null. if (response == null) &#123; throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;); &#125; if (response.body() == null) &#123; throw new IllegalStateException( &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;); &#125; return response; &#125;&#125; 上面是RealInterceptorChain的全部代码，注意看一段代码 12345678// 最开始index = 0，注意这里构造RealInterceptorChain时，传入的为index+1 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的最前面的，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 RetryAndFollowUpInterceptor 拦截器 Interceptor interceptor = interceptors.get(index); // 然后调用拦截器的 intercept函数 Response response = interceptor.intercept(next); 看注释现在可能又点绕，接着往下看，Interceptor是一个接口，没必要看，可以直接先看RetryAndFollowUpInterceptor RetryAndFollowUpInterceptor 重试以及重定向拦截器RetryAndFollowUpInterceptor 实现 Interceptor 接口 查看其中的intercept函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); /** * todo 管理类，维护了 与服务器的连接、数据流与请求三者的关系。真正使用的拦截器为 Connect */ StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; Response priorResponse = null; // 在这里无限循环，只有抛出异常或者return response才会中断 while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); &#125; Response response; boolean releaseConnection = true; try &#123; //todo 请求出现了异常，那么releaseConnection依旧为true。 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; //todo 路由异常，连接未成功，请求还没发出去 //The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getLastConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接) // HTTP2才会抛出ConnectionShutdownException。所以对于HTTP1 requestSendStarted一定是true //An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We&apos;re throwing an unchecked exception. Release any resources. //todo 不是前两种的失败，那直接关闭清理所有资源 if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; //todo 如果进过重试/重定向才成功的，则在本次响应中记录上次响应的情况 //Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse( priorResponse.newBuilder() .body(null) .build() ) .build(); &#125; //todo 处理3和4xx的一些状态码，如301 302重定向 Request followUp = followUpRequest(response, streamAllocation.route()); if (followUp == null) &#123; if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; closeQuietly(response.body()); //todo 限制最大 followup 次数为20次 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); &#125; if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code()); &#125; //todo 判断是不是可以复用同一份连接 if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;); &#125; request = followUp; priorResponse = response; &#125; &#125; 可以看到此处的主要逻辑，将传入的chain对象转为RealInterceptorChain，无限循环，然后在循环中调用chain.proceed函数，获取response，循环的主要作用为catch异常，并针对RouteException 或者 IOException 做重试操作，其他异常则终止， 而chain.proceed又会回到上面RealInterceptorChain中 123456789// 当从RetryAndFollowUpInterceptor再过来时，index = 1； index + 1 = 2； RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 1，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 BridgeInterceptor 拦截器 Interceptor interceptor = interceptors.get(index); // 然后调用拦截器的 intercept函数 Response response = interceptor.intercept(next); BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应BridgeInterceptor 也是实现 Interceptor 接口 同样直接查看intercept函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(&quot;Content-Type&quot;, contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength)); requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); &#125; else &#123; requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); &#125; &#125; if (userRequest.header(&quot;Host&quot;) == null) &#123; requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(&quot;Connection&quot;) == null) &#123; requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;); &#125; // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also // decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123; transparentGzip = true; requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies)); &#125; if (userRequest.header(&quot;User-Agent&quot;) == null) &#123; requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent()); &#125; Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(&quot;Content-Encoding&quot;) .removeAll(&quot;Content-Length&quot;) .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(&quot;Content-Type&quot;); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; 可以看到，这个函数的逻辑，先对请求头信息进行再处理，然后执行chain.proceed获取networkResponse，然后再对networkResponse进行再包装处理 同RetryAndFollowUpInterceptor一样，又会调用到chain.proceed函数，又会回到上面RealInterceptorChain中 12345678// 当从RetryAndFollowUpInterceptor再过来时，index = 2； index + 1 = 3； RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 2，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CacheInterceptor 拦截器 Interceptor interceptor = interceptors.get(index); // 然后调用拦截器的 intercept函数 Response response = interceptor.intercept(next); 再看CacheInterceptor代码 CacheInterceptor 负责读取缓存以及更新缓存CacheInterceptor 也是实现 Interceptor 接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104@Overridepublic Response intercept(Chain chain) throws IOException &#123; //todo 通过url的md5数据 从文件缓存查找 （GET请求才有缓存） Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //todo 缓存策略:根据各种条件(请求头)组成 请求与缓存 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); // Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it. &#125; //todo 没有网络请求也没有缓存 //If we&apos;re forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; //todo 没有请求，肯定就要使用缓存 //If we don&apos;t need the network, we&apos;re done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; //todo 去发起请求 Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we&apos;re doing a conditional get. if (cacheResponse != null) &#123; //todo 服务器返回304无修改，那就使用缓存的响应修改了时间等数据后作为本次请求的响应 if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //todo 走到这里说明缓存不可用 那就使用网络的响应 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //todo 进行缓存 if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;&#125; 过程就是获取一个networlRequets，以及一个缓存的cacheResponse，如果networlRequets与cacheResponse，则直接报504的网络异常如果networlRequets为空，则只能返回cacheResponse，如果networlRequets不为空，则执行网络请求，获取networkResponse，如果cacheResponse 不为空 且 networkResponse响应码304，代表无更改，则可以返回， 再往下就是对networlRequets进行处理，并加入缓存。 注意：此处获取networkResponse也是调用chain.proceed，于是与上面一直，也会走到 RealInterceptorChain中。 12345678// 当从RetryAndFollowUpInterceptor再过来时，index = 3； index + 1 = 4；RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 3，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 ConnectInterceptor 拦截器Interceptor interceptor = interceptors.get(index);// 然后调用拦截器的 intercept函数Response response = interceptor.intercept(next); 此时会调用到ConnectInterceptor中的intercept函数 ConnectInterceptorConnectInterceptor 也是实现 Interceptor 接口 123456789101112131415161718192021public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; 如上代码就是ConnectInterceptor类中所有源码，intercept函数中，重新获取了几个参数，和上面的几个Interceptor实现类不太一样，最后调用的proceed函数是四个参数的，最后还是会走到 RealInterceptorChain中。 12345678// 当从RetryAndFollowUpInterceptor再过来时，index = 4； index + 1 = 5；RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 4，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CallServerInterceptor 拦截器Interceptor interceptor = interceptors.get(index);// 然后调用拦截器的 intercept函数Response response = interceptor.intercept(next); CallServerInterceptorCallServerInterceptor 也是实现 Interceptor 接口，CallServerInterceptor 中 intercept 函数就是直接与服务端通信的，而在这里会获取到真正的response，并返回到上一层，也就是ConnectInterceptor的intercept，同理会依次向上返回。 责任链模式在上面看到的，一层一层拦截器向下调用，Interceptor类实现 调用 Interceptor类实现，每一层的拦截器实现自己的功能，然后交付给下一层拦截器，这种设计模式就是责任链模式。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"react Hook","slug":"react-Hook","date":"2021-01-11T03:27:26.000Z","updated":"2021-01-11T08:01:07.188Z","comments":true,"path":"blog/2021/01/react-Hook.html","link":"","permalink":"hexo/blog/2021/01/react-Hook.html","excerpt":"","text":"Hook技术Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。 useStateuseEffectuseEffect 是一个副作用函数，默认在每次渲染之后都会执行。而且保证每次运行effect时，DOM已经渲染完毕。 传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。事实上这正是我们可以在 effect 中获取最新的 useState中 的值，而不用担心其过期的原因。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。 与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。 useEffect提供清除操作，当我们需要在React组件清除时，执行某一些操作，可以在useEffect中，返回清除函数。当React清除时，会执行useEffect中的返回函数。 12345678useEffect(() =&gt; &#123; ... return function remove() &#123; // when react remove &#125;&#125;) 为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。 React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。 还可以对useEffect进行优化，useEffect接受两个参数，第二个参数为比较值，当这个值发生了变化，才会执行useEffect。 123456789const [count, setCount] = useState(0)useEffect(() =&gt; &#123; ... return function remove() &#123; // when react remove &#125;&#125;, [count]) 这样，只有当count发生变化，即我们调用过 setCount来改变count的值，下一次渲染完毕，才会执行useEffect 所以，当我们需要执行一些只需执行一次的逻辑时，可以传入一个定值，一般使用空数组[] 123456789101112useEffect(() =&gt; &#123; ... function request() &#123; &#125; return function remove() &#123; // when react remove &#125;&#125;, []]) 如上所示，request只会在第一次渲染完毕执行一次，remove函数也时只会执行一次","categories":[],"tags":[{"name":"react","slug":"react","permalink":"hexo/tags/react/"}]},{"title":"IOC","slug":"IOC","date":"2021-01-08T02:32:38.000Z","updated":"2021-01-19T09:32:15.489Z","comments":true,"path":"blog/2021/01/IOC.html","link":"","permalink":"hexo/blog/2021/01/IOC.html","excerpt":"","text":"IOCandroid ioc 技术 dagger2使用：主要使用了工厂模式、APT技术 利用注解处理器，变异时生成大量代码，完成自动注入","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Glide框架解析","slug":"Glide框架解析","date":"2020-12-30T02:50:47.000Z","updated":"2020-12-30T08:48:55.173Z","comments":true,"path":"blog/2020/12/Glide框架解析.html","link":"","permalink":"hexo/blog/2020/12/Glide框架解析.html","excerpt":"","text":"Glide是android平台中的一个图片加载框架，可以加载本地图片、网络图片、动态图 Glide的使用 1Glide.with(context).load(url).into(imageView); 可以看出分成三部分：with、load、into下面我们也分成三部分针对讲解 withwith函数其实是对生命周期的管理在Glide源码中，可以看到几个with函数,入参类型各不相同 12345678910111213141516171819202122232425262728293031@NonNullpublic static RequestManager with(@NonNull Context context) &#123; return getRetriever(context).get(context);&#125;@NonNullpublic static RequestManager with(@NonNull Activity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment);&#125;@SuppressWarnings(&quot;deprecation&quot;)@Deprecated@NonNullpublic static RequestManager with(@NonNull android.app.Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment);&#125;@NonNullpublic static RequestManager with(@NonNull View view) &#123; return getRetriever(view.getContext()).get(view);&#125; with函数的入参有 Context Activity FragmentActivity androidX.Fragment android.app.Fragment View可以看到，在with函数中都是调用getRetriever返回RequestManager对象，而调用getRetriever的入参有两个类型 1、context 2、activity getRetriever的两种入参类型又是根据上面with函数获取的，针对fragment、fragmentActiivty、Actiivty获取对应的actiivty针对context、view，则获取对应的context 再看一下getRetriever函数 getRetriever12345678910111213@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) &#123; Preconditions.checkNotNull( context, &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot; + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot; + &quot;is attached or after the Fragment is destroyed).&quot;); return Glide.get(context).getRequestManagerRetriever();&#125;@NonNullpublic RequestManagerRetriever getRequestManagerRetriever() &#123; return requestManagerRetriever;&#125; 也就是说，getRetriever返回就是一个 RequestManagerRetriever对象 也就是说 with函数最后调用到了RequestManagerRetriever对象的get函数 RequestManagerRetriever看在Glide.java中的with函数就知道，RequestManagerRetriever中get函数也存在多个1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@NonNull public RequestManager get(@NonNull Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; return getApplicationManager(context); &#125; @NonNull public RequestManager get(@NonNull FragmentActivity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); FragmentManager fm = activity.getSupportFragmentManager(); return supportFragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); &#125; &#125; @NonNull public RequestManager get(@NonNull Fragment fragment) &#123; Preconditions.checkNotNull(fragment.getActivity(), &quot;You cannot start a load on a fragment before it is attached or after it is destroyed&quot;); if (Util.isOnBackgroundThread()) &#123; return get(fragment.getActivity().getApplicationContext()); &#125; else &#123; FragmentManager fm = fragment.getChildFragmentManager(); return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible()); &#125; &#125; @SuppressWarnings(&quot;deprecation&quot;) @NonNull public RequestManager get(@NonNull Activity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); &#125; &#125;@SuppressWarnings(&quot;deprecation&quot;)@NonNullpublic RequestManager get(@NonNull View view) &#123; if (Util.isOnBackgroundThread()) &#123; return get(view.getContext().getApplicationContext()); &#125; Preconditions.checkNotNull(view); Preconditions.checkNotNull(view.getContext(), &quot;Unable to obtain a request manager for a view without a Context&quot;); Activity activity = findActivity(view.getContext()); if (activity == null) &#123; return get(view.getContext().getApplicationContext()); &#125; if (activity instanceof FragmentActivity) &#123; Fragment fragment = findSupportFragment(view, (FragmentActivity) activity); return fragment != null ? get(fragment) : get(activity); &#125; android.app.Fragment fragment = findFragment(view, activity); if (fragment == null) &#123; return get(activity); &#125; return get(fragment);&#125; 第一个get函数，传入context对象，对context做分发，其他的get函数，都是判断当前执行线程是否在main线程，如果不是 则都会走到1return getApplicationManager(context) 在main线程时，会根据传入的参数获取对应的activity，activity为null，则也会执行1return getApplicationManager(context) 如果activity不为空，则执行123android.app.FragmentManager fm = activity.getFragmentManager();return supportFragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); 其中android.app.Fragment会略有差异，因为该Fragment为android包下，已被遗弃，但执行逻辑其实大同小异 接下来我们再看supportFragmentGet函数 supportFragmentGet()跟随Fragment的生命周期1234567891011121314151617181920@NonNullprivate RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) &#123; SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint, isParentVisible); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); current.setRequestManager(requestManager); &#125; return requestManager;&#125; getApplicationManager跟随应用的生命周期 12345678910111213141516171819202122232425@NonNull private RequestManager getApplicationManager(@NonNull Context context) &#123; // Either an application context or we&apos;re on a background thread. if (applicationManager == null) &#123; synchronized (this) &#123; if (applicationManager == null) &#123; // Normally pause/resume is taken care of by the fragment we add to the fragment or // activity. However, in this case since the manager attached to the application will not // receive lifecycle events, we must force the manager to start resumed using // ApplicationLifecycle. // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context.getApplicationContext()); applicationManager = factory.build( glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode(), context.getApplicationContext()); &#125; &#125; &#125; return applicationManager; &#125; 这样的话，就可以看得出调用with函数时，会绑定到一个requestManaget对象，但是分两种： 1、子线程，或出入的Context为ApplicationContext —》 applicationManager —— 跟随应用的生命周期 2、main线程 &amp; 非ApplicationContext —-》 requestManager —- 跟随当前Fragment/Activity的生命周期 接着看RequestManager RequestManager查看RequestManager的构造函数1234567891011121314151617181920212223242526272829303132333435363738public RequestManager( @NonNull Glide glide, @NonNull Lifecycle lifecycle, @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) &#123; this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory(), context);&#125;@SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)RequestManager( Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode, RequestTracker requestTracker, ConnectivityMonitorFactory factory, Context context) &#123; this.glide = glide; this.lifecycle = lifecycle; this.treeNode = treeNode; this.requestTracker = requestTracker; this.context = context; connectivityMonitor = factory.build( context.getApplicationContext(), new RequestManagerConnectivityListener(requestTracker)); if (Util.isOnBackgroundThread()) &#123; mainHandler.post(addSelfToLifecycle); &#125; else &#123; lifecycle.addListener(this); &#125; lifecycle.addListener(connectivityMonitor); defaultRequestListeners = new CopyOnWriteArrayList&lt;&gt;(glide.getGlideContext().getDefaultRequestListeners()); setRequestOptions(glide.getGlideContext().getDefaultRequestOptions()); glide.registerRequestManager(this);&#125; 两个构造函数，上面的构造函数会调用到下面的构造函数，只有上面的函数才对外暴露。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"okhttp解析(一) 执行与分发","slug":"okhttp解析","date":"2020-12-25T03:25:23.000Z","updated":"2021-01-14T02:09:33.769Z","comments":true,"path":"blog/2020/12/okhttp解析.html","link":"","permalink":"hexo/blog/2020/12/okhttp解析.html","excerpt":"","text":"okhttp解析okhttp 是一个网络框架，是当下android使用最频繁的网络请求框架，由Square公司开源。 google在Android4.4后开始将源码中的HttpUrlConnection底层实现替换为okhttp，现在流程的Retrofit框架底层同样是使用okhttp的。 优点 支持http1、http2、Quic以及WebSocket 连接池复用底层TCP(Socket),减少请求延时 无缝支持GZIP减少通信数据流量 缓存相应数据减少重复请求次数 请求失败自动重试主机其他ip，自动重定向 使用方法okhttp具体使用可以查看： Call在client执行request时，会调用newCall方法。 1234@Overridepublic Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125; 会返回一个RealCall对象，而RealCall是Call接口的一个实现。 client调用newCall时，只是返回一个RealCall对象，请求还没有发送出去。需要执行RealCall的execute()或者enqueue() 这两个方法由什么区别呢，现在看一下。 execute这是一个同步方法，即会直接执行 123456789101112131415161718192021@Overridepublic Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this); // 发起请求 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 此处会调用client.dispatcher().executed(this); 其实是将当前RealCall对象加入到Dispatch的同步执行队列在最后执行完毕会调用 client.dispatcher().finished(this); 其实是将当前RealCall对象从Dispatch的同步执行队列移除，因为当前RealCall对象的任务已执行完毕 会获取到response，并直接return enqueue这是一个异步方法 12345678910@Overridepublic void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 在上面的两个方法中，最后都会调用到dispatcher的对应函数，Dispatch是一个分发器 注意调用dispatch的enqueue函数时，会将responseCallback包装成一个AsyncCall对象，AsyncCall为RealCall的一个内部类 AsyncCall1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super(&quot;OkHttp %s&quot;, redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //执行请求 （拦截器） Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;&#125; AysncCall实质上实现的是Runnable，execute执行的是获取response过程，请求成功则执行responseCallback.onResponse，否则执行responseCallback.onFailure 最后执行client.dispatcher().finished(this); 注意最后传入的this指向是AsyncCall实例对象， DispatchDispatch是okHttp内一个任务分发器，用于管理任务、管理线程池。我们可以自定义Dispatch，如果没有传入自定义的，okHttp内部也有默认的，okhttp3.Dispatcher 123456789101112131415161718192021222324252627282930313233public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; /** * Executes calls. Created lazily. * 内部的线程池 */ private @Nullable ExecutorService executorService; /** * Ready async calls in the order they&apos;ll be run. * 等待执行的异步队列 */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** * Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. * 正在执行的异步队列 */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** * Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. * 正在执行的同步队列 */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); ....&#125; 可以看到在Dispatch内部有一个线程池，有三个队列，这三个队列下面会用的，会根据不同的任务添加到不同的队列 看一下Dispatch内部的executed以及enqueue函数 线程池12345678public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); &#125; return executorService;&#125; 关于线程池的详细解析可以查看之前的文章：线程池第4个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小 当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。 所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。 LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定 当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的integer.MAX_VALUE,此时添加任务会一直成功。 最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。 SynchronousQueue: 无容量的队列 使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。 唯一制约就是配置的最大线程数，如果使用Integer.MAX_VALUE就实现了真正的无等待。 而在okhttp中就采用的SynchronousQueue，但进程内存是有限制的，不能无限添加，所以在Okhttp内部又有maxRequests限制，保证不超过64个。 executed123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 可以看到在同步函数中，会将call 添加到同步执行队列 enqueue12345678910synchronized void enqueue(AsyncCall call) &#123; //todo : 1、如果正在执行的请求小于64 // 2、相同host的请求不能超过5个 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); //正在执行的请求 executorService().execute(call); //线程池跑任务 &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125; 在异步执行时，会判断当前正在执行异步队列大大小是否小于64 &amp;&amp; 传入的call的Host在正在执行队列中数量是否小于，如果都满足，则会被放入正在执行异步队列，并且调用线程池执行该任务如果不满足，则会被放入待执行异步队列 注意：此处的call为一个AsyncCall实例， 上面在AsyncCall中讲过了，当AsyncCall执行完毕会调用finished（AsyncCall）函数来移除正在执行异步队列中的这个AsyncCall对象 finished123456789101112131415161718192021222324// 异步执行队列移除AsyncCall对象void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true);&#125;// 同步队列移除RealCall对象void finished(RealCall call) &#123; finished(runningSyncCalls, call, false);&#125;private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 当异步执行队列移除AsyncCall对象时，会执行promoteCalls()；而且当this.idleCallback不为空，而且异步执行队列为空时,会执行this.idleCallback.run(); promoteCalls12345678910111213141516171819/** * 从异步等待队列中取任务执行 */private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); // 同一Host请求只能同时有5个 if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125;&#125; promoteCalls函数主题其实就是从等待异步队列中取任务放入到执行异步任务队列中，并执行。 先判断异步执行队列大小是否大于64，是则不向下执行 再判断待执行异步队列是否没有数据，是则不向下执行 然后遍历readyAsyncCalls队列，判断当前AsyncCall的Host是否在异步执行队列中&lt;5,小于5时，将该任务从待执行异步队列移除，并将该任务添加到执行异步队列，并放入线程池判断异步执行队列大小是否大于64，是的话，终止遍历 到这里，okHttp的任务执行基本就看完了。 当然还有任务的取消 Cancel12345678910111213public synchronized void cancelAll() &#123; for (AsyncCall call : readyAsyncCalls) &#123; call.get().cancel(); &#125; for (AsyncCall call : runningAsyncCalls) &#123; call.get().cancel(); &#125; for (RealCall call : runningSyncCalls) &#123; call.cancel(); &#125; &#125; 就是遍历三个队列，调用Call对象的cancel方法。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"android-自定义View-继承Drawable","slug":"android-自定义View-继承Drawable","date":"2020-12-22T02:11:42.000Z","updated":"2020-12-22T03:00:18.385Z","comments":true,"path":"blog/2020/12/android-自定义View-继承Drawable.html","link":"","permalink":"hexo/blog/2020/12/android-自定义View-继承Drawable.html","excerpt":"","text":"源码地址 最后实现效果如下图： 思路：1、将正个鱼分成几个部分，鱼头圆，鱼身二阶贝塞尔曲线，鱼尾，鱼鳍2、因为鱼会摆动，需要考虑一个角度问题，需要定义一个点，来确定整个的角度3、以鱼的重心点作为基准点，即鱼身的中心点4、根据鱼的中心点以及每条线的长度获取其他点的坐标，就可以绘制整个图形5、鱼的摆动根据属性动画来绘制，但要考虑鱼头与鱼尾的摆动频率不一致，可以使用三角函数，0-360，鱼头设置一倍，鱼尾设置多倍，此时就能鱼头与鱼尾摆动频率不一致了。6、鱼尾分两段，摆动的方向不一致，一段带动另一段，一个采用正旋sin，一个采用余旋cos 进阶：鱼能游动7、点击时的水波纹8、鱼回头问题","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Android 嵌套滑动","slug":"Android-嵌套滑动","date":"2020-12-17T02:31:48.000Z","updated":"2020-12-17T02:31:48.218Z","comments":true,"path":"blog/2020/12/Android-嵌套滑动.html","link":"","permalink":"hexo/blog/2020/12/Android-嵌套滑动.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android View的事件分发","slug":"Android-View的事件分发","date":"2020-12-17T02:11:13.000Z","updated":"2020-12-18T05:34:44.146Z","comments":true,"path":"blog/2020/12/Android-View的事件分发.html","link":"","permalink":"hexo/blog/2020/12/Android-View的事件分发.html","excerpt":"","text":"View的事件分发首先用户的交互事件都是先交给Actiivty，然后再来向下分发事件 Activity我们可以查看Activity的dispatchTouchEvent 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 首先需要明确一点，ACTION_DOWN是一次完整的交互事件的起点，onUserInteraction是一个空函数可以不要管， 会将事件分发到window的superDispatchTouchEvent，而window指的是PhoneWindow，在andorid源码中，只有一个window的实现类，就是PhoneWindow，如果window的dispatch返回为true则不向下执行，否则会执行到Activity的onTouchEvent， PhoneWindow1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 在PhoneWindow.java中 superDispatchTouchEvent函数又代理给DecorView的superDispatchTouchEvent DecorViewDecorView继承自FrameLayout，FrameLayout继承自ViewGroup123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; DecorView中的superDispatchTouchEvent直接调用父类的dispatchTouchEvent，而在FrameLayout中没有重写dispatchTouchEvent函数，所以会直接调用到ViewGroup的dispatchTouchEvent函数 ViewGroup首先，所有的View都是继承自View的，ViewGroup也是继承自View 在ViewGroup的dispatchTouchEvent函数中，代码太长，先将部分代码收缩起来 123456789101112131415161718192021222324252627@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; // mInputEventConsistencyVerifier是View中的一个变量，这里是对事件的一些校验 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. // 此处是对一些无障碍功能的设置 if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; // 局部变量，每一个事件分发时，都会重置为false boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; ... &#125; // 重新校验 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 其实主要逻辑还是在 if (onFilterTouchEventForSecurity(ev)) { 这个代码区域里 123456789public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123; //noinspection RedundantIfStatement if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123; // Window is obscured, drop this touch. return false; &#125; return true;&#125; 对事件安全过滤的函数，正常情况都能通过。接着看dispatchTouchEvent函数 1234567891011final int action = ev.getAction();final int actionMasked = action &amp; MotionEvent.ACTION_MASK;// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();&#125; 判断是ACTION_DOWN就清除、重置touch事件，因为在上面讲过，ACTION_DOWN是一次交互的起点，在这里将上一次交互的状态都清除掉 判断事件是否拦截12345678910111213141516// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 这里是判断是否开启拦截，注意这里的判断逻辑，intercepted是是否拦截标志位disallowIntercept： 是否允许拦截，此处是一个外部拦截，在子视图中设置的，子视图设置是否让父容器拦截事件如果disallowIntercept = false，再取执行内部拦截，onInterceptTouchEvent，查看ViewGroup是否拦截，为内部拦截disallowIntercept为true时，代表子视图不允许父容器拦截，则intercepted = false; 12345678910111213141516 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false);&#125;// Check for cancelation.final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;// Update list of touch targets for pointer down, if needed.final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;TouchTarget newTouchTarget = null;boolean alreadyDispatchedToNewTouchTarget = false;``` 当被拦截时，或者touchTarget不为空时，设置事件的TargetAccessibilityFocus为false然后判断事件是否是取消事件初始化一个变量alreadyDispatchedToNewTouchTarget=false, 是否已经将事件绑定到一个targetView if (!canceled &amp;&amp; !intercepted) { // 当不是取消、没有被拦截时 // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. // 获取到该事件绑定的view View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; ...... }1234在上述代码段中，其实只是执行了一个操作，即遍历子View，获取该事件对应的处理的View。注意这里有一个函数调用 dispatchTransformedTouchEvent当遍历找到需要处理这个事件的View或者确定不存在该View时，即执行这个函数，对这个事件进行重新分发 private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don&apos;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { // 为空，将事件交给View.dispatchTouchEvent处理 handled = super.dispatchTouchEvent(event); } else { // 子View处理 handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don&apos;t need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; } 123456789上述函数总结其实就是判断childView是否为空，如果为空的话，就再将事件转交给View.dispatchTouchEvent来处理，super.dispatchTouchEvent，因为ViewGroup继承自View，此时会调用到View.dispatchTouchEvent如果childView存在，则执行childView.dispatchTouchEvent，如果childView还是ViewGroup，还会再次执行这个过程，遍历-找寻子View-分发，注意在分发过程中，如果已经返回为true了，则不会再向下分发。接下来看View的dispatchTouchEvent## View public boolean dispatchTouchEvent(MotionEvent event) { // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) { // We don’t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) { return false; } // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); } boolean result = false; if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture // 当手指触碰时，停止滚动 stopNestedScroll(); } if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement // 当onTouch事件返回了true时，此处返回true ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } // 当onTouch事件返回了true时，此处返回true if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } if (!result &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest // of the gesture. // 当手指抬起、取消时，结束滚动 if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) { stopNestedScroll(); } return result; }12再看一下onTouchEvent事件，onTouchEvent是对事件的处理 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn’t respond to them. return clickable;}`如果View是不可点击的，如：ImageView,直接return false View里因为设置了 onClickListener(), 这样就导致 View是 clickable (或者可以直接在xml里加上android:clickable=”true”)，即可点击，那么View.onTouchEvent就会永远返回 True, 代表View consume了该事件。注意：只要View consume了该事件，那么该事件既不会往下传(不会传给子view)，也不会往上传(后面Activity/ViewGroup 的 onTouchEvent将不会再调用)。 View中不存在拦截，只有ViewGroup才有拦截","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"网络通信","slug":"网络通信","date":"2020-12-09T06:32:30.000Z","updated":"2020-12-11T08:26:06.828Z","comments":true,"path":"blog/2020/12/网络通信.html","link":"","permalink":"hexo/blog/2020/12/网络通信.html","excerpt":"","text":"网络通信计算机网络发展概史计算机的发展大致分为以下四个阶段1、诞生阶段，单个计算机为中心的远程联机系统2、ARPANET，多个主机通过通信线路互联起来3、开放性的标准化体系结构，OSI诞生4、Internet互联网 OSI模型分为7层，tcp/ip模型分为4层，并存在对应关系osi：物理层、链路层、 网络层、 传输层、 会话层、表示层、应用层tcp/ip：链路层、 网络层、 传输层、 应用层 像我们日常中所说的4G、5G网络，是作用在链路层 TCP协议的基本特性：面向链接、可靠性、RTT和RTO、数据排序、流量控制、全双工 三次握手TCP协议中，Client与Server端建立链接会经历三次握手过程 1、Client 向 Server端发送报文， 含有SYN = 1； seq(序列号)=1234(系统决定，1234是举例)，Client端进入SYN_SENT状态2、Server 接收到 Client端报文，向Client端发送一个确认报文， 含有 SYN = 1；ACK = 1; ack=1235(1234 + 1);seq(序列号)=2637(系统决定，2637是举例) Server端进入SYN_SYN_RCND状态3、Client端接收到Server的确认报文，向Server端也发送一次确认报文， 含有 ACK = 1；ack=2638(2637+1); Client与Server端都进入ESTABLISHED状态，通信建立，开始会话 以上就是三次握手的过程 问题：为何tcp协议需要三次握手，而不是两次 因为三次是保证连接可靠、效率最高的次数。第一次：客户端询问服务端能否建立通信第二次：服务端向客户端确认可以通信第三次：客户端向服务端确认可以通信然后建立通信。 洪泛攻击黑客伪造大量虚假ip向服务端发送第一次握手报文，使server端大量通信进入SYN_SYN_RCND状态，消耗server资源，使服务端无法响应其他的请求，甚至宕机。 处理方案：防火墙、 四次挥手当要断开连接时，客户端与服务端之间将进行四次挥手，来确保数据传输都完毕，确保连接断开。 1、client向server端发送FIN报文， 含有FIN = 1，seq(序列号)=J(系统决定，J是举例)，Client进入FIN_WAITING2、server收到客户端发送的报文，同时向Server发送一个FIN ACK 确认报文 含有ACK = 1； ack = J + 1; Server进入CLOSE_WAITING3、server向client发送一个FIN报文， 含有FIN = 1； seq = K；Server进入 CLOSE状态4、client收到上述两个server端报文，Client进入TIME_WAITING状态,同时client向server发送一个ACK报文， 含有FIN = 1； ACK = 1； ack = K + 1; server接收到此报文后，进入CLOSED状态， 而client，在经过2 * MSL的时间段后，client进入CLOSED状态。 注意：四次挥手设计到四次报文的传输，但在实际中，可能会存在报文合并的现象，就是报文发送的次数可能只有3次甚至两次。MSL理论上是2分钟，可实际一般会被重写为30s，所以最后等待时间为1min-4min。 为什么需要四次挥手因为tcp是全双工(即客户端和服务器端可以相互发送和接收请求)，所以需要双方都确认关闭连接。 为什么需要TIME-WAIT状态？在第三次报文发送，client接收到时，client会进入TIME_WAIT状态，而且是需要经过经过2 * MSL，才会进入CLOSED状态，为何这么设计呢，因为要考虑最后一个报文的接收，要考虑到Server未接收到时，需要重新发送，还要考虑，如果Client即时进入CLOSED，连接断开，端口可能会有一个新的程序使用，可能存在报文被发送到这个新启动的程序。 wireshark使用wireshark可以抓包，查看到连接过程中的每一次数据包的传递 使用过滤器查看 tcp udp 可以指定协议 tcp.port==80 端口 ip.src==192.168.101.130 ip连接符使用and tcp and tcp.port==3306 and ip.src==192.168.101.130","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Activity一键换肤","slug":"Activity一键换肤","date":"2020-12-07T07:51:39.000Z","updated":"2020-12-11T09:59:44.348Z","comments":true,"path":"blog/2020/12/Activity一键换肤.html","link":"","permalink":"hexo/blog/2020/12/Activity一键换肤.html","excerpt":"","text":"Activity一键换肤Activity绘制过程ActivityThread查看ActivityThread代码源码，performLaunchActivity函数123456789101112131415161718192021222324Activity activity = null;try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125;......activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); Activity我们在看Activity类中的attach函数中的部分12345mWindow = new PhoneWindow(this, window, activityConfigCallback);mWindow.setWindowControllerCallback(this);mWindow.setCallback(this);mWindow.setOnWindowDismissedCallback(this);mWindow.getLayoutInflater().setPrivateFactory(this); 再看我们在Activity中设置布局的setContentView函数在Activity中的实现1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; 这里可以看出我们传入的layout布局是设置到window对象上的，继续往里看Window类中的setContentView是一个抽象方法，而getWindow()返回的是我们上面的PhoneWindow对象，我们看PhoneWindow中的setContentView方法 PhoneWindowPhoneWindow.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125;@Overridepublic void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 当初次运行时，肯定会走到installDecor 函数，在此函数中，又会新建一个DecorView绑定到window上。 也就是说我们的window上还有挂载一个DecorView 而在installDecor中，会对mContentParent判断，当为空时，会初始化mContentParent = (DecorContentParent) mDecor.findViewById(R.id.decor_content_parent); 所以其实我们的view的层级其实是：Window -&gt; DecorView -&gt; mContentParent + 我们自己的布局而我们自己的View最后都是调用到LayoutInflater.inflate来加载的。 LayoutInflater最后所有View的加载会走到tryCreateView函数LayoutInflater 中的 tryCreateView函数 12345678910111213141516171819202122232425@UnsupportedAppUsage(trackingBug = 122360734)@Nullablepublic final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; if (name.equals(TAG_1995)) &#123; // Let&apos;s party like it&apos;s 1995! return new BlinkLayout(context, attrs); &#125; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; return view;&#125; 可以看得出先判断mFactory2是否存在，存在的话，会通过mFactory2.onCreateView来创建View再判断mFactory是否存在，存在的话，会通过mFactory.onCreateView来创建View如果上面两个都不存在，则会调用mPrivateFactory来创建 实践设计思路根据上面的描述，我们知道所有的View创建都会走到LayoutInflater.tryCreateView函数，而且这里有一个工厂类mFactory2，如果我们能创建一个mFactory2对象，并设置上去，那所有的view创建就都会走到我们自己的代码，则我们可以获取到所有的view 换肤：是替换所有可以替换的颜色、背景，包括背景颜色、背景图片，因为我们替换了背景颜色，所以文本颜色也是需要替换。我们明确了换肤的目标，原理呢就是：换肤插件module中具有的资源名与宿主app的资源名都一致，只是资源值不同，如在宿主app中res/value/colors.xml中1234567891011121314&lt;!--宿主app--&gt;&lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt; &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#ffce3d3a&lt;/color&gt;&lt;/resources&gt;&lt;!--插件module--&gt;&lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#1F1F1F&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#373935&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#ffffff&lt;/color&gt; &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#FFA500&lt;/color&gt;&lt;/resources&gt; 如上所示，所有的资源名称都是一致，只是资源内容不同，图片也是如此。当需要换肤时，通过获取宿主app的资源名称，到插件module中获取该名称的对应资源，然后替换","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"注解","slug":"注解","date":"2020-12-03T01:13:53.000Z","updated":"2021-01-19T10:03:46.001Z","comments":true,"path":"blog/2020/12/注解.html","link":"","permalink":"hexo/blog/2020/12/注解.html","excerpt":"","text":"注解Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。 注解作用可以在源码、编译、运行时起作用， 自定义注解新建一个 @interface与java类或接口大致相同的格式要求，但使用关键字 @interface 可以在自定义注解上使用其他注解 1234public @interface CustomAnnotation &#123;&#125;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android消息机制","slug":"android消息机制","date":"2020-11-24T03:09:22.000Z","updated":"2020-11-25T10:09:41.994Z","comments":true,"path":"blog/2020/11/android消息机制.html","link":"","permalink":"hexo/blog/2020/11/android消息机制.html","excerpt":"","text":"在andorid中，系统的行为、用户的输入等事件都会被包装为一个消息，进行消息发送、处理 关于消息的处理，就离不开Handler、Message、Loop在平时使用时，Handler多用于多线程之间通信。 那么Handler如何实现多线程通信？ 多线程之间为何不会互相干扰？ 为什么不使用用wait/notify？ Handler多线程通信先看一下普通使用案例 12345678910111213141516171819202122232425public class MyActiivty extends Activity &#123; private Handler myHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if(msg.what=100) &#123; // TODO &#125; &#125; &#125; &#125; static class MyThread extends Thread() &#123; @Overtide public void run() &#123; super.run(); Message message = Message.obtain(); message.what = 100; myHandler.sendMessage(); &#125; &#125;&#125; 上面就是一个简单的在子线程发送消息，回到主线程处理消息的过程，通过在子线程构造一个message对象，在主线程中获取到该message对象，来处理消息。 所以其实Handler处理多线程通信是通过共享Message对象内存来实现的。内存是不区分线程的，这种通信原理就是在子线程与主线程共享message内存 所以 那么Handler如何实现多线程通信？通过 内存共享 实现。 在多线程时，Handler又是如何保证消息如何在正确的线程发送的呢，或者说是如何保证执行的线程是正确的了。这就要引入我们的Loop、消息队列概念了。 handler处理消息模型: handler负责发送、处理消息looper负责一直轮询消息messageQueue消息队列，负责存放、取出消息 Looper讲到looper负责一直轮询消息，但是好像在上面的代码中，都没有使用到looper。 其实是在主线程中，系统已经默认为我们创建了looper，在ActivityThread.java的main方法中（ActivityThread即为主线程） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format &quot;seq=114&quot; long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; 我们可以看到，调用了Loop.prepareMainLooper()、Looper.loop()函数，而且在Looper.loop()后面就抛出异常，也就是说主线程中loop一旦停止轮询，则会抛出异常闪退。正常情况时，loop就是一直在轮询。 查看Looper的这两个函数123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper = myLooper(); &#125; &#125; 在prepareMainLooper中可以看到，不允许调用两次，否则会抛出异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos; final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); boolean slowDeliveryDetected = false; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; // Make sure the observer won&apos;t change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (slowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); slowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; loop函数中，首先获取通过myLooper()函数获取looper对象，如果looper对象为空，则抛出异常，提示必须在当前线程先执行Looper.prepare()然后获取looper对象持有的messageQueue，然后就是for(;;)无限循环，获取messageQueue下一条消息获取到message后调用msg.target.dispatchMessage(msg);将这条消息发送出去。最后执行msg.recycleUnchecked()，相当于一个回收利用。 我们看一下myLooper函数123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 说明looper是存放在ThreadLocal中的。关于ThreadLocal，在之前已经大致讲过了。ThreadLocal讲解（https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）在每一个线程，都存在一个对应且唯一的值 我们可以看一下prepare函数123456789101112131415public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 可以看到与prepareMainLooper的不同，因为prepareMainLooper是在主线程调用，而主线程很自由一个，所以直接使用sMainLooper来保存主线程的looper，而且主线程中prepare(false)；标示不允许looper退出。 而在子线程时，就是将looper对象保存到sThreadLocal中，sThreadLocal.get()不为null时，会抛出异常。也就是说子线程中prepare只允许调用一次，保证了每个线程中的looper对象唯一性 然后看到子线程和主线程的另一个差异prepare(false) &amp;&amp; prepare(true)因为andorid，所有事件如：用户的操作、ui的渲染等都是作为消息发送的，而这些都是在主线程操作的，所以在主线程中是不允许退出loop循环，否则抛出异常。 而在子线程中prepare(true)，允许退出，其实在子线程中新建handler、looper时，当我们不需要再使用，需要终止loop循环。此时需要调用：123public void quitSafely() &#123; mQueue.quit(true);&#125; MessageQueue在上面中已经讲过Looper，looper中持有一个messageQueuefinal MessageQueue queue = me.mQueue;mQueue 在Looper的私有构造函数中被初始化 接下来我们看一下MessageQueue队列是一种数据结果，FIFO先进先出MessageQueue 是一个消息队列，默认也是先进先出，有序执行 之前说了，MessageQueue主要用于存放、取出消息。在Looper中主要用到了messagequeue的next函数，用于取出下一条消息 我们先看一下存放消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 如果当前线程已经退出，mQuitting为true，则抛出异常。 123456789msg.when = when;Message p = mMessages;boolean needWake;if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked;&#125; 当全局变量mMessages为空，或者当前传入的when为0， 或者当前when小于全局变量mMessages.when(即时间在前)其实判断的是两种状态，1:messageQueue队列为空 2:添加的消息执行时间在前此时将该消息置于队首，needWake = mBlocked；如果mBlocked为true，needWake也为true，就是如果之前阻塞则唤醒，反之无需唤醒 再看不满足上面情况下时,即消息队列中已添加过消息，而且要添加的消息.when在上一次添加的消息之后12345678910111213141516171819else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;&#125; for循环，遍历链表，当找到节点为null即遍历完 || 传入的when小于遍历节点的when（即传入消息的时间在遍历节点时间之前时）终止循环，将msg.next -&gt; p原来prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; p -&gt; …现在prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; msg.next -&gt; p -&gt; … 也就是说，message链表是按照when排序的，when越小，在越靠近链头为何要根据when排序了，其实是因为message执行时间是要按时间排序，要执行时间越小，代表时间越早，所以放在链头 以上是消息队列，入队函数，再看一下出队函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@UnsupportedAppUsageMessage next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 其中有一段代码可以先不看，1234567if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125; 这一块设计到消息的同步屏障，放到下面再将，我们先只看出队时的逻辑next函数就是取出下一条消息。开启for循环123if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands();&#125; 如果nextPollTimeoutMillis不等于0时，会阻塞。 123456789101112131415161718192021222324final long now = SystemClock.uptimeMillis();Message prevMsg = null;Message msg = mMessages;if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125;&#125; else &#123; // No more messages. nextPollTimeoutMillis = -1;&#125; 当当前message不为空时：如果当前时间小于msg.when，即没到执行时间，则阻塞线程到msg.when时间将msg.next赋值给全局变量mMessages，再将msg.next指向null然后返回msg这一个节点，如此不会返回一个链表 如果msg为空，说明队列为空，没有消息，此时赋值nextPollTimeoutMillis = -1;下一次循环时，就会阻塞。 MessageQueue 添加消息、取出消息是线程安全的吗？是，是线程安全的。 如何保证线程安全的？通过锁，存放消息以及取出消息时都有设置synchronized (this)，synchronized 后面修饰的是this，同一个对象在多线程环境调用函数时，只会有一个线程获取到锁，进行操作。synchronized 是内置锁，JVM已经内置处理了锁的获取以及释放 为什么不使用用wait/notify？在上述代码可以看到使用了阻塞、锁，阻塞是直接调用native 函数来阻塞，其实在内部已经使用了wait/notif。 Message上面讲了消息机制中的Handler、Looper、MessageQueue；现在我们再讲一下消息的本体Message 首先通过我们在上面的分析，可以知道Message在数据结构上看，是一个链表，而且是只有next指针，所以是个单链表。Message中没有什么复杂操作，都是一些赋值函数有两个地址可以注意下12345678910111213141516171819202122232425262728293031323334public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); &#125; return; &#125; recycleUnchecked();&#125;void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; Message的回收函数不是将对象置为空，而是将Message中的变量都还原为默认值。 12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; Message还提供obtain函数，不会直接new 一个Message对象，而是共享之前的对象，改变对象的内部属性。 所以我们在实际使用中都是使用Message.obtain()来构建message对象，而不是一直使用new ，这样可以避免频繁的生成、回收，避免内存抖动。 这种设计被成为 享元设计模式 Message 同步屏障上面讲的消息message链表是根据when时间排序，那如果有紧急的消息必须马上处理呢，这个时候不可能等其他先执行而必须是马上执行的事件时，怎么办？ 这个时候就可以用到 同步屏障 handler消息机制大概流程：生成Looper对象，生成Handler对象，Lopper.looper循环在Handler构造函数内，获取到上面生成的looper对象，通过ThreadLocal保存到对应的线程，与MessageQueue绑定在需要发送消息的地方调用handler.sendMessage(),在sendMessage时，将message与handler绑定，将message.target赋值为当前handler同时，sendMessage时，调用messageQueue.enqueueMessage将message放入消息队列。同时，Looper.loop()在循环一直取出消息message，然后通过message.target获取到handler对象，最终回调到handler.handlerMessage函数。 这样消息从产生到处理流程就走完了。 总结提问： Looper.loop()一直在循环，为什么不会导致应用卡死(ANR)? 答：loop()循环与ANR是两个不相关的事情，loop只是循环事件，ANR是处理事件耗时，导致无法响应用户的下一次输入。系统的ANR弹窗都是通过消息机制发送，并弹出提示窗的。 fragment生命周期","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"APT注解处理器","slug":"APT注解处理器","date":"2020-11-16T03:04:49.000Z","updated":"2020-11-16T10:01:32.916Z","comments":true,"path":"blog/2020/11/APT注解处理器.html","link":"","permalink":"hexo/blog/2020/11/APT注解处理器.html","excerpt":"","text":"APTAPT(Annotation Processing Tool) 是一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，根据注解自动生成代码，如果想要自定义的注解处理器能够正常运行，必须要通过APT工具来进行处理。 也可以这样理解，只有通过声明APT工具后，程序在编译期间自定义注解解释器才能执行。 通俗理解：根据规则，帮我们生成代码、生成类文件 在使用APT在项目编译时期动态生成我们需要的java文件时，有两种方式，传统方式、javapoet 项目源码(https://github.com/wangchongwei/apt) javapoet以面向对象(OOP)思维，在编译时，动态生成java文件 优点：OOP思维，不需要导包缺点：倒序写法，从函数-&gt;类-&gt;包 这种方式和写作思维不同，从调用链尾部到头部。开源组件butterknife、ARouter都是使用javapoet方式 example: 新建一个工程，并在工程新建一个javaLib，在此工程新建一个注解类123456789@Target(ElementType.TYPE) // 表明注解是添加在类上@Retention(RetentionPolicy.CLASS) // 表明在编译器执行public @interface ARouter &#123; String path(); // 声明注解时 必须参数 String group() default &quot;&quot;; // 因为已经设置了default值，所以这个是选填参数&#125; 此时我们就完成了一个注解的定义然后再新建一个javaLib，在此工程新建一个处理注解的类，而这个类就是我们在编译时生成java类的主要代码部分在此工程build.gradle中添加依赖123456789101112dependencies &#123; // 背后的服务 能够监听 你是否在编译中..... // AS3.4.1 + Gradle 5.1.1 + auto-service:1.0-rc4 compileOnly&apos;com.google.auto.service:auto-service:1.0-rc4&apos; annotationProcessor&apos;com.google.auto.service:auto-service:1.0-rc4&apos; // 帮助我们通过类调用的形式来生成Java代码 [JavaPoet] implementation &quot;com.squareup:javapoet:1.9.0&quot; // 依赖注解module implementation project(&quot;:annotations&quot;)&#125; 然后我们开始写监听到注解时需要生成java类的部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@AutoService(Processor.class) // 启用服务 google 自动服务，一直监控@SupportedAnnotationTypes(&#123;&quot;com.justin.annotationprocessor.ARouter&quot;&#125;) // 注解 包名.类名@SupportedSourceVersion(SourceVersion.RELEASE_8) // 环境的版本@SupportedOptions(&quot;student&quot;) // 接收在app/build.gradle中声明的参数public class ARouterProcessor extends AbstractProcessor &#123; private Elements elements; private Messager messager; private Filer filer; private Types typeTool; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); elements = processingEnvironment.getElementUtils(); messager = processingEnvironment.getMessager(); filer = processingEnvironment.getFiler(); typeTool = processingEnvironment.getTypeUtils(); // 获取在app/build.gradle中申明的参数 String value = processingEnvironment.getOptions().get(&quot;student&quot;); messager.printMessage(Diagnostic.Kind.NOTE, &quot;=========&gt;&quot; + value); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; // 此时会运行两次，一次执行，一次检查 messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; compiler is running&quot;); if(set.isEmpty()) &#123; // 使用注解的类集合为空 return false; &#125; // 获取被 ARouter注解的 &quot;类节点信息&quot; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class); for(Element element : elements) &#123; /** 举例我们需要生成这样一个类 package com.example.helloworld; public final class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, JavaPoet!&quot;); &#125; public int add(int a, int b)&#123; return 5; &#125; &#125; */ // javapoet生成java文件的方式时，OOP思维，先生成函数，再生成类，最后生成包 // 1 生成函数 MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;main&quot;) // 构造一个函数， 函数名 .addModifiers(Modifier.PUBLIC, Modifier.STATIC) // public 、static .returns(void.class) // 返回值类型 .addParameter(String[].class, &quot;args&quot;) // 入参类型 .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)// 函数执行语句 不需要添加分号 .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, agent!&quot;) .build(); // 多个函数 MethodSpec methodSpec1 = MethodSpec.methodBuilder(&quot;add&quot;) .addModifiers(Modifier.PUBLIC) .returns(int.class) .addParameter(int.class, &quot;a&quot;) .addParameter(int.class, &quot;b&quot;) // 可以添加多个入参 .addStatement(&quot;return 5&quot;) .build(); // 2 生成类 TypeSpec myClass = TypeSpec.classBuilder(&quot;HelloWorld&quot;) // 构造一个类，类名 .addModifiers(Modifier.PUBLIC, Modifier.FINAL) // 添加申明 public、final .addMethod(methodSpec) // 绑定函数 .addMethod(methodSpec1) // 绑定多个函数 .build(); // 3、生成包 JavaFile myPackage = JavaFile.builder(&quot;com.example.helloworld&quot;, myClass).build(); try &#123; myPackage.writeTo(filer); &#125; catch (IOException e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; 创建HelloWorld类失败,异常原因：&quot; + e.getMessage()); &#125; &#125; return false; &#125;&#125; 最后使用@ARouter注解在MainActivity中使用123456789@ARouter(path = &quot;main/MainActivity&quot;)public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 点击build项目，即会在app/build/ap_generated_sources/debug下生成对应的包以及java文件 在上述方式中，我们只是写成了一个固定的java文件，还没有体现动态生成概念。下面我们就要改造，动态接收参数来生成代码只显示动态生成代码部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取被 ARouter注解的 &quot;类节点信息&quot; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class); for(Element element : elements) &#123; // 动态生成java代码 // 获取组件class的包路径 String packageName = elementTool.getPackageOf(element).getQualifiedName().toString(); // 获取注解的类名 String className = element.getSimpleName().toString(); // 获取到注解以及注解时的参数 ARouter aRouter = element.getAnnotation(ARouter.class); String path = aRouter.path(); /** 模板： public class MainActivity3$$$$$$$$$ARouter &#123; public static Class findTargetClass(String path) &#123; return path.equals(&quot;/app/MainActivity3&quot;) ? MainActivity3.class : null; &#125; &#125; */ // 1、方法 MethodSpec method = MethodSpec.methodBuilder(&quot;findTargetClass&quot;) .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .returns(Class.class) .addParameter(String.class, &quot;path&quot;) .addStatement(&quot;return path.equals($S) ? $T.class : null&quot;, path, ClassName.get((TypeElement) element) // 获取注解类的class对象 ) .build(); // 2 类 TypeSpec mineClass = TypeSpec.classBuilder(className + &quot;$$$$$$$$$ARouter&quot;) .addModifiers(Modifier.PUBLIC) .addMethod(method) .build(); // 3 包 JavaFile minePackage = JavaFile .builder(packageName, mineClass) .build(); try &#123; minePackage.writeTo(filer); &#125; catch (IOException e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + className + &quot;类失败&quot;); &#125; &#125; 此时我们就完成了自动获取注解类的包名、类名、注解时的path自动生成的类也在相同包名下，获取注解时的path，可以做一些操作 传统方式生成java文件在编译时，一行一行，从头到尾，以写文本的方式写一个java文件 优点：套版格式，思路清晰缺点：所有代码都需要写，包括导包，如果有任一一个字符错误、分号缺失，都会导致报错。 这种方式需要及其细心开源组建EventBus就是采用的这种方式 example：首先自定义注解类：123456@Target(TYPE) @Retention(CLASS) // 编译期 XUtil==运行期public @interface Binding &#123; String router();&#125; 然后写注解处理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@SupportedSourceVersion(SourceVersion.RELEASE_7) // 环境的版本@AutoService(Processor.class) // 启用服务@SupportedAnnotationTypes(&#123;&quot;com.derry.arouter_annotations.Binding&quot;&#125;) // 注解public class BindingProcessor extends AbstractProcessor &#123; private Elements elementTool; private Messager messager; private Filer filer; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); elementTool = processingEnvironment.getElementUtils(); messager = processingEnvironment.getMessager(); filer = processingEnvironment.getFiler(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; if(set.isEmpty()) &#123; return false; &#125; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Binding.class); for (Element element : elements) &#123; // 获取包名 String packageName = elementTool.getPackageOf(element).getQualifiedName().toString(); String className = element.getSimpleName().toString(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;被@ARetuer注解的类有：&quot; + className); String findClassName = className + &quot;$$$$$$$Binding&quot;; Binding binding = element.getAnnotation(Binding.class); try &#123; JavaFileObject javaFileObject = filer.createSourceFile(packageName + &apos;.&apos; + findClassName, element.getEnclosingElement()); Writer writer = javaFileObject.openWriter(); StringBuilder sb = new StringBuilder(); sb.append(&quot;package &quot;).append(packageName).append(&quot;;\\n\\n&quot;); sb.append(&quot;public class &quot;).append(findClassName).append(&quot;&#123;\\n&quot;); sb.append(&quot;public String findTargetRouter()&#123;\\n&quot;);// sb.append(&quot;return &quot; + binding.router().toString()).append(&quot;;\\n&quot;); sb.append(&quot;return \\&quot;test\\&quot;;\\n&quot;); sb.append(&quot;&#125;\\n&quot;); sb.append(&quot;&#125;\\n&quot;); writer.write(sb.toString()); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + findClassName + &quot;类失败&quot;); &#125; &#125; return false; &#125;&#125;","categories":[],"tags":[{"name":"andorid","slug":"andorid","permalink":"hexo/tags/andorid/"}]},{"title":"android 性能优化","slug":"android-性能优化","date":"2020-11-04T05:56:47.000Z","updated":"2020-11-06T10:13:20.318Z","comments":true,"path":"blog/2020/11/android-性能优化.html","link":"","permalink":"hexo/blog/2020/11/android-性能优化.html","excerpt":"","text":"android性能优化性能优化分为几个方向： 内存优化 电量优化 渲染优化 size大小优化 异常捕获 apk瘦身针对与apk大小优化而言，首先需要知道apk中主要结构，了解其中是哪些部分比较大。然后来针对性优化。 一般而言比较占用的是：资源文件、架构文件(.so) 资源文件优化针对资源文件，首先我们去除没有被使用的资源，然后就是降低所用资源的大小。 在app/build.gradle文件中设置shrinkResources true 12345release &#123; shrinkResources true proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot; &#125; 则会在Gradle打包release apk时，自动忽略未使用的资源文件，包括：图片、xml 但要注意此时也会忽略隐式调用的资源文件，如通过反射调用，或者react-native中在js调用drawable木土图片，在这两种场景时，都会被忽略。针对这种场景，可以通过keep文件，保持这些资源文件不会被忽略。 在res目录下新建xml目录，在xml目录下新建文件keep.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resourcesxmlns:tools=&quot;http://schemas.android.com/tools&quot;tools:keep=&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;tools:discard=&quot;@layout/unused2&quot; /&gt; 其中tools:keep是强制不忽略，tools:discard是强制忽略 上面讲述的是去除无用资源，还有我们可以去除无用的代码，如未被调用的函数，未被使用的变量 minifyEnabled设置为true，设置在与shrinkResources一起的地方。注意shrinkResources需要与minifyEnabled一起使用才会生效123456release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot; &#125; 针对架构.so优化在大型项目，特别时继承第三方过多时，此时.so文件才是占用最多的部分。 异常捕获开发时怕的不是出现问题，而是问题无法重现。因为android碎片化严重 生产上的问题肯定要比开发时问题多。而且很多都是在开发端未必能重现的。此时需要我们记录发生在用户手机上的异常。 针对异常可以分类，java异常、native异常。native异常即是native函数c++代码异常 java异常捕获在andorid app中捕获java异常，只需要实现Thread.UncaughtExceptionHandler native异常","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"线程与进程","slug":"线程与进程","date":"2020-10-29T02:35:27.000Z","updated":"2021-01-20T01:27:03.156Z","comments":true,"path":"blog/2020/10/线程与进程.html","link":"","permalink":"hexo/blog/2020/10/线程与进程.html","excerpt":"","text":"进程是操作系统资源分配的基本单位， 线程是处理器（CPU）任务调度和执行的基本单位线程依赖于进程，一个进程可能对应多个线程。 并发与并行 1、并发（Concurrent）：指两个或多个事件在同一时间间隔内发生，即交替做不同事的能力，多线程是并发的一种形式。例如垃圾回收时，用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。 2、并行（Parallel）：指两个或者多个事件在同一时刻发生，即同时做不同事的能力。例如垃圾回收时，多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 同时能处理的最大线程数取决于CPU内核数量，有些机器还有逻辑处理器， 能同时处理任务的线程最大数量为CPU内核与逻辑处理器的较大值。 如内核：4，逻辑处理器：8那么CPU正在能同时处理的任务数量为8。 但为何我们写代码的时候，设置多线程运行时为何感觉可以同时设置很多个线程数量呢。 这个就跟CPU的时间轮转片调度算法有关了 在早期的时间片轮转法中,系统将所有的就绪进程按先来先服务的原则,排成一个队列,每次调度时,把CPU分配给队首进程,并令其执行一个时间片.时间片的大小从几ms到几百ms.当执行的时间片用完时,由一个计时器发出时钟中断请求,调度程序便据此信号来停止该进程的执行,并将它送往就绪队列的末尾;然后,再把处理机分配给就绪队列中新的队首进程,同时也让它执行一个时间片.这样就可以保证就绪队列中的所有进程,在一给定的时间内,均能获得一时间片的处理机执行时间. 所以我们在多线程运行时，超过内核数量的线程任务在执行时，其实是在切换运行的。只是因为CPU的时间片粒度很小，所以在切换时，很多都是无感的 线程的启动java中的程序天生的多线程的，启动线程有两种方式。 继承Thread类 实现Runnable接口 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[]args) &#123; MyThread thread = new MyThread(); thread.start(); MyThread2 thread2 = new MyThread2(); new Thread(thread2).start(); &#125; static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); System.out.println(&quot;extends Thread&quot;); &#125; &#125; static class MyThread2 implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;implements Runnable&quot;); &#125; &#125;&#125; 线程的终止线程启动了，如何终止呢？Thread类中提供了stop、suspend、resume等函数，但都是已经遗弃的，不提倡使用，在API29时，调用内部就是直接抛出异常UnsupportedOperationException。 为何遗弃，因为suspend函数，只会终止当前线程，而不会释放线程已经占有的资源(比如锁)，而是占有资源进入睡眠状态，这样容易引发死锁问题。而stop函数也是同理，在终止线程时，不会保证线程资源能够正常释放所以这些函数都已经被遗弃，不提倡使用。 正确的中断线程的方法，是调用Thread中的interrupt().interrupt()函数不会强制中断线程，而只是改变了一个线程的标志位，线程通过检测自身的标志位是否被置为true来判断是否需要继续执行。 可以调用isInterrupted()来获取该标志位，判断线程任务是否应该中断，还可以调用Thread中的静态函数interrupted()来判断，但是interrupted()函数调用时，会将标志位重新置于false。 1234567891011121314151617181920212223242526class Test &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); try &#123; Thread.sleep(300); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); while (!currentThread().isInterrupted()) &#123; System.out.println(&quot;线程正常运行&quot;); &#125;// while (!Thread.interrupted()) &#123;// System.out.println(&quot;线程正常运行&quot;);// &#125; System.out.println(&quot;线程已经被终止 flag ---&quot; + currentThread().isInterrupted()); &#125; &#125;&#125; 打印结果可以看得出isInterrupted()与interrupted()的区别。 run() start()我们new一个Thread实例对象，只是创建了一个对象，并没有与操作系统的真正的线程挂钩，只有在执行start函数时，才是真正启动了一个线程，执行了其中的run方法 start()的调用，让线程进入就绪队列等待分配cpu，分到cpu后执行run()方法，start方法不能重复调用，否则抛出异常 123456789101112131415161718192021222324252627282930313233343536373839public synchronized void start() &#123; /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ // Android-changed: Replace unused threadStatus field with started field. // The threadStatus field is unused on Android. if (started) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group&apos;s list of threads * and the group&apos;s unstarted count can be decremented. */ group.add(this); // Android-changed: Use field instead of local variable. // It is necessary to remember the state of this across calls to this method so that it // can throw an IllegalThreadStateException if this method is called on an already // started thread. started = false; try &#123; // Android-changed: Use Android specific nativeCreate() method to create/start thread. // start0(); nativeCreate(this, stackSize, daemon); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; 主要逻辑在这个native函数中nativeCreate() Thread中其他函数yieldyield(): 使当前让出cpu占有权，但让出时间不可限定，也不会让出锁资源，而且执行yield()的线程也不一定持有锁，我们可以在释放锁后执行这个方法。执行yield()后让出cpu，但也可能在下一个时间片重新获取cpu。 joinjoin() ：将指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行，比如在线程B中执行了A线程的join函数，直到A线程执行完毕，才会执行B线程。 1234567891011121314151617181920212223242526272829303132class Test &#123; public static void main(String[] args) &#123; Thread a = new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(&quot;这是a线程在执行&quot;); try &#123; Thread.sleep(100); System.out.println(&quot;这是a线程在休眠结束&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread b = new Thread()&#123; @Override public void run() &#123; super.run(); try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;这是b线程在执行&quot;); &#125; &#125;; a.start(); b.start(); &#125;&#125; 线程的同步synchronized锁，内置锁，具体详情可以查看： volatile只保证可见性，不能保证原子性 ThreadLocal在每个线程存在副本，各个线程数据互不干扰。具体详情可以查看：","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"android 8.0屏幕朝向","slug":"android-8-0屏幕朝向","date":"2020-10-28T07:08:43.000Z","updated":"2020-10-28T08:38:44.140Z","comments":true,"path":"blog/2020/10/android-8-0屏幕朝向.html","link":"","permalink":"hexo/blog/2020/10/android-8-0屏幕朝向.html","excerpt":"","text":"在android8.0设备发现一个问题，在androidManifest.xml中已配置了固定的屏幕方向，但是在应用中，点击设备menu键，选择应用时，此时应用仍然可以旋转。 在MainActivity中通过代码设置 setRequestedOrientation时会报错：Only fullscreen activities can request orientation 原因是在android8.0 的Activity.java 的代码中 1234567891011121314151617protected void onCreate(@Nullable Bundle savedInstanceState) &#123; if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (getApplicationInfo().targetSdkVersion &gt;= O &amp;&amp; mActivityInfo.isFixedOrientation()) &#123; final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window); final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta); ta.recycle(); if (isTranslucentOrFloating) &#123; throw new IllegalStateException( &quot;Only fullscreen opaque activities can request orientation&quot;); &#125; &#125; .......&#125; 如果sdk版本&gt;O &amp;&amp; 当前Activity的屏幕方向固定时，判断当前主题样式，如果包含透明样式，则会抛出该异常。 很明显这段代码存在问题，sdk&gt;=O其实就是android8.0(26)及以上。而后面两个要求，固定屏幕方向在特定应用时很常见的，而透明样式页比较常见，我们常用透明背景做一个简单的启动优化，避免其他样式导致的闪屏现象。 而这段代码也在8.0之后的版本修复，但是现在市面存在的手机在andorid8.0的时候基本都存在该问题。 修复方式时只能去除透明背景，但为了修复26存在的问题，修改应用整个的表现有些得不偿失。 所以我们可以针对特定版本修改资源。 首先去掉AndroidManifest.xml中的 android:screenOrientation 配置， 在res新增values-v26文件夹，这样在sdk26的手机就会在这个文件夹下寻找对应的资源，如果没有才会有主目录values中去找。 在values-v26中修改styles.xml，去掉此处的透明背景。 再在代码中调用setRequestedOrientation来固定屏幕 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);&#125; 此时则不会再报错，也不存在之前所说的点击menu键，回到应用会旋转问题。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android内存优化","slug":"android内存优化","date":"2020-10-21T02:08:26.000Z","updated":"2020-10-21T06:57:09.845Z","comments":true,"path":"blog/2020/10/android内存优化.html","link":"","permalink":"hexo/blog/2020/10/android内存优化.html","excerpt":"","text":"内存优化内存检测工具 MATandroid studio profile 内存抖动内存泄漏内存溢出 JMM 内存结果模型 GC算法 对象的生命周期：内存分配初始化、不可见、不可达、收集、终结、内存重新分配 四种引用类型 incomegoing: 持有该对象的对象outgoing: 该对象持有的对象 12345678910111213141516171819class A &#123; C c = new C()&#125;class B &#123; C c = new C()&#125;class C &#123; public C() &#123; &#125; C instance = new C() public C getInstance() &#123; return c &#125; D d = new D() E e = new E()&#125; C 的incomegoing为 A、B、CC 的outgoing为 C、D、E","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"ContentProvider","slug":"ContentProvider","date":"2020-10-16T01:44:40.000Z","updated":"2020-10-16T01:51:56.976Z","comments":true,"path":"blog/2020/10/ContentProvider.html","link":"","permalink":"hexo/blog/2020/10/ContentProvider.html","excerpt":"","text":"ContentProviderContentProvider 内容提供者 是android四大组件之一，为不同应用、进程之间数据共享，制定统一的接口","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Service、IntentService","slug":"Service、IntentService","date":"2020-10-09T07:06:04.000Z","updated":"2020-10-15T09:34:09.714Z","comments":true,"path":"blog/2020/10/Service、IntentService.html","link":"","permalink":"hexo/blog/2020/10/Service、IntentService.html","excerpt":"","text":"Service、IntentServiceService是android中四大组件之一，用于处理后台任务，不能处理耗时任务，否则会造成ANR而IntentService继承自Service，但是可以处理耗时任务，因为在内部开启了一个子线程。 Service生命周期Service的生命周期分为两种情形，一种是通过startService启动，另一种是通过bindService启动。在这两种情况下时，Service的生命周期是有差异的。 startService通过startService去启动一个Service，如果该Service未被创建，则会走onCreate、onStartCommand、onStart生命周期如果该Service已被创建，则不会执行onCreate，只会执行onStartCommand、onStart onStart为正常运行时的生命周期 而且startService可以被多次调用被重复调用后会执行下面的生命周期 通过startService启动的Service存活不依赖与Activity，即使启动该Service的Activity已经被销毁，但该Service仍然可以存活。通过startService启动的Service需要调用stopService来销毁该Service,此时会执行onDestroy周期函数 bindServicebindService时，Service是依赖Activity的，当当前Activity被销毁、或者调用unBindService时，Service都会被销毁。 所以每一次调用bindService时，Service都会被重新创建所以通过bindService去启动一个Service，会走onCreate、onBind生命周期 12345678910111213class ServiceConnect() : ServiceConnection &#123; override fun onServiceDisconnected(name: ComponentName?) &#123; Log.d(TAG, &quot;onServiceDisconnected: &quot;) &#125; override fun onServiceConnected(name: ComponentName?, service: IBinder?) &#123; Log.d(TAG, &quot;onServiceConnected: &quot;) &#125;&#125;btn_bindService.setOnClickListener &#123; var conn = ServiceConnect() bindService(Intent(this, MyService::class.java), conn, Context.BIND_AUTO_CREATE) hasBind = true&#125; 当执行到onBind时，还会执行onServiceConnected 在Service中，不能执行耗时操作，超过5秒，则会造成程序不响应ANR当我们需要执行耗时操作时，则必须开启子线程，或者使用IntentService IntentServiceIntentService有与Service一样的生命周期，只是在内部开启了一个子线程，暴露onHandleIntent来执行耗时任务，当子线程执行完就会终止当前Service IntentService中的部分源码123456789101112131415161718192021222324252627282930private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125;@Overridepublic void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125;@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; Servicehandler是IntentService的一个内部类，当收到消息时调用onHandleIntent,当执行完，则调用stopSelf，终止当前服务 在OnCreate中，新建了一个HandleThread，并运行。创建一个Servicehandler，而该ServiceHandler的Looper对象为HandleThread线程中创建的， 当执行到onStart生命周期时，handler发送一条消息，此时就会走到ServiceHandler中的handlerMessage中，也就会执行onHandleIntent中。因为mServiceLooper = thread.getLooper();所以onHandleIntent是运行在HandlerThread中的。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Fragment的懒加载实现，参数传递与保存","slug":"Fragment的懒加载实现，参数传递与保存","date":"2020-09-28T08:07:59.000Z","updated":"2020-09-28T08:54:03.943Z","comments":true,"path":"blog/2020/09/Fragment的懒加载实现，参数传递与保存.html","link":"","permalink":"hexo/blog/2020/09/Fragment的懒加载实现，参数传递与保存.html","excerpt":"","text":"Fragment懒加载关于Fragment的懒加载，针对ViewPager、ViewPager2又有不同， ViewPager针对ViewPager，其实是使用Fragment中的setUserVisibleHint函数以及onHiddenChanged函数，通过getUserVisibleHint()获取当前的Fragment是否可见，当不可见时，则不加载，当可见时再创建视图并缓存。这样可以只加载一次，大致原理就是如此。 ViewPager2ViewPager是androidX下的包，之前使用的setUserVisibleHint、getUserVisibleHint等都已被申明遗弃，而在ViewPager2时通过FragmentTransaction.setMaxLifecycle() 来实现懒加载","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Application生命周期","slug":"Application生命周期","date":"2020-09-28T06:44:45.000Z","updated":"2020-09-28T07:57:42.613Z","comments":true,"path":"blog/2020/09/Application生命周期.html","link":"","permalink":"hexo/blog/2020/09/Application生命周期.html","excerpt":"","text":"ApplicationApplication是指代一个应用，默认我们在android应用中可以不指定，也可以写一个类，继承Application，在AndroidManifest.xml中指定applictaion类即可 Application是应用的入口。 Application的生命周期就是应用的生命周期。 生命周期生命周期函数有：onCreate、onLowMemory、onTrimMemory、onTerminate、onConfigurationChanged 各个生命周期函数解释 onCreate: 应用被创建时调用，是程序的主入口，在此处做一些初始化操作，不要做耗时操作。 onLowMemory： 当系统整体内存可用量较少时触发，可以在这里做一些不重要数据的清除、释放资源，避免因内存不足导致App被系统杀掉 onTrimMemory(int level)： andorid4.0后出的API，用来取代onLowMemory函数的，其中这个函数还有一个入参，来表示等级。 onTerminate： 当Application结束时，又系统决定调用时机。常规手动kill app进程没有触发此函数 onTrimMemory此函数是在android4.0后引入的，能实现的组件不止Application，还有Activity、Fragment、Service、ContentProvider作用是指导应用程序在不同情况下进行自身的内存释放，以避免被系统杀掉，提高用户体验 根据不同的情况，在函数中的提现就是 onTrimMemory函数中的 level这个入参。level有7个值， TRIM_MEMORY_UI_HIDDEN：表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键、Pause键导致应用的UI界面不可见．这时候应该释放一些资源． 当app运行在前台时，会回调下面这三个值，内存余量从高到低排列 TRIM_MEMORY_MODERATE：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。 TRIM_MEMORY_RUNNING_CRITICAL：表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。 TRIM_MEMORY_RUNNING_LOW：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。 当app缓存在后台时，会回调一下三个值，内存余量从高到低排列 TRIM_MEMORY_BACKGROUND：表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。 TRIM_MEMORY_RUNNING_MODERATE： 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。 TRIM_MEMORY_COMPLETE：表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。 onTrimMemory 主要是在考虑内存优化时需要考虑。在此处做数据清除、资源释放","categories":[],"tags":[{"name":"andorid","slug":"andorid","permalink":"hexo/tags/andorid/"}]},{"title":"Activity的启动模式","slug":"Activity的启动模式","date":"2020-09-25T07:59:03.000Z","updated":"2020-09-28T06:32:10.651Z","comments":true,"path":"blog/2020/09/Activity的启动模式.html","link":"","permalink":"hexo/blog/2020/09/Activity的启动模式.html","excerpt":"","text":"Activity启动模式首先，Activity有四大启动模式：standard、singleTask、singleTop、singleInstance 如何设置Activity的启动模式： 静态设置，在AndoridManifest.xml文件中，对Activity设置launchMode 123&lt;activity android:name=&quot;.MainActivity3&quot; android:launchMode=&quot;singleInstance&quot; /&gt; 动态设置，在Activity跳转时，intent设置FLAG 123var intent = Intent(this, MainActivity::class.java);intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)startActivity(intent) 并且注意，同时设置了两种方式时，动态设置会覆盖静态设置 launchModestandardstandard: 标准模式，默认模式，当设置为此模式时，每一次跳入都会重新创建实例 singleTasksingleTask: 栈内复用模式，当设置此模式时，如果栈内没有该Activity就会重新创建，如果已经有了，则会复用栈内已存在的该Activity，而不会重新创建，并会移除之前在栈中处于该Activity上部的所有的Activity。ex：A的启动模式是standard， B的启动模式为singleTask A -&gt; B -&gt; A -&gt; B A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以不会重新创建b的实例，而是复用之前B的实例，同时会调用onNewIntent生命周期函数，而且会销毁之前处于栈顶的A。最后栈内就是： A、B，B位于栈顶 singleTopsingleTop：栈顶复用，与singleTask有部分相似，singleTask是只要在栈内就会复用，而singleTop是只有在栈顶才会复用，如果栈内存在实例，但不处于栈顶，则表现与standard一致，如果站内存在实例，且处于栈顶，则表现与singleTask一致， ex：A的启动模式是standard、B的启动模式是singleTopA -&gt; B -&gt; A -&gt; BA -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，但之前的B不在栈顶，所以会重新创建一个B的实例 singleInstancesingleInstance: 独立运行在一个单独的task中，而且只会存在一个实例在Activity跳转时，注意查看，普通的Activity跳转和Activity Task跳转，两者的动画效果是不同的。 ex: A的启动模式是standard、B的启动模式是singleInstanceA -&gt; B -&gt; A -&gt; BA -&gt; B 时，因为当前Activity栈task A中只有A，会重新创建一个task B并新建一个B的实例放入task BA -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例，并放入到task A中A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以会将task B置顶，最后的栈情况为： A -&gt; A -&gt; B，如下图所示： 我们可以通过指令：adb shell dumpsys activity查看Activity栈中的Activity task情况 通过关键字：ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)即可搜索到上述截图情况","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android生命周期","slug":"android生命周期","date":"2020-09-24T06:29:33.000Z","updated":"2020-09-28T08:02:40.768Z","comments":true,"path":"blog/2020/09/android生命周期.html","link":"","permalink":"hexo/blog/2020/09/android生命周期.html","excerpt":"","text":"准备对andorid基础性的东西都进行整理，梳理一下。 android的生命周期单个Actiivty正常的生命周期 onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory 这就是一个Activity从被创建到被销毁过程。 其中正常运行状态为onResume 当Activity从前台被置于后台，onResume -&gt; onPause -&gt; onStop 当从后台重新置于前台onStop -&gt; onPause -&gt; onResatrt -&gt; onStart-&gt; onResume 其中可以发现，只要Activity置于前台都会执行onStart函数，所以我们可以考虑在这里做一下需要在前台就处理的逻辑 各个生命周期函数：onCreate: Activity被创建，此时Activity处于不可见、不可交互onStart: 此时Activity 部分可见不可交互onRestart: Activity从后台重新回到前台，部分可见不可交互onResume: 完全可见可交互，为Activity正常运行状态onPause: Activity处于暂停，从前台被置于后台 部分可见部分不可见，不可交互onStop: 完全置于后台，完全不可见，onDestroy: Activity被销毁 上面就是一个正常的Activity的生命周期， 屏幕旋转在Activity生命周期中，还设计一些其他：Activity旋转：onCreate -&gt; onStart -&gt; onResume此时被旋转-&gt; onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume 可以发现当Activity被旋转时，整个Activity是被销毁然后重新创建的。其中新增调用了两个生命周期函数onSaveInstanceState: 当Activity被系统异常销毁时被调用，用于存储数据，用于系统恢复Activity时恢复数据onRestoreInstanceState: 当Actiivty被系统异常销毁并重新创建时，取出在onSaveInstanceState时存储的数据 注意，在onCreate函数中，其实也是有参数的12345override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) Log.d(TAG, &quot;onCreate: &quot;) setContentView(R.layout.activity_main) &#125; 此处的savedInstanceState也是在onSaveInstanceState时存储的数据，但此处可能为nll，因为在正常的Activity时，此处就是null，只有在Activity被异常销毁然后被系统重新创建时，此处才有值。如果要在此处使用，切记要判空。 onNewIntentonNewIntent与Activity的启动模式有关 当Activity未设置启动模式时，则不会触发该生命周期函数 当Activity已经处于应用的Activity栈中 如果Actiivty的LaunchMode为Standard时，即默认模式，此时不会触发该生命周期函数。 如果Activity的LaunchMode为SignleTop，如果ActivityA已经处于栈顶，再通过StartActivityForResult调用该Activity，此时会触发的生命周期函数为： onPause -&gt; onNewIntent -&gt; onResume 如果Activity的LainchMode为SingleInstance,SingleTask时，并且ActivityA已经处于Activity栈中，再次通过StartActivityForResult调用该Activity，此时生命周期函数：onNewIntent—&gt;onRestart—&gt;onStart—&gt;onResume onNewIntent只会在Activity设置了启动模式，并且Activity被复用时才会调起。 注意：只对startActivityForResult调起的Activity起作用，statActivity本质调用的也是startActivityForResult，Activity正常的切换前后台时不会触发的。 Activity交互A -&gt; B:A正常运行处于 onResume，打开B A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop点击跳入B页面， 首先A进入暂停，B开始创建，到onResume完全可见可交互，于是A被完全遮挡，变成完全不可见、处于后台，进入onStop A -&gt; B -&gt;goBack-&gt; A 在B页再执行返回 B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B Stop -&gt; B onDestory和A进入B类似，B返回A时，B进入暂停，A变得重新可见到A完全可见，进入onResume，然后B进入停止，并销毁 B启动模式设置为 SingleTop，B -&gt; BB onPause -&gt; B onNewIntent -&gt; B onResume因为 B已经处于栈顶，启动模式为 SingleTop 则不会重新创建B的实例 将A的启动模式设置为SingleTask 可以通过在andorid studio的终端 Terminal中输入：adb shell dumpsys activity查看当前应用的Activity task栈","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"react-native 适配androidX","slug":"react-native-适配androidX","date":"2020-09-15T01:15:50.000Z","updated":"2020-09-16T01:20:26.023Z","comments":true,"path":"blog/2020/09/react-native-适配androidX.html","link":"","permalink":"hexo/blog/2020/09/react-native-适配androidX.html","excerpt":"","text":"androidX在API28后，android新增androidX依赖，用于解决以前的android.support.v*依赖混乱问题。对v1-v9做了合并处理。 然后很多使用的第三方依赖中在新版本都适配了androidX，当你需要使用这些插件的较新版本时，只能去适配androidX。 最近使用react-native-firebase时，被提示必须使用17.0.0+的 Firebase Crashlytics SDK，否则2020年11月15日之后，将不再向firebase发送错误日志。 适配androidX点击andorid studio上方导航栏Refactor/Migrate to AndroidX这时会提示你，gradle tool version 最低3.2.0项目中每一个project的build.gradle都需要修改 classpath(“com.android.tools.build:gradle:3.2.0”)其中3.2.0为最低版本。 注意，选择的版本可能maven仓库找不到。如在第三方插件中，设置的maven仓库可能不存在该版本。如： 我使用的是版本：3.4.0123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.4.0&apos; &#125;&#125; 此时会报错，404，找不到。因为在jcenter远程仓库中不存在该版本。 3.4.0的版本只有google的maven仓库中有，所以需要修改 1234repositories &#123; google() jcenter() &#125; 查看maven插件地址：https://maven.aliyun.com/mvn/search 同时需要修改每个project的targetSdkVersion 将所有project的版本都修改为3.4.0之后，在点即Migrate to AndroidX,此时会提示你需要修改的地方， java文件，去除一些v*的引入 build.gradle 去除一些v*的依赖 manifest.xml 需要修改一些属性，如配置的FileProvider,修改name属性android:name=&quot;androidx.core.content.FileProvider&quot; 修改完后，无报错时直接运行。 会有一些java文件报错，就是引入的之前的v*的包，需要手动修改，哪里报错改哪里。 最后运行，运行成功","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"","slug":"java-反射基本概念与class","date":"2020-09-10T01:26:24.085Z","updated":"2020-09-10T03:51:39.694Z","comments":true,"path":"blog/2020/09/java-反射基本概念与class.html","link":"","permalink":"hexo/blog/2020/09/java-反射基本概念与class.html","excerpt":"","text":"反射 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 * 类名 用途Class类 代表类的实体，在运行的Java应用程序中表示类和接口Field类 代表类的成员变量（成员变量也称为类的属性）Method类 代表类的方法Constructor类 代表类的构造方法 获得类相关的方法方法 用途asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象Cast 把对象转换成代表类或是接口的对象getClassLoader() 获得类的加载器getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象forName(String className) 根据类名返回类的对象getName() 获得类的完整路径名字newInstance() 创建类的实例getPackage() 获得类的包getSimpleName() 获得类的名字getSuperclass() 获得当前类继承的父类的名字getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法方法 用途getField(String name) 获得某个公有的属性对象getFields() 获得所有公有的属性对象getDeclaredField(String name) 获得某个属性对象getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法方法 用途getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象getAnnotations() 返回该类所有的公有注解对象getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法方法 用途getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法getConstructors() 获得该类的所有公有构造方法getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法方法 用途getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法getMethods() 获得该类所有公有的方法getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法getDeclaredMethods() 获得该类所有方法 类中其他重要的方法方法 用途isAnnotation() 如果是注解类型则返回trueisAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回trueisAnonymousClass() 如果是匿名类则返回trueisArray() 如果是一个数组类则返回trueisEnum() 如果是枚举类则返回trueisInstance(Object obj) 如果obj是该类的实例则返回trueisInterface() 如果是接口类则返回trueisLocalClass() 如果是局部类则返回trueisMemberClass() 如果是内部类则返回true Field类Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途equals(Object obj) 属性与obj相等则返回trueget(Object obj) 获得obj中对应的属性值set(Object obj, Object value) 设置obj中对应属性值 Method类Method代表类的方法。 方法 用途invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类Constructor代表类的构造方法。 方法 用途newInstance(Object… initargs) 根据传递的参数创建类的对象","categories":[],"tags":[]},{"title":"kotlin 在android老项目中引入kotlin","slug":"kotlin-在android老项目中引入kotlin","date":"2020-09-09T08:31:56.000Z","updated":"2020-11-16T06:17:22.895Z","comments":true,"path":"blog/2020/09/kotlin-在android老项目中引入kotlin.html","link":"","permalink":"hexo/blog/2020/09/kotlin-在android老项目中引入kotlin.html","excerpt":"","text":"在android项目中引入kotlin修改项目的build.gradle 文件中 buildscript { ext { kotlin_version = &quot;1.3.10&quot; } dependencies { classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; } } 在app/build.gradle中 1234apply plugin: &quot;com.android.application&quot;// 在顶行下添加apply plugin: &apos;kotlin-android&apos;apply plugin: &apos;kotlin-android-extensions&apos; 然后同步一下即可","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"hexo/tags/kotlin/"}]},{"title":"google play 提交要求","slug":"google-play-提交要求","date":"2020-09-09T03:27:05.000Z","updated":"2020-09-09T05:48:13.893Z","comments":true,"path":"blog/2020/09/google-play-提交要求.html","link":"","permalink":"hexo/blog/2020/09/google-play-提交要求.html","excerpt":"","text":"google play 提交要求本文于2020/09/09日起记录在google play提交版本时，google play提出的提交要求 targetSdkVersion在2020/08/05日，提交版本发现多了一个警告 新提交的应用在8月开始，必须设定targetSdkVersion为29或以上，已存在的应用提交新版本时，必须设定targetSdkVersion为29或以上 关于targetSdkVersion的原理targetSdkVersion相当于在编写代码时设定一个假想的运行手机版本，打包后，再运行到真实设备。最终的运行表现取决与targetSdkVersion与真实运行设备版本中的低值。 targetSdkVersion的预设就相当于预设一个代码运行环境，我们所写的代码功能如果是只有部分版本才有的API，我们需要先判断真实的运行版本是否符合。如在android6.0后引入权限请求，在每次请求权限时，我们需要判断SDK版本是否大于等于23. 12345private void request() &#123; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; requestPermissions(new String[]&#123;Manifest.permission.CAMERA&#125;, 101); &#125;&#125; 当然，是否需要判断版本其实和minSdkVersion也是有关的，如上面的代码，因为权限请求是23以后的，如果我们直接将minSdkVersion设置为23，则此时就不需要判断版本了，因为肯定是运行在23之后的手机，因为23以前的手机此时会无法安装该应用。 ex:当我们设定targetSdkVersion=29，即android10，而用户手机为API=23，即android6.0，此时app的表现会是6.0。 当我们设定targetSdkVersion=23，即android6，而用户手机为API=29，即android10，此时app的表现也会是6.0。 64位框架在去年时，google play要求提及的应用必须支持64位的框架，也就是.so文件必须支持64位架构，在提交审核的apk中，有armeabi-v7a则必须也要有arm64-v8a，如果有x86，则必须也要有x86_64。react-native 原本只有armeabi-v7a，在之后的版本0.59.10中就开始内部源码中支持64位含有arm64-v8a下的.so文件","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"git使用","slug":"git使用","date":"2020-09-08T03:11:56.000Z","updated":"2020-12-17T07:58:35.448Z","comments":true,"path":"blog/2020/09/git使用.html","link":"","permalink":"hexo/blog/2020/09/git使用.html","excerpt":"","text":"gitgit是一款分布式代码版本控制工具 初始化使用：当我们在gitlab、github初始化一个项目路径后，需要将本地仓库的代码提交到新建好的远端仓库 12345git initgit remote add origin &lt;remoteurl&gt; // 链接远端仓库 &lt;remoteurl&gt;为远端仓库地址git add .git commit -m &quot;commit info&quot;git push 设置全局用户信息12git config --global user.name &quot;userName&quot;git config --global user.email &quot;useremail&quot; git fetch 拉取代码git merge 合并代码git pull 拉取并合并代码git push 将本地仓库的commit提交到远端仓库 git checkout 切换分支git checkout -b 新建分支并切换 git branch -d 删除分支 不能删除有未提交commit的分支git branch -D 强制删除分支 git push -u origin 将本地分支推送到远端，如果远端没有此分支则会创建 git reset –hard 代码回滚到某个commit commitId可以通过git log查看 git log 可以查看每一个的commit，显示的信息有 commit date，commit person，commitId，commit info git merge A 将A分支合并到当前分支 git rebase A 将A分支合并并且将A分支节点置于当前分支之后 git mv 修改文件名，因为git默认忽略文件大小写，如修改文件名 File.js 到 file.js此时是无法检测到更改，需要使用命令：git mv File.js file.js update在github中已修改默认分支为main 而不再是master 此时针对命令为git initgit remote add origin // 链接远端仓库 为远端仓库地址git branch -M maingit push -u origin main 异常解决-refusing to merge unrelated histories当执行git push时提示先执行git pull而执行git pull时报错如标题，此时需执行：1git pull origin master --allow-unrelated-histories","categories":[],"tags":[{"name":"git","slug":"git","permalink":"hexo/tags/git/"}]},{"title":"Java内存模型 JMM","slug":"Java内存模型-JMM","date":"2020-09-08T01:41:19.000Z","updated":"2020-09-08T01:42:00.716Z","comments":true,"path":"blog/2020/09/Java内存模型-JMM.html","link":"","permalink":"hexo/blog/2020/09/Java内存模型-JMM.html","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"Lock详解","slug":"Lock详解","date":"2020-09-03T07:26:40.000Z","updated":"2020-09-03T07:26:40.879Z","comments":true,"path":"blog/2020/09/Lock详解.html","link":"","permalink":"hexo/blog/2020/09/Lock详解.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Synchronized详解","slug":"Synchronized详解","date":"2020-09-03T07:26:31.000Z","updated":"2021-01-18T06:27:17.095Z","comments":true,"path":"blog/2020/09/Synchronized详解.html","link":"","permalink":"hexo/blog/2020/09/Synchronized详解.html","excerpt":"","text":"Synchronized详解Synchronized是内置锁，锁的是对象，Synchronized 有几个使用方式，但其实都是作用于对象。 1、作用于方法块 2、作用于obj 3、作用于this 4、作用于class 1234567891011121314151617181920212223public synchronized void lockFun() &#123; try &#123; Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName()); Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName() + &quot;结束&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;public void lockThis() &#123; synchronized (this) &#123; try &#123; Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName()); Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName() + &quot;结束&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面的示例代码中，lockFun是作用于方法块，lockThis是作用于this，但实际上这两个函数都是作用于当前的类的实例对象上的 123456789public void lockClass() &#123; synchronized (Test.class) &#123; &#125;&#125;public static synchronized void lockStatic() &#123; &#125; 而在lockClass与lockStatic中，lockStatic作用与static静态函数，lockClass作用与Test.class对象，但实际都是作用与Test的所有实例对象 12345public void lockObj(Object o) &#123; synchronized (o)&#123; &#125;&#125; lockObj就是直接作用于Object对象。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 设计模式","slug":"java-设计模式","date":"2020-09-03T07:13:47.000Z","updated":"2020-09-03T07:13:47.169Z","comments":true,"path":"blog/2020/09/java-设计模式.html","link":"","permalink":"hexo/blog/2020/09/java-设计模式.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java IO","slug":"java-IO","date":"2020-09-03T07:13:19.000Z","updated":"2020-09-03T07:13:19.185Z","comments":true,"path":"blog/2020/09/java-IO.html","link":"","permalink":"hexo/blog/2020/09/java-IO.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"动态代理","slug":"动态代理","date":"2020-09-03T07:13:07.000Z","updated":"2020-09-03T07:13:07.579Z","comments":true,"path":"blog/2020/09/动态代理.html","link":"","permalink":"hexo/blog/2020/09/动态代理.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"注解","slug":"注解","date":"2020-09-03T07:12:37.000Z","updated":"2020-09-03T07:12:37.204Z","comments":true,"path":"blog/2020/09/注解.html","link":"","permalink":"hexo/blog/2020/09/注解.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据传输与序列化","slug":"数据传输与序列化","date":"2020-09-03T07:11:44.000Z","updated":"2020-09-11T10:37:25.207Z","comments":true,"path":"blog/2020/09/数据传输与序列化.html","link":"","permalink":"hexo/blog/2020/09/数据传输与序列化.html","excerpt":"","text":"序列化方式 Serializable java自带 Parcelable android中","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"Callback Future","slug":"Callback-Future","date":"2020-09-03T07:08:01.000Z","updated":"2020-09-08T07:43:29.298Z","comments":true,"path":"blog/2020/09/Callback-Future.html","link":"","permalink":"hexo/blog/2020/09/Callback-Future.html","excerpt":"","text":"Future Future代表一个异步计算的结果，并且它提供一些方法来让调用者检测异步过程是否完成，或者取得异步计算的结果，或者取消正在执行的异步任务。 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; private static ExecutorService executorService = Executors.newSingleThreadExecutor(); public static void main(String[]args)&#123; System.out.println(&quot;hello world&quot;); Future&lt;Integer&gt;future = calcute(9); while (!future.isDone())&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;正在执行&quot;); &#125; &#125; try &#123; int result = future.get(); System.out.println(&quot;result = &quot; + result); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static Future&lt;Integer&gt;calcute(Integer i) &#123; return executorService.submit(() -&gt; &#123; Thread.sleep(1000); System.out.println(&quot;return future for &quot; + i); return i *i; &#125;); &#125;&#125; 一个简单Future使用用例写完，使用线程池+Callback+Future，完成了一个简单的计算操作。 Future是一个接口，先看一下内部方法： 1234567891011public interface Future&lt;V&gt; &#123; boolean cancel(boolean var1); boolean isCancelled(); boolean isDone(); V get() throws ExecutionException, InterruptedException; V get(long var1, TimeUnit var3) throws ExecutionException, InterruptedException, TimeoutException;&#125; get()函数是返回计算结果，注意get会同步操作，每天返回结果前，会阻塞线程。get还有一个重载函数get(long var1, TimeUnit var3)，第一个参数是时长，第二个是单位。表示在多少时长内获取结果，如果仍未返回，则抛出异常TimeoutException。12345try&#123; int result2 = future2.get(1000, TimeUnit.MILLISECONDS);&#125; catch(TimeoutException e) &#123; e.printStackTrace();&#125; cancel(boolean) 表示是否取消该future， 不能在调用cancel(true)/cancel(false)后，调用get()函数，否则会抛出异常CancellationException isCancelled()函数是判断该future是否已取消 isDone()函数是判断该future是否已完成 isDone()函数是实时状态读取，不会阻塞线程。 CallbackCallback 是一个接口，内部只有一个函数 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; Callback 可以理解为一个执行任务，如上面例子中的计算 FutureTask介绍Future是一个接口，RunnableFuture也是一个接口，继承Future、Runnable两个接口1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; 而FutureTask是对RunnableFuture的基本实现 FutureTask 有一个状态值12345678910111213141516/** 状态值存在如下几种变化：* Possible state transitions:* NEW -&gt; COMPLETING -&gt; NORMAL* NEW -&gt; COMPLETING -&gt; EXCEPTIONAL* NEW -&gt; CANCELLED* NEW -&gt; INTERRUPTING -&gt; INTERRUPTED*/private volatile int state;private static final int NEW = 0;private static final int COMPLETING = 1;private static final int NORMAL = 2;private static final int EXCEPTIONAL = 3;private static final int CANCELLED = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED = 6;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"android AsyncTask","slug":"android-AsyncTask","date":"2020-09-03T07:04:59.000Z","updated":"2020-09-03T07:05:13.298Z","comments":true,"path":"blog/2020/09/android-AsyncTask.html","link":"","permalink":"hexo/blog/2020/09/android-AsyncTask.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"线程池","slug":"线程池","date":"2020-09-03T07:04:37.000Z","updated":"2021-01-14T02:06:22.933Z","comments":true,"path":"blog/2020/09/线程池.html","link":"","permalink":"hexo/blog/2020/09/线程池.html","excerpt":"","text":"java 线程池线程池是用来管理以及调度线程的容器。 线程池的优势 复用线程，避免大量线程重复创建、销毁，降低消耗 提升效率，当线程池内未饱和时，无需等待线程的重新创建和初始化，便能立即执行 方便线程并发管理，避免线程无限制的创建，可能造成的OOM、cpu过高等问题，规定了最大并发数 延时定时执行任务 创建线程池创建线程池的几种方法：1234567ExecutorService pool = Executors.newCachedThreadPool();ExecutorService pool1 = Executors.newFixedThreadPool(1);ExecutorService pool2 = Executors.newScheduledThreadPool(1);ExecutorService pool3 = Executors.newSingleThreadScheduledExecutor();ExecutorService pool4 = new ThreadPoolExecutor(0, 10, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); 最后都会执行到ThreadPoolExecutor的构造函数中 线程池参数1234567891011121314151617181920212223242526public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 即时是ThreadPoolExecutor的其他几个构造函数，最后也会调用到这个7参的构造函数 corePoolSize: 核心线程数量，当向线程池提交一个任务时，如果线程数小于核心线程数，不管是否有线程处于空闲状态，都会创建一个新的线程来执行该任务，直到线程池中的线程数大于等于核心线程数量 maximumPoolSize: 最大线程数，线程池中线程数量最大值，当向线程池提交任务，核心线程都已创建完毕，且核心线程都处于工作状态，此时会先将该任务提交到阻塞队列，如果阻塞队列已满， 并线程池中线程数量小于最大线程数时，此时会新创建一个线程执行该任务。如果阻塞队列已满，且线程数也达到最大值，此时会执行线程饱和策略。 keepAliveTime：非核心线程可空闲时长，非核心线程处于空闲时，且空闲时长超过keepAliveTime，则该线程会被回收，但不会回收核心线程 unit： keepAliveTime的时长单位 workQueue： 阻塞队列，用于保存和运输待执行任务的阻塞队列 threadFactory：线程工厂，用于创建工作线程，threadFactory也是采用new Thread()形式创建一个新线程，但命名线程名称，格式为：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。 defaultHandler： 线程饱和策略，当线程池和阻塞队列都满了，再添加任务时，会执行此策略 线程池第4个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小 当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。 所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。 LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定 当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的integer.MAX_VALUE,此时添加任务会一直成功。 最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。 SynchronousQueue: 无容量的队列 使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。 唯一制约就是配置的最大线程数，如果使用Integer.MAX_VALUE就实现了真正的无等待。 运行流程; execute 提交任务123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn&apos;t, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; ctl是一个原子Integer对象，存储的是正在运行的线程数看英文注释也写的很清楚了，分三部，1、判断正在运行的线程是否小于核心线程数，是的话则 调用 addWorker(command, true)；并不再向下执行2、判断队列能否添加command 以及 线程池是否还在运行，而且双重检测，成功将加任务加入到阻塞队列， 再进行第二次判断，如果线程池没有再运行 &amp;&amp; 移除这个任务，执行拒绝 或者工作线程数 == 0， 则直接 addWorker(null, false);3、尝试添加失败，执行 reject(command) addWorker查看添加任务的函数 12345678910111213141516171819202122232425retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; 外层for循环： 当线程池已经 SHUTDOWN时，不能添加任务内层for循环：当前线程数大于总容量 ｜｜ 为添加核心线程时，&gt; 核心线程数 当为非核心线程时，&gt; 最大线程数，不能添加任务 如果能添加时，终止外层for循环 compareAndIncrementWorkerCount 函数是将当前的正在运行的线程数 + 1； 12345678910111213141516171819202122232425262728293031323334353637boolean workerStarted = false;boolean workerAdded = false;Worker w = null;try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125;&#125; finally &#123; if (! workerStarted) addWorkerFailed(w);&#125; Worker 是ThreadPoolExecutor中的内部类，implements Runnable此处就是在构建一个Worker，并启动线程执行。 流程总结当提交一个任务时， 1、查询核心线程是否已满，如果未满则新创建核心线程执行该任务 2、当核心线程已满，判断阻塞队列是否已满，如果阻塞队列未满则将该任务加入到阻塞队列中 3、当阻塞队列已满时，判断线程池是否已满，如果未满，则新创建线程执行该任务 4、当线程池已满时，则执行饱和策略 线程池为何需要使用阻塞队列1、因为线程池是管理并调度线程、以完成任务，肯定不可能无限制的创建线程， 2、提高核心线程的使用效率","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 强、软、弱、虚四种引用类型","slug":"java-强、软、弱、虚四种引用类型","date":"2020-08-28T06:21:35.000Z","updated":"2020-08-31T10:19:09.345Z","comments":true,"path":"blog/2020/08/java-强、软、弱、虚四种引用类型.html","link":"","permalink":"hexo/blog/2020/08/java-强、软、弱、虚四种引用类型.html","excerpt":"","text":"引用类型在jdk 1.2之前，一个对象只有 “已被引用” 和 “未被引用”两种概念，在jdk1.8之后，引用类型分为4类：强引用：Strong Reference软引用：Soft Reference弱饮用：Weak Reference虚引用：Phantom Reference这4中引用的强度依次减弱 强引用java中默认的引用类型，只要引用存在，永远不会回收，哪怕内存不足，系统会抛出OOM异常，也不会回收。 软引用只有当内存不足时，才会回收，回收后如果还是内存不足才会抛出OOM 123456789101112131415private static void testSoftReference() &#123; for (int i = 0; i &lt; 10; i++) &#123; byte[] buff = new byte[1024 * 1024]; SoftReference&lt;byte[]&gt; sr = new SoftReference&lt;&gt;(buff); list.add(sr); &#125; System.gc(); //主动通知垃圾回收 for(int i=0; i &lt; list.size(); i++)&#123; Object obj = ((SoftReference) list.get(i)).get(); System.out.println(obj); &#125; &#125; 弱引用// 无论内存是否足够，只要JVN开始回收，弱饮用都会被回收很多文章都说，只要执行GC就会回收软引用，这种结论是错误的。 当一个对象只被弱引用实例引用（持有）时，这个对象就会被GC回收 被回收的对象弱饮用实例引用的对象，而不是弱饮用本身 如果显式地声明了一个变量E e，并使之指向一个对象：e = new E()，这时变量e就是对对象的一个强引用。如果变量e所引用的这个对象同时又被WeakReference的一个实例持有，则由于存在对对象的一个强引用e，对象并不符合上述回收规则，因此对象至少在变量e的作用域范围内都不会被回收。 12345678910111213141516171819class TestWeakReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); &#125; private static void testWeakReference() &#123; byte[]buff = new byte[1024 * 1024]; for (int i = 0; i &lt; 10; i++) &#123; WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff); list.add(weakReference); &#125; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 在上述情况下，buff是一个强引用类型，在它的作用域时是不可回收的，即使除了弱饮用持有没有其他的引用。 将上述代码改一下，将buff与gc作用域修改 12345678910111213141516171819202122232425class TestSoftReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); private static List&lt;Object&gt; lists = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); gc(); &#125; static WeakReference&lt;byte[]&gt; softReference; private static void testWeakReference() &#123; byte[]buff = new byte[1024 * 1024]; for (int i = 0; i &lt; 10; i++) &#123; softReference = new WeakReference&lt;&gt;(buff); list.add(softReference); &#125; &#125; public static void gc() &#123; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 在上面这种情况下，gc执行的作用域与buff的作用域是同级的另一个作用域，且buff无其他引用，则可以回收 将上述代码再修改一下12345678910111213141516171819class TestWeakReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); &#125; private static void testWeakReference() &#123; for (int i = 0; i &lt; 10; i++) &#123; byte[]buff = new byte[1024 * 1024]; WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff); list.add(weakReference); &#125; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 此时buff的作用域只在for循环内，此时是可以被回收的，因为输出的结果均为null 虚引用虚引用是最弱的引用类型，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。 引用队列（ReferenceQueue）引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。 与软引用、弱引用不同，虚引用必须和引用队列一起使用。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java ThreadLocal解析","slug":"java-ThreadLocal解析","date":"2020-08-28T05:46:49.000Z","updated":"2020-08-31T07:33:20.221Z","comments":true,"path":"blog/2020/08/java-ThreadLocal解析.html","link":"","permalink":"hexo/blog/2020/08/java-ThreadLocal解析.html","excerpt":"","text":"ThreadLocalThreadLocal 是一个线程的内部存储类，对于被存储的对象，在不同的线程读取的变量是独立的。 实现原理是：对每一个线程都有一个ThreadLocalMap，ThreadLocal维护每个ThreadLocalMap中的值ThreadLocalMap 内部是一个[]Enter, 不同的ThreadLocal都是存储在线程的同一个ThreadLocalMap中的，只是下标位置不同，同一个ThreadLocal在不同线程的ThreadLocalMap中的下标值即索引值是相同的。 ThreadLocal 方法解析ThreadLocal 最常用的示例：123ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;();threadLocal.set(&quot;1&quot;);String name = threadLocal.get(); 在主线程初始化ThreadLocal实例，在各个线程调用set、get，设置、获取存储在各个线程中的值 查看源码 set12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 当调用set函数时，会去获取当前线程的ThreadLocalMap对象，该对象是在Thread.java中申明，默认值为null。当map为null时，则调用createMap,为threadLocals对象赋值，不为null，在调用ThreadLocalMap中的set函数，将值保存到数组中 get12345678910111213141516171819202122232425 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 当调用get方法时，获取当前线程的ThreadLocalMap对象，如果map不为null，则获取map持有的Entry对象，再返回该Entry对象持有的value值。如果map为null或者获取的Enter对象为null，则会调用setInitialValue，而initialValue的返回值是null。当map为null时，会调用createMap方法，实例化ThreadLocalMap 上面的set、get都会调用getMap方法，来获取当前线程的ThreadLocalMap实例 getMap123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; threadLocals 是在Thread.java中声明的，默认值为null，也就是说每个线程中都有这个对象，只是默认是null。 createMap在set、get中都会对当前线程的ThreadLocalMap对象判断，当为null时，会调用createMap对ThreadLocalMap对象threadLocals赋值， 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; ThreadLocalMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static class ThreadLocalMap &#123; // 必须为2的次方 private static final int INITIAL_CAPACITY = 16; // 最终存储数据的数组 private Entry[] table; // table 有值的长度 private int size = 0; // resize后的大小 private int threshold; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don&apos;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; ......&#125; getEntry 函数就是获取key对应的节点Entry在getEntry、set函数中可以看到value存储在[]Entry中的下标位置是由 key.threadLocalHashCode &amp; (len-1)计算得出的。就是ThreadLocal中的threadLocalHashCode 对[]Entry长度取模getEntry，通过下标获取e，如果不为null而且再次校验key相等，则返回eset时，e不为null，而且key相等，代表已存在，则替换e.value，key不相等，代表不存在，而添加 1234567891011121314151617181920212223242526272829303132333435 private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize(); &#125;private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; 当Entry[] 中存入的值数量已达到数组长度的3/4；则会调用resize函数，调整Entry[]的长度，将新数组长度*2，遍历老数组，重新获取下标h，判断h处是否有值，无值填充，有值则重新获取h，再填充 EntryThreadLocalMap 的内部类 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry继承WeakReference，说明ThreadLocal内部存储的类型都是采取弱引用累心存储，当GC时，则会被回收。这样保证当线程执行完时，当前线程中存储在ThreadLocalMap中的对象会被回收，不会在此处出现内存泄漏 value是调用ThreadLocal保存的值，","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java volatile关键字","slug":"java-volatile关键字","date":"2020-08-27T09:27:26.000Z","updated":"2020-08-28T03:59:27.622Z","comments":true,"path":"blog/2020/08/java-volatile关键字.html","link":"","permalink":"hexo/blog/2020/08/java-volatile关键字.html","excerpt":"","text":"valotile 可见性1、修改volatile变量时会强制将修改后的值刷新的主内存中。 2、修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 1234567891011121314151617181920212223242526272829class TestThread &#123; public static void main(String[] args)&#123; Work work = new Work(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::shutdown).start(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::work).start(); &#125; static class Work&#123; volatile boolean isShutdown = false; void shutdown() &#123; System.out.println(&quot;shutdown -----&quot;); isShutdown = true; System.out.println(&quot;shutdown ---- down&quot;); &#125; void work() &#123; while (!isShutdown) &#123; System.out.println(&quot;work ----&quot;); &#125; &#125; &#125;&#125; 上面的代码运行后输出的结果如下：work —-work —-work —-work —-work —-work —-work —-work —-work —-work —-work —-shutdown —–work —-shutdown —- downwork —-work —- 说明一个问题：volatile的可见性，volatile变量时会强制将修改后的值刷新的主内存修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。将主内存的值刷新，其他线程去读取主内存的值是需要一定时间的，","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java wait方法","slug":"java-wait方法","date":"2020-08-27T09:26:45.000Z","updated":"2020-09-09T07:56:20.712Z","comments":true,"path":"blog/2020/08/java-wait方法.html","link":"","permalink":"hexo/blog/2020/08/java-wait方法.html","excerpt":"","text":"wait()、notify()、notifyAll()wait()、notify()、notifyAll()这三个函数都是Object类中的方法，而Object类是所有类的父类，所以所有对象实例都有该方法. wait():阻塞当前之前直到该对象(调用wait函数的对象)在另一个线程调用了notify()或者notifyAll();notify():唤醒单个线程notifyAll():唤醒所有线程 这三个方法，都是Java语言提供的实现线程间阻塞(Blocking)和控制进程内调度(inter-process communication)的底层机制。在解释如何使用前，先说明一下两点： 正如Java内任何对象都能成为锁(Lock)一样，任何对象也都能成为条件队列(Condition queue)。而这个对象里的wait(), notify()和notifyAll()则是这个条件队列的固有(intrinsic)的方法。 一个对象的固有锁和它的固有条件队列是相关的，为了调用对象X内条件队列的方法，你必须获得对象X的锁。这是因为等待状态条件的机制和保证状态连续性的机制是紧密的结合在一起的。 12345678910111213141516171819202122class TestWait &#123; public static void main(String[]args) &#123; TestWaitBean bean = new TestWaitBean(&quot;bean&quot;); System.out.println(&quot;init bean&quot;); System.out.println(&quot;invoke bean wait&quot;); try &#123; bean.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;wait finished&quot;); &#125; &#125; static class TestWaitBean &#123; String name; public TestWaitBean(String name) &#123; this.name = name; &#125; &#125;&#125; 上述代码运行后会抛出异常java.lang.IllegalMonitorStateException因为未获取对象bean的锁，就去调用bean.wait() 修改一下代码，实现一个简单的阻塞、唤醒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TestWait &#123; public static void main(String[]args) &#123; TestWaitBean bean = new TestWaitBean(&quot;bean&quot;); System.out.println(&quot;init bean&quot;); System.out.println(&quot;invoke bean wait&quot;); WeakUpThread thread = new WeakUpThread(bean); thread.start(); synchronized (bean) &#123; try &#123; bean.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;wait finished&quot;); &#125; &#125; &#125; static class TestWaitBean &#123; String name; public TestWaitBean(String name) &#123; this.name = name; &#125; &#125; static class WeakUpThread extends Thread &#123; Object lock; public WeakUpThread(Object lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; super.run(); synchronized (lock) &#123; try &#123; System.out.println(&quot;Current Thread is sleep 2000ms&quot; ); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot; weakUp!!!&quot;); lock.notify(); &#125; &#125; &#125; &#125;&#125; 注意： 不管是调用wait，还是notify、notifyAll，都要是在同步修饰的代码块或者方法中，即必须先获取对象锁，在调用对象方法 使用wait、notifyAll实现一个多线程的生产者、消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class BlockTest &#123; public static void main(String []args) &#123; List&lt;Object&gt;list = new ArrayList&lt;&gt;(); Block block = new Block(list); list.add(null); Thread thread1 = new Thread(new PutThread(block, new Person(&quot;person1&quot;)), &quot;thread1&quot;); Thread thread2 = new Thread(new PutThread(block, new Person(&quot;person2&quot;)), &quot;thread2&quot;); Thread thread3 = new Thread(new PutThread(block, new Person(&quot;person3&quot;)), &quot;thread3&quot;); Thread thread4 = new Thread(new PutThread(block, new Person(&quot;person4&quot;)), &quot;thread4&quot;); Thread thread5 = new Thread(new OutThread(block), &quot;thread5&quot;); Thread thread6 = new Thread(new OutThread(block), &quot;thread6&quot;); Thread thread7 = new Thread(new OutThread(block), &quot;thread7&quot;); thread1.start(); thread2.start(); thread5.start(); thread6.start(); thread7.start(); thread3.start(); thread4.start(); &#125; static class PutThread implements Runnable &#123; Block block; Person person; public PutThread(Block block, Person person) &#123; this.block = block; this.person = person; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; puting the person name is &quot; + person.getName()); block.put(person); &#125; &#125; static class OutThread implements Runnable &#123; Block block; public OutThread(Block block) &#123; this.block = block; &#125; @Override public void run() &#123; Person person = (Person) block.get(); if(person != null) &#123; System.out.println(Thread.currentThread().getName() + &quot; get the person name is &quot; + person.getName()); &#125; else &#123; System.out.println(Thread.currentThread().getName() + &quot; the person is null&quot;); &#125; &#125; &#125; static class Block&lt;T&gt; &#123; List&lt;T&gt;t; Object lock = new Object(); int currentIndex = 0; volatile boolean isRead = false; public Block(List&lt;T&gt;t)&#123; this.t= t; &#125; public void put(T at) &#123; if(t == null) throw new NullPointerException(&quot;t is null&quot;); synchronized (lock) &#123; try &#123; if(isRead) &#123; lock.wait(); &#125; currentIndex++; t.add(at); lock.notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public T get() &#123; synchronized (lock)&#123; T at = null; try &#123; if(currentIndex == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 当前下标已为0 阻塞 等待写入再取&quot;); lock.wait(); &#125; if(isRead)&#123; System.out.println(Thread.currentThread().getName() + &quot; 当前正在读 阻塞 等待写入再取 index&quot; + currentIndex); lock.wait(); &#125; isRead = true; at = t.remove(currentIndex); if(at == null) &#123; System.out.println(Thread.currentThread().getName() + &quot; index&quot; + currentIndex); return null; &#125; currentIndex --; return at; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.notifyAll(); isRead = false; return at; &#125; &#125; &#125; &#125; static class Person&#123; private String name = &quot;&quot;; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 上述生产者、消费者只能适用于多个线程直接的put、get 因为wait、和notify/notifyAll本身就是互斥的，因为调用wait后，就会阻塞当前调用线程，本身线程的notify/notifyAll也就不会被调用，所以说上述代码只能实现多个线程直接的场景，还有就是上述代码只是简单的实现，而且是读操作加锁，一般而言应该是写操作时堵塞。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java join方法","slug":"java-join方法","date":"2020-08-27T08:18:59.000Z","updated":"2020-08-27T09:24:35.404Z","comments":true,"path":"blog/2020/08/java-join方法.html","link":"","permalink":"hexo/blog/2020/08/java-join方法.html","excerpt":"","text":"t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续如在main线程调用t.join(),则会阻塞main线程直到t线程执行完。 而join()函数参数，当调用为t.join(2000),代表阻塞2000毫秒, 当2000毫秒完后，main线程会向下执行，但也有例外，join(millis)如在t线程使用 synchronized时，则必须等到synchronized包裹的代码块执行完并传递的millis毫秒后，t.join()的调用线程才会向下执行。 12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; super.run();// synchronized (currentThread()) &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;休眠&quot; + i); &#125; System.out.println(&quot;线程结束&quot;);// &#125; &#125; &#125;; long start = System.currentTimeMillis(); thread.start(); try &#123; thread.join(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;main线程结束&quot;); System.out.println(System.currentTimeMillis() - start); &#125;&#125; 输出结果： main线程结束1005休眠0休眠1休眠2休眠3休眠4线程结束 将thread.join(1000) 改为2000 时，输出结果如下：休眠0main线程结束2005休眠1休眠2休眠3休眠4线程结束 将上面代码synchronized 注释放开后再运行，输出结果如下：休眠0休眠1休眠2休眠3休眠4线程结束main线程结束5011 查看join方法源码12345678910111213141516171819202122232425262728293031/** * Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever. 当为0时，会一直阻塞调用join函数的线程，直到调用join函数的对象线程执行完毕 */public final synchronized void join(long millis) throws InterruptedException &#123; // 获取当时系统时间 long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; // 当传过来的入参时间小于0，抛出异常 throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (millis == 0) &#123; // 当等于0时，只要线程未执行完毕，则一直阻塞 while (isAlive()) &#123; // 当前线程未执行完一直阻塞 wait(0); &#125; &#125; else &#123; // 当时间大于0 while (isAlive()) &#123; // 当前线程还未执行完，则一直循环获取时间，阻塞调用线程到时间结束 long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 注意：wait()是运行在调用线程的，如在main线程中调用t.join();则join()函数的调用线程是main线程，wait()也是运行在main线程的，所以阻塞main线程，而t才是join()的调用对象线程，isAlive也是判断的t线程是否执行完毕，只有在t线程执行完毕，isAlive才为false","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"android 指纹验证","slug":"android-指纹验证","date":"2020-08-12T01:42:55.000Z","updated":"2020-08-13T03:17:41.339Z","comments":true,"path":"blog/2020/08/android-指纹验证.html","link":"","permalink":"hexo/blog/2020/08/android-指纹验证.html","excerpt":"","text":"android 指纹识别android API 23时新增的功能，指纹识别 主要类：FingerpringManager 在API28后，FingerpringManager被遗弃，使用BiometricPrompt，此时授权识别的弹窗不能自定义，只能使用官方统一弹窗，只能设置各个授权文案。各个开发商内部实现可能不一致。 通过只是使用指纹识别，直接使用官方api即可，但出于安全或业务场景需求，很多都需要去检测生物库信息是否变更，如指纹库在重新指纹识别前是否发生变更，这个官方api就没有提供方法，需要我们自己实现。 检测指纹库是否发生变更参考：通过检测密钥查看是否变更(https://www.jianshu.com/p/dbb1a43cfb21) 在API28以前，指纹库信息时可以通过反射获取，获取的信息有指纹id、groupId、指纹名称、指纹个数、设备id等等， 12345678910111213141516if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; Log.d(TAG, &quot;getFingerPrintInfo: &quot;); FingerprintManager fingerprintManager = (FingerprintManager) getCurrentActivity().getSystemService(Context.FINGERPRINT_SERVICE); try&#123; Class clz = Class.forName(&quot;android.hardware.fingerprint.FingerprintManager&quot;); Method method = clz.getDeclaredMethod(&quot;getEnrolledFingerprints&quot;, new Class[]&#123;&#125;); method.setAccessible(true); Object obj = method.invoke(fingerprintManager, null); if (obj != null) &#123; Log.e(TAG, &quot;objStr:&quot; + JsonUtils.toJson(obj)); List&lt;FingerprintBean&gt; list = (List&lt;FingerprintBean&gt;) JsonUtils.fromJson(objStr, new TypeToken&lt;List&lt;FingerprintBean&gt;&gt;()&#123;&#125;.getType()); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 而FingerprintBean是这样的：123456789public class FingerprintBean implements Serializable &#123; private static final long serialVersionUID = 1L; private long mDeviceId; private long mFingerId; private long mGroupId; private String mName;&#125; 最理想的方式是我们反射获取到这些指纹库信息，然后将这些信息保存到本地，每次调用指纹识别时，获取当前指纹库信息与之前的指纹库信息比较，只有不同即可判定指纹库信息变更，但在实际操作中，发现在手机上获取到的指纹id只是简单的1、2、3即指纹库里的排列顺序，而指纹名称是可以随意更改，groupId、deviceId都为0，如果使用这些信息去校验，错误率太高。 还有一种方式即是上面参考链接中的，检测指纹库密钥信息是否变更 但在上面链接那种方法中，有几个问题：1、增加、删除指纹无法检测2、使用修改指纹的手指识别后才能检测出修改 于是将反射、密钥检测两者结合，先反射获取指纹库信息，只是比较指纹库指纹个数，先判断指纹个数是否发生变更，就可知道指纹库信息变更了如果指纹个数没有变更，再来校验密钥是否发生变化","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"kotlin (二)","slug":"kotlin-二","date":"2020-07-29T13:58:32.000Z","updated":"2020-07-29T13:58:32.468Z","comments":true,"path":"blog/2020/07/kotlin-二.html","link":"","permalink":"hexo/blog/2020/07/kotlin-二.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"android-动画","date":"2020-07-27T03:26:53.233Z","updated":"2020-07-27T03:26:53.233Z","comments":true,"path":"blog/2020/07/android-动画.html","link":"","permalink":"hexo/blog/2020/07/android-动画.html","excerpt":"","text":"android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画","categories":[],"tags":[]},{"title":"android 动画","slug":"android-动画","date":"2020-07-21T01:32:47.000Z","updated":"2020-09-04T01:11:22.579Z","comments":true,"path":"blog/2020/07/android-动画.html","link":"","permalink":"hexo/blog/2020/07/android-动画.html","excerpt":"","text":"android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画alpha在res/anim下新建文件alpha_anime.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; android:duration=&quot;1000&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt; 在Activity中123Animation animation = AnimationUtils.loadAnimation(this.getApplicationContext(), R.anim.alpha_anime);ImageView alphaImage = findViewById(R.id.alphaImageView);alphaImage.startAnimation(animation); 这样就能实现图片渐隐的无限循环效果 scale在res/anim下新建文件scale.xml1234567891011&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt; translate123456789&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromYDelta=&quot;100%p&quot; android:toYDelta=&quot;0%p&quot; android:duration=&quot;1000&quot; android:fromXDelta=&quot;100%&quot; android:toXDelta=&quot;0%&quot; /&gt; rotate1234567891011&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;359&quot; android:duration = &quot;1000&quot; android:drawable = &quot;@mipmap/image1&quot; android:visible = &quot;true&quot;&gt; &lt;/rotate&gt;&lt;/rotate&gt; 属性动画","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android MVP","slug":"android-MVP","date":"2020-05-30T08:28:01.000Z","updated":"2020-05-30T08:39:07.044Z","comments":true,"path":"blog/2020/05/android-MVP.html","link":"","permalink":"hexo/blog/2020/05/android-MVP.html","excerpt":"","text":"MVPandroid MVP是一种开发架构，由MVC演化而来，因为在MVC中，Activity层，糅合逻辑、ui操作，显得臃肿、混乱。 在MVP中， M：model，数据层 V：View，页面操作 P：Present，M、V的桥接，逻辑操作 MVP的优势 1、代码简洁，逻辑清晰 2、解耦，便于维护 因为MVP将逻辑与视图分离，降低了业务耦合，使得整个代码层次分明，所以也就更好维护 下面以登陆做一个示例","categories":[],"tags":[{"name":"andorid","slug":"andorid","permalink":"hexo/tags/andorid/"}]},{"title":"android MVVM","slug":"android-MVVM","date":"2020-05-30T08:27:55.000Z","updated":"2020-05-30T08:27:55.412Z","comments":true,"path":"blog/2020/05/android-MVVM.html","link":"","permalink":"hexo/blog/2020/05/android-MVVM.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"android 高级ui","slug":"android-高级ui","date":"2020-05-30T08:27:36.000Z","updated":"2020-05-30T08:27:36.317Z","comments":true,"path":"blog/2020/05/android-高级ui.html","link":"","permalink":"hexo/blog/2020/05/android-高级ui.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"android 图片加载","slug":"android-图片加载","date":"2020-05-30T08:20:33.000Z","updated":"2020-05-30T08:20:48.207Z","comments":true,"path":"blog/2020/05/android-图片加载.html","link":"","permalink":"hexo/blog/2020/05/android-图片加载.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 网络请求框架","slug":"android-网络请求框架","date":"2020-05-30T08:20:15.000Z","updated":"2020-05-30T08:20:51.794Z","comments":true,"path":"blog/2020/05/android-网络请求框架.html","link":"","permalink":"hexo/blog/2020/05/android-网络请求框架.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 序列化","slug":"android-序列化","date":"2020-05-27T12:48:49.000Z","updated":"2020-06-01T02:22:37.503Z","comments":true,"path":"blog/2020/05/android-序列化.html","link":"","permalink":"hexo/blog/2020/05/android-序列化.html","excerpt":"","text":"android序列化什么是序列化将java对象转化为二进制过程，就是序列化，将二进制转化为java对象的过程，就是反序列化 为什么要序列化在下面几种场景下我们需要序列化 永久性保存对象，保存对象的字节序列到本地文件中； 对象在网络中传递； 对象在IPC间传递（进程通信） 如何序列化序列化有两种方法，java中自带的实现Serializable，android中特有的Parcelable Serializable新建类实现Serializable，Serializable为空接口，没有要实现的方法， 需要 定义一个静态常量serialVersionUID 1234567891011121314public class SerBean implements Serializable &#123; private static final long serialVersionUID = 263894729013938L; private String name; private int age; public SerBean(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 这样这个类的序列化就完成了。 Parcelable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ParBean implements Parcelable &#123; private String name; private int age; // 系统自动添加，给createFromParcel里面用 protected ParBean(Parcel in) &#123; name = in.readString(); age = in.readInt(); &#125; public static final Creator&lt;ParBean&gt; CREATOR = new Creator&lt;ParBean&gt;() &#123; /** * * @param in * @return *createFromParcel()方法中我们要去读取刚才写出的name和age字段， * 并创建一个Person对象进行返回，其中color和size都是调用Parcel的readXxx()方法读取到的， * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。 * 读取的工作我们利用一个构造函数帮我们完成了 * */ @Override public ParBean createFromParcel(Parcel in) &#123; return new ParBean(in); &#125; //供反序列化本类数组时调用的 @Override public ParBean[] newArray(int size) &#123; return new ParBean[size]; &#125; &#125;; // 内容接口描述，默认返回0即可。 @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); // 写出name dest.writeInt(age); // 写出age &#125; // --------下面为自己写的构造函数和get set public ParBean() &#123; &#125; public ParBean(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 序列化方案区别上面讲了两个序列化方案，Serializable：是java就有的，代码量少，但在序列化时，会产生大量的临时对象，容易造成频繁的minor GC Parcelable：android特有的，代码量比Serializable要多，但使用效率高，且没那么占内存 因为在选择序列化时，优先使用Parcelable，但有一种情况特殊，当数据保存在磁盘上时，Parcelable在外界有变化的情况下，不能很好的保证数据的连续性，因此在此种场景下推荐使用Serializable； 序列化某种程度来说并不安全 因为序列化的对象数据转换为二进制，并且完全可逆。但是在RMI调用时所有private字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的 解决方案1、 序列化Hook化（移位和复位）2、 序列数据加密和签名3、 利用transient的特性解决4、 打包和解包代理 补充 static和transient字段不能被序列化（感兴趣的同学可以深入研究下）","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"kotlin","slug":"kotlin","date":"2020-05-26T13:28:38.000Z","updated":"2020-12-01T06:00:42.741Z","comments":true,"path":"blog/2020/05/kotlin.html","link":"","permalink":"hexo/blog/2020/05/kotlin.html","excerpt":"","text":"kotlin学习hello world新建一个kt文件， 1234fun main(args:Array&lt;String&gt;) &#123; println(&quot;Hello world!&quot;);&#125; 程序主入口main方法， 无需新建类即可运行，函数声明用fun 123fun sum(a:Int, b:Int):Int&#123; return a + b;&#125; 返回值写在参数之后 表达式可以作为函数体，返回值类型自动推断1fun sun(a:Int, b:Int) = a+b; 返回无意义的值用Unit表示 fun test():Unit { println(“test”);} 变量赋值变量赋值声明关键字：var、valvar：声明变量val：声明常量 var i:Int = 1;val PI:Double = 3.14; 当声明并赋值时，数据类型可以省略, 会自动推断数据类型var i = 1;val PI = 3.14 当声明但不赋值时，不能省略数据类型var i:Int;val PI:Double; 字符串模板123var s = &quot;aaaaa&quot;;var b = &quot;str = $s&quot;;var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot; 条件表达式1234fun testIf(a:Int, b:Int):Int &#123; if(a &gt; b) return a; return b;&#125; 在kotlin中，if还可以用作表达式 1fun max(a:Int, b:Int) = if(a &gt; b) a else b 空值与null检测当某个值可以为空时，需要在类型后添加?表示可以为空此时，声明时不能省略类型12345var obj:Objects ? = null;// 表示返回值可以为nullfun parseInt(str:String):Int?&#123; ...&#125; 类型检测与自动类型转换is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换 123456789fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125; 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 for循环12345678910var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);// 根据元素遍历for (item in items) &#123; println(item);&#125;// 根据下标便利for (item in items.indices) &#123; println(items[item]);&#125; while 循环12345var index = 0;while (index &lt; items.size) &#123; println(items[index]); index ++;&#125; when表达式123456789101112private fun testWhen(s: Any?) &#123; when(s) &#123; &quot;a&quot; -&gt; 1; &quot;b&quot; -&gt; 2; is String -&gt; 3; 1 -&gt; &quot;n&quot;; 2 -&gt; &#123; println(&quot;222&quot;); &#125;; else -&gt; &quot;else&quot;; &#125; &#125; 有点类似java中的 switch 区间 range12345var x = 6;var y = 9;if(x in 0..y) &#123; println(&quot;x in 0 - y&quot;);&#125; 注意：区间只用于数字 集合集合的迭代可以用的上面的 for in 循环1234var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);for(item in items) &#123; println(item);&#125; 判断集合中是否包含某元素 用while in || when12345678while (&quot;a&quot; in items) &#123; println(&quot;items include a&quot;);&#125;when &#123; &quot;a&quot; in items -&gt; println(&quot;aaa&quot;); &quot;d&quot; in items -&gt; println(&quot;ddd);&#125; 用lambda来过滤和映射集合 ，与java8 lambda stream大致 1234items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125; .sortBy&#123; it &#125; .map&#123; it.toUpperCase() &#125; .forEach&#123; println(it) &#125; 协程什么是协程？官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。 协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。CPU调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。 协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。 build.gralde中引入依赖implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1” runBlocking123456789101112131415class MainActivity4 : AppCompatActivity() &#123; val TAG = &quot;MainActivity4&quot; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main2) test() Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;) &#125; fun test() = runBlocking &#123; repeat(8) &#123; Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;) delay(1000) &#125; &#125;&#125; 打印结果如下：协程执行0 线程id：1协程执行1 线程id：1协程执行2 线程id：1协程执行3 线程id：1协程执行4 线程id：1协程执行5 线程id：1协程执行6 线程id：1协程执行7 线程id：1线程main ：1 我们可以得出结论：runBlocking会阻塞线程，但允许还是在当前线程 launch:Job12345678fun testJob() &#123; val job = GlobalScope.launch &#123; repeat(8) &#123; delay(2000) Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, ) &#125; &#125; &#125; 打印结果如下：testJob: 线程main：2testJob: 线程id:6809testJob: 线程id:6807testJob: 线程id:6807testJob: 线程id:6815testJob: 线程id:6807testJob: 线程id:6808testJob: 线程id:6818testJob: 线程id:6809 说明使用GlobalScope.launch 并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务 是非阻塞、异步执行，相当于开启了子线程 async123456789101112131415161718192021222324fun testAsync()&#123; GlobalScope.launch &#123; var result1 = GlobalScope.async &#123; getResult1() &#125; var result2 = GlobalScope.async &#123; getResult2() &#125; val result = result1.await() + result2.await() Log.e(TAG, &quot;testAsync: ThreadId = $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;) &#125;&#125;private suspend fun getResult1():Int &#123; delay(3000) Log.e(TAG, &quot;getResult1: ThreadId = $&#123;Thread.currentThread().id&#125;&quot;) return 4&#125;private suspend fun getResult2():Int &#123; delay(5000) Log.e(TAG, &quot;getResult2: ThreadId = $&#123;Thread.currentThread().id&#125;&quot;) return 5&#125; 输出结果：E/MainActivity4: 线程main ：2E/MainActivity4: getResult1: ThreadId = 7870E/MainActivity4: getResult2: ThreadId = 7870E/MainActivity4: testAsync: ThreadId = 7870 result = 9 其中当打印getResult2后就打印了testAsync: result = 9 阻塞时间为5秒，而不是8秒，说明getResult1、getResult2是并行的。 而且发现 threadId都一样，说明处于同一个线程。但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。 协程并不等于线程，协程内部会根据任务情况自动调度线程。","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"hexo/tags/kotlin/"}]},{"title":"react 掉起摄像头","slug":"react-掉起摄像头","date":"2020-05-22T09:21:42.000Z","updated":"2020-05-22T09:29:17.381Z","comments":true,"path":"blog/2020/05/react-掉起摄像头.html","link":"","permalink":"hexo/blog/2020/05/react-掉起摄像头.html","excerpt":"","text":"在h5中掉起摄像头，碰到一些问题，无法切换到后置摄像头 —-&gt; 将本地http 改为https就可以了chrome浏览器报错：不支持访问用户媒体 —》 将本地http 改为https就可以了 npm start默认采用的是http协议而npm start其实执行的脚本是react-script/start.js文件查看 79行代码1const protocol = process.env.HTTPS === &apos;true&apos; ? &apos;https&apos; : &apos;http&apos;; 我们只要在环境变量中将HTTPS设置为true即可在macos 执行1234567cd ~code .bash_profile添加一行 HTTPS=truesource .bash_profile// 也可以在终端执行export PORT=8081 在 window 新增环境变量 HTTPS true或者在终端执行 set HTTPS=true 本地掉起的摄像头呈现镜像 —-》css 镜像翻转 transform: ‘rotateY(180deg)’ // 水平镜像翻转180 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import React from &apos;react&apos;;import &#123;StyleSheet,css&#125; from &apos;aphrodite/no-important&apos;import &#123; dpw, dph &#125; from &apos;../../common/tool/ScreenFit&apos;;export default class AliveCheck extends React.PureComponent &#123; componentDidMount() &#123; this.video = document.getElementById(&apos;video&apos;); this.canvas = document.getElementById(&apos;canvas&apos;); this.context = this.canvas.getContext(&apos;2d&apos;); const constraints = &#123; audio: false, video : &#123; width: 480, height: 320, sourceId: &apos;default&apos;, facingMode: &#123; exact: &quot;environment&quot; &#125;, // facingMode: &#123; exact: &quot;user&quot; &#125;, permissions: &#123; &quot;audio-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture audio using getUserMedia()&quot; &#125;, &quot;video-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture video using getUserMedia()&quot; &#125; &#125; &#125; &#125; // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;; &#125; if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123; //调用用户媒体设备, 访问摄像头 this.getUserMedia(constraints, this.success, this.error); &#125; else &#123; alert(&apos;不支持访问用户媒体&apos;); &#125; &#125; //访问用户媒体设备的兼容方法 getUserMedia =(constraints, success, error) =&gt; &#123; if (navigator.mediaDevices.getUserMedia) &#123; //最新的标准API navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error); &#125; else if (navigator.webkitGetUserMedia) &#123; //webkit核心浏览器 navigator.webkitGetUserMedia(constraints,success, error) &#125; else if (navigator.mozGetUserMedia) &#123; //firfox浏览器 navigator.mozGetUserMedia(constraints, success, error); &#125; else if (navigator.getUserMedia) &#123; //旧版API navigator.getUserMedia(constraints, success, error); &#125; &#125; success =(stream) =&gt; &#123; //兼容webkit核心浏览器 let CompatibleURL = window.URL || window.webkitURL; //将视频流设置为video元素的源 console.log(stream); //video.src = CompatibleURL.createObjectURL(stream); this.video.srcObject = stream; this.video.play(); &#125; error =(error)=&gt; &#123; console.log(`访问用户媒体设备失败$&#123;error.name&#125;, $&#123;error.message&#125;`); &#125; takePhoto =() =&gt; &#123; alert(&apos;takePhoto&apos;) this.context.drawImage(this.video, 0, 0, 480, 320); &#125; stopCamera =() =&gt; &#123; if (!this.video.srcObject) return let stream = this.video.srcObject let tracks = stream.getTracks(); tracks.forEach(track =&gt; &#123; track.stop() &#125;) &#125; render() &#123; return( &lt;div className=&#123;css(styles.box)&#125;&gt; &lt;video className=&#123;css(styles.video)&#125; id=&quot;video&quot; width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;/video&gt; &lt;div&gt; &lt;button id=&quot;capture&quot; onClick=&#123;this.takePhoto&#125;&gt;拍照&lt;/button&gt; &lt;/div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; box: &#123; display: &apos;flex&apos;, width: &apos;100%&apos;, height: &apos;100%&apos;, flexDirection: &apos;column&apos;, &#125;, video: &#123; // 水平镜像翻转180 transform: &apos;rotateY(180deg)&apos;, &#125;&#125;)","categories":[],"tags":[{"name":"react","slug":"react","permalink":"hexo/tags/react/"}]},{"title":"日常记录","slug":"日常记录","date":"2020-05-21T13:48:21.000Z","updated":"2020-06-01T02:22:37.501Z","comments":true,"path":"blog/2020/05/日常记录.html","link":"","permalink":"hexo/blog/2020/05/日常记录.html","excerpt":"","text":"i++++ 在后，先运算完当前结果，再给i赋值 ex：1234567Object [] obj = new Object [16]i = 0；obj[i ++] = &quot;obj&quot;// 会先执行obj[0]=&quot;obj&quot;;// 再执行i = i + 1; –i;– 在前，则先给i赋值，再执行当前运算","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"位操作符","slug":"位操作符","date":"2020-05-21T13:39:31.000Z","updated":"2020-06-01T02:22:37.500Z","comments":true,"path":"blog/2020/05/位操作符.html","link":"","permalink":"hexo/blog/2020/05/位操作符.html","excerpt":"","text":"&amp;逻辑 与A &amp; B将A、B都转化为二进制，同为均为1则为1，否则为0 ex：5 &amp; 80000 0101&amp;0000 1000 result ： 0000 0000 结果就是0 逻辑或A | B将A、B都转化为二进制，同为有一位为1则为1，否则为0ex ： 5 &amp; 80000 0101&amp;0000 1000 result ： 0000 1101 结果就是13 逻辑非 逻辑异或 5&gt;&gt;2 0000 0101 &gt;&gt; 2 — 0000 0001 === 1 像右移2左移运算符，&gt;&gt;&gt; &lt;&lt; 5 &lt;&lt; 2像左移20000 0101 &lt;&lt; 2 – 0001 0100 === 20左移运算符， 无符号移动 无符号右移，忽略符号位，空位都以0补齐","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 枚举","slug":"java-枚举","date":"2020-05-21T13:26:46.000Z","updated":"2020-06-01T02:22:37.499Z","comments":true,"path":"blog/2020/05/java-枚举.html","link":"","permalink":"hexo/blog/2020/05/java-枚举.html","excerpt":"","text":"枚举enum 的全程事 Enumeration 是jdk1.5引进的 被enum 修饰的数据类型就是枚举类型：1enum Test &#123; TEST0, TEST1, TEST2 &#125; 如果枚举不添加任何方法，枚举值默认为从0开始的递增数值，ru上面的： TEST0：0， TEST1：1，TEST2：2 枚举的好处：可以将常量组织起来，便于管理应用场景：状态码：错误码 枚举的本质枚举的本质是一个类，受限制的类 创建enum是，编译器会自动为你生成一个相关的类，这个类继承 java.lang.Enum b编译过后其实是12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; ... &#125; 是一个抽象类，并且继承了Comparable以及Serializable，也就是标记了序列化 而且枚举可以添加自己的方法、变量，但是不能为枚举常量用 “=”赋值，但不能继承其他类，因为已经继承了Enum类，也不能被继承。 枚举可以实现接口，像上面就是内部实现了两个接口，我们也可以自己实现其他接口 枚举添加方法123456789101112131415public enum TestEnum &#123; //此处调用额其实就是下面写的构造函数 TEST(22), TEST1(33), TEST2(44), TEST3(55); private TestEnum(int num) &#123; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 泛型","slug":"java-泛型","date":"2020-05-19T15:05:30.000Z","updated":"2020-06-01T02:22:37.499Z","comments":true,"path":"blog/2020/05/java-泛型.html","link":"","permalink":"hexo/blog/2020/05/java-泛型.html","excerpt":"","text":"声明中有一个或者多个类型化参数的类或者接口，叫做泛型类或者接口。泛型类和接口统称为泛型。 泛型是一种安全规范，帮助我们在编译前就发现类型安全问题，而不需要等到编译报错。泛型在编译时会被擦除。 关于使用泛型的几个规则： 请不要使用原生态类型 如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势 消除非受检的警告 优先考虑泛型 优先考虑泛型方法 通配符无限通配符 ？上限通配符 ？ extends T下限通配符 ? super T","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 集合","slug":"java-集合","date":"2020-05-18T15:08:59.000Z","updated":"2020-06-01T02:22:37.498Z","comments":true,"path":"blog/2020/05/java-集合.html","link":"","permalink":"hexo/blog/2020/05/java-集合.html","excerpt":"","text":"java中的集合包括map、set、list collection 所有的linked 都是链表实现所有的hash 都是hash表，存储的对象都需要重写hashcode、equas函数","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"多进程通信 IBinder","slug":"多线程通信-IBinder","date":"2020-05-18T15:08:07.000Z","updated":"2020-09-10T03:51:20.941Z","comments":true,"path":"blog/2020/05/多线程通信-IBinder.html","link":"","permalink":"hexo/blog/2020/05/多线程通信-IBinder.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"wechat-app","slug":"wechat-app","date":"2020-05-13T08:24:04.000Z","updated":"2020-05-13T08:24:23.722Z","comments":true,"path":"blog/2020/05/wechat-app.html","link":"","permalink":"hexo/blog/2020/05/wechat-app.html","excerpt":"","text":"微信小程序开发","categories":[],"tags":[{"name":"wechatApp","slug":"wechatApp","permalink":"hexo/tags/wechatApp/"}]},{"title":"kotlin 类","slug":"kotlin","date":"2020-05-13T08:20:15.000Z","updated":"2020-07-27T03:26:53.229Z","comments":true,"path":"blog/2020/05/kotlin.html","link":"","permalink":"hexo/blog/2020/05/kotlin.html","excerpt":"","text":"kotlin 类kotlin中使用class申明类 构造函数构造函数分为主构造函数、次构造函数 主构造函数kotlin中可以在申明类时申明一个构造函数，并且次构造函数为 主构造函数 12// 申明了主构造函数class Person constructor(var name: String, var age: Int ) &#123;&#125; 如果主构造函数没有使用任何注解或者修饰符，则可以省略constructor关键字 1class Person (var name: String, var age: Int ) &#123;&#125; 主构造函数不能含有代码块，有需要初始化的代码可以放在以init关键字作为前缀的初始化块中。其中init可以申明多个，会根据代码顺序来执行。 123456789class Person (var name: String, var age: Int ) &#123; var myName = name; init &#123; println(&quot;this person&apos;s name was $&#123;myName&#125;&quot;); &#125; init &#123; println(&quot; test &quot;); &#125;&#125; 如果没有申明主构造函数，系统会自动创建一个无参的主构造函数。 次构造函数次构造函数必须要用constructor申明，如果有主构造函数，必须将次构造函数委托给主构造函数 1234567891011121314class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125; 初始化init代码块实际上会成为主构造函数的一部分。当次级构造函数委托给主构造函数，init代码块会成为次级构造函数的第一句语句。即使该类没有主构造函数，这种委托也会隐式发生，仍会执行初始化代码块。 如果一个非抽象类没有申明任何主、次构造函数，默认会生成一个不带参的主构造函数。函数的可见性为public。如果不想类有一个公有构造函数，需要声明一个private的主构造函数。1class TestClass private constructor () &#123;&#125; 在JVM上，如果主构造函数中的所有参数都有默认值，则会默认生成一个额外的无参构造函数，它将使用默认值。 创建类的实例kotlin 在创建实例时，不需要new 关键字12class MyPerson(str: String, var age: Int) &#123;&#125;var person = MyPerson(&quot;jack&quot;, 11); 类成员 构造函数与初始化代码块 函数 属性 嵌套类、内部类 对象申明 继承在kotlin中，所有类都有一个超类 Any，这对于没有超类型声明的类是默认超类： var oneClass; // 从Any隐式继承 Any 类中有三个方法 equas()、 hashcode()、 toString(), 因此所有kotlin类都定义有这三个方法 默认情况下，kotlin中类都是final 的，不可被继承，如果需要声明该类可以被继承，需要使用关键字 open。 并且kotlin中是使用 : 来表示继承。 12open class TestClassSuper &#123;&#125;class TestClassChild : TestClassSuper &#123;&#125; 如果超类中有声明主构造函数，则子类可以声明主构造函数，则并必须用子类中主构造函数参数初始化超类。如果子类没有声明主构造函数，则必须声明次级构造函数，并且使用super初始化基类12345678910111213141516171819open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall);&#125; 函数的重写正如类的继承需要申明open标识该类开放继承，类中的函数标识可以被重写也是需要使用open申明，如果没有函数没有申明open，则在子类中不允许出现同名并且同参数类型的函数。出现同名但不同参数的函数时允许的，正如java中的重载 12345678910111213141516171819202122232425262728293031323334open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125; open fun testMethod() &#123; &#125; fun test1() &#123; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall); override fun testMethod() &#123; super.testMethod() &#125; fun test1(str:String) &#123; &#125;&#125; 属性的重写同函数的重写，属性的重写也是需要使用open标识，并在子类中使用override1234open var i = 2;// childClassoverride var i = 4; 在属性的重写中，有一点需要注意，可以用var 重写val，却不能用val重写var；这一点是和java不一样的。因为用val申明的属性本质上申明了get方法，而将其重写为var只是在子类新增了一个set方法 派生类的初始化顺序1、进入子类的构造函数2、进入父类的构造函数并完成初始化3、进入父类的init代码块4、父类中属性的初始化5、子类构造函数完成初始化6、子类init代码块7、子类属性初始化 调用父类方法或属性可以使用super关键字1234// 方法super.method();// 属性super.nema; 内部类中调用外部类父类属性或方法，使用super@Outer1super@OutClass.method();","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"hexo/tags/kotlin/"}]},{"title":"android dialog ","slug":"android-dialog","date":"2020-05-13T07:56:53.000Z","updated":"2020-05-13T08:14:46.157Z","comments":true,"path":"blog/2020/05/android-dialog.html","link":"","permalink":"hexo/blog/2020/05/android-dialog.html","excerpt":"","text":"dialog在日常开发时会经常使用到弹窗dialog 针对自定义视图的弹窗使用方法， 1234567AlertDialog.Builder builder = new AlertDialog.Builder(context);LayoutInflater inflater = context.getLayoutInflater();View view = inflater.inflate(R.layout.view, null);build.setView(view);AlertDialog dialog = build.create();dialog.show(); 上面就是一个AlertDialog实例的创建过程，其中AlertDialog使用了创建者模式。 关于点击弹窗其他部分、点击手机back而不关闭dialog的方法有如下:12dialog.setCancelable(false); // 点击back、其他部位都不关闭弹窗dialog.setCanceledOnTouchOutside(false);// 点击其他部位不关闭、点back关闭 设置dialog弹窗的大小： 12345678910// 在dialog.show() 之后Window window = dialog.getWindow();if(window != null) &#123; WindowManager.LayoutParams attr = window.getAttributes(); if (attr != null) &#123; attr.height = ViewGroup.LayoutParams.MATCH_PARENT; attr.width = ViewGroup.LayoutParams.MATCH_PARENT; window.setAttributes(attr); &#125;&#125; 这样就将dialog窗口大小设置为了最大，但是可以发现我们的弹窗还是没有充满整个屏幕，因为dialog默认的主题theme就是偏距margin的，所以如果我们想要充满整个屏幕的话，需要改变我们dialog的主题， 12// AlertDialog.Builder builder = new AlertDialog.Builder(context);AlertDialog.Builder builder = new AlertDialog.Builder(context, R.style.AppTheme);","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"java流","slug":"java流","date":"2020-05-13T07:55:26.000Z","updated":"2020-05-13T07:55:32.490Z","comments":true,"path":"blog/2020/05/java流.html","link":"","permalink":"hexo/blog/2020/05/java流.html","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java范型","slug":"java范型","date":"2020-05-13T07:54:59.000Z","updated":"2020-05-13T07:55:07.530Z","comments":true,"path":"blog/2020/05/java范型.html","link":"","permalink":"hexo/blog/2020/05/java范型.html","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"jvm 线程私有区","slug":"jvm-线程私有区","date":"2020-05-13T06:33:03.000Z","updated":"2020-05-13T07:41:22.551Z","comments":true,"path":"blog/2020/05/jvm-线程私有区.html","link":"","permalink":"hexo/blog/2020/05/jvm-线程私有区.html","excerpt":"","text":"jvm 线程私有区jvm从多线程角度看，分为线程共享区、线程私有区 而在线程私有区中有：程序计数器、方法栈区（包括虚拟机栈、本地方法栈） 程序计数器较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响 jvm的多线程是通过cpu时间片轮转算法实现的，某个线程在执行过程中会因为时间片耗尽而被挂起，其他线程获得时间片开始执行。当被挂起的线程重新获取到时间片，它要想从之前被挂起的地方开始执行，就需要知道之前执行到了哪里，在jvm中，通过程序计数器来记录字节码执行的位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。 程序计数器的特点1、线程隔离：每个线程都有自己的程序计数器2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。 方法栈区线程在运行时，在执行每一个方法的时候都会打包成一个栈帧，然后将栈帧入栈，当方法执行完时，就会将该栈帧出栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。 栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k 栈帧结构栈帧中含有：局部变量表、操作数据栈、动态链接、返回地址 局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 锁","slug":"java-锁","date":"2020-05-07T02:42:32.000Z","updated":"2021-01-18T01:12:32.885Z","comments":true,"path":"blog/2020/05/java-锁.html","link":"","permalink":"hexo/blog/2020/05/java-锁.html","excerpt":"","text":"java中使用锁，主要是用于解决多线程并发问题多个线程对某个对象进行操作，就存在并发问题。 java内存规定了，所有变量都储存在主内存中，每个线程又有自己的工作内存 线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存 线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 注意：锁作用的都是对象，在对象的内存空间中，有标志位标记是有有锁。 并发三要素原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。 可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：程序执行的顺序按照代码的先后顺序执行。 解决并发问题volatile：保证可见性，不保证原子性当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中 这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见 禁止指令重排序指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则 不会对存在依赖关系的指令重排序，例如 a = 1;b = a; a 和b存在依赖关系，不会被重排序 不能影响单线程下的执行结果。比如：a=1;b=2;c=a+b这三个操作,前两个操作可以重排序，但是c=a+b不会被重排序，因为要保证结果是3 使用场景对于一个变量，单个线程写，其他线程读，这个时候就可以使用volatile来修饰这个变量 123456789101112131415161718public class Utils &#123; private static volatile Utils instance; public static Utils getInstance() &#123; // 1 if(instance == null) &#123; // 2 synchronized(Utils.class) &#123; // 3 if(instance == null) &#123; // 4 instance = new Utils(); // 5 &#125; &#125; &#125; return instance; &#125;&#125; 初始化一个对象有如下步骤：分配内存，初始化对象，指向内存 如上代码，如果不使用volatile修饰，这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断instance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。 volatile 原理在jvm底层，volatile是通过内存屏障来实现的，内存屏障会提供三个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将缓存的修改操作立即写到主内存 写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。 valatile局限性volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题 Synchronized多个线程同时写一个变量这个时候使用Synchronized，可以保证同一时刻，只有一个线程可执行某个方法或某个代码块 Synchronized锁升级Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。 偏向锁 ：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。 轻量级锁 ：在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。 重量级锁 ：如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。 Synchromized缺陷不能设置锁超时时间不能通过代码释放锁容易造成死锁 ReentrantLock上面说到Synchronized的缺点，不能设置锁超时时间和不能通过代码释放锁，ReentranLock就可以解决这个问题 在多个条件变量和高度竞争锁的地方 ， 用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性 原文地址(https://www.jianshu.com/p/4eec21c3338e) JVM内存模型、指令重排、内存屏障概念解析(https://www.cnblogs.com/chenyangyao/p/5269622.html) 在java中有以下锁： 公平锁/非公平锁 可重入锁 互斥锁/读写锁 独享锁/共享锁 分段锁 偏向锁/轻量级锁/重量级锁","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 内存结构","slug":"java-内存结构","date":"2020-01-13T08:15:01.000Z","updated":"2020-06-01T02:22:37.497Z","comments":true,"path":"blog/2020/01/java-内存结构.html","link":"","permalink":"hexo/blog/2020/01/java-内存结构.html","excerpt":"","text":"java 内存结构首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。 程序计数器程序计数器： 主要功能是记录当前线程执行程序的位置，通过改变计数值来确定执行下一条指令。每个线程的创建，都会创建一个程序计数器，并且对于每个线程而言是互相独立的。比如我们在debuger模式下运行，for循环的停止，异常的抛出，都是通过改变该线程对应的计数值来确定下一个执行指令。 java虚拟机栈java虚拟机栈：主要功能是临时存储线程执行到的每个方法需要的参数，其内存空间在编译时就已确定。与程序计数器一样，每创建一个线程，则创建一个虚拟机栈，线程每执行到一个方法，对应的栈里就会创建一个栈帧，栈帧会存储局部变量表、动态链接、操作数和方法出口等信息，执行方法，栈帧入栈，方法执行完，栈帧出栈。 本地方法栈本地方法栈与java虚拟机栈一样，只是记录native方法执行。jni native调用的c、c++函数 堆得内存结构分为老年代、新生代，内存比为8:2其中新生代分为: edan、from、to 内存分为8:1:1直接new产生的对象被分配到edan（大对象会被直接分配到老年代），当发生GC时，会通过复制清楚算法，清楚edan+from区域可被回收的对象，而不可被回收对象会被复制到to区，而在下一次GC时，会清除edan+to区可回收对象，将不可清楚的对象复制到from区，并且每次回收时，会整理碎片内存。 GCgc分为minor GC、full GCminor 作用区域是新生代内存、算法：复制清除算法。会整理碎片full GC作用区域是老年代内存，算法：标记清除算法，不会整理碎片。 GC时判断是否可回收的依据是：内存可达化：判断堆、方法栈、静态变量、静态方法区中是否有该对象的引用。 每次 gc时会 会stw（stop the world）,线程会被挂起两次","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"算法（1）简单算法","slug":"算法","date":"2020-01-06T07:49:28.000Z","updated":"2020-01-13T10:07:11.324Z","comments":true,"path":"blog/2020/01/算法.html","link":"","permalink":"hexo/blog/2020/01/算法.html","excerpt":"","text":"算法（1）简单算法简单常见算法 二分查找法针对有序的数据集，每次查找时都取中间值，逐步缩小查找范围，最后获取到目标值 复杂度：$O(log_n)$ 选择排序选择排序是针对数组的一种排序算法。过程：遍历数组，计算出最值，新建一个数组，将最值放入新数组, 复杂度：$O(n^2)$ 递归递归指函数在内部调用本身，使用递归注意两个条件：基线条件、递归条件。基线条件：跳出递归的条件递归条件：对递归元素逐步减少的条件，要合理利用这两点，不然容易无限循环。 在数组中取最大值12345678910111213function findMax(arr) &#123; let max = 0; if(arr.length === 0) &#123; return max; &#125; else &#123; max = arr[0] &gt; max ? arr[0] : max; arr.splice(0, 1); return findMax(arr); &#125;&#125;var arr = [1, 2, 3, 4, 5];findMax(arr); 递归算法与数据结构中的 栈 是及其相似的。已上面的算法为例，调用findMax([1,2,3,4,5])时，将findMax([1,2,3,4,5])压入栈顶，而findMax会调用findMax([2,3,4,5]),然后将findMax([2,3,4,5])压入栈,如下图所示： 然后从栈顶依次得出计算结果出栈。 快速排序","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"hexo/tags/算法/"}]},{"title":"数据结构 (1)","slug":"数据结构-1","date":"2020-01-03T09:27:20.000Z","updated":"2020-09-24T06:19:08.580Z","comments":true,"path":"blog/2020/01/数据结构-1.html","link":"","permalink":"hexo/blog/2020/01/数据结构-1.html","excerpt":"","text":"数据结构 (1) - 简单数据数组数组：有序、内存连续的数据集， 数组是有序的，顺序就是插入的顺序，先插入的值排在前面，内存连续：在内存分配时，数组中的值的内存空间是分配在一起的所以在我们使用数组时，推荐在申明时申明数组的长度，不然在后续插入值时可能会导致之前的数据内存空间不够，需要重新分配整个数据内存空间 数组的索引就是数组中值的下标：从0开始计数。数组的查找通过索引，所以快。而增删、修改时，当插入一个值，则需要将后面的数据都后移，删除也是类似。 数组查询快，增删慢查询：O(1)增删：O(n)修改：O(n) 数组查询原理我们知道通过数组查询快，但是为何快呢。 因为数组是内存连续的，当我们通过下标查询时，其实是通过数组0处内存地址+下标 得出该下标对应的内存地址，然后获取存储的对象。 所以查询会快。 链表链表：无序、内存非连续、每个节点都具有下一个节点的地址 链表是无序的，内存非连续，因为每一个节点都含有下一个节点的地址，相比于数组，内存非连续，则当数据增多，也不会存在内存空间的问题，因为只需随便分配下一个节点的内存，然后将上一个节点的中含有的下一个节点地址指向最新分配的地址即可。 链表数据第一个、最后一个节点的值是明确的。因为链表是无序的。所以查询慢，因为想要获取一个节点的值，需要先获取上一个节点，通过上一个节点获取到下一个节点的地址。 查询：O(n)增删：O(1)修改：O(1) 链表分为：单链表、双链表、循环链表 栈栈是一种只允许在一端进行插入或删除的线性表 栈的操作只有两种：出栈、进栈特点：先进后出(FILO:first in last out) 只允许对栈顶的元素操作。最先进入的元素将会被压入栈底 栈可以通过数组实现，也可以通过链表实现 集合队列FIFO 树","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"hexo/tags/数据结构/"}]},{"title":"android 贝塞尔曲线","slug":"android-贝塞尔曲线","date":"2020-01-03T08:46:06.000Z","updated":"2020-12-25T03:30:53.313Z","comments":true,"path":"blog/2020/01/android-贝塞尔曲线.html","link":"","permalink":"hexo/blog/2020/01/android-贝塞尔曲线.html","excerpt":"","text":"在自定义view中，绘制连续的曲线时，我们经常会使用到贝塞尔曲线。 贝塞尔曲线又分成几阶贝塞尔曲线，","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android-自定义View-继承EditText","slug":"android-自定义View-继承EditText","date":"2019-12-19T09:59:28.000Z","updated":"2019-12-30T10:08:03.595Z","comments":true,"path":"blog/2019/12/android-自定义View-继承EditText.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View-继承EditText.html","excerpt":"","text":"android-自定义View-继承EditText一直觉得flutter中的输入框效果不错。动画，提示标题都有。这次要通过自定义View, 继承重写EditText来实现同样的输入框效果 源码地址 首先确定大致思路两个元素：TextView、EditText，TextView为标题，EditText为输入框展示当未获取焦点时：1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部2、输入框如果没有输入的内容，则输入框展示的提示文本当获取焦点时：不管有无输入内容，提示文本缩小在输入框上部 TextView并非实质组件，只是绘制Text，当作TextView。 1、先写一个类继承AppCompatEditText，并实现构造函数123456789101112131415161718192021public class AnimatedInput extends AppCompatEditText &#123; public AnimatedInput(Context context) &#123; super(context); this.context = context; &#125; public AnimatedInput(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; initView(attrs); &#125; public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initView(attrs); &#125;&#125; 2、重写onFocusChanged函数这样获取到 是否获取焦点的标识位123456@Override protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123; super.onFocusChanged(focused, direction, previouslyFocusedRect); isFocus = focused; postInvalidate(); &#125; 3、重写onTextChanged函数这样获取到输入框的内容value12345@Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; super.onTextChanged(text, start, lengthBefore, lengthAfter); value = text.toString(); &#125; 4、绘制提示文本这时候要分情况，即是否获取焦点、输入框是否有内容1234567891011121314151617181920212223242526272829@Overrideprotected void onDraw(Canvas canvas) &#123; // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸 int width = getMeasuredWidth(); int height = getMeasuredHeight(); top = getPaddingTop(); left = getPaddingLeft(); right = width - left - getPaddingRight(); bottom = height - top; drawTitle(canvas); super.onDraw(canvas);&#125;/** * 绘制标题 * @param canvas */private void drawTitle(Canvas canvas) &#123; if(TextUtils.isEmpty(value)) &#123; if(isFocus) &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125; else &#123; canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint); &#125; &#125; else &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125;&#125; 如此就基本实现了我们的预期目标。这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android-自定义View 继承ViewGroup","slug":"android-自定义View-继承ViewGroup","date":"2019-12-12T07:13:45.000Z","updated":"2020-12-10T06:01:09.172Z","comments":true,"path":"blog/2019/12/android-自定义View-继承ViewGroup.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View-继承ViewGroup.html","excerpt":"","text":"android 自定义View 继承ViewGroup自定义ViewGroup与自定义View不同.自定义View主要侧重于实现如何绘制，而自定义ViewGroup主要侧重于如何布局。所以自定义ViewGroup时，必须重写onMeasure、onLayout函数。onMeasure测量每个子View的大小，最后得出容器的大小onLayout上根据测量的每个子View，来对每个子View进行布局 自定义FlowLayout这里我们自定义一个自动换行的流式布局。效果图： 设计思路：1、默认横向布局、当横向布局宽度要超出容器宽度时，则自动换行，2、将整个视图分割成多少行，而每行又能分割成多个视图3、使用两个数组，一个记录单行视图，一个记录所有行（也就是前一个数组）4、每次需要换行时，记录这行的高度，当前所有视图的高度，当所有子视图计算完毕，就能知道所有子视图一起需要的宽度与高度5、根据ViewGroup使用时的SpecMode来得出最后实际的宽高,并将宽高设置上去，此处onMeasure函数完成6、处理onLayout，遍历所有行，遍历每一行，得到每个View的left、top、right、bottom，调用View.layout函数，将每个View相对于父容器的位置设置上去，此时就完成了布局，整个FlowLayout的设计基本完成 关于第5点，与自定义View中是一样的 EXACTLY AT_MOST UNSPECIFIED &lt;-MeasureSpec wrap_parnet EXACTLY AT_MOST AT_MOST match_parent EXACTLY AT_MOST AT_MOST 50dp 50dp 50dp 50dp ^LayoutParams onMeasure所以onMeasure函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); recyle(); // 获取各个偏距 int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); // 先获取父容器能给的尺寸大小 int selfWidth = MeasureSpec.getSize(widthMeasureSpec); int selfHeight = MeasureSpec.getSize(heightMeasureSpec); // 获取子视图的数量 int childViewCount = getChildCount(); // 记录每行中的子view List&lt;View&gt;lineViews = new ArrayList&lt;&gt;(); int lineWidthUsed = 0; // 每行已用宽度 int lineHeight = 0; // 行高 int parentNeededWidth = 0; // measure过程中，子View要求的父ViewGroup的宽 int parentNeededHeight = 0; // measure过程中，子View要求的父ViewGroup的高 // 遍历所有的子View for (int i = 0 ; i &lt; childViewCount; i ++) &#123; View childView = getChildAt(i); // 获取子视图的宽、高 LayoutParams lp = childView.getLayoutParams(); // 如果View存在 因为GONE的视图不占位置 if(childView.getVisibility() != GONE) &#123; // 获取子视图的测量规格 int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, paddingLeft + paddingRight, lp.width); int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, paddingTop+paddingTop, lp.height); // 设置子View的尺寸 childView.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 当执行完measure函数后，即可获取到该子view的尺寸 int childViewWidth = childView.getMeasuredWidth(); int childVieeHeight = childView.getMeasuredHeight(); // 当所用宽度 + 宽度间隔 + 当前子视图宽度 &gt; 容器View的宽度，则需要换行 if(lineWidthUsed + mHorizontalSpacing + childViewWidth &gt; selfWidth) &#123; // 记录当前行的视图、高度 allView.add(lineViews); lineHeights.add(lineHeight); // 父容器需要的宽、高 parentNeededHeight = parentNeededHeight + lineHeight + mVerticalSpacing; parentNeededWidth = Math.max(parentNeededWidth, lineWidthUsed + mHorizontalSpacing); // 执行换行、清空当前行数据 lineViews = new ArrayList&lt;&gt;(); lineHeight = 0; lineWidthUsed = 0; &#125; else &#123; lineViews.add(childView); lineHeight = Math.max(lineHeight, childVieeHeight); lineWidthUsed = lineWidthUsed + childViewWidth + mHorizontalSpacing; &#125; //处理最后一行数据 因为最后一行肯定不会触发上面的换行 if (i == childViewCount - 1) &#123; allView.add(lineViews); lineHeights.add(lineHeight); parentNeededHeight = parentNeededHeight + lineHeight + mVerticalSpacing; parentNeededWidth = Math.max(parentNeededWidth, lineWidthUsed + mHorizontalSpacing); &#125; &#125; &#125; // 通过子View的计算得出了需要的最小具体值 再根据spec一起得出最后应该的值 此处需要参考上面提到的第5点 // 根据mode以及lp获取实际值 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int realWidth = widthMode == MeasureSpec.EXACTLY ? selfWidth : parentNeededWidth; int realHeight = heightMode == MeasureSpec.EXACTLY ? selfHeight : parentNeededHeight; // 设置实际尺寸 setMeasuredDimension(realWidth, realHeight); &#125; 这样我们就完成了整个ViewGroup的尺寸测量，ViewGroup的onMeasure过程其实就是遍历子View，测量各个子View的过程。measure方法会调用到onMeasure函数，而在onMeasure中会测量到具体尺寸。 注意一下在onMeasure执行时，我们调用了一个recyle函数，1234 private void recyle() &#123; allView.clear(); lineHeights.clear();&#125; 这个函数作用就是将记录的每行view、行高信息清空。因为onMeasure函数会被调用多次，上面说了，容器的测量就会遍历子View测量，因为上层View视图中，至少存在两层ViewGroup，所以最少会被执行两次。所以每次执行此函数时，我们需要清空一下上一次的数据。 测量函数执行完毕，现在我们知道了每个view的大小，接下来我们就按照记录的View的排列、行高等信息，来对每个子View做布局处理 onLayout在上面的话，我们已经获取到了每个view的行数排列，我们只需再遍历到所有行的View，获取到每个view针对父容器的左偏距、上偏距就能够对view定位，再获取该view的宽高时，就能获取到右偏距、下偏距了。注意在onMeasure执行完毕后，就能调用getMeasuredWidth，获取尺寸信息而在onLayout执行完毕后，就能调用getWidth获取尺寸信息 1234567891011121314151617181920212223242526272829@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; // 获取容器的左、上偏距 int left = getPaddingLeft(); int top = getPaddingTop(); Log.e(TAG, &quot;onLayout: top : &quot; + top); for(int i = 0; i &lt; allView.size(); i ++) &#123; List&lt;View&gt; lineView = allView.get(i); int lineHeight = lineHeights.get(i); // 该行的高度 for(int j = 0; j &lt; lineView.size(); j ++) &#123; View childView = lineView.get(j); // 右偏距等于左偏距加上自身宽度 int right = left + childView.getMeasuredWidth(); // 下偏距等于上偏距加上自身高度 int bottom = top + childView.getMeasuredHeight(); Log.d(TAG, &quot;onLayout: left = &quot; + left + &quot; top = &quot; + top + &quot; bottom = &quot; + bottom); // 设置该view childView.layout(left, top, right, bottom); // 为下一个view准备 left = right + mHorizontalSpacing; &#125; // 为下一行准备 top = lineHeight + mVerticalSpacing + top; left = getPaddingLeft(); &#125;&#125; 这样我们自定义一个ViewGroup就完成了，实现了一个自动换行的ViewGroup 项目源码地址：https://github.com/wangchongwei/customView/blob/master/app/src/main/java/com/justin/customview/customview/FlowLayout.java","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 自定义View 继承View","slug":"android-自定义View-继承View","date":"2019-12-11T01:47:36.000Z","updated":"2019-12-19T09:44:13.225Z","comments":true,"path":"blog/2019/12/android-自定义View-继承View.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View-继承View.html","excerpt":"","text":"android 自定义View 继承View上篇关于自定义View的介绍接下来将会针对自定义View三种情况一一实现。 源码地址 最后实现效果如下图： 继承View创建一个class MyView 继承View 目标是写一个折线图 现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;LineView&quot;&gt; &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 先新建一个clas 继承View， 并初始化几个构造函数1234567891011121314151617181920212223242526272829303132public class MyView extends View &#123; // 代码生成时，才会调用该构造函数 public MyView(Context context) &#123; super(context); this.context = context; &#125; public MyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; // xml配置时，会调用这个生命周期 public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initData(attrs); &#125; // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。 private void initData(AttributeSet attrs) &#123; Log.d(TAG, &quot;initData: &quot;); // 获取xml中配置的数据 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView); paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black)); // 画笔初始化 paint = new Paint(); paint.setColor(context.getResources().getColor(R.color.black)); paint.setTextSize(40); paint.setStrokeWidth(10); // 线条粗细 &#125;&#125; 在onMeasure函数中对尺寸做约束12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.d(TAG, &quot;onMeasure: &quot;); int height = measuretDimension(defaultHeight, heightMeasureSpec); int width = measuretDimension(0, widthMeasureSpec); top = 0; left = 0; bottom = top + height; right = left + width; setMeasuredDimension(width, height);&#125;/** * 测量实际尺寸 * @param defaultSize: 默认尺寸 * @param measureSpec: 测量规格 * @return */public int measureDimension(int defaultSize, int measureSpec) &#123; int resultSize = defaultSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; // 没有做限制，取默认值 case MeasureSpec.UNSPECIFIED: resultSize = defaultSize; break; // WRAP case MeasureSpec.AT_MOST: // 要取默认值和测量值中较小值 // 当默认值为0时，取最大值, 即宽充满屏幕 resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize); break; // 具体值 或 MATCH case MeasureSpec.EXACTLY: resultSize = specSize; break; default: break; &#125; return resultSize;&#125; 先绘制两个轴线注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。这两个里的坐标不要弄混。 12345678/** 绘制两条轴线 */private void drawXY(Canvas canvas) &#123; Log.d(TAG, &quot;drawXY: &quot;); // 绘制x轴 canvas.drawLine(left + 20, bottom, right, bottom, paint); // 绘制y轴 canvas.drawLine(left + 20, top, left + 20, bottom, paint);&#125; 在MainActivity中配置该视图123456789&lt;com.justin.customview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot; android:layout_marginTop=&quot;20dp&quot; android:padding=&quot;10dp&quot; app:axieColor=&quot;@color/black&quot; android:id=&quot;@+id/myView&quot; /&gt; 我们直接运行,效果如下： x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。新增一个方法初始化这些尺寸数据 123456789101112131415161718192021/** * 尺寸数据初始化 */private void initSize () &#123; // 获取padding尺寸 paddingLeft = getPaddingLeft(); paddingTop = getPaddingTop(); paddingRight = getPaddingRight(); paddingBottom = getPaddingBottom(); StringBuilder sb = new StringBuilder(); sb.append(&quot;paddingLeft =&quot;).append(paddingLeft) .append(&quot;paddingTop =&quot;).append(paddingTop) .append(&quot;paddingRight =&quot;).append(paddingRight) .append(&quot;paddingBottom =&quot;).append(paddingBottom); Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString())); top = paddingTop; left = paddingLeft; bottom = height - top - paddingBottom; right = width - left; setMeasuredDimension(width, height);&#125; 这样我们就对padding做了处理，接下来接着绘制我们需要的图形。我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头 123456789101112131415161718private void drawArrow(Canvas canvas) &#123; Path path = new Path(); // 先绘制x轴三角 //先移动到三角形一个点 path.moveTo(right-20, bottom + 20); path.lineTo(right-20, bottom - 20); // 画线 path.lineTo(right, bottom); // 画线 path.close(); // 图形闭合 canvas.drawPath(path, paint); // 绘制y轴三角 path.moveTo(left - 20, top + 20); path.lineTo(left + 20, top + 20); path.lineTo(left, top); path.close(); canvas.drawPath(path, paint);&#125; 这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。 设置数据并绘制点我们已经完成了绘制两条轴线，现在要开始绘制数据了。首先我们要确认标准线，x轴的标准线肯定就是xValue的值，但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。我们先假设我们的值在0-100以内，取5条标准线，每条间距20. 先设置两个数据1234567891011121314151617// 数据 private float[] yValue; private String[] xValue; private int lineNum = 5; /** 设置数据并刷新 */ public void setData(float[]yValue, String[]xValue) &#123; this.yValue = yValue; this.xValue = xValue; postInvalidate(); &#125; /** 设置标准线数目 */ public void setData(int lineNum) &#123; this.lineNum = lineNum; postInvalidate(); &#125; 然后我们开始绘制标准线、各个点123456789101112131415161718192021/** 绘制各个点 */private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 5, paint); &#125;&#125; 而在MainActivity.kt中，我们可以这样使用 1234567891011// kotlin语法class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;) var yValue = floatArrayOf(70f, 80f, 90f); myView.setData(yValue, xValue); &#125;&#125; 此时的实现效果： 现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些 绘制x、y轴标准线值，将各个点连接起来。123456789101112131415161718192021222324252627282930313233343536/** 绘制各个点 */ private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; int itemValue = yMax / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); // 绘制y轴标准值 canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 10, paint); // 绘制点与点之间的连线 if(lastX &gt; 0f) &#123; canvas.drawLine(lastX, lastY, x, y, paint); &#125; // 绘制x轴标准值 canvas.drawText(xValue[i-1], x, bottom + 50, paint); lastX = x; lastY = y; &#125; &#125; 最后实现效果如下图：","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 自定义View","slug":"android-自定义View","date":"2019-12-10T07:42:49.000Z","updated":"2020-12-22T02:10:44.001Z","comments":true,"path":"blog/2019/12/android-自定义View.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View.html","excerpt":"","text":"Android 自定义View自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。 首页android自定义View有三种类型，1、继承View，多用于实现一些不规则的图形。 2、继承特定的组件，如TextView， 3、继承ViewGroup，用于视图组 在自定义View中有三个关键的方法：onMeasure、onLayout、onDraw onMeasure测量，ViewGroup 会遍历测量子视图的onMeasure方法。一般view 则是在测量自身。 在这个方法中，一般是对视图的尺寸做一些要求。如：处理padding、处理wrap_parent margin是无需处理的，margin其实是在父容器的onMeasure时处理的。 在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。这两个参数都是父容器传递过来。 视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec LayoutParams我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：android:layout_width = “wrap_parent | 50dp | match_parent”存在三种情况，wrap_parent： 自适应大小，50dp: 具体尺寸match_parent: 充满父容器-父容器大小 MeasureSpec测量规格，MeasureSpec由size和mode组成 1.static int getMode(int measureSpec): // 获取mode2.static int getSize(int measureSpec):// 获取size3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec specMode存在三种情况:EXACTLY:具体尺寸、具体值AT_MOST：表示子视图最多只能是specSize中指定的大小UNSPECIFIED：可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。 size：就是LayputParams中指定的大小 而子视图的大小也就是通过size和specMode获取的，具体关系如下图： EXACTLY AT_MOST UNSPECIFIED &lt;-MeasureSpec wrap_parnet EXACTLY AT_MOST AT_MOST match_parent EXACTLY AT_MOST AT_MOST 50dp 50dp 50dp 50dp ^LayoutParams 总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸 下面会讲具体使用 onLayout布局方法 在调用onLayout时，onMeasure已经完成，子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。 onDraw绘制的方法onDraw是在容器的draw方法时调用的。而绘制的顺序为：1.绘制背景2.如果有必要，保存画布的图层，以准备失效3.绘制视图的内容4.绘制子控件5.如果必要，绘制衰落边缘和恢复层6.绘制装饰（比如滚动条） onDraw 有一个参数(Canvas cancas),canvas 就是画布，画布的范围就是onLayout布局后确定的区域Paint 画笔 Paint的常用配置1Paint mPaint = new Paint(); Style画笔的样式分三种类型 Style是个枚举类12345678910111213141516171819202122232425public enum Style &#123; /** * Geometry and text drawn with this style will be filled, ignoring all * stroke-related settings in the paint. */ FILL (0), /** * Geometry and text drawn with this style will be stroked, respecting * the stroke-related fields on the paint. */ STROKE (1), /** * Geometry and text drawn with this style will be both filled and * stroked at the same time, respecting the stroke-related fields on * the paint. This mode can give unexpected results if the geometry * is oriented counter-clockwise. This restriction does not apply to * either FILL or STROKE. */ FILL_AND_STROKE (2); Style(int nativeInt) &#123; this.nativeInt = nativeInt; &#125; final int nativeInt;&#125; canvas的常用函数","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"react redux","slug":"react-redux","date":"2019-12-03T01:54:38.000Z","updated":"2019-12-03T05:34:32.439Z","comments":true,"path":"blog/2019/12/react-redux.html","link":"","permalink":"hexo/blog/2019/12/react-redux.html","excerpt":"","text":"在react-native中集成redux对react框架而言，状态树、dom树是它的一大优势。而redux就是对数据、状态进行管理。 集成redux1、执行1234npm install redux --savenpm install react-redux --savenpm install redux-thunk --savenpm i redux-logger --save 以上命令下载关于redux的组件。 2、store的配置1234567891011121314// configStore.jsimport &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import rootReducer from &apos;./reducer&apos;;const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);export default configStore =(initState) =&gt; &#123; const store = createStoreWithMiddleware(rootReducer, initState); return store;&#125; 而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰 123456789101112// rootReducerimport &#123; combineReducers &#125; from &apos;redux&apos;;import &#123; reducer as test &#125; from &apos;../Home/store&apos;;const appReducer = combineReducers(&#123; test,&#125;);const rootReducer =(state, action) =&gt; &#123; return appReducer(state, action);&#125;export default rootReducer; test是一个测试的reducer。 在入口处，绑定store，在入口文件中：1234567891011121314151617181920AppRegistry.registerComponent(&apos;projectName&apos;, () =&gt; Root);// 指向了root.js，在root.js中：import &#123; Provider &#125; from &apos;react-redux&apos;;import configStore from &apos;./store/configStore&apos;;const store = configStore();export default class Root extends React.PureComponent &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &#123;...&#125; &lt;/View&gt; &lt;/Provider&gt; ) &#125;&#125; 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142// actionType.jsexport const TEST_REDUCE = &quot;TEST_REDUCE&quot;;// test action.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const test =() =&gt; (&#123; type: TEST_REDUCE,&#125;)export &#123; test,&#125;// test reducer.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const initState = &#123; num: 0,&#125;export default reducer = (state = initState, action) =&gt; &#123; switch(action.type) &#123; case TEST_REDUCE: return &#123; ...state, num: state.num + 1, &#125; default: return &#123; ...initState, &#125; &#125;&#125; 在组件component中使用Test.js 123456789101112131415161718192021222324252627282930313233343536373839import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; action &#125; from &apos;./store&apos;class Test extends Component &#123; testFunction =() =&gt; &#123; this.props.action.test(); &#125; render() &#123; const &#123; num &#125; = this.props; return ( &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;this.testFunction&#125; &gt; &lt;Text&gt; 触发按钮 &lt;/Text&gt; &lt;Text&gt;&#123;num&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; (&#123; num: state.test.num,&#125;)const mapActionToProps = dispatch =&gt; &#123; return &#123; action: bindActionCreators(action, dispatch), &#125;&#125;export default connect(mapStateToProps, mapActionToProps)(Test); 具体的使用方法已在上面，下面再去讲解redux原理 redux原理说明redux状态管理大致流程： component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render reducer中数据改变即store中数据改变为何会导致 component props改变呢？其实就是connect函数。 我们在组件中，export default connect(mapStateToProps, mapActionToProps)(Test);connet是一个柯里化函数。第一组入参两个：第一个mapStateToProps，其实就是将store中的数据绑定到props，第二个mapActionToProps，是将action函数绑定到props，所以我们在使用是，如取store中的值，const { num } = this.props;dispatch action：this.props.action.test(); 第二组入参：当前的Test对象。 再往深考虑connect 函数","categories":[],"tags":[{"name":"react","slug":"react","permalink":"hexo/tags/react/"}]},{"title":"android sqlite的使用","slug":"android-sqlite的使用","date":"2019-11-19T06:01:11.000Z","updated":"2019-11-21T03:43:42.735Z","comments":true,"path":"blog/2019/11/android-sqlite的使用.html","link":"","permalink":"hexo/blog/2019/11/android-sqlite的使用.html","excerpt":"","text":"android sqlite的使用1、创建表a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法 onCreate（SQLiteDatabase）在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。 onUpgrade（SQLiteDatabase，int，int）当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。 onOpen（SQLiteDatabase）这是当打开数据库时的回调函数，一般在程序中不是很常使用。 在构造函数中创建数据库12345678910// 数据表名 private static final String TABLE_NAME = &quot;userlog.db&quot;; public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public MyDatabase(Context context, int version) &#123; this(context, TABLE_NAME, null, version); &#125; 在onCreate方法中创建数据表数据库数据类型：NULL：null值INTEGER：整数，1、2、3、4、6、8字节REAL：浮点值，8字节TEXT：字符串BLOB：blob数据DATE：日期 年月日TIME：时刻 时分秒 1234567@Override public void onCreate(SQLiteDatabase db) &#123; Log.d(TAG, &quot;onCreate: onCreate&quot;); String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;; db.execSQL(sql); &#125; 然后在需要建表的实话，初始化一个该java类实例即可 增删改查增加 insert 一条数据1、使用sql语句插入一条数据12String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;db.execSQL(sql); 但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’ 此时应该使用 ? 替代符，如下：1234567891011public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123; SQLiteDatabase db = getWritableDatabase(); StringBuilder sql = new StringBuilder(); sql.append(&quot;insert into &quot;) .append(table_name) .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;); Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;; Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString()))); db.execSQL(sql.toString(), values); db.close();&#125;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"ValueAnimator","slug":"ValueAnimator","date":"2019-10-22T08:48:04.000Z","updated":"2019-10-22T08:48:33.038Z","comments":true,"path":"blog/2019/10/ValueAnimator.html","link":"","permalink":"hexo/blog/2019/10/ValueAnimator.html","excerpt":"","text":"属性动画 ValueAnimator","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"canvas 中的方法","slug":"canvas-中的方法","date":"2019-10-22T08:09:46.000Z","updated":"2020-09-04T01:11:22.578Z","comments":true,"path":"blog/2019/10/canvas-中的方法.html","link":"","permalink":"hexo/blog/2019/10/canvas-中的方法.html","excerpt":"","text":"canvas 中的一些方法在canvas中一般使用的方法为drawXXX(): 绘制的方法clipXXX(): 裁剪的方法 clipRect裁剪画布，clipRect(int left, top, right, bottom);clipRectF(float left, top, right, bottom) 当执行了该方法，如clipRect(0,0,500,500);则后面都只能在(0,0,500,500)区域绘制 用Rect实现多区域裁剪intersect 交集】12345678Rect rect = new Rect(0, 0, 500, 500); rect.intersect(250, 250, 750, 750); canvas.clipRect(rect);// 取到区域(250, 250, 500, 500) 绘制多个区域相交的区域 union 合集12345678Rect rect = new Rect(0, 0, 500, 500); rect.union(250, 250, 750, 750); canvas.clipRect(rect);// 取到的区域为(0, 0, 750, 750) 绘制多个区域之和 clipPath 取出某个区域12345678910111213// 实例化路径mPath = new Path();// 移动起点至[50,50]mPath.moveTo(50, 50); mPath.lineTo(75, 23); mPath.lineTo(150, 100); mPath.lineTo(80, 110); // 闭合路径mPath.close();// 按照路径进行裁剪canvas.clipPath(mPath); 即是将path区域裁剪出来同样后面在能在该path区域绘制图形 Region.Opcanvas.drawRect","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"hashMap解析","slug":"hashMap解析","date":"2019-09-03T06:01:51.000Z","updated":"2021-01-19T10:07:45.096Z","comments":true,"path":"blog/2019/09/hashMap解析.html","link":"","permalink":"hexo/blog/2019/09/hashMap解析.html","excerpt":"","text":"HashMap源码分析Hash内部类Node：Node(节点)，链表中的节点，当HashMap数据少于6条时，为链表结构，Node为其中的节点。链表数据结构，每一个节点都记录下一个节点的地址。在Node的构造函数中，直接包含了下一个节点，1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; // 将下一个节点作为入参放入构造函数中 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; .... 获取某个节点12345678910111213141516171819202122232425262728293031 public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 当为树结构的时候 if (first instanceof TreeNode) // 获取树形结构中某个节点 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 遍历链表结构 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; HashMap底部是数组，数组中存放链表，当链表长度大于6时，转为红黑树 put：初始化table[],使用时再初始化，避免内存。 根据k获取hash，hash &amp; length 获取 index，放入数组指定下标的链表，头插法, 链表超长6时，转为红黑树 jdk1.7及以前采用的头插法，在jdk1.8及以后，为避免死锁，采用尾插法。 hash &amp; length 使用位运算符，因为位运算符快，cpu指令就是基于位运算符， 扩容：hashmap的初识容量是16，每次扩容 * 2， 为何容量取 2的次方，因为这样在位运算时，让每一位都能使用到，效率最高，而且这样保证位运算结果与取模结果一致。 加载因子：默认0.75，因为大量测试表面。0。6-0.75最佳，0.75保证在该范围内存使用率最高。加载因子过大时，会让hash碰撞概率增加，降低hashmap使用效率。 hashmap使用缺点：内存使用率最高也只有75%， hash碰撞，极端情况退化为单链表。用空间换时间。 可以使用其他数据类型替代：SparseArray： 双数组结构，key，value分别使用数组存储， 但SparseArray的key只能为int，有序，通过二分查找来定位元素。用时间换空间。缺点： key值只能是int类型 ArrayMap：sdk 19引入，双数组结果，key值可以为任何类型，根据key获取hash，就和SparseArray类型一致了。Bundle内部就是使用ArrayMap","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"升级rn版本适配android64","slug":"升级rn版本适配android64","date":"2019-08-21T01:31:14.000Z","updated":"2019-08-21T01:38:46.589Z","comments":true,"path":"blog/2019/08/升级rn版本适配android64.html","link":"","permalink":"hexo/blog/2019/08/升级rn版本适配android64.html","excerpt":"","text":"google play在2019/08/01起实施强制支持64位手机的措施。 因为之前的version为0.55.4,到0.59.1版本更新太多，采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目","categories":[],"tags":[{"name":"react-native","slug":"react-native","permalink":"hexo/tags/react-native/"}]},{"title":"Rxjava + Retrofit 实现BaseResult","slug":"Rxjava-Retrofit-实现BaseResult","date":"2019-07-25T03:24:56.000Z","updated":"2019-07-25T03:25:23.897Z","comments":true,"path":"blog/2019/07/Rxjava-Retrofit-实现BaseResult.html","link":"","permalink":"hexo/blog/2019/07/Rxjava-Retrofit-实现BaseResult.html","excerpt":"","text":"Rxjava + Retrofit 实现BaseResult最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。答案肯定是可以的。本文只讲使用。 依赖：12345implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos; 普通使用案例首先创建实体数据类Test 1234567891011121314public class Test &#123; private static final String TAG = &quot;=====TEST&quot;; String key = &quot;&quot;; String test = &quot;&quot;; public void log() &#123; Log.d(TAG,&quot;key=&quot; + key); Log.d(TAG, &quot;test=&quot; + test); &#125;&#125; 在写一个接口TestServer，申明请求 1234public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用请求1234567891011121314151617181920212223242526272829303132private void testService() &#123; // 实例化一个Retrofit 对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.1.42:8080/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); TestServer service = retrofit.create(TestService.class); service.getObJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Test&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Test test) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125; 开发考虑我们不可能每个请求都重新创建一个Retrofit对象，而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。 1、写一个result实体类1234567891011121314151617181920212223242526272829303132// 因为每一个接口返回的数据结构都不同，肯定要用泛型。public class Result&lt;T&gt; &#123; private final String TAG = &quot;Result ====&quot;; private String msg; private String code = &quot;0&quot;; private T data; public void logCode() &#123; Log.d(TAG, code); &#125; public long getLongCode() &#123; long resultCode = 0; if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123; resultCode = Long.parseLong(code); &#125; return resultCode; &#125; public void log() &#123; Log.d(TAG, &quot;msg:&quot; +msg + &quot;\\n code:&quot; + code + &quot;\\n data:&quot; + data); &#125; public T getResultData() &#123; return data; &#125;&#125; 注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论 然后需要写一个BaseObserver观察者基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里还是因为接口返回数据格式问题，使用泛型。public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123; private final String TAG = &quot;====BaseObserver===&quot;; /** * 请求成功 * @param t */ public abstract void onSuccess(T t); /** * 当返回的code值错误时的默认方法 * @param code */ public void onResultCodeErr(long code) &#123; Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code); &#125; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(Result result) &#123; if(result.getLongCode() != 200) &#123; onResultCodeErr(result.getLongCode()); &#125; else &#123; onSuccess((T)result.getResultData()); &#125; result.log(); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); Log.d(TAG, e.getMessage()); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125;&#125; 然后我们的Server类就变成了如下：123456789public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson(); @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用就变成了这样： 1234567891011121314151617BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123; @Override public void onSuccess(Test test) &#123; Log.d(&quot;======&quot;, &quot;onSuccess&quot;); test.log(); &#125; &#125;; /** Retrofit + Rxjav */ private void testRxjavaService() &#123; Retrofit retrofit = RetrofitUtil.getRetrofit(); TestService ts = retrofit.create(TestService.class); ts.getTestRxjavaJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Flutter入门（三）布局组件","slug":"Flutter入门（三）布局组件","date":"2019-07-25T03:00:09.000Z","updated":"2019-07-25T03:10:55.549Z","comments":true,"path":"blog/2019/07/Flutter入门（三）布局组件.html","link":"","permalink":"hexo/blog/2019/07/Flutter入门（三）布局组件.html","excerpt":"","text":"Flutter入门（三）布局组件之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！ 查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍 ui组件学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。 Text123456789101112131415Text( &apos;要显示的文本&apos;, &#123; textAlign: TextAlign.center, // 文本横向对齐方式 居中 overflow: TextOverflow.ellipsis, // 文本溢出处理方式 textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left) softWrap: true, // 是否自动换行 textScaleFactor: 2.0, // 字体显示倍率 maxLines: 1, // 文本最大行数 style: new TextStyle( color: Colors.purple, fontSize: 20.0, ), // 文本样式 &#125;)","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"flutter入门  vscode调试及查看日志","slug":"flutter入门-vscode调试及查看日志","date":"2019-07-25T02:55:36.000Z","updated":"2019-07-25T03:12:04.381Z","comments":true,"path":"blog/2019/07/flutter入门-vscode调试及查看日志.html","link":"","permalink":"hexo/blog/2019/07/flutter入门-vscode调试及查看日志.html","excerpt":"","text":"flutter入门 vscode调试及查看日志开发肯定需要调试应用，以及查看日志。 在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。 还有一个print()函数，最终发现这个是可以的。 情景再现a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。 b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出 c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出 正确方法print()日志输出函数通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出 ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。 用vscode调试flutetr一个正常的flutter项目用vscode应该是这样的。之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。 点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目 我打了一个断点，当项目运行起来，如下图。 当我点击按钮，进入断点。如下图可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。 添加断点点击代码左侧的红框区域即可（下图）。 在左上角的调试/新建断点 也可以。","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"Flutter入门（二） 使用vscode编写第一个Flutter应用","slug":"Flutter入门（二）-使用vscode编写第一个Flutter应用","date":"2019-07-25T02:51:37.000Z","updated":"2019-07-25T03:12:34.757Z","comments":true,"path":"blog/2019/07/Flutter入门（二）-使用vscode编写第一个Flutter应用.html","link":"","permalink":"hexo/blog/2019/07/Flutter入门（二）-使用vscode编写第一个Flutter应用.html","excerpt":"","text":"Flutter入门（二） 使用vscode编写第一个Flutter应用在上一篇中我们利用android studio运行了一个hello word项目。作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。 ###1、配置插件需要在vscode中下载插件找到这两个插件下载好并重新加载vscode就可以了。 ###2、运行flutter项目的运行命令是 flutter run但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。 在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。还有有一些提示信息 当你需要热加载的时候按 r，需要重启应用按R。所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。 ###3、写第一个flutter应用。按照flutter中文网（https://flutterchina.club/get-started/codelab/）写我们第一个flutter应用。其中我个人碰到一个问题。就是在第2步、使用外部package中， 在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。然后重新打开vscode才好，应该是vscode对这个以来的读取问题。 然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。 ###个人体会 flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼 fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。没有对state这个做解释、没有state的使用说明，然后那个路由也是。 ##待续","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"Flutter入门（一）环境配置","slug":"Flutter入门（一）环境配置","date":"2019-07-25T02:41:53.000Z","updated":"2019-07-25T03:12:56.177Z","comments":true,"path":"blog/2019/07/Flutter入门（一）环境配置.html","link":"","permalink":"hexo/blog/2019/07/Flutter入门（一）环境配置.html","excerpt":"","text":"Flutter入门（一）环境配置在/flutter/bin目录下执行 flutter doctor命令。 3、android studio插件下载android studio就不说了，打开android studio/file/setting/plugin/输入 flutter查找并install。第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。 在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project hello word按照惯例，接下来我们跑一个hello world。 照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。 项目目录 项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。 运行点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行 第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"flutter数据持久化","slug":"flutter数据持久化","date":"2019-07-25T02:40:34.000Z","updated":"2019-07-25T02:40:56.389Z","comments":true,"path":"blog/2019/07/flutter数据持久化.html","link":"","permalink":"hexo/blog/2019/07/flutter数据持久化.html","excerpt":"","text":"flutter数据持久化shared_preferences本地存储临时数据此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。 添加插件依赖： 123456// 在pubspec.yaml文件中添加依赖dependencies: flutter: sdk: flutter shared_preferences: &quot;&lt;newest version&gt;&quot; 调用： shared_preference 存储方式是根据key-value形式使用便捷，但有限制： a: 只能使用原始类型: int，double，bool，string 和 string list。 b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。 1234567891011import &apos;package:shared_preferences/shared_preferences.dart&apos;;getAsyncData() async &#123; // 获取实例 var prefs = await SharedPreferences.getInstance(); // 获取存储数据 var count = prefs.getInt(&apos;count&apos;) ?? 0 + 1; // 设置存储数据 await prefs.setInt(&apos;count&apos;, count);&#125;","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"dart语言语法糖","slug":"dart语言语法糖","date":"2019-07-25T02:35:05.000Z","updated":"2019-07-25T02:35:29.306Z","comments":true,"path":"blog/2019/07/dart语言语法糖.html","link":"","permalink":"hexo/blog/2019/07/dart语言语法糖.html","excerpt":"","text":"dart语言语法糖a、 以 _命名的变量或函数为强制私有 var _num; b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式 1234int getInt() =&gt; 2;int getInt() =&gt; isTrue ? 2 : 0; c、 运算符 aa ?? bb; ?? 为null 时 d、异步 async await then async、await使用与rn中使用方式一致 .then也是异步操作 12345678910111213141516171819202122232425/// 设置需要填写的内容 _setDefaultData(List&lt;dynamic&gt; list) &#123; Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;); List&lt;dynamic&gt; list1 = []; /// 对jsonStr数据做解析 jsonStr.then((value) &#123; var data = json.decode(value); if(list != null || list.length &gt; 0) &#123; data = list; &#125; print(&apos;data ====&apos; + data.toString()); data.forEach((item) &#123; if(item[&apos;type&apos;] == &apos;1&apos;) &#123; list1.add(item); &#125; &#125;); &#125;); print(&apos;list1======&apos; + list1.toString()); this.setState(() &#123; this.saveList = list1; &#125;); &#125; 如图这种代码会先输出list1的信息，然后在输出data的信息说明jsonStr.then 为异步操作","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"flutter android端 原理解析","slug":"flutter-android端-原理解析","date":"2019-07-25T02:32:54.000Z","updated":"2019-07-25T02:33:34.203Z","comments":true,"path":"blog/2019/07/flutter-android端-原理解析.html","link":"","permalink":"hexo/blog/2019/07/flutter-android端-原理解析.html","excerpt":"","text":"flutter android端 原理解析首先看MainActivity， 继承FlutterActivity 再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory 12345678910111213141516private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);private final FlutterActivityEvents eventDelegate;private final Provider viewProvider;private final PluginRegistry pluginRegistry;public FlutterActivity() &#123; this.eventDelegate = this.delegate; this.viewProvider = this.delegate; this.pluginRegistry = this.delegate;&#125;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.eventDelegate.onCreate(savedInstanceState);&#125; 一看delegate就知道代理模式 在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值， FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。 FlutterActivityDelegate 就是FlutterActivityEvents类的实现. 看FlutterActivityDelegate类中的onCreate函数 123456789101112131415161718192021222324252627282930public void onCreate(Bundle savedInstanceState) &#123; if (VERSION.SDK_INT &gt;= 21) &#123; Window window = this.activity.getWindow(); window.addFlags(-2147483648); window.setStatusBarColor(1073741824); window.getDecorView().setSystemUiVisibility(1280); &#125; String[] args = getArgsFromIntent(this.activity.getIntent()); FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args); this.flutterView = this.viewFactory.createFlutterView(this.activity); if (this.flutterView == null) &#123; FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView(); this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView); this.flutterView.setLayoutParams(matchParent); this.activity.setContentView(this.flutterView); this.launchView = this.createLaunchView(); if (this.launchView != null) &#123; this.addLaunchView(); &#125; &#125; if (!this.loadIntent(this.activity.getIntent())) &#123; String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext()); if (appBundlePath != null) &#123; this.runBundle(appBundlePath); &#125; &#125; &#125; 首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。 android端与dart端通信1、dart端调用android端代码1、原生android代码新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。 重写onMethodCall方法，在此处写需要实现的逻辑代码 最后是将插件绑定。 12345678910111213141516171819202122232425262728293031323334public class TestPlugin implements MethodChannel.MethodCallHandler &#123; public static final String CHANNEL = &quot;plugin/test&quot;; static MethodChannel channel; // 上下文 private Activity activity; private TestPlugin(Activity activity) &#123; this.activity = activity; &#125; public static void registerWith(PluginRegistry.Registrar registrar) &#123; channel = new MethodChannel(registrar.messenger(), CHANNEL); TestPlugin plugin = new TestPlugin(registrar.activity()); // 在此通道上接受方法调用的回调 channel.setMethodCallHandler(plugin); &#125; @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123; if(methodCall.method.equals(&quot;test&quot;)) &#123; Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show(); result.success(&quot;调用成功&quot;); &#125; // 当未找到该函数 result.notImplemented(); &#125;&#125; 在MainActivity中绑定 1234567891011121314151617public class MainActivity extends FlutterActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); registerPlugin(this); &#125; private void registerPlugin(PluginRegistry registry) &#123; TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL)); &#125;&#125; 2、在dart中调用该原生方法1234567static const _platform = const MethodChannel(&apos;plugin/test&apos;);_toast() &#123; /// 调用原生的方法 _platform.invokeMethod(&apos;test&apos;); &#125; 一个原生插件调用就完成了。","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"facebook推广api 推广主页","slug":"facebook推广api-推广主页","date":"2019-07-11T02:58:31.000Z","updated":"2019-07-11T03:01:09.159Z","comments":true,"path":"blog/2019/07/facebook推广api-推广主页.html","link":"","permalink":"hexo/blog/2019/07/facebook推广api-推广主页.html","excerpt":"","text":"主页推广","categories":[],"tags":[]},{"title":"maven","slug":"maven","date":"2019-07-08T06:36:59.000Z","updated":"2020-05-13T07:54:35.649Z","comments":true,"path":"blog/2019/07/maven.html","link":"","permalink":"hexo/blog/2019/07/maven.html","excerpt":"","text":"mavenmaven 查看依赖树mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXXcode xxx // 打开xxx文件 // gradle 查看依赖树gradle app:dependency // 查看依赖树关系","categories":[],"tags":[]},{"title":"react发布到javaweb","slug":"react发布到javaweb","date":"2019-07-05T06:29:35.000Z","updated":"2019-07-05T09:33:42.061Z","comments":true,"path":"blog/2019/07/react发布到javaweb.html","link":"","permalink":"hexo/blog/2019/07/react发布到javaweb.html","excerpt":"","text":"react项目发布到javaweb中1、打包react直接执行npm run build命令：发现在build目录下生成资源文件，但是打开index.html发现报错，发现在生成的index.html中引入的文件路径有问题：/static /多余，或者说少了. 正确的路径应该是：static 或者 ./static 发现是%PUBLIC_URL%问题，在构建时应该执行 PUBLIC_URL=./ npm run build 2、集成到javaweb中将上一步生成build目录下的文件都复制放在webapp路径下，启动应用就能直接访问到index.html文件","categories":[],"tags":[{"name":"react+spring","slug":"react-spring","permalink":"hexo/tags/react-spring/"}]},{"title":"facebook 营销api集成","slug":"facebook-营销api集成","date":"2019-06-28T02:15:25.000Z","updated":"2019-07-11T03:08:15.587Z","comments":true,"path":"blog/2019/06/facebook-营销api集成.html","link":"","permalink":"hexo/blog/2019/06/facebook-营销api集成.html","excerpt":"","text":"facebook 营销api集成营销api需要通过后端服务器与facebook服务器交互 1、下载营销api java代码git clone https://github.com/facebook/facebook-java-business-sdk.git 编辑器：IDEA 123456789101112// 在pom.xml中添加依赖&lt;dependency&gt; &lt;groupId&gt;com.facebook.business.sdk&lt;/groupId&gt; &lt;artifactId&gt;facebook-java-business-sdk&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;插件maven-source-plugin 无法下载因缺失版本号添加&lt;version&gt;3.1.0&lt;/version&gt;// 解决idea报错在&lt;build&gt;&lt;/build&gt;标签内添加&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;在&lt;plugins&gt;&lt;/plugins&gt;标签外套一个标签&lt;pluginManagement&gt;&lt;/pluginManagement&gt; 添加java文件123456789101112131415161718192021222324252627282930import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;import com.facebook.ads.sdk.APIException;public class QuickStartExample &#123; public static final String ACCESS_TOKEN = &quot;[Your access token]&quot;;//Your access token public static final Long ACCOUNT_ID = 123456789L; //Your account ID public static final String APP_SECRET = &quot;[Your app secret]&quot;;//Your app secret public static final APIContext context = new APIContext(ACCESS_TOKEN, APP_SECRET); public static void main(String[] args) &#123; try &#123; System.out.println(&quot;==========&quot;); AdAccount account = new AdAccount(ACCOUNT_ID, context); Campaign campaign = account.createCampaign() .setName(&quot;Java SDK Test Campaign&quot;) .setObjective(Campaign.EnumObjective.VALUE_LINK_CLICKS) .setSpendCap(10000L) .setStatus(Campaign.EnumStatus.VALUE_PAUSED) .execute(); System.out.println(campaign.fetch()); &#125; catch (APIException e) &#123; e.printStackTrace(); &#125; &#125;&#125; or 123456789101112131415161718192021222324import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.APINodeList;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;public class TestFBJavaSDK&#123; public static final APIContext context = new APIContext( &quot;your-access-token&quot;, &quot;your-appsecret&quot; ); public static void main(String[] args) &#123; AdAccount account = new AdAccount(&quot;act_&#123;your-adaccount-id&#125;&quot;, context); try &#123; APINodeList&lt;Campaign&gt; campaigns = account.getCampaigns().requestAllFields().execute(); for(Campaign campaign : campaigns) &#123; System.out.println(campaign.getFieldName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行java文件既可发布请求到facebook服务器， 需要安全上网 1、主页推广根据提示一步一步提交，到 沙盒账号，如果之前没有添加则新建，要推广的主页，如果无则新建 到下载示例代码，点下载，将会获得一个java文件，里面含有accessToken、appid、ad_account_id、app_secret等信息，将该下载的SAMPLE_CODE.java文件放于与上面两个java文件同级目录，直接运行该java文件即可，注意此时电脑需要科学上网，不然会报错Timeout","categories":[],"tags":[{"name":"facebook","slug":"facebook","permalink":"hexo/tags/facebook/"}]},{"title":"facebook sdk 集成","slug":"facebook-sdk-集成","date":"2019-06-26T08:52:30.000Z","updated":"2019-12-10T10:14:02.050Z","comments":true,"path":"blog/2019/06/facebook-sdk-集成.html","link":"","permalink":"hexo/blog/2019/06/facebook-sdk-集成.html","excerpt":"","text":"Facebook sdk 集成首先需要在facebook注册一个账号，自通过账号进入facebook的开发者平台 创建应用，只需要填写应用名即可，回生成一个appid。 集成事件功能1、配置远端maven仓库地址 在项目android/build.gradle文件123456789101112131415buildscript&#123; repositories&#123; ... mavenCentral(); // 添加这行 &#125;&#125;allprojects&#123; repositories &#123; ... mavenCentral() // 添加这行 &#125;&#125; 2、添加依赖在app/build.gradle文件中添加依赖123456dependencies&#123; ... implementation &apos;com.facebook.android:facebook-android-sdk:[4,5)&apos; // 添加这行 // 最新sdk版本为 implementation &apos;com.facebook.android:facebook-android-sdk:[5,6)&apos; &#125; 3、添加facebook-app-id在res/values/string.xml中1234&lt;string name=&quot;facebook_app_id&quot;&gt;462119014332748&lt;/string&gt; &lt;string name=&quot;fb_login_protocol_scheme&quot;&gt;fb462119014332748&lt;/string&gt;// 462119014332748为你在facebook应用的appid// fb_login_protocol_scheme应该是用于登陆的 在/app/manifest/AndroidManifest.xml中12345678910111213141516&lt;application&gt; &lt;meta-data android:name=&quot;com.facebook.sdk.ApplicationId&quot; android:value=&quot;@string/facebook_app_id&quot;/&gt; &lt;activity android:name=&quot;com.facebook.FacebookActivity&quot; android:configChanges= &quot;keyboard|keyboardHidden|screenLayout|screenSize|orientation&quot; android:label=&quot;@string/app_name&quot; /&gt; &lt;activity android:name=&quot;com.facebook.CustomTabActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;@string/fb_login_protocol_scheme&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 4、在facebook开发者控制台配置analytics sdk在facebook开发者官网，点击「我的应用」即可进入应用控制台，可以创建应用，只需提供应用名，以及邮箱即可， 点击单个应用即可进入应用控制台进行编辑;上图是应用可添加的功能， 点击Analytics即将功能添加进应用，点设置，前几步都是提示，第四步，填入应用id，app/build.gradle中的applicationid，以及应用默认启动的Actiivty， 第五步，填入密钥散列，注意应该要填入两个，一个开发、一个发布，即debug自带的、一个release时通过jks文件签名生成的。获取方法12345// macos debug ，按下enter键需要输入开机密码keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64// release keytool -exportcert -alias YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl base64 5、发送事件 上面的1、2、3都只是基本配置，下面是手动发送事件 在MainApplication.java中FacebookSdk.sdkInitialize 四个初始化方法都已被遗弃， 看到说是不需要初始化了 在MainApplication.java中 12345678910@Override public void onCreate() &#123; super.onCreate(); // facebook 初始化 FacebookSdk.setIsDebugEnabled(true); AppEventsLogger.activateApp(MainApplication.this); FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS); &#125; 注意facebooksdk回自动收集一些事件,如果不需要自动收集功能需要在清单文件中配置 1234&lt;meta-data android:name=&quot;com.facebook.sdk.AutoLogAppEventsEnabled&quot; android:value=&quot;false&quot;/&gt; 在Actiivty中测试发送自定义事件 123456789101112@Overrideprotected void onResume() &#123; super.onResume(); logEvent();&#125;private void logEvent() &#123; Log.d(&quot;========&quot;, &quot;logEvent&quot;); AppEventsLogger logger = AppEventsLogger.newLogger(this); logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP); logger.logEvent(&quot;Test Event&quot;);&#125; 在测试时发现，当打断点调试时发现，发送事件总是会失败，正常运行却可以在facebook分析工具中看得到提交的事件。 后续：在sdk集成后，可以看到之前定义的事件数据。但是在连接商务平台，想要发布广告时。需要通过自己的事件来定义受众、或者定义类似受众时发现，在商务平台无法获取到自定义事件的数据。甚至都无法获取到我们的应用。后来看官方文档，发现出了自定义事件、自动收集的事件，还有一个标准事件。在我添加了一个标准事件后，就在商务平台上能找到在开发平台提交的app了。但是那些自定义受众、类似受众功能貌似只能绑定到 facebook定义的标准事件，而不能是我们自己的自定义事件 注意，运行时手机需要能连接到facebook后台服务器，大陆用户需要科学上网。","categories":[],"tags":[{"name":"facebook","slug":"facebook","permalink":"hexo/tags/facebook/"}]},{"title":"android okHttp3","slug":"android-okHttp3","date":"2019-06-18T02:52:40.000Z","updated":"2021-01-12T06:33:22.746Z","comments":true,"path":"blog/2019/06/android-okHttp3.html","link":"","permalink":"hexo/blog/2019/06/android-okHttp3.html","excerpt":"","text":"OkHttp3使用添加依赖，在app/build.gradle中添加依赖1implementation &apos;com.squareup.okhttp3:okhttp:3.10.0&apos; get一个普通的get请求 1234567891011121314151617181920212223242526private void get() &#123; OkHttpClient client = new OkHttpClient.Builder().build(); Request request = new Request.Builder() .addHeader(&quot;header_key&quot;, &quot;header_value&quot;) .url(&quot;https://www.baidu.com&quot;) .get() .build(); try &#123; // 同步执行 client.newCall(request).execute(); // 异步执行 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(TAG, &quot;onFailure: &quot; + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(TAG, &quot;onResponse: &quot; + response.body().string()); &#125; &#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; post12345678910111213141516171819202122232425262728293031private void post() &#123; OkHttpClient client = new OkHttpClient.Builder().build(); RequestBody body = new FormBody.Builder() .add(&quot;content&quot;, &quot;content&quot;) .build(); Request request = new Request.Builder() .addHeader(&quot;header_key&quot;, &quot;header_value&quot;) .post(body) .url(&quot;https://www.baidu.com&quot;) .build(); try &#123; // 同步执行 client.newCall(request).execute(); // 异步执行 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(TAG, &quot;onResponse: &quot; + response.body().string()); &#125; &#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 上面就是一个简单的post与get请求，区别就是post会多一个RequestBody 而关于okhttp的使用还有很多其他的用户，如自定义分发器Dispatch、拦截器、缓存","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"vscode的常用插件与插件开发","slug":"vscode的常用插件与插件开发","date":"2019-04-28T07:06:57.000Z","updated":"2019-04-28T07:43:46.000Z","comments":true,"path":"blog/2019/04/vscode的常用插件与插件开发.html","link":"","permalink":"hexo/blog/2019/04/vscode的常用插件与插件开发.html","excerpt":"Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。","text":"Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。 nodejs123456curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash. ~/.bashrc#显示有远端的版本nvm ls-remote#安装对应的版本nvm install 对应的版本 安装常用工具： 1234567891011npm install hexo-cli -gnpm install hexo-server -gnpm install hexo-deployer-git -gnpm install yarn -gnpm install http-server -gyarn global add servenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalyarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 常用插件安装以下插件：12345678910111213141516171819202122232425262728293031323334#javascripteslintColor PickernpmDebugger for ChromeEclipse Keymap#reactES7 React/Redux/GraphQL/React-Native snippets#vueVeturVue VSCode Snippets#gitGitLenszerofinance-git#其他公共插件Local HistoryXML ToolsPrettier#https://zhuanlan.zhihu.com/p/54031899koroFileHeaderAutoFileNameImport Cost#javaJava Extension PackSpring Boot Extension PackJava Code GeneratorsDocker#android/ios pluginAndroid iOS EmulatorReact Native Tools#see debug:https://github.com/Microsoft/vscode-react-native/blob/master/doc/debugging.md#debugging-on-ios-device#Install ios-deploy: npm install -g ios-deploy 代码注释koroFileHeader添加注释，在全局的settings.json中添加： 参考： https://code.visualstudio.com/docs/editor/emmet https://www.cnblogs.com/summit7ca/p/6944215.html 12345678910111213141516171819202122232425262728\"editor.fontSize\": 14,\"terminal.integrated.fontSize\": 14,\"emmet.triggerExpansionOnTab\": true,\"emmet.includeLanguages\": &#123; \"javascript\": \"javascriptreact\", \"vue-html\": \"html\", \"razor\": \"html\", \"plaintext\": \"jade\"&#125;,// 注释\"fileheader.configObj\": &#123; // 将该选项设置为true即可开启 \"autoAdd\": false&#125;,// 头部注释\"fileheader.customMade\": &#123; \"Author\": \"dave.zhao\", \"Date\": \"Do not edit\", \"LastEditors\": \"dave.zhao\", \"LastEditTime\": \"Do not edit\", \"Description\": \"\"&#125;,// 函数注释\"fileheader.cursorMode\": &#123; \"Date\": \"Do not edit\", \"description\": \"\", \"param\": \"\"&#125; 注意：Author和LastEditors填写自己的名字 文件头注释快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i 函数注释快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t 常用配置可以放在全局的settings.json中，也可以放在各个项目的settings.json中： 1234567891011121314151617181920&#123; \"eslint.validate\": [\"javascript\", \"javascriptreact\"], \"javascript.updateImportsOnFileMove.enabled\": \"always\", // 代码缩进修改成4个空格 \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.formatOnSave\": true, // 每次保存的时候将代码按eslint格式进行修复 \"eslint.autoFixOnSave\": true, // 让prettier使用eslint的代码格式进行校验 \"prettier.eslintIntegration\": true, // 去掉代码结尾的分号 \"prettier.semi\": false, // 使用带引号替代双引号 \"prettier.singleQuote\": true, \"prettier.tabWidth\": 4, \"prettier.printWidth\": 250, // 让函数(名)和后面的括号之间加个空格 \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true&#125; 插件开发参考代码https://github.com/zhaoxunyong/vs-code-git-plugin 参考 https://segmentfault.com/a/1190000008968904 https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://github.com/steveukx/git-js https://www.jianshu.com/p/2b096d8ad9b8 https://github.com/Microsoft/vscode-extension-samples https://www.jianshu.com/p/520c575e91c3 https://segmentfault.com/a/1190000017279102 https://segmentfault.com/a/1190000014758981 https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path","categories":[{"name":"vscode","slug":"vscode","permalink":"hexo/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"hexo/tags/vscode/"}]}]}