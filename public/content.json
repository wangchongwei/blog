{"meta":{"title":"Happy To Try","subtitle":"Plan","description":"Please description","author":"justin","url":"hexo"},"pages":[{"title":"关于","date":"2016-12-25T07:58:56.000Z","updated":"2019-07-05T09:18:33.220Z","comments":false,"path":"about/index.html","permalink":"hexo/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-01-01T06:50:50.000Z","updated":"2019-04-19T02:04:38.000Z","comments":false,"path":"tags/index.html","permalink":"hexo/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-01-01T06:52:00.000Z","updated":"2019-04-19T02:04:38.000Z","comments":false,"path":"categories/index.html","permalink":"hexo/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Fragment的懒加载实现，参数传递与保存","slug":"Fragment的懒加载实现，参数传递与保存","date":"2020-09-28T08:07:59.000Z","updated":"2020-09-28T08:46:16.928Z","comments":true,"path":"blog/2020/09/Fragment的懒加载实现，参数传递与保存.html","link":"","permalink":"hexo/blog/2020/09/Fragment的懒加载实现，参数传递与保存.html","excerpt":"","text":"Fragment懒加载关于Fragment的懒加载，针对ViewPager、ViewPager2又有不同， ViewPager针对ViewPager，其实是使用Fragment中的setUserVisibleHint函数，通过getUserVisibleHint()获取当前的Fragment是否可见，当不可见时，则不加载，当可见时再创建视图并缓存。这样可以只加载一次，大致原理就是如此。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Application生命周期","slug":"Application生命周期","date":"2020-09-28T06:44:45.000Z","updated":"2020-09-28T07:57:42.613Z","comments":true,"path":"blog/2020/09/Application生命周期.html","link":"","permalink":"hexo/blog/2020/09/Application生命周期.html","excerpt":"","text":"ApplicationApplication是指代一个应用，默认我们在android应用中可以不指定，也可以写一个类，继承Application，在AndroidManifest.xml中指定applictaion类即可 Application是应用的入口。 Application的生命周期就是应用的生命周期。 生命周期生命周期函数有：onCreate、onLowMemory、onTrimMemory、onTerminate、onConfigurationChanged 各个生命周期函数解释 onCreate: 应用被创建时调用，是程序的主入口，在此处做一些初始化操作，不要做耗时操作。 onLowMemory： 当系统整体内存可用量较少时触发，可以在这里做一些不重要数据的清除、释放资源，避免因内存不足导致App被系统杀掉 onTrimMemory(int level)： andorid4.0后出的API，用来取代onLowMemory函数的，其中这个函数还有一个入参，来表示等级。 onTerminate： 当Application结束时，又系统决定调用时机。常规手动kill app进程没有触发此函数 onTrimMemory此函数是在android4.0后引入的，能实现的组件不止Application，还有Activity、Fragment、Service、ContentProvider作用是指导应用程序在不同情况下进行自身的内存释放，以避免被系统杀掉，提高用户体验 根据不同的情况，在函数中的提现就是 onTrimMemory函数中的 level这个入参。level有7个值， TRIM_MEMORY_UI_HIDDEN：表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键、Pause键导致应用的UI界面不可见．这时候应该释放一些资源． 当app运行在前台时，会回调下面这三个值，内存余量从高到低排列 TRIM_MEMORY_MODERATE：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。 TRIM_MEMORY_RUNNING_CRITICAL：表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。 TRIM_MEMORY_RUNNING_LOW：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。 当app缓存在后台时，会回调一下三个值，内存余量从高到低排列 TRIM_MEMORY_BACKGROUND：表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。 TRIM_MEMORY_RUNNING_MODERATE： 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。 TRIM_MEMORY_COMPLETE：表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。 onTrimMemory 主要是在考虑内存优化时需要考虑。在此处做数据清除、资源释放","categories":[],"tags":[{"name":"andorid","slug":"andorid","permalink":"hexo/tags/andorid/"}]},{"title":"Activity的启动模式","slug":"Activity的启动模式","date":"2020-09-25T07:59:03.000Z","updated":"2020-09-28T06:32:10.651Z","comments":true,"path":"blog/2020/09/Activity的启动模式.html","link":"","permalink":"hexo/blog/2020/09/Activity的启动模式.html","excerpt":"","text":"Activity启动模式首先，Activity有四大启动模式：standard、singleTask、singleTop、singleInstance 如何设置Activity的启动模式： 静态设置，在AndoridManifest.xml文件中，对Activity设置launchMode 123&lt;activity android:name=&quot;.MainActivity3&quot; android:launchMode=&quot;singleInstance&quot; /&gt; 动态设置，在Activity跳转时，intent设置FLAG 123var intent = Intent(this, MainActivity::class.java);intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)startActivity(intent) 并且注意，同时设置了两种方式时，动态设置会覆盖静态设置 launchModestandardstandard: 标准模式，默认模式，当设置为此模式时，每一次跳入都会重新创建实例 singleTasksingleTask: 栈内复用模式，当设置此模式时，如果栈内没有该Activity就会重新创建，如果已经有了，则会复用栈内已存在的该Activity，而不会重新创建，并会移除之前在栈中处于该Activity上部的所有的Activity。ex：A的启动模式是standard， B的启动模式为singleTask A -&gt; B -&gt; A -&gt; B A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以不会重新创建b的实例，而是复用之前B的实例，同时会调用onNewIntent生命周期函数，而且会销毁之前处于栈顶的A。最后栈内就是： A、B，B位于栈顶 singleTopsingleTop：栈顶复用，与singleTask有部分相似，singleTask是只要在栈内就会复用，而singleTop是只有在栈顶才会复用，如果栈内存在实例，但不处于栈顶，则表现与standard一致，如果站内存在实例，且处于栈顶，则表现与singleTask一致， ex：A的启动模式是standard、B的启动模式是singleTopA -&gt; B -&gt; A -&gt; BA -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，但之前的B不在栈顶，所以会重新创建一个B的实例 singleInstancesingleInstance: 独立运行在一个单独的task中，而且只会存在一个实例在Activity跳转时，注意查看，普通的Activity跳转和Activity Task跳转，两者的动画效果是不同的。 ex: A的启动模式是standard、B的启动模式是singleInstanceA -&gt; B -&gt; A -&gt; BA -&gt; B 时，因为当前Activity栈task A中只有A，会重新创建一个task B并新建一个B的实例放入task BA -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例，并放入到task A中A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以会将task B置顶，最后的栈情况为： A -&gt; A -&gt; B，如下图所示： 我们可以通过指令：adb shell dumpsys activity查看Activity栈中的Activity task情况 通过关键字：ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)即可搜索到上述截图情况","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android生命周期","slug":"android生命周期","date":"2020-09-24T06:29:33.000Z","updated":"2020-09-28T08:02:40.768Z","comments":true,"path":"blog/2020/09/android生命周期.html","link":"","permalink":"hexo/blog/2020/09/android生命周期.html","excerpt":"","text":"准备对andorid基础性的东西都进行整理，梳理一下。 android的生命周期单个Actiivty正常的生命周期 onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory 这就是一个Activity从被创建到被销毁过程。 其中正常运行状态为onResume 当Activity从前台被置于后台，onResume -&gt; onPause -&gt; onStop 当从后台重新置于前台onStop -&gt; onPause -&gt; onResatrt -&gt; onStart-&gt; onResume 其中可以发现，只要Activity置于前台都会执行onStart函数，所以我们可以考虑在这里做一下需要在前台就处理的逻辑 各个生命周期函数：onCreate: Activity被创建，此时Activity处于不可见、不可交互onStart: 此时Activity 部分可见不可交互onRestart: Activity从后台重新回到前台，部分可见不可交互onResume: 完全可见可交互，为Activity正常运行状态onPause: Activity处于暂停，从前台被置于后台 部分可见部分不可见，不可交互onStop: 完全置于后台，完全不可见，onDestroy: Activity被销毁 上面就是一个正常的Activity的生命周期， 屏幕旋转在Activity生命周期中，还设计一些其他：Activity旋转：onCreate -&gt; onStart -&gt; onResume此时被旋转-&gt; onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume 可以发现当Activity被旋转时，整个Activity是被销毁然后重新创建的。其中新增调用了两个生命周期函数onSaveInstanceState: 当Activity被系统异常销毁时被调用，用于存储数据，用于系统恢复Activity时恢复数据onRestoreInstanceState: 当Actiivty被系统异常销毁并重新创建时，取出在onSaveInstanceState时存储的数据 注意，在onCreate函数中，其实也是有参数的12345override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) Log.d(TAG, &quot;onCreate: &quot;) setContentView(R.layout.activity_main) &#125; 此处的savedInstanceState也是在onSaveInstanceState时存储的数据，但此处可能为nll，因为在正常的Activity时，此处就是null，只有在Activity被异常销毁然后被系统重新创建时，此处才有值。如果要在此处使用，切记要判空。 onNewIntentonNewIntent与Activity的启动模式有关 当Activity未设置启动模式时，则不会触发该生命周期函数 当Activity已经处于应用的Activity栈中 如果Actiivty的LaunchMode为Standard时，即默认模式，此时不会触发该生命周期函数。 如果Activity的LaunchMode为SignleTop，如果ActivityA已经处于栈顶，再通过StartActivityForResult调用该Activity，此时会触发的生命周期函数为： onPause -&gt; onNewIntent -&gt; onResume 如果Activity的LainchMode为SingleInstance,SingleTask时，并且ActivityA已经处于Activity栈中，再次通过StartActivityForResult调用该Activity，此时生命周期函数：onNewIntent—&gt;onRestart—&gt;onStart—&gt;onResume onNewIntent只会在Activity设置了启动模式，并且Activity被复用时才会调起。 注意：只对startActivityForResult调起的Activity起作用，statActivity本质调用的也是startActivityForResult，Activity正常的切换前后台时不会触发的。 Activity交互A -&gt; B:A正常运行处于 onResume，打开B A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop点击跳入B页面， 首先A进入暂停，B开始创建，到onResume完全可见可交互，于是A被完全遮挡，变成完全不可见、处于后台，进入onStop A -&gt; B -&gt;goBack-&gt; A 在B页再执行返回 B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B Stop -&gt; B onDestory和A进入B类似，B返回A时，B进入暂停，A变得重新可见到A完全可见，进入onResume，然后B进入停止，并销毁 B启动模式设置为 SingleTop，B -&gt; BB onPause -&gt; B onNewIntent -&gt; B onResume因为 B已经处于栈顶，启动模式为 SingleTop 则不会重新创建B的实例 将A的启动模式设置为SingleTask 可以通过在andorid studio的终端 Terminal中输入：adb shell dumpsys activity查看当前应用的Activity task栈","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"react-native 适配androidX","slug":"react-native-适配androidX","date":"2020-09-15T01:15:50.000Z","updated":"2020-09-16T01:20:26.023Z","comments":true,"path":"blog/2020/09/react-native-适配androidX.html","link":"","permalink":"hexo/blog/2020/09/react-native-适配androidX.html","excerpt":"","text":"androidX在API28后，android新增androidX依赖，用于解决以前的android.support.v*依赖混乱问题。对v1-v9做了合并处理。 然后很多使用的第三方依赖中在新版本都适配了androidX，当你需要使用这些插件的较新版本时，只能去适配androidX。 最近使用react-native-firebase时，被提示必须使用17.0.0+的 Firebase Crashlytics SDK，否则2020年11月15日之后，将不再向firebase发送错误日志。 适配androidX点击andorid studio上方导航栏Refactor/Migrate to AndroidX这时会提示你，gradle tool version 最低3.2.0项目中每一个project的build.gradle都需要修改 classpath(“com.android.tools.build:gradle:3.2.0”)其中3.2.0为最低版本。 注意，选择的版本可能maven仓库找不到。如在第三方插件中，设置的maven仓库可能不存在该版本。如： 我使用的是版本：3.4.0123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.4.0&apos; &#125;&#125; 此时会报错，404，找不到。因为在jcenter远程仓库中不存在该版本。 3.4.0的版本只有google的maven仓库中有，所以需要修改 1234repositories &#123; google() jcenter() &#125; 查看maven插件地址：https://maven.aliyun.com/mvn/search 同时需要修改每个project的targetSdkVersion 将所有project的版本都修改为3.4.0之后，在点即Migrate to AndroidX,此时会提示你需要修改的地方， java文件，去除一些v*的引入 build.gradle 去除一些v*的依赖 manifest.xml 需要修改一些属性，如配置的FileProvider,修改name属性android:name=&quot;androidx.core.content.FileProvider&quot; 修改完后，无报错时直接运行。 会有一些java文件报错，就是引入的之前的v*的包，需要手动修改，哪里报错改哪里。 最后运行，运行成功","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"","slug":"java-反射基本概念与class","date":"2020-09-10T01:26:24.085Z","updated":"2020-09-10T03:51:39.694Z","comments":true,"path":"blog/2020/09/java-反射基本概念与class.html","link":"","permalink":"hexo/blog/2020/09/java-反射基本概念与class.html","excerpt":"","text":"反射 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 * 类名 用途Class类 代表类的实体，在运行的Java应用程序中表示类和接口Field类 代表类的成员变量（成员变量也称为类的属性）Method类 代表类的方法Constructor类 代表类的构造方法 获得类相关的方法方法 用途asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象Cast 把对象转换成代表类或是接口的对象getClassLoader() 获得类的加载器getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象forName(String className) 根据类名返回类的对象getName() 获得类的完整路径名字newInstance() 创建类的实例getPackage() 获得类的包getSimpleName() 获得类的名字getSuperclass() 获得当前类继承的父类的名字getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法方法 用途getField(String name) 获得某个公有的属性对象getFields() 获得所有公有的属性对象getDeclaredField(String name) 获得某个属性对象getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法方法 用途getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象getAnnotations() 返回该类所有的公有注解对象getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法方法 用途getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法getConstructors() 获得该类的所有公有构造方法getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法方法 用途getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法getMethods() 获得该类所有公有的方法getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法getDeclaredMethods() 获得该类所有方法 类中其他重要的方法方法 用途isAnnotation() 如果是注解类型则返回trueisAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回trueisAnonymousClass() 如果是匿名类则返回trueisArray() 如果是一个数组类则返回trueisEnum() 如果是枚举类则返回trueisInstance(Object obj) 如果obj是该类的实例则返回trueisInterface() 如果是接口类则返回trueisLocalClass() 如果是局部类则返回trueisMemberClass() 如果是内部类则返回true Field类Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途equals(Object obj) 属性与obj相等则返回trueget(Object obj) 获得obj中对应的属性值set(Object obj, Object value) 设置obj中对应属性值 Method类Method代表类的方法。 方法 用途invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类Constructor代表类的构造方法。 方法 用途newInstance(Object… initargs) 根据传递的参数创建类的对象","categories":[],"tags":[]},{"title":"kotlin 在android老项目中引入kotlin","slug":"kotlin-在android老项目中引入kotlin","date":"2020-09-09T08:31:56.000Z","updated":"2020-09-09T09:10:39.976Z","comments":true,"path":"blog/2020/09/kotlin-在android老项目中引入kotlin.html","link":"","permalink":"hexo/blog/2020/09/kotlin-在android老项目中引入kotlin.html","excerpt":"","text":"在android项目中引入kotlin修改项目的build.gradle 文件 123456789101112buildscript &#123; ext &#123; kotlin_version = &quot;1.3.10&quot; &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; &#125; ...&#125; 在app/build.gradle中 1234apply plugin: &quot;com.android.application&quot;// 在顶行下添加apply plugin: &apos;kotlin-android&apos;apply plugin: &apos;kotlin-android-extensions&apos; 然后同步一下即可","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"hexo/tags/kotlin/"}]},{"title":"google play 提交要求","slug":"google-play-提交要求","date":"2020-09-09T03:27:05.000Z","updated":"2020-09-09T05:48:13.893Z","comments":true,"path":"blog/2020/09/google-play-提交要求.html","link":"","permalink":"hexo/blog/2020/09/google-play-提交要求.html","excerpt":"","text":"google play 提交要求本文于2020/09/09日起记录在google play提交版本时，google play提出的提交要求 targetSdkVersion在2020/08/05日，提交版本发现多了一个警告 新提交的应用在8月开始，必须设定targetSdkVersion为29或以上，已存在的应用提交新版本时，必须设定targetSdkVersion为29或以上 关于targetSdkVersion的原理targetSdkVersion相当于在编写代码时设定一个假想的运行手机版本，打包后，再运行到真实设备。最终的运行表现取决与targetSdkVersion与真实运行设备版本中的低值。 targetSdkVersion的预设就相当于预设一个代码运行环境，我们所写的代码功能如果是只有部分版本才有的API，我们需要先判断真实的运行版本是否符合。如在android6.0后引入权限请求，在每次请求权限时，我们需要判断SDK版本是否大于等于23. 12345private void request() &#123; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; requestPermissions(new String[]&#123;Manifest.permission.CAMERA&#125;, 101); &#125;&#125; 当然，是否需要判断版本其实和minSdkVersion也是有关的，如上面的代码，因为权限请求是23以后的，如果我们直接将minSdkVersion设置为23，则此时就不需要判断版本了，因为肯定是运行在23之后的手机，因为23以前的手机此时会无法安装该应用。 ex:当我们设定targetSdkVersion=29，即android10，而用户手机为API=23，即android6.0，此时app的表现会是6.0。 当我们设定targetSdkVersion=23，即android6，而用户手机为API=29，即android10，此时app的表现也会是6.0。 64位框架在去年时，google play要求提及的应用必须支持64位的框架，也就是.so文件必须支持64位架构，在提交审核的apk中，有armeabi-v7a则必须也要有arm64-v8a，如果有x86，则必须也要有x86_64。react-native 原本只有armeabi-v7a，在之后的版本0.59.10中就开始内部源码中支持64位含有arm64-v8a下的.so文件","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"git使用","slug":"git使用","date":"2020-09-08T03:11:56.000Z","updated":"2020-09-09T07:58:34.568Z","comments":true,"path":"blog/2020/09/git使用.html","link":"","permalink":"hexo/blog/2020/09/git使用.html","excerpt":"","text":"gitgit是一款分布式代码版本控制工具 初始化使用：当我们在gitlab、github初始化一个项目路径后，需要将本地仓库的代码提交到新建好的远端仓库 12345git initgit remote add origin &lt;remoteurl&gt; // 链接远端仓库 &lt;remoteurl&gt;为远端仓库地址git add .git commit -m &quot;commit info&quot;git push git fetch 拉取代码git merge 合并代码git pull 拉取并合并代码git push 将本地仓库的commit提交到远端仓库 git checkout 切换分支git checkout -b 新建分支并切换 git branch -d 删除分支 不能删除有未提交commit的分支git branch -D 强制删除分支 git push -u origin 将本地分支推送到远端，如果远端没有此分支则会创建 git reset –hard 代码回滚到某个commit commitId可以通过git log查看 git log 可以查看每一个的commit，显示的信息有 commit date，commit person，commitId，commit info git merge A 将A分支合并到当前分支 git rebase A 将A分支合并并且将A分支节点置于当前分支之后 git mv 修改文件名，因为git默认忽略文件大小写，如修改文件名 File.js 到 file.js此时是无法检测到更改，需要使用命令：git mv File.js file.js","categories":[],"tags":[{"name":"git","slug":"git","permalink":"hexo/tags/git/"}]},{"title":"Java内存模型 JMM","slug":"Java内存模型-JMM","date":"2020-09-08T01:41:19.000Z","updated":"2020-09-08T01:42:00.716Z","comments":true,"path":"blog/2020/09/Java内存模型-JMM.html","link":"","permalink":"hexo/blog/2020/09/Java内存模型-JMM.html","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"Lock详解","slug":"Lock详解","date":"2020-09-03T07:26:40.000Z","updated":"2020-09-03T07:26:40.879Z","comments":true,"path":"blog/2020/09/Lock详解.html","link":"","permalink":"hexo/blog/2020/09/Lock详解.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Synchronized详解","slug":"Synchronized详解","date":"2020-09-03T07:26:31.000Z","updated":"2020-09-03T07:26:31.918Z","comments":true,"path":"blog/2020/09/Synchronized详解.html","link":"","permalink":"hexo/blog/2020/09/Synchronized详解.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java 设计模式","slug":"java-设计模式","date":"2020-09-03T07:13:47.000Z","updated":"2020-09-03T07:13:47.169Z","comments":true,"path":"blog/2020/09/java-设计模式.html","link":"","permalink":"hexo/blog/2020/09/java-设计模式.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java IO","slug":"java-IO","date":"2020-09-03T07:13:19.000Z","updated":"2020-09-03T07:13:19.185Z","comments":true,"path":"blog/2020/09/java-IO.html","link":"","permalink":"hexo/blog/2020/09/java-IO.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"动态代理","slug":"动态代理","date":"2020-09-03T07:13:07.000Z","updated":"2020-09-03T07:13:07.579Z","comments":true,"path":"blog/2020/09/动态代理.html","link":"","permalink":"hexo/blog/2020/09/动态代理.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"注解","slug":"注解","date":"2020-09-03T07:12:37.000Z","updated":"2020-09-03T07:12:37.204Z","comments":true,"path":"blog/2020/09/注解.html","link":"","permalink":"hexo/blog/2020/09/注解.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据传输与序列化","slug":"数据传输与序列化","date":"2020-09-03T07:11:44.000Z","updated":"2020-09-11T10:37:25.207Z","comments":true,"path":"blog/2020/09/数据传输与序列化.html","link":"","permalink":"hexo/blog/2020/09/数据传输与序列化.html","excerpt":"","text":"序列化方式 Serializable java自带 Parcelable android中","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"Callback Future","slug":"Callback-Future","date":"2020-09-03T07:08:01.000Z","updated":"2020-09-08T07:43:29.298Z","comments":true,"path":"blog/2020/09/Callback-Future.html","link":"","permalink":"hexo/blog/2020/09/Callback-Future.html","excerpt":"","text":"Future Future代表一个异步计算的结果，并且它提供一些方法来让调用者检测异步过程是否完成，或者取得异步计算的结果，或者取消正在执行的异步任务。 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; private static ExecutorService executorService = Executors.newSingleThreadExecutor(); public static void main(String[]args)&#123; System.out.println(&quot;hello world&quot;); Future&lt;Integer&gt;future = calcute(9); while (!future.isDone())&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;正在执行&quot;); &#125; &#125; try &#123; int result = future.get(); System.out.println(&quot;result = &quot; + result); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static Future&lt;Integer&gt;calcute(Integer i) &#123; return executorService.submit(() -&gt; &#123; Thread.sleep(1000); System.out.println(&quot;return future for &quot; + i); return i *i; &#125;); &#125;&#125; 一个简单Future使用用例写完，使用线程池+Callback+Future，完成了一个简单的计算操作。 Future是一个接口，先看一下内部方法： 1234567891011public interface Future&lt;V&gt; &#123; boolean cancel(boolean var1); boolean isCancelled(); boolean isDone(); V get() throws ExecutionException, InterruptedException; V get(long var1, TimeUnit var3) throws ExecutionException, InterruptedException, TimeoutException;&#125; get()函数是返回计算结果，注意get会同步操作，每天返回结果前，会阻塞线程。get还有一个重载函数get(long var1, TimeUnit var3)，第一个参数是时长，第二个是单位。表示在多少时长内获取结果，如果仍未返回，则抛出异常TimeoutException。12345try&#123; int result2 = future2.get(1000, TimeUnit.MILLISECONDS);&#125; catch(TimeoutException e) &#123; e.printStackTrace();&#125; cancel(boolean) 表示是否取消该future， 不能在调用cancel(true)/cancel(false)后，调用get()函数，否则会抛出异常CancellationException isCancelled()函数是判断该future是否已取消 isDone()函数是判断该future是否已完成 isDone()函数是实时状态读取，不会阻塞线程。 CallbackCallback 是一个接口，内部只有一个函数 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; Callback 可以理解为一个执行任务，如上面例子中的计算 FutureTask介绍Future是一个接口，RunnableFuture也是一个接口，继承Future、Runnable两个接口1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; 而FutureTask是对RunnableFuture的基本实现 FutureTask 有一个状态值12345678910111213141516/** 状态值存在如下几种变化：* Possible state transitions:* NEW -&gt; COMPLETING -&gt; NORMAL* NEW -&gt; COMPLETING -&gt; EXCEPTIONAL* NEW -&gt; CANCELLED* NEW -&gt; INTERRUPTING -&gt; INTERRUPTED*/private volatile int state;private static final int NEW = 0;private static final int COMPLETING = 1;private static final int NORMAL = 2;private static final int EXCEPTIONAL = 3;private static final int CANCELLED = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED = 6;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"android AsyncTask","slug":"android-AsyncTask","date":"2020-09-03T07:04:59.000Z","updated":"2020-09-03T07:05:13.298Z","comments":true,"path":"blog/2020/09/android-AsyncTask.html","link":"","permalink":"hexo/blog/2020/09/android-AsyncTask.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"线程池","slug":"线程池","date":"2020-09-03T07:04:37.000Z","updated":"2020-09-10T05:33:10.382Z","comments":true,"path":"blog/2020/09/线程池.html","link":"","permalink":"hexo/blog/2020/09/线程池.html","excerpt":"","text":"java 线程池线程池是用来管理以及调度线程的容器。 线程池的优势 复用线程，避免大量线程重复创建、销毁，降低消耗 提升效率，当线程池内未饱和时，无需等待线程的重新创建和初始化，便能立即执行 方便线程并发管理，避免线程无限制的创建，可能造成的OOM、cpu过高等问题，规定了最大并发数 延时定时执行任务 线程池参数1234public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize: 核心线程数量，当向线程池提交一个任务时，如果线程数小于核心线程数，不管是否有线程处于空闲状态，都会创建一个新的线程来执行该任务，直到线程池中的线程数大于等于核心线程数量 maximumPoolSize: 最大线程数，线程池中线程数量最大值，当向线程池提交任务，核心线程都已创建完毕，且核心线程都处于工作状态，此时会先将该任务提交到阻塞队列，如果阻塞队列已满， 并线程池中线程数量小于最大线程数时，此时会新创建一个线程执行该任务。如果阻塞队列已满，且线程数也达到最大值，此时会执行线程饱和策略。 keepAliveTime：非核心线程可空闲时长，非核心线程处于空闲时，且空闲时长超过keepAliveTime，则该线程会被回收，但不会回收核心线程 unit： keepAliveTime的时长单位 workQueue： 阻塞队列，用于保存和运输待执行任务的阻塞队列 threadFactory：线程工厂，用于创建工作线程，threadFactory也是采用new Thread()形式创建一个新线程，但命名线程名称，格式为：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。 defaultHandler： 线程饱和策略，当线程池和阻塞队列都满了，再添加任务时，会执行此策略 运行流程; 当提交一个任务时， 1、查询核心线程是否已满，如果未满则新创建核心线程执行该任务 2、当核心线程已满，判断阻塞队列是否已满，如果阻塞队列未满则将该任务加入到阻塞队列中 3、当阻塞队列已满时，判断线程池是否已满，如果未满，则新创建线程执行该任务 4、当线程池已满时，则执行饱和策略 线程池为何需要使用阻塞队列1、因为线程池是管理并调度线程、以完成任务，肯定不可能无限制的创建线程， 2、提高核心线程的使用效率","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 强、软、弱、虚四种引用类型","slug":"java-强、软、弱、虚四种引用类型","date":"2020-08-28T06:21:35.000Z","updated":"2020-08-31T10:19:09.345Z","comments":true,"path":"blog/2020/08/java-强、软、弱、虚四种引用类型.html","link":"","permalink":"hexo/blog/2020/08/java-强、软、弱、虚四种引用类型.html","excerpt":"","text":"引用类型在jdk 1.2之前，一个对象只有 “已被引用” 和 “未被引用”两种概念，在jdk1.8之后，引用类型分为4类：强引用：Strong Reference软引用：Soft Reference弱饮用：Weak Reference虚引用：Phantom Reference这4中引用的强度依次减弱 强引用java中默认的引用类型，只要引用存在，永远不会回收，哪怕内存不足，系统会抛出OOM异常，也不会回收。 软引用只有当内存不足时，才会回收，回收后如果还是内存不足才会抛出OOM 123456789101112131415private static void testSoftReference() &#123; for (int i = 0; i &lt; 10; i++) &#123; byte[] buff = new byte[1024 * 1024]; SoftReference&lt;byte[]&gt; sr = new SoftReference&lt;&gt;(buff); list.add(sr); &#125; System.gc(); //主动通知垃圾回收 for(int i=0; i &lt; list.size(); i++)&#123; Object obj = ((SoftReference) list.get(i)).get(); System.out.println(obj); &#125; &#125; 弱引用// 无论内存是否足够，只要JVN开始回收，弱饮用都会被回收很多文章都说，只要执行GC就会回收软引用，这种结论是错误的。 当一个对象只被弱引用实例引用（持有）时，这个对象就会被GC回收 被回收的对象弱饮用实例引用的对象，而不是弱饮用本身 如果显式地声明了一个变量E e，并使之指向一个对象：e = new E()，这时变量e就是对对象的一个强引用。如果变量e所引用的这个对象同时又被WeakReference的一个实例持有，则由于存在对对象的一个强引用e，对象并不符合上述回收规则，因此对象至少在变量e的作用域范围内都不会被回收。 12345678910111213141516171819class TestWeakReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); &#125; private static void testWeakReference() &#123; byte[]buff = new byte[1024 * 1024]; for (int i = 0; i &lt; 10; i++) &#123; WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff); list.add(weakReference); &#125; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 在上述情况下，buff是一个强引用类型，在它的作用域时是不可回收的，即使除了弱饮用持有没有其他的引用。 将上述代码改一下，将buff与gc作用域修改 12345678910111213141516171819202122232425class TestSoftReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); private static List&lt;Object&gt; lists = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); gc(); &#125; static WeakReference&lt;byte[]&gt; softReference; private static void testWeakReference() &#123; byte[]buff = new byte[1024 * 1024]; for (int i = 0; i &lt; 10; i++) &#123; softReference = new WeakReference&lt;&gt;(buff); list.add(softReference); &#125; &#125; public static void gc() &#123; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 在上面这种情况下，gc执行的作用域与buff的作用域是同级的另一个作用域，且buff无其他引用，则可以回收 将上述代码再修改一下12345678910111213141516171819class TestWeakReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); &#125; private static void testWeakReference() &#123; for (int i = 0; i &lt; 10; i++) &#123; byte[]buff = new byte[1024 * 1024]; WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff); list.add(weakReference); &#125; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 此时buff的作用域只在for循环内，此时是可以被回收的，因为输出的结果均为null 虚引用虚引用是最弱的引用类型，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。 引用队列（ReferenceQueue）引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。 与软引用、弱引用不同，虚引用必须和引用队列一起使用。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java ThreadLocal解析","slug":"java-ThreadLocal解析","date":"2020-08-28T05:46:49.000Z","updated":"2020-08-31T07:33:20.221Z","comments":true,"path":"blog/2020/08/java-ThreadLocal解析.html","link":"","permalink":"hexo/blog/2020/08/java-ThreadLocal解析.html","excerpt":"","text":"ThreadLocalThreadLocal 是一个线程的内部存储类，对于被存储的对象，在不同的线程读取的变量是独立的。 实现原理是：对每一个线程都有一个ThreadLocalMap，ThreadLocal维护每个ThreadLocalMap中的值ThreadLocalMap 内部是一个[]Enter, 不同的ThreadLocal都是存储在线程的同一个ThreadLocalMap中的，只是下标位置不同，同一个ThreadLocal在不同线程的ThreadLocalMap中的下标值即索引值是相同的。 ThreadLocal 方法解析ThreadLocal 最常用的示例：123ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;();threadLocal.set(&quot;1&quot;);String name = threadLocal.get(); 在主线程初始化ThreadLocal实例，在各个线程调用set、get，设置、获取存储在各个线程中的值 查看源码 set12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 当调用set函数时，会去获取当前线程的ThreadLocalMap对象，该对象是在Thread.java中申明，默认值为null。当map为null时，则调用createMap,为threadLocals对象赋值，不为null，在调用ThreadLocalMap中的set函数，将值保存到数组中 get12345678910111213141516171819202122232425 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 当调用get方法时，获取当前线程的ThreadLocalMap对象，如果map不为null，则获取map持有的Entry对象，再返回该Entry对象持有的value值。如果map为null或者获取的Enter对象为null，则会调用setInitialValue，而initialValue的返回值是null。当map为null时，会调用createMap方法，实例化ThreadLocalMap 上面的set、get都会调用getMap方法，来获取当前线程的ThreadLocalMap实例 getMap123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; threadLocals 是在Thread.java中声明的，默认值为null，也就是说每个线程中都有这个对象，只是默认是null。 createMap在set、get中都会对当前线程的ThreadLocalMap对象判断，当为null时，会调用createMap对ThreadLocalMap对象threadLocals赋值， 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; ThreadLocalMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static class ThreadLocalMap &#123; // 必须为2的次方 private static final int INITIAL_CAPACITY = 16; // 最终存储数据的数组 private Entry[] table; // table 有值的长度 private int size = 0; // resize后的大小 private int threshold; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don&apos;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; ......&#125; getEntry 函数就是获取key对应的节点Entry在getEntry、set函数中可以看到value存储在[]Entry中的下标位置是由 key.threadLocalHashCode &amp; (len-1)计算得出的。就是ThreadLocal中的threadLocalHashCode 对[]Entry长度取模getEntry，通过下标获取e，如果不为null而且再次校验key相等，则返回eset时，e不为null，而且key相等，代表已存在，则替换e.value，key不相等，代表不存在，而添加 1234567891011121314151617181920212223242526272829303132333435 private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize(); &#125;private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; 当Entry[] 中存入的值数量已达到数组长度的3/4；则会调用resize函数，调整Entry[]的长度，将新数组长度*2，遍历老数组，重新获取下标h，判断h处是否有值，无值填充，有值则重新获取h，再填充 EntryThreadLocalMap 的内部类 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry继承WeakReference，说明ThreadLocal内部存储的类型都是采取弱引用累心存储，当GC时，则会被回收。这样保证当线程执行完时，当前线程中存储在ThreadLocalMap中的对象会被回收，不会在此处出现内存泄漏 value是调用ThreadLocal保存的值，","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java volatile关键字","slug":"java-volatile关键字","date":"2020-08-27T09:27:26.000Z","updated":"2020-08-28T03:59:27.622Z","comments":true,"path":"blog/2020/08/java-volatile关键字.html","link":"","permalink":"hexo/blog/2020/08/java-volatile关键字.html","excerpt":"","text":"valotile 可见性1、修改volatile变量时会强制将修改后的值刷新的主内存中。 2、修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 1234567891011121314151617181920212223242526272829class TestThread &#123; public static void main(String[] args)&#123; Work work = new Work(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::shutdown).start(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::work).start(); &#125; static class Work&#123; volatile boolean isShutdown = false; void shutdown() &#123; System.out.println(&quot;shutdown -----&quot;); isShutdown = true; System.out.println(&quot;shutdown ---- down&quot;); &#125; void work() &#123; while (!isShutdown) &#123; System.out.println(&quot;work ----&quot;); &#125; &#125; &#125;&#125; 上面的代码运行后输出的结果如下：work —-work —-work —-work —-work —-work —-work —-work —-work —-work —-work —-shutdown —–work —-shutdown —- downwork —-work —- 说明一个问题：volatile的可见性，volatile变量时会强制将修改后的值刷新的主内存修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。将主内存的值刷新，其他线程去读取主内存的值是需要一定时间的，","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java wait方法","slug":"java-wait方法","date":"2020-08-27T09:26:45.000Z","updated":"2020-09-09T07:56:20.712Z","comments":true,"path":"blog/2020/08/java-wait方法.html","link":"","permalink":"hexo/blog/2020/08/java-wait方法.html","excerpt":"","text":"wait()、notify()、notifyAll()wait()、notify()、notifyAll()这三个函数都是Object类中的方法，而Object类是所有类的父类，所以所有对象实例都有该方法. wait():阻塞当前之前直到该对象(调用wait函数的对象)在另一个线程调用了notify()或者notifyAll();notify():唤醒单个线程notifyAll():唤醒所有线程 这三个方法，都是Java语言提供的实现线程间阻塞(Blocking)和控制进程内调度(inter-process communication)的底层机制。在解释如何使用前，先说明一下两点： 正如Java内任何对象都能成为锁(Lock)一样，任何对象也都能成为条件队列(Condition queue)。而这个对象里的wait(), notify()和notifyAll()则是这个条件队列的固有(intrinsic)的方法。 一个对象的固有锁和它的固有条件队列是相关的，为了调用对象X内条件队列的方法，你必须获得对象X的锁。这是因为等待状态条件的机制和保证状态连续性的机制是紧密的结合在一起的。 12345678910111213141516171819202122class TestWait &#123; public static void main(String[]args) &#123; TestWaitBean bean = new TestWaitBean(&quot;bean&quot;); System.out.println(&quot;init bean&quot;); System.out.println(&quot;invoke bean wait&quot;); try &#123; bean.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;wait finished&quot;); &#125; &#125; static class TestWaitBean &#123; String name; public TestWaitBean(String name) &#123; this.name = name; &#125; &#125;&#125; 上述代码运行后会抛出异常java.lang.IllegalMonitorStateException因为未获取对象bean的锁，就去调用bean.wait() 修改一下代码，实现一个简单的阻塞、唤醒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TestWait &#123; public static void main(String[]args) &#123; TestWaitBean bean = new TestWaitBean(&quot;bean&quot;); System.out.println(&quot;init bean&quot;); System.out.println(&quot;invoke bean wait&quot;); WeakUpThread thread = new WeakUpThread(bean); thread.start(); synchronized (bean) &#123; try &#123; bean.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;wait finished&quot;); &#125; &#125; &#125; static class TestWaitBean &#123; String name; public TestWaitBean(String name) &#123; this.name = name; &#125; &#125; static class WeakUpThread extends Thread &#123; Object lock; public WeakUpThread(Object lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; super.run(); synchronized (lock) &#123; try &#123; System.out.println(&quot;Current Thread is sleep 2000ms&quot; ); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot; weakUp!!!&quot;); lock.notify(); &#125; &#125; &#125; &#125;&#125; 注意： 不管是调用wait，还是notify、notifyAll，都要是在同步修饰的代码块或者方法中，即必须先获取对象锁，在调用对象方法 使用wait、notifyAll实现一个多线程的生产者、消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class BlockTest &#123; public static void main(String []args) &#123; List&lt;Object&gt;list = new ArrayList&lt;&gt;(); Block block = new Block(list); list.add(null); Thread thread1 = new Thread(new PutThread(block, new Person(&quot;person1&quot;)), &quot;thread1&quot;); Thread thread2 = new Thread(new PutThread(block, new Person(&quot;person2&quot;)), &quot;thread2&quot;); Thread thread3 = new Thread(new PutThread(block, new Person(&quot;person3&quot;)), &quot;thread3&quot;); Thread thread4 = new Thread(new PutThread(block, new Person(&quot;person4&quot;)), &quot;thread4&quot;); Thread thread5 = new Thread(new OutThread(block), &quot;thread5&quot;); Thread thread6 = new Thread(new OutThread(block), &quot;thread6&quot;); Thread thread7 = new Thread(new OutThread(block), &quot;thread7&quot;); thread1.start(); thread2.start(); thread5.start(); thread6.start(); thread7.start(); thread3.start(); thread4.start(); &#125; static class PutThread implements Runnable &#123; Block block; Person person; public PutThread(Block block, Person person) &#123; this.block = block; this.person = person; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; puting the person name is &quot; + person.getName()); block.put(person); &#125; &#125; static class OutThread implements Runnable &#123; Block block; public OutThread(Block block) &#123; this.block = block; &#125; @Override public void run() &#123; Person person = (Person) block.get(); if(person != null) &#123; System.out.println(Thread.currentThread().getName() + &quot; get the person name is &quot; + person.getName()); &#125; else &#123; System.out.println(Thread.currentThread().getName() + &quot; the person is null&quot;); &#125; &#125; &#125; static class Block&lt;T&gt; &#123; List&lt;T&gt;t; Object lock = new Object(); int currentIndex = 0; volatile boolean isRead = false; public Block(List&lt;T&gt;t)&#123; this.t= t; &#125; public void put(T at) &#123; if(t == null) throw new NullPointerException(&quot;t is null&quot;); synchronized (lock) &#123; try &#123; if(isRead) &#123; lock.wait(); &#125; currentIndex++; t.add(at); lock.notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public T get() &#123; synchronized (lock)&#123; T at = null; try &#123; if(currentIndex == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 当前下标已为0 阻塞 等待写入再取&quot;); lock.wait(); &#125; if(isRead)&#123; System.out.println(Thread.currentThread().getName() + &quot; 当前正在读 阻塞 等待写入再取 index&quot; + currentIndex); lock.wait(); &#125; isRead = true; at = t.remove(currentIndex); if(at == null) &#123; System.out.println(Thread.currentThread().getName() + &quot; index&quot; + currentIndex); return null; &#125; currentIndex --; return at; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.notifyAll(); isRead = false; return at; &#125; &#125; &#125; &#125; static class Person&#123; private String name = &quot;&quot;; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 上述生产者、消费者只能适用于多个线程直接的put、get 因为wait、和notify/notifyAll本身就是互斥的，因为调用wait后，就会阻塞当前调用线程，本身线程的notify/notifyAll也就不会被调用，所以说上述代码只能实现多个线程直接的场景，还有就是上述代码只是简单的实现，而且是读操作加锁，一般而言应该是写操作时堵塞。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java join方法","slug":"java-join方法","date":"2020-08-27T08:18:59.000Z","updated":"2020-08-27T09:24:35.404Z","comments":true,"path":"blog/2020/08/java-join方法.html","link":"","permalink":"hexo/blog/2020/08/java-join方法.html","excerpt":"","text":"t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续如在main线程调用t.join(),则会阻塞main线程直到t线程执行完。 而join()函数参数，当调用为t.join(2000),代表阻塞2000毫秒, 当2000毫秒完后，main线程会向下执行，但也有例外，join(millis)如在t线程使用 synchronized时，则必须等到synchronized包裹的代码块执行完并传递的millis毫秒后，t.join()的调用线程才会向下执行。 12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; super.run();// synchronized (currentThread()) &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;休眠&quot; + i); &#125; System.out.println(&quot;线程结束&quot;);// &#125; &#125; &#125;; long start = System.currentTimeMillis(); thread.start(); try &#123; thread.join(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;main线程结束&quot;); System.out.println(System.currentTimeMillis() - start); &#125;&#125; 输出结果： main线程结束1005休眠0休眠1休眠2休眠3休眠4线程结束 将thread.join(1000) 改为2000 时，输出结果如下：休眠0main线程结束2005休眠1休眠2休眠3休眠4线程结束 将上面代码synchronized 注释放开后再运行，输出结果如下：休眠0休眠1休眠2休眠3休眠4线程结束main线程结束5011 查看join方法源码12345678910111213141516171819202122232425262728293031/** * Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever. 当为0时，会一直阻塞调用join函数的线程，直到调用join函数的对象线程执行完毕 */public final synchronized void join(long millis) throws InterruptedException &#123; // 获取当时系统时间 long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; // 当传过来的入参时间小于0，抛出异常 throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (millis == 0) &#123; // 当等于0时，只要线程未执行完毕，则一直阻塞 while (isAlive()) &#123; // 当前线程未执行完一直阻塞 wait(0); &#125; &#125; else &#123; // 当时间大于0 while (isAlive()) &#123; // 当前线程还未执行完，则一直循环获取时间，阻塞调用线程到时间结束 long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 注意：wait()是运行在调用线程的，如在main线程中调用t.join();则join()函数的调用线程是main线程，wait()也是运行在main线程的，所以阻塞main线程，而t才是join()的调用对象线程，isAlive也是判断的t线程是否执行完毕，只有在t线程执行完毕，isAlive才为false","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"android 指纹验证","slug":"android-指纹验证","date":"2020-08-12T01:42:55.000Z","updated":"2020-08-13T03:17:41.339Z","comments":true,"path":"blog/2020/08/android-指纹验证.html","link":"","permalink":"hexo/blog/2020/08/android-指纹验证.html","excerpt":"","text":"android 指纹识别android API 23时新增的功能，指纹识别 主要类：FingerpringManager 在API28后，FingerpringManager被遗弃，使用BiometricPrompt，此时授权识别的弹窗不能自定义，只能使用官方统一弹窗，只能设置各个授权文案。各个开发商内部实现可能不一致。 通过只是使用指纹识别，直接使用官方api即可，但出于安全或业务场景需求，很多都需要去检测生物库信息是否变更，如指纹库在重新指纹识别前是否发生变更，这个官方api就没有提供方法，需要我们自己实现。 检测指纹库是否发生变更参考：通过检测密钥查看是否变更(https://www.jianshu.com/p/dbb1a43cfb21) 在API28以前，指纹库信息时可以通过反射获取，获取的信息有指纹id、groupId、指纹名称、指纹个数、设备id等等， 12345678910111213141516if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; Log.d(TAG, &quot;getFingerPrintInfo: &quot;); FingerprintManager fingerprintManager = (FingerprintManager) getCurrentActivity().getSystemService(Context.FINGERPRINT_SERVICE); try&#123; Class clz = Class.forName(&quot;android.hardware.fingerprint.FingerprintManager&quot;); Method method = clz.getDeclaredMethod(&quot;getEnrolledFingerprints&quot;, new Class[]&#123;&#125;); method.setAccessible(true); Object obj = method.invoke(fingerprintManager, null); if (obj != null) &#123; Log.e(TAG, &quot;objStr:&quot; + JsonUtils.toJson(obj)); List&lt;FingerprintBean&gt; list = (List&lt;FingerprintBean&gt;) JsonUtils.fromJson(objStr, new TypeToken&lt;List&lt;FingerprintBean&gt;&gt;()&#123;&#125;.getType()); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 而FingerprintBean是这样的：123456789public class FingerprintBean implements Serializable &#123; private static final long serialVersionUID = 1L; private long mDeviceId; private long mFingerId; private long mGroupId; private String mName;&#125; 最理想的方式是我们反射获取到这些指纹库信息，然后将这些信息保存到本地，每次调用指纹识别时，获取当前指纹库信息与之前的指纹库信息比较，只有不同即可判定指纹库信息变更，但在实际操作中，发现在手机上获取到的指纹id只是简单的1、2、3即指纹库里的排列顺序，而指纹名称是可以随意更改，groupId、deviceId都为0，如果使用这些信息去校验，错误率太高。 还有一种方式即是上面参考链接中的，检测指纹库密钥信息是否变更 但在上面链接那种方法中，有几个问题：1、增加、删除指纹无法检测2、使用修改指纹的手指识别后才能检测出修改 于是将反射、密钥检测两者结合，先反射获取指纹库信息，只是比较指纹库指纹个数，先判断指纹个数是否发生变更，就可知道指纹库信息变更了如果指纹个数没有变更，再来校验密钥是否发生变化","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"kotlin (二)","slug":"kotlin-二","date":"2020-07-29T13:58:32.000Z","updated":"2020-07-29T13:58:32.468Z","comments":true,"path":"blog/2020/07/kotlin-二.html","link":"","permalink":"hexo/blog/2020/07/kotlin-二.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"android-动画","date":"2020-07-27T03:26:53.233Z","updated":"2020-07-27T03:26:53.233Z","comments":true,"path":"blog/2020/07/android-动画.html","link":"","permalink":"hexo/blog/2020/07/android-动画.html","excerpt":"","text":"android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画","categories":[],"tags":[]},{"title":"android 动画","slug":"android-动画","date":"2020-07-21T01:32:47.000Z","updated":"2020-09-04T01:11:22.579Z","comments":true,"path":"blog/2020/07/android-动画.html","link":"","permalink":"hexo/blog/2020/07/android-动画.html","excerpt":"","text":"android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画alpha在res/anim下新建文件alpha_anime.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; android:duration=&quot;1000&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt; 在Activity中123Animation animation = AnimationUtils.loadAnimation(this.getApplicationContext(), R.anim.alpha_anime);ImageView alphaImage = findViewById(R.id.alphaImageView);alphaImage.startAnimation(animation); 这样就能实现图片渐隐的无限循环效果 scale在res/anim下新建文件scale.xml1234567891011&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt; translate123456789&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromYDelta=&quot;100%p&quot; android:toYDelta=&quot;0%p&quot; android:duration=&quot;1000&quot; android:fromXDelta=&quot;100%&quot; android:toXDelta=&quot;0%&quot; /&gt; rotate1234567891011&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;359&quot; android:duration = &quot;1000&quot; android:drawable = &quot;@mipmap/image1&quot; android:visible = &quot;true&quot;&gt; &lt;/rotate&gt;&lt;/rotate&gt; 属性动画","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android MVP","slug":"android-MVP","date":"2020-05-30T08:28:01.000Z","updated":"2020-05-30T08:39:07.044Z","comments":true,"path":"blog/2020/05/android-MVP.html","link":"","permalink":"hexo/blog/2020/05/android-MVP.html","excerpt":"","text":"MVPandroid MVP是一种开发架构，由MVC演化而来，因为在MVC中，Activity层，糅合逻辑、ui操作，显得臃肿、混乱。 在MVP中， M：model，数据层 V：View，页面操作 P：Present，M、V的桥接，逻辑操作 MVP的优势 1、代码简洁，逻辑清晰 2、解耦，便于维护 因为MVP将逻辑与视图分离，降低了业务耦合，使得整个代码层次分明，所以也就更好维护 下面以登陆做一个示例","categories":[],"tags":[{"name":"andorid","slug":"andorid","permalink":"hexo/tags/andorid/"}]},{"title":"android MVVM","slug":"android-MVVM","date":"2020-05-30T08:27:55.000Z","updated":"2020-05-30T08:27:55.412Z","comments":true,"path":"blog/2020/05/android-MVVM.html","link":"","permalink":"hexo/blog/2020/05/android-MVVM.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"android 高级ui","slug":"android-高级ui","date":"2020-05-30T08:27:36.000Z","updated":"2020-05-30T08:27:36.317Z","comments":true,"path":"blog/2020/05/android-高级ui.html","link":"","permalink":"hexo/blog/2020/05/android-高级ui.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"android 图片加载","slug":"android-图片加载","date":"2020-05-30T08:20:33.000Z","updated":"2020-05-30T08:20:48.207Z","comments":true,"path":"blog/2020/05/android-图片加载.html","link":"","permalink":"hexo/blog/2020/05/android-图片加载.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 网络请求框架","slug":"android-网络请求框架","date":"2020-05-30T08:20:15.000Z","updated":"2020-05-30T08:20:51.794Z","comments":true,"path":"blog/2020/05/android-网络请求框架.html","link":"","permalink":"hexo/blog/2020/05/android-网络请求框架.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 序列化","slug":"android-序列化","date":"2020-05-27T12:48:49.000Z","updated":"2020-06-01T02:22:37.503Z","comments":true,"path":"blog/2020/05/android-序列化.html","link":"","permalink":"hexo/blog/2020/05/android-序列化.html","excerpt":"","text":"android序列化什么是序列化将java对象转化为二进制过程，就是序列化，将二进制转化为java对象的过程，就是反序列化 为什么要序列化在下面几种场景下我们需要序列化 永久性保存对象，保存对象的字节序列到本地文件中； 对象在网络中传递； 对象在IPC间传递（进程通信） 如何序列化序列化有两种方法，java中自带的实现Serializable，android中特有的Parcelable Serializable新建类实现Serializable，Serializable为空接口，没有要实现的方法， 需要 定义一个静态常量serialVersionUID 1234567891011121314public class SerBean implements Serializable &#123; private static final long serialVersionUID = 263894729013938L; private String name; private int age; public SerBean(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 这样这个类的序列化就完成了。 Parcelable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ParBean implements Parcelable &#123; private String name; private int age; // 系统自动添加，给createFromParcel里面用 protected ParBean(Parcel in) &#123; name = in.readString(); age = in.readInt(); &#125; public static final Creator&lt;ParBean&gt; CREATOR = new Creator&lt;ParBean&gt;() &#123; /** * * @param in * @return *createFromParcel()方法中我们要去读取刚才写出的name和age字段， * 并创建一个Person对象进行返回，其中color和size都是调用Parcel的readXxx()方法读取到的， * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。 * 读取的工作我们利用一个构造函数帮我们完成了 * */ @Override public ParBean createFromParcel(Parcel in) &#123; return new ParBean(in); &#125; //供反序列化本类数组时调用的 @Override public ParBean[] newArray(int size) &#123; return new ParBean[size]; &#125; &#125;; // 内容接口描述，默认返回0即可。 @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); // 写出name dest.writeInt(age); // 写出age &#125; // --------下面为自己写的构造函数和get set public ParBean() &#123; &#125; public ParBean(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 序列化方案区别上面讲了两个序列化方案，Serializable：是java就有的，代码量少，但在序列化时，会产生大量的临时对象，容易造成频繁的minor GC Parcelable：android特有的，代码量比Serializable要多，但使用效率高，且没那么占内存 因为在选择序列化时，优先使用Parcelable，但有一种情况特殊，当数据保存在磁盘上时，Parcelable在外界有变化的情况下，不能很好的保证数据的连续性，因此在此种场景下推荐使用Serializable； 序列化某种程度来说并不安全 因为序列化的对象数据转换为二进制，并且完全可逆。但是在RMI调用时所有private字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的 解决方案1、 序列化Hook化（移位和复位）2、 序列数据加密和签名3、 利用transient的特性解决4、 打包和解包代理 补充 static和transient字段不能被序列化（感兴趣的同学可以深入研究下）","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"kotlin","slug":"kotlin","date":"2020-05-26T13:28:38.000Z","updated":"2020-07-27T03:26:53.230Z","comments":true,"path":"blog/2020/05/kotlin.html","link":"","permalink":"hexo/blog/2020/05/kotlin.html","excerpt":"","text":"kotlin学习hello world新建一个kt文件， 1234fun main(args:Array&lt;String&gt;) &#123; println(&quot;Hello world!&quot;);&#125; 程序主入口main方法， 无需新建类即可运行，函数声明用fun 123fun sum(a:Int, b:Int):Int&#123; return a + b;&#125; 返回值写在参数之后 表达式可以作为函数体，返回值类型自动推断1fun sun(a:Int, b:Int) = a+b; 返回无意义的值用Unit表示 fun test():Unit { println(“test”);} 变量赋值变量赋值声明关键字：var、valvar：声明变量val：声明常量 var i:Int = 1;val PI:Double = 3.14; 当声明并赋值时，数据类型可以省略, 会自动推断数据类型var i = 1;val PI = 3.14 当声明但不赋值时，不能省略数据类型var i:Int;val PI:Double; 字符串模板123var s = &quot;aaaaa&quot;;var b = &quot;str = $s&quot;;var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot; 条件表达式1234fun testIf(a:Int, b:Int):Int &#123; if(a &gt; b) return a; return b;&#125; 在kotlin中，if还可以用作表达式 1fun max(a:Int, b:Int) = if(a &gt; b) a else b 空值与null检测当某个值可以为空时，需要在类型后添加?表示可以为空此时，声明时不能省略类型12345var obj:Objects ? = null;// 表示返回值可以为nullfun parseInt(str:String):Int?&#123; ...&#125; 类型检测与自动类型转换is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换 123456789fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125; 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 for循环12345678910var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);// 根据元素遍历for (item in items) &#123; println(item);&#125;// 根据下标便利for (item in items.indices) &#123; println(items[item]);&#125; while 循环12345var index = 0;while (index &lt; items.size) &#123; println(items[index]); index ++;&#125; when表达式123456789101112private fun testWhen(s: Any?) &#123; when(s) &#123; &quot;a&quot; -&gt; 1; &quot;b&quot; -&gt; 2; is String -&gt; 3; 1 -&gt; &quot;n&quot;; 2 -&gt; &#123; println(&quot;222&quot;); &#125;; else -&gt; &quot;else&quot;; &#125; &#125; 有点类似java中的 switch 区间 range12345var x = 6;var y = 9;if(x in 0..y) &#123; println(&quot;x in 0 - y&quot;);&#125; 注意：区间只用于数字 集合集合的迭代可以用的上面的 for in 循环1234var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);for(item in items) &#123; println(item);&#125; 判断集合中是否包含某元素 用while in || when12345678while (&quot;a&quot; in items) &#123; println(&quot;items include a&quot;);&#125;when &#123; &quot;a&quot; in items -&gt; println(&quot;aaa&quot;); &quot;d&quot; in items -&gt; println(&quot;ddd);&#125; 用lambda来过滤和映射集合 ，与java8 lambda stream大致 1234items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125; .sortBy&#123; it &#125; .map&#123; it.toUpperCase() &#125; .forEach&#123; println(it) &#125;","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"hexo/tags/kotlin/"}]},{"title":"react 掉起摄像头","slug":"react-掉起摄像头","date":"2020-05-22T09:21:42.000Z","updated":"2020-05-22T09:29:17.381Z","comments":true,"path":"blog/2020/05/react-掉起摄像头.html","link":"","permalink":"hexo/blog/2020/05/react-掉起摄像头.html","excerpt":"","text":"在h5中掉起摄像头，碰到一些问题，无法切换到后置摄像头 —-&gt; 将本地http 改为https就可以了chrome浏览器报错：不支持访问用户媒体 —》 将本地http 改为https就可以了 npm start默认采用的是http协议而npm start其实执行的脚本是react-script/start.js文件查看 79行代码1const protocol = process.env.HTTPS === &apos;true&apos; ? &apos;https&apos; : &apos;http&apos;; 我们只要在环境变量中将HTTPS设置为true即可在macos 执行1234567cd ~code .bash_profile添加一行 HTTPS=truesource .bash_profile// 也可以在终端执行export PORT=8081 在 window 新增环境变量 HTTPS true或者在终端执行 set HTTPS=true 本地掉起的摄像头呈现镜像 —-》css 镜像翻转 transform: ‘rotateY(180deg)’ // 水平镜像翻转180 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import React from &apos;react&apos;;import &#123;StyleSheet,css&#125; from &apos;aphrodite/no-important&apos;import &#123; dpw, dph &#125; from &apos;../../common/tool/ScreenFit&apos;;export default class AliveCheck extends React.PureComponent &#123; componentDidMount() &#123; this.video = document.getElementById(&apos;video&apos;); this.canvas = document.getElementById(&apos;canvas&apos;); this.context = this.canvas.getContext(&apos;2d&apos;); const constraints = &#123; audio: false, video : &#123; width: 480, height: 320, sourceId: &apos;default&apos;, facingMode: &#123; exact: &quot;environment&quot; &#125;, // facingMode: &#123; exact: &quot;user&quot; &#125;, permissions: &#123; &quot;audio-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture audio using getUserMedia()&quot; &#125;, &quot;video-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture video using getUserMedia()&quot; &#125; &#125; &#125; &#125; // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;; &#125; if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123; //调用用户媒体设备, 访问摄像头 this.getUserMedia(constraints, this.success, this.error); &#125; else &#123; alert(&apos;不支持访问用户媒体&apos;); &#125; &#125; //访问用户媒体设备的兼容方法 getUserMedia =(constraints, success, error) =&gt; &#123; if (navigator.mediaDevices.getUserMedia) &#123; //最新的标准API navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error); &#125; else if (navigator.webkitGetUserMedia) &#123; //webkit核心浏览器 navigator.webkitGetUserMedia(constraints,success, error) &#125; else if (navigator.mozGetUserMedia) &#123; //firfox浏览器 navigator.mozGetUserMedia(constraints, success, error); &#125; else if (navigator.getUserMedia) &#123; //旧版API navigator.getUserMedia(constraints, success, error); &#125; &#125; success =(stream) =&gt; &#123; //兼容webkit核心浏览器 let CompatibleURL = window.URL || window.webkitURL; //将视频流设置为video元素的源 console.log(stream); //video.src = CompatibleURL.createObjectURL(stream); this.video.srcObject = stream; this.video.play(); &#125; error =(error)=&gt; &#123; console.log(`访问用户媒体设备失败$&#123;error.name&#125;, $&#123;error.message&#125;`); &#125; takePhoto =() =&gt; &#123; alert(&apos;takePhoto&apos;) this.context.drawImage(this.video, 0, 0, 480, 320); &#125; stopCamera =() =&gt; &#123; if (!this.video.srcObject) return let stream = this.video.srcObject let tracks = stream.getTracks(); tracks.forEach(track =&gt; &#123; track.stop() &#125;) &#125; render() &#123; return( &lt;div className=&#123;css(styles.box)&#125;&gt; &lt;video className=&#123;css(styles.video)&#125; id=&quot;video&quot; width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;/video&gt; &lt;div&gt; &lt;button id=&quot;capture&quot; onClick=&#123;this.takePhoto&#125;&gt;拍照&lt;/button&gt; &lt;/div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; box: &#123; display: &apos;flex&apos;, width: &apos;100%&apos;, height: &apos;100%&apos;, flexDirection: &apos;column&apos;, &#125;, video: &#123; // 水平镜像翻转180 transform: &apos;rotateY(180deg)&apos;, &#125;&#125;)","categories":[],"tags":[{"name":"react","slug":"react","permalink":"hexo/tags/react/"}]},{"title":"日常记录","slug":"日常记录","date":"2020-05-21T13:48:21.000Z","updated":"2020-06-01T02:22:37.501Z","comments":true,"path":"blog/2020/05/日常记录.html","link":"","permalink":"hexo/blog/2020/05/日常记录.html","excerpt":"","text":"i++++ 在后，先运算完当前结果，再给i赋值 ex：1234567Object [] obj = new Object [16]i = 0；obj[i ++] = &quot;obj&quot;// 会先执行obj[0]=&quot;obj&quot;;// 再执行i = i + 1; –i;– 在前，则先给i赋值，再执行当前运算","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"位操作符","slug":"位操作符","date":"2020-05-21T13:39:31.000Z","updated":"2020-06-01T02:22:37.500Z","comments":true,"path":"blog/2020/05/位操作符.html","link":"","permalink":"hexo/blog/2020/05/位操作符.html","excerpt":"","text":"&amp;逻辑 与A &amp; B将A、B都转化为二进制，同为均为1则为1，否则为0 ex：5 &amp; 80000 0101&amp;0000 1000 result ： 0000 0000 结果就是0 逻辑或A | B将A、B都转化为二进制，同为有一位为1则为1，否则为0ex ： 5 &amp; 80000 0101&amp;0000 1000 result ： 0000 1101 结果就是13 逻辑非 逻辑异或 5&gt;&gt;2 0000 0101 &gt;&gt; 2 — 0000 0001 === 1 像右移2左移运算符，&gt;&gt;&gt; &lt;&lt; 5 &lt;&lt; 2像左移20000 0101 &lt;&lt; 2 – 0001 0100 === 20左移运算符， 无符号移动 无符号右移，忽略符号位，空位都以0补齐","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 枚举","slug":"java-枚举","date":"2020-05-21T13:26:46.000Z","updated":"2020-06-01T02:22:37.499Z","comments":true,"path":"blog/2020/05/java-枚举.html","link":"","permalink":"hexo/blog/2020/05/java-枚举.html","excerpt":"","text":"枚举enum 的全程事 Enumeration 是jdk1.5引进的 被enum 修饰的数据类型就是枚举类型：1enum Test &#123; TEST0, TEST1, TEST2 &#125; 如果枚举不添加任何方法，枚举值默认为从0开始的递增数值，ru上面的： TEST0：0， TEST1：1，TEST2：2 枚举的好处：可以将常量组织起来，便于管理应用场景：状态码：错误码 枚举的本质枚举的本质是一个类，受限制的类 创建enum是，编译器会自动为你生成一个相关的类，这个类继承 java.lang.Enum b编译过后其实是12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; ... &#125; 是一个抽象类，并且继承了Comparable以及Serializable，也就是标记了序列化 而且枚举可以添加自己的方法、变量，但是不能为枚举常量用 “=”赋值，但不能继承其他类，因为已经继承了Enum类，也不能被继承。 枚举可以实现接口，像上面就是内部实现了两个接口，我们也可以自己实现其他接口 枚举添加方法123456789101112131415public enum TestEnum &#123; //此处调用额其实就是下面写的构造函数 TEST(22), TEST1(33), TEST2(44), TEST3(55); private TestEnum(int num) &#123; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 泛型","slug":"java-泛型","date":"2020-05-19T15:05:30.000Z","updated":"2020-06-01T02:22:37.499Z","comments":true,"path":"blog/2020/05/java-泛型.html","link":"","permalink":"hexo/blog/2020/05/java-泛型.html","excerpt":"","text":"声明中有一个或者多个类型化参数的类或者接口，叫做泛型类或者接口。泛型类和接口统称为泛型。 泛型是一种安全规范，帮助我们在编译前就发现类型安全问题，而不需要等到编译报错。泛型在编译时会被擦除。 关于使用泛型的几个规则： 请不要使用原生态类型 如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势 消除非受检的警告 优先考虑泛型 优先考虑泛型方法 通配符无限通配符 ？上限通配符 ？ extends T下限通配符 ? super T","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 集合","slug":"java-集合","date":"2020-05-18T15:08:59.000Z","updated":"2020-06-01T02:22:37.498Z","comments":true,"path":"blog/2020/05/java-集合.html","link":"","permalink":"hexo/blog/2020/05/java-集合.html","excerpt":"","text":"java中的集合包括map、set、list collection 所有的linked 都是链表实现所有的hash 都是hash表，存储的对象都需要重写hashcode、equas函数","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"多进程通信 IBinder","slug":"多线程通信-IBinder","date":"2020-05-18T15:08:07.000Z","updated":"2020-09-10T03:51:20.941Z","comments":true,"path":"blog/2020/05/多线程通信-IBinder.html","link":"","permalink":"hexo/blog/2020/05/多线程通信-IBinder.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"wechat-app","slug":"wechat-app","date":"2020-05-13T08:24:04.000Z","updated":"2020-05-13T08:24:23.722Z","comments":true,"path":"blog/2020/05/wechat-app.html","link":"","permalink":"hexo/blog/2020/05/wechat-app.html","excerpt":"","text":"微信小程序开发","categories":[],"tags":[{"name":"wechatApp","slug":"wechatApp","permalink":"hexo/tags/wechatApp/"}]},{"title":"kotlin 类","slug":"kotlin","date":"2020-05-13T08:20:15.000Z","updated":"2020-07-27T03:26:53.229Z","comments":true,"path":"blog/2020/05/kotlin.html","link":"","permalink":"hexo/blog/2020/05/kotlin.html","excerpt":"","text":"kotlin 类kotlin中使用class申明类 构造函数构造函数分为主构造函数、次构造函数 主构造函数kotlin中可以在申明类时申明一个构造函数，并且次构造函数为 主构造函数 12// 申明了主构造函数class Person constructor(var name: String, var age: Int ) &#123;&#125; 如果主构造函数没有使用任何注解或者修饰符，则可以省略constructor关键字 1class Person (var name: String, var age: Int ) &#123;&#125; 主构造函数不能含有代码块，有需要初始化的代码可以放在以init关键字作为前缀的初始化块中。其中init可以申明多个，会根据代码顺序来执行。 123456789class Person (var name: String, var age: Int ) &#123; var myName = name; init &#123; println(&quot;this person&apos;s name was $&#123;myName&#125;&quot;); &#125; init &#123; println(&quot; test &quot;); &#125;&#125; 如果没有申明主构造函数，系统会自动创建一个无参的主构造函数。 次构造函数次构造函数必须要用constructor申明，如果有主构造函数，必须将次构造函数委托给主构造函数 1234567891011121314class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125; 初始化init代码块实际上会成为主构造函数的一部分。当次级构造函数委托给主构造函数，init代码块会成为次级构造函数的第一句语句。即使该类没有主构造函数，这种委托也会隐式发生，仍会执行初始化代码块。 如果一个非抽象类没有申明任何主、次构造函数，默认会生成一个不带参的主构造函数。函数的可见性为public。如果不想类有一个公有构造函数，需要声明一个private的主构造函数。1class TestClass private constructor () &#123;&#125; 在JVM上，如果主构造函数中的所有参数都有默认值，则会默认生成一个额外的无参构造函数，它将使用默认值。 创建类的实例kotlin 在创建实例时，不需要new 关键字12class MyPerson(str: String, var age: Int) &#123;&#125;var person = MyPerson(&quot;jack&quot;, 11); 类成员 构造函数与初始化代码块 函数 属性 嵌套类、内部类 对象申明 继承在kotlin中，所有类都有一个超类 Any，这对于没有超类型声明的类是默认超类： var oneClass; // 从Any隐式继承 Any 类中有三个方法 equas()、 hashcode()、 toString(), 因此所有kotlin类都定义有这三个方法 默认情况下，kotlin中类都是final 的，不可被继承，如果需要声明该类可以被继承，需要使用关键字 open。 并且kotlin中是使用 : 来表示继承。 12open class TestClassSuper &#123;&#125;class TestClassChild : TestClassSuper &#123;&#125; 如果超类中有声明主构造函数，则子类可以声明主构造函数，则并必须用子类中主构造函数参数初始化超类。如果子类没有声明主构造函数，则必须声明次级构造函数，并且使用super初始化基类12345678910111213141516171819open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall);&#125; 函数的重写正如类的继承需要申明open标识该类开放继承，类中的函数标识可以被重写也是需要使用open申明，如果没有函数没有申明open，则在子类中不允许出现同名并且同参数类型的函数。出现同名但不同参数的函数时允许的，正如java中的重载 12345678910111213141516171819202122232425262728293031323334open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125; open fun testMethod() &#123; &#125; fun test1() &#123; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall); override fun testMethod() &#123; super.testMethod() &#125; fun test1(str:String) &#123; &#125;&#125; 属性的重写同函数的重写，属性的重写也是需要使用open标识，并在子类中使用override1234open var i = 2;// childClassoverride var i = 4; 在属性的重写中，有一点需要注意，可以用var 重写val，却不能用val重写var；这一点是和java不一样的。因为用val申明的属性本质上申明了get方法，而将其重写为var只是在子类新增了一个set方法 派生类的初始化顺序1、进入子类的构造函数2、进入父类的构造函数并完成初始化3、进入父类的init代码块4、父类中属性的初始化5、子类构造函数完成初始化6、子类init代码块7、子类属性初始化 调用父类方法或属性可以使用super关键字1234// 方法super.method();// 属性super.nema; 内部类中调用外部类父类属性或方法，使用super@Outer1super@OutClass.method();","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"hexo/tags/kotlin/"}]},{"title":"android dialog ","slug":"android-dialog","date":"2020-05-13T07:56:53.000Z","updated":"2020-05-13T08:14:46.157Z","comments":true,"path":"blog/2020/05/android-dialog.html","link":"","permalink":"hexo/blog/2020/05/android-dialog.html","excerpt":"","text":"dialog在日常开发时会经常使用到弹窗dialog 针对自定义视图的弹窗使用方法， 1234567AlertDialog.Builder builder = new AlertDialog.Builder(context);LayoutInflater inflater = context.getLayoutInflater();View view = inflater.inflate(R.layout.view, null);build.setView(view);AlertDialog dialog = build.create();dialog.show(); 上面就是一个AlertDialog实例的创建过程，其中AlertDialog使用了创建者模式。 关于点击弹窗其他部分、点击手机back而不关闭dialog的方法有如下:12dialog.setCancelable(false); // 点击back、其他部位都不关闭弹窗dialog.setCanceledOnTouchOutside(false);// 点击其他部位不关闭、点back关闭 设置dialog弹窗的大小： 12345678910// 在dialog.show() 之后Window window = dialog.getWindow();if(window != null) &#123; WindowManager.LayoutParams attr = window.getAttributes(); if (attr != null) &#123; attr.height = ViewGroup.LayoutParams.MATCH_PARENT; attr.width = ViewGroup.LayoutParams.MATCH_PARENT; window.setAttributes(attr); &#125;&#125; 这样就将dialog窗口大小设置为了最大，但是可以发现我们的弹窗还是没有充满整个屏幕，因为dialog默认的主题theme就是偏距margin的，所以如果我们想要充满整个屏幕的话，需要改变我们dialog的主题， 12// AlertDialog.Builder builder = new AlertDialog.Builder(context);AlertDialog.Builder builder = new AlertDialog.Builder(context, R.style.AppTheme);","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"java流","slug":"java流","date":"2020-05-13T07:55:26.000Z","updated":"2020-05-13T07:55:32.490Z","comments":true,"path":"blog/2020/05/java流.html","link":"","permalink":"hexo/blog/2020/05/java流.html","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java范型","slug":"java范型","date":"2020-05-13T07:54:59.000Z","updated":"2020-05-13T07:55:07.530Z","comments":true,"path":"blog/2020/05/java范型.html","link":"","permalink":"hexo/blog/2020/05/java范型.html","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"jvm 线程私有区","slug":"jvm-线程私有区","date":"2020-05-13T06:33:03.000Z","updated":"2020-05-13T07:41:22.551Z","comments":true,"path":"blog/2020/05/jvm-线程私有区.html","link":"","permalink":"hexo/blog/2020/05/jvm-线程私有区.html","excerpt":"","text":"jvm 线程私有区jvm从多线程角度看，分为线程共享区、线程私有区 而在线程私有区中有：程序计数器、方法栈区（包括虚拟机栈、本地方法栈） 程序计数器较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响 jvm的多线程是通过cpu时间片轮转算法实现的，某个线程在执行过程中会因为时间片耗尽而被挂起，其他线程获得时间片开始执行。当被挂起的线程重新获取到时间片，它要想从之前被挂起的地方开始执行，就需要知道之前执行到了哪里，在jvm中，通过程序计数器来记录字节码执行的位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。 程序计数器的特点1、线程隔离：每个线程都有自己的程序计数器2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。 方法栈区线程在运行时，在执行每一个方法的时候都会打包成一个栈帧，然后将栈帧入栈，当方法执行完时，就会将该栈帧出栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。 栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k 栈帧结构栈帧中含有：局部变量表、操作数据栈、动态链接、返回地址 局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 锁","slug":"java-锁","date":"2020-05-07T02:42:32.000Z","updated":"2020-09-03T07:25:57.923Z","comments":true,"path":"blog/2020/05/java-锁.html","link":"","permalink":"hexo/blog/2020/05/java-锁.html","excerpt":"","text":"java中使用锁，主要是用于解决多线程并发问题多个线程对某个对象进行操作，就存在并发问题。 java内存规定了，所有变量都储存在主内存中，每个线程又有自己的工作内存 线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存 线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 并发三要素原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。 可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：程序执行的顺序按照代码的先后顺序执行。 解决并发问题volatile：保证可见性，不保证原子性当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中 这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见 禁止指令重排序指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则 不会对存在依赖关系的指令重排序，例如 a = 1;b = a; a 和b存在依赖关系，不会被重排序 不能影响单线程下的执行结果。比如：a=1;b=2;c=a+b这三个操作,前两个操作可以重排序，但是c=a+b不会被重排序，因为要保证结果是3 使用场景对于一个变量，单个线程写，其他线程读，这个时候就可以使用volatile来修饰这个变量 123456789101112131415161718public class Utils &#123; private static volatile Utils instance; public static Utils getInstance() &#123; // 1 if(instance == null) &#123; // 2 synchronized(Utils.class) &#123; // 3 if(instance == null) &#123; // 4 instance = new Utils(); // 5 &#125; &#125; &#125; return instance; &#125;&#125; 初始化一个对象有如下步骤：分配内存，初始化对象，指向内存 如上代码，如果不使用volatile修饰，这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断instance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。 volatile 原理在jvm底层，volatile是通过内存屏障来实现的，内存屏障会提供三个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将缓存的修改操作立即写到主内存 写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。 valatile局限性volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题 Synchronized多个线程同时写一个变量这个时候使用Synchronized，可以保证同一时刻，只有一个线程可执行某个方法或某个代码块 Synchronized锁升级Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。 偏向锁 ：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。 轻量级锁 ：在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。 重量级锁 ：如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。 Synchromized缺陷不能设置锁超时时间不能通过代码释放锁容易造成死锁 ReentrantLock上面说到Synchronized的缺点，不能设置锁超时时间和不能通过代码释放锁，ReentranLock就可以解决这个问题 在多个条件变量和高度竞争锁的地方 ， 用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性 原文地址(https://www.jianshu.com/p/4eec21c3338e) JVM内存模型、指令重排、内存屏障概念解析(https://www.cnblogs.com/chenyangyao/p/5269622.html) 在java中有以下锁： 公平锁/非公平锁 可重入锁 互斥锁/读写锁 独享锁/共享锁 分段锁 偏向锁/轻量级锁/重量级锁","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"java 内存结构","slug":"java-内存结构","date":"2020-01-13T08:15:01.000Z","updated":"2020-06-01T02:22:37.497Z","comments":true,"path":"blog/2020/01/java-内存结构.html","link":"","permalink":"hexo/blog/2020/01/java-内存结构.html","excerpt":"","text":"java 内存结构首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。 程序计数器程序计数器： 主要功能是记录当前线程执行程序的位置，通过改变计数值来确定执行下一条指令。每个线程的创建，都会创建一个程序计数器，并且对于每个线程而言是互相独立的。比如我们在debuger模式下运行，for循环的停止，异常的抛出，都是通过改变该线程对应的计数值来确定下一个执行指令。 java虚拟机栈java虚拟机栈：主要功能是临时存储线程执行到的每个方法需要的参数，其内存空间在编译时就已确定。与程序计数器一样，每创建一个线程，则创建一个虚拟机栈，线程每执行到一个方法，对应的栈里就会创建一个栈帧，栈帧会存储局部变量表、动态链接、操作数和方法出口等信息，执行方法，栈帧入栈，方法执行完，栈帧出栈。 本地方法栈本地方法栈与java虚拟机栈一样，只是记录native方法执行。jni native调用的c、c++函数 堆得内存结构分为老年代、新生代，内存比为8:2其中新生代分为: edan、from、to 内存分为8:1:1直接new产生的对象被分配到edan（大对象会被直接分配到老年代），当发生GC时，会通过复制清楚算法，清楚edan+from区域可被回收的对象，而不可被回收对象会被复制到to区，而在下一次GC时，会清除edan+to区可回收对象，将不可清楚的对象复制到from区，并且每次回收时，会整理碎片内存。 GCgc分为minor GC、full GCminor 作用区域是新生代内存、算法：复制清除算法。会整理碎片full GC作用区域是老年代内存，算法：标记清除算法，不会整理碎片。 GC时判断是否可回收的依据是：内存可达化：判断堆、方法栈、静态变量、静态方法区中是否有该对象的引用。 每次 gc时会 会stw（stop the world）,线程会被挂起两次","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"算法（1）简单算法","slug":"算法","date":"2020-01-06T07:49:28.000Z","updated":"2020-01-13T10:07:11.324Z","comments":true,"path":"blog/2020/01/算法.html","link":"","permalink":"hexo/blog/2020/01/算法.html","excerpt":"","text":"算法（1）简单算法简单常见算法 二分查找法针对有序的数据集，每次查找时都取中间值，逐步缩小查找范围，最后获取到目标值 复杂度：$O(log_n)$ 选择排序选择排序是针对数组的一种排序算法。过程：遍历数组，计算出最值，新建一个数组，将最值放入新数组, 复杂度：$O(n^2)$ 递归递归指函数在内部调用本身，使用递归注意两个条件：基线条件、递归条件。基线条件：跳出递归的条件递归条件：对递归元素逐步减少的条件，要合理利用这两点，不然容易无限循环。 在数组中取最大值12345678910111213function findMax(arr) &#123; let max = 0; if(arr.length === 0) &#123; return max; &#125; else &#123; max = arr[0] &gt; max ? arr[0] : max; arr.splice(0, 1); return findMax(arr); &#125;&#125;var arr = [1, 2, 3, 4, 5];findMax(arr); 递归算法与数据结构中的 栈 是及其相似的。已上面的算法为例，调用findMax([1,2,3,4,5])时，将findMax([1,2,3,4,5])压入栈顶，而findMax会调用findMax([2,3,4,5]),然后将findMax([2,3,4,5])压入栈,如下图所示： 然后从栈顶依次得出计算结果出栈。 快速排序","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"hexo/tags/算法/"}]},{"title":"数据结构 (1)","slug":"数据结构-1","date":"2020-01-03T09:27:20.000Z","updated":"2020-09-24T06:19:08.580Z","comments":true,"path":"blog/2020/01/数据结构-1.html","link":"","permalink":"hexo/blog/2020/01/数据结构-1.html","excerpt":"","text":"数据结构 (1) - 简单数据数组数组：有序、内存连续的数据集， 数组是有序的，顺序就是插入的顺序，先插入的值排在前面，内存连续：在内存分配时，数组中的值的内存空间是分配在一起的所以在我们使用数组时，推荐在申明时申明数组的长度，不然在后续插入值时可能会导致之前的数据内存空间不够，需要重新分配整个数据内存空间 数组的索引就是数组中值的下标：从0开始计数。数组的查找通过索引，所以快。而增删、修改时，当插入一个值，则需要将后面的数据都后移，删除也是类似。 数组查询快，增删慢查询：O(1)增删：O(n)修改：O(n) 数组查询原理我们知道通过数组查询快，但是为何快呢。 因为数组是内存连续的，当我们通过下标查询时，其实是通过数组0处内存地址+下标 得出该下标对应的内存地址，然后获取存储的对象。 所以查询会快。 链表链表：无序、内存非连续、每个节点都具有下一个节点的地址 链表是无序的，内存非连续，因为每一个节点都含有下一个节点的地址，相比于数组，内存非连续，则当数据增多，也不会存在内存空间的问题，因为只需随便分配下一个节点的内存，然后将上一个节点的中含有的下一个节点地址指向最新分配的地址即可。 链表数据第一个、最后一个节点的值是明确的。因为链表是无序的。所以查询慢，因为想要获取一个节点的值，需要先获取上一个节点，通过上一个节点获取到下一个节点的地址。 查询：O(n)增删：O(1)修改：O(1) 链表分为：单链表、双链表、循环链表 栈栈是一种只允许在一端进行插入或删除的线性表 栈的操作只有两种：出栈、进栈特点：先进后出(FILO:first in last out) 只允许对栈顶的元素操作。最先进入的元素将会被压入栈底 栈可以通过数组实现，也可以通过链表实现 集合队列FIFO 树","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"hexo/tags/数据结构/"}]},{"title":"android 贝塞尔曲线","slug":"android-贝塞尔曲线","date":"2020-01-03T08:46:06.000Z","updated":"2020-01-03T08:46:26.266Z","comments":true,"path":"blog/2020/01/android-贝塞尔曲线.html","link":"","permalink":"hexo/blog/2020/01/android-贝塞尔曲线.html","excerpt":"","text":"","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android-自定义View-继承EditText","slug":"android-自定义View-继承EditText","date":"2019-12-19T09:59:28.000Z","updated":"2019-12-30T10:08:03.595Z","comments":true,"path":"blog/2019/12/android-自定义View-继承EditText.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View-继承EditText.html","excerpt":"","text":"android-自定义View-继承EditText一直觉得flutter中的输入框效果不错。动画，提示标题都有。这次要通过自定义View, 继承重写EditText来实现同样的输入框效果 源码地址 首先确定大致思路两个元素：TextView、EditText，TextView为标题，EditText为输入框展示当未获取焦点时：1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部2、输入框如果没有输入的内容，则输入框展示的提示文本当获取焦点时：不管有无输入内容，提示文本缩小在输入框上部 TextView并非实质组件，只是绘制Text，当作TextView。 1、先写一个类继承AppCompatEditText，并实现构造函数123456789101112131415161718192021public class AnimatedInput extends AppCompatEditText &#123; public AnimatedInput(Context context) &#123; super(context); this.context = context; &#125; public AnimatedInput(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; initView(attrs); &#125; public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initView(attrs); &#125;&#125; 2、重写onFocusChanged函数这样获取到 是否获取焦点的标识位123456@Override protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123; super.onFocusChanged(focused, direction, previouslyFocusedRect); isFocus = focused; postInvalidate(); &#125; 3、重写onTextChanged函数这样获取到输入框的内容value12345@Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; super.onTextChanged(text, start, lengthBefore, lengthAfter); value = text.toString(); &#125; 4、绘制提示文本这时候要分情况，即是否获取焦点、输入框是否有内容1234567891011121314151617181920212223242526272829@Overrideprotected void onDraw(Canvas canvas) &#123; // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸 int width = getMeasuredWidth(); int height = getMeasuredHeight(); top = getPaddingTop(); left = getPaddingLeft(); right = width - left - getPaddingRight(); bottom = height - top; drawTitle(canvas); super.onDraw(canvas);&#125;/** * 绘制标题 * @param canvas */private void drawTitle(Canvas canvas) &#123; if(TextUtils.isEmpty(value)) &#123; if(isFocus) &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125; else &#123; canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint); &#125; &#125; else &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125;&#125; 如此就基本实现了我们的预期目标。这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android-自定义View 继承ViewGroup","slug":"android-自定义View-继承ViewGroup","date":"2019-12-12T07:13:45.000Z","updated":"2019-12-19T10:02:04.746Z","comments":true,"path":"blog/2019/12/android-自定义View-继承ViewGroup.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View-继承ViewGroup.html","excerpt":"","text":"android 自定义View 继承ViewGroup","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 自定义View 继承View","slug":"android-自定义View-继承View","date":"2019-12-11T01:47:36.000Z","updated":"2019-12-19T09:44:13.225Z","comments":true,"path":"blog/2019/12/android-自定义View-继承View.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View-继承View.html","excerpt":"","text":"android 自定义View 继承View上篇关于自定义View的介绍接下来将会针对自定义View三种情况一一实现。 源码地址 最后实现效果如下图： 继承View创建一个class MyView 继承View 目标是写一个折线图 现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;LineView&quot;&gt; &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 先新建一个clas 继承View， 并初始化几个构造函数1234567891011121314151617181920212223242526272829303132public class MyView extends View &#123; // 代码生成时，才会调用该构造函数 public MyView(Context context) &#123; super(context); this.context = context; &#125; public MyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; // xml配置时，会调用这个生命周期 public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initData(attrs); &#125; // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。 private void initData(AttributeSet attrs) &#123; Log.d(TAG, &quot;initData: &quot;); // 获取xml中配置的数据 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView); paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black)); // 画笔初始化 paint = new Paint(); paint.setColor(context.getResources().getColor(R.color.black)); paint.setTextSize(40); paint.setStrokeWidth(10); // 线条粗细 &#125;&#125; 在onMeasure函数中对尺寸做约束12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.d(TAG, &quot;onMeasure: &quot;); int height = measuretDimension(defaultHeight, heightMeasureSpec); int width = measuretDimension(0, widthMeasureSpec); top = 0; left = 0; bottom = top + height; right = left + width; setMeasuredDimension(width, height);&#125;/** * 测量实际尺寸 * @param defaultSize: 默认尺寸 * @param measureSpec: 测量规格 * @return */public int measureDimension(int defaultSize, int measureSpec) &#123; int resultSize = defaultSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; // 没有做限制，取默认值 case MeasureSpec.UNSPECIFIED: resultSize = defaultSize; break; // WRAP case MeasureSpec.AT_MOST: // 要取默认值和测量值中较小值 // 当默认值为0时，取最大值, 即宽充满屏幕 resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize); break; // 具体值 或 MATCH case MeasureSpec.EXACTLY: resultSize = specSize; break; default: break; &#125; return resultSize;&#125; 先绘制两个轴线注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。这两个里的坐标不要弄混。 12345678/** 绘制两条轴线 */private void drawXY(Canvas canvas) &#123; Log.d(TAG, &quot;drawXY: &quot;); // 绘制x轴 canvas.drawLine(left + 20, bottom, right, bottom, paint); // 绘制y轴 canvas.drawLine(left + 20, top, left + 20, bottom, paint);&#125; 在MainActivity中配置该视图123456789&lt;com.justin.customview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot; android:layout_marginTop=&quot;20dp&quot; android:padding=&quot;10dp&quot; app:axieColor=&quot;@color/black&quot; android:id=&quot;@+id/myView&quot; /&gt; 我们直接运行,效果如下： x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。新增一个方法初始化这些尺寸数据 123456789101112131415161718192021/** * 尺寸数据初始化 */private void initSize () &#123; // 获取padding尺寸 paddingLeft = getPaddingLeft(); paddingTop = getPaddingTop(); paddingRight = getPaddingRight(); paddingBottom = getPaddingBottom(); StringBuilder sb = new StringBuilder(); sb.append(&quot;paddingLeft =&quot;).append(paddingLeft) .append(&quot;paddingTop =&quot;).append(paddingTop) .append(&quot;paddingRight =&quot;).append(paddingRight) .append(&quot;paddingBottom =&quot;).append(paddingBottom); Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString())); top = paddingTop; left = paddingLeft; bottom = height - top - paddingBottom; right = width - left; setMeasuredDimension(width, height);&#125; 这样我们就对padding做了处理，接下来接着绘制我们需要的图形。我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头 123456789101112131415161718private void drawArrow(Canvas canvas) &#123; Path path = new Path(); // 先绘制x轴三角 //先移动到三角形一个点 path.moveTo(right-20, bottom + 20); path.lineTo(right-20, bottom - 20); // 画线 path.lineTo(right, bottom); // 画线 path.close(); // 图形闭合 canvas.drawPath(path, paint); // 绘制y轴三角 path.moveTo(left - 20, top + 20); path.lineTo(left + 20, top + 20); path.lineTo(left, top); path.close(); canvas.drawPath(path, paint);&#125; 这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。 设置数据并绘制点我们已经完成了绘制两条轴线，现在要开始绘制数据了。首先我们要确认标准线，x轴的标准线肯定就是xValue的值，但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。我们先假设我们的值在0-100以内，取5条标准线，每条间距20. 先设置两个数据1234567891011121314151617// 数据 private float[] yValue; private String[] xValue; private int lineNum = 5; /** 设置数据并刷新 */ public void setData(float[]yValue, String[]xValue) &#123; this.yValue = yValue; this.xValue = xValue; postInvalidate(); &#125; /** 设置标准线数目 */ public void setData(int lineNum) &#123; this.lineNum = lineNum; postInvalidate(); &#125; 然后我们开始绘制标准线、各个点123456789101112131415161718192021/** 绘制各个点 */private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 5, paint); &#125;&#125; 而在MainActivity.kt中，我们可以这样使用 1234567891011// kotlin语法class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;) var yValue = floatArrayOf(70f, 80f, 90f); myView.setData(yValue, xValue); &#125;&#125; 此时的实现效果： 现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些 绘制x、y轴标准线值，将各个点连接起来。123456789101112131415161718192021222324252627282930313233343536/** 绘制各个点 */ private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; int itemValue = yMax / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); // 绘制y轴标准值 canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 10, paint); // 绘制点与点之间的连线 if(lastX &gt; 0f) &#123; canvas.drawLine(lastX, lastY, x, y, paint); &#125; // 绘制x轴标准值 canvas.drawText(xValue[i-1], x, bottom + 50, paint); lastX = x; lastY = y; &#125; &#125; 最后实现效果如下图：","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"android 自定义View","slug":"android-自定义View","date":"2019-12-10T07:42:49.000Z","updated":"2019-12-10T10:07:35.452Z","comments":true,"path":"blog/2019/12/android-自定义View.html","link":"","permalink":"hexo/blog/2019/12/android-自定义View.html","excerpt":"","text":"Android 自定义View自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。 首页android自定义View有三种类型，1、继承View，多用于实现一些不规则的图形。 2、继承特定的组件，如TextView， 3、继承ViewGroup，用于视图组 在自定义View中有三个关键的方法：onMeasure、onLayout、onDraw onMeasure测量，ViewGroup 会遍历测量子视图的onMeasure方法。一般view 则是在测量自身。 在这个方法中，一般是对视图的尺寸做一些要求。如：处理padding、处理wrap_parent margin是无需处理的，margin其实是在父容器的onMeasure时处理的。 在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。这两个参数都是父容器传递过来。 视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec LayoutParams我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：android:layout_width = “wrap_parent | 50dp | match_parent”存在三种情况，wrap_parent： 自适应大小，50dp: 具体尺寸match_parent: 充满父容器-父容器大小 MeasureSpec测量规格，MeasureSpec由size和mode组成 1.static int getMode(int measureSpec): // 获取mode2.static int getSize(int measureSpec):// 获取size3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec specMode存在三种情况:EXACTLY:具体尺寸、具体值AT_MOST：表示子视图最多只能是specSize中指定的大小UNSPECIFIED：可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。 size：就是LayputParams中指定的大小 而子视图的大小也就是通过size和specMode获取的，具体关系如下图： EXACTLY AT_MOST UNSPECIFIED &lt;-MeasureSpec wrap_parnet EXACTLY AT_MOST AT_MOST match_parent EXACTLY AT_MOST AT_MOST 50dp 50dp 50dp 50dp ^LayoutParams 总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸 下面会讲具体使用 onLayout布局方法 在调用onLayout时，onMeasure已经完成，子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。 onDraw绘制的方法onDraw是在容器的draw方法时调用的。而绘制的顺序为：1.绘制背景2.如果有必要，保存画布的图层，以准备失效3.绘制视图的内容4.绘制子控件5.如果必要，绘制衰落边缘和恢复层6.绘制装饰（比如滚动条） onDraw 有一个参数(Canvas cancas),canvas 就是画布，画布的范围就是onLayout布局后确定的区域","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"react redux","slug":"react-redux","date":"2019-12-03T01:54:38.000Z","updated":"2019-12-03T05:34:32.439Z","comments":true,"path":"blog/2019/12/react-redux.html","link":"","permalink":"hexo/blog/2019/12/react-redux.html","excerpt":"","text":"在react-native中集成redux对react框架而言，状态树、dom树是它的一大优势。而redux就是对数据、状态进行管理。 集成redux1、执行1234npm install redux --savenpm install react-redux --savenpm install redux-thunk --savenpm i redux-logger --save 以上命令下载关于redux的组件。 2、store的配置1234567891011121314// configStore.jsimport &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import rootReducer from &apos;./reducer&apos;;const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);export default configStore =(initState) =&gt; &#123; const store = createStoreWithMiddleware(rootReducer, initState); return store;&#125; 而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰 123456789101112// rootReducerimport &#123; combineReducers &#125; from &apos;redux&apos;;import &#123; reducer as test &#125; from &apos;../Home/store&apos;;const appReducer = combineReducers(&#123; test,&#125;);const rootReducer =(state, action) =&gt; &#123; return appReducer(state, action);&#125;export default rootReducer; test是一个测试的reducer。 在入口处，绑定store，在入口文件中：1234567891011121314151617181920AppRegistry.registerComponent(&apos;projectName&apos;, () =&gt; Root);// 指向了root.js，在root.js中：import &#123; Provider &#125; from &apos;react-redux&apos;;import configStore from &apos;./store/configStore&apos;;const store = configStore();export default class Root extends React.PureComponent &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &#123;...&#125; &lt;/View&gt; &lt;/Provider&gt; ) &#125;&#125; 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142// actionType.jsexport const TEST_REDUCE = &quot;TEST_REDUCE&quot;;// test action.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const test =() =&gt; (&#123; type: TEST_REDUCE,&#125;)export &#123; test,&#125;// test reducer.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const initState = &#123; num: 0,&#125;export default reducer = (state = initState, action) =&gt; &#123; switch(action.type) &#123; case TEST_REDUCE: return &#123; ...state, num: state.num + 1, &#125; default: return &#123; ...initState, &#125; &#125;&#125; 在组件component中使用Test.js 123456789101112131415161718192021222324252627282930313233343536373839import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; action &#125; from &apos;./store&apos;class Test extends Component &#123; testFunction =() =&gt; &#123; this.props.action.test(); &#125; render() &#123; const &#123; num &#125; = this.props; return ( &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;this.testFunction&#125; &gt; &lt;Text&gt; 触发按钮 &lt;/Text&gt; &lt;Text&gt;&#123;num&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; (&#123; num: state.test.num,&#125;)const mapActionToProps = dispatch =&gt; &#123; return &#123; action: bindActionCreators(action, dispatch), &#125;&#125;export default connect(mapStateToProps, mapActionToProps)(Test); 具体的使用方法已在上面，下面再去讲解redux原理 redux原理说明redux状态管理大致流程： component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render reducer中数据改变即store中数据改变为何会导致 component props改变呢？其实就是connect函数。 我们在组件中，export default connect(mapStateToProps, mapActionToProps)(Test);connet是一个柯里化函数。第一组入参两个：第一个mapStateToProps，其实就是将store中的数据绑定到props，第二个mapActionToProps，是将action函数绑定到props，所以我们在使用是，如取store中的值，const { num } = this.props;dispatch action：this.props.action.test(); 第二组入参：当前的Test对象。 再往深考虑connect 函数","categories":[],"tags":[{"name":"react","slug":"react","permalink":"hexo/tags/react/"}]},{"title":"android sqlite的使用","slug":"android-sqlite的使用","date":"2019-11-19T06:01:11.000Z","updated":"2019-11-21T03:43:42.735Z","comments":true,"path":"blog/2019/11/android-sqlite的使用.html","link":"","permalink":"hexo/blog/2019/11/android-sqlite的使用.html","excerpt":"","text":"android sqlite的使用1、创建表a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法 onCreate（SQLiteDatabase）在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。 onUpgrade（SQLiteDatabase，int，int）当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。 onOpen（SQLiteDatabase）这是当打开数据库时的回调函数，一般在程序中不是很常使用。 在构造函数中创建数据库12345678910// 数据表名 private static final String TABLE_NAME = &quot;userlog.db&quot;; public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public MyDatabase(Context context, int version) &#123; this(context, TABLE_NAME, null, version); &#125; 在onCreate方法中创建数据表数据库数据类型：NULL：null值INTEGER：整数，1、2、3、4、6、8字节REAL：浮点值，8字节TEXT：字符串BLOB：blob数据DATE：日期 年月日TIME：时刻 时分秒 1234567@Override public void onCreate(SQLiteDatabase db) &#123; Log.d(TAG, &quot;onCreate: onCreate&quot;); String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;; db.execSQL(sql); &#125; 然后在需要建表的实话，初始化一个该java类实例即可 增删改查增加 insert 一条数据1、使用sql语句插入一条数据12String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;db.execSQL(sql); 但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’ 此时应该使用 ? 替代符，如下：1234567891011public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123; SQLiteDatabase db = getWritableDatabase(); StringBuilder sql = new StringBuilder(); sql.append(&quot;insert into &quot;) .append(table_name) .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;); Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;; Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString()))); db.execSQL(sql.toString(), values); db.close();&#125;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"ValueAnimator","slug":"ValueAnimator","date":"2019-10-22T08:48:04.000Z","updated":"2019-10-22T08:48:33.038Z","comments":true,"path":"blog/2019/10/ValueAnimator.html","link":"","permalink":"hexo/blog/2019/10/ValueAnimator.html","excerpt":"","text":"属性动画 ValueAnimator","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"canvas 中的方法","slug":"canvas-中的方法","date":"2019-10-22T08:09:46.000Z","updated":"2020-09-04T01:11:22.578Z","comments":true,"path":"blog/2019/10/canvas-中的方法.html","link":"","permalink":"hexo/blog/2019/10/canvas-中的方法.html","excerpt":"","text":"canvas 中的一些方法在canvas中一般使用的方法为drawXXX(): 绘制的方法clipXXX(): 裁剪的方法 clipRect裁剪画布，clipRect(int left, top, right, bottom);clipRectF(float left, top, right, bottom) 当执行了该方法，如clipRect(0,0,500,500);则后面都只能在(0,0,500,500)区域绘制 用Rect实现多区域裁剪intersect 交集】12345678Rect rect = new Rect(0, 0, 500, 500); rect.intersect(250, 250, 750, 750); canvas.clipRect(rect);// 取到区域(250, 250, 500, 500) 绘制多个区域相交的区域 union 合集12345678Rect rect = new Rect(0, 0, 500, 500); rect.union(250, 250, 750, 750); canvas.clipRect(rect);// 取到的区域为(0, 0, 750, 750) 绘制多个区域之和 clipPath 取出某个区域12345678910111213// 实例化路径mPath = new Path();// 移动起点至[50,50]mPath.moveTo(50, 50); mPath.lineTo(75, 23); mPath.lineTo(150, 100); mPath.lineTo(80, 110); // 闭合路径mPath.close();// 按照路径进行裁剪canvas.clipPath(mPath); 即是将path区域裁剪出来同样后面在能在该path区域绘制图形 Region.Opcanvas.drawRect","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"hashMap解析","slug":"hashMap解析","date":"2019-09-03T06:01:51.000Z","updated":"2019-09-03T07:31:47.454Z","comments":true,"path":"blog/2019/09/hashMap解析.html","link":"","permalink":"hexo/blog/2019/09/hashMap解析.html","excerpt":"","text":"HashMap源码分析Hash内部类Node：Node(节点)，链表中的节点，当HashMap数据少于6条时，为链表结构，Node为其中的节点。链表数据结构，每一个节点都记录下一个节点的地址。在Node的构造函数中，直接包含了下一个节点，1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; // 将下一个节点作为入参放入构造函数中 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; .... 获取某个节点12345678910111213141516171819202122232425262728293031 public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 当为树结构的时候 if (first instanceof TreeNode) // 获取树形结构中某个节点 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 遍历链表结构 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"hexo/tags/java/"}]},{"title":"升级rn版本适配android64","slug":"升级rn版本适配android64","date":"2019-08-21T01:31:14.000Z","updated":"2019-08-21T01:38:46.589Z","comments":true,"path":"blog/2019/08/升级rn版本适配android64.html","link":"","permalink":"hexo/blog/2019/08/升级rn版本适配android64.html","excerpt":"","text":"google play在2019/08/01起实施强制支持64位手机的措施。 因为之前的version为0.55.4,到0.59.1版本更新太多，采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目","categories":[],"tags":[{"name":"react-native","slug":"react-native","permalink":"hexo/tags/react-native/"}]},{"title":"Rxjava + Retrofit 实现BaseResult","slug":"Rxjava-Retrofit-实现BaseResult","date":"2019-07-25T03:24:56.000Z","updated":"2019-07-25T03:25:23.897Z","comments":true,"path":"blog/2019/07/Rxjava-Retrofit-实现BaseResult.html","link":"","permalink":"hexo/blog/2019/07/Rxjava-Retrofit-实现BaseResult.html","excerpt":"","text":"Rxjava + Retrofit 实现BaseResult最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。答案肯定是可以的。本文只讲使用。 依赖：12345implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos; 普通使用案例首先创建实体数据类Test 1234567891011121314public class Test &#123; private static final String TAG = &quot;=====TEST&quot;; String key = &quot;&quot;; String test = &quot;&quot;; public void log() &#123; Log.d(TAG,&quot;key=&quot; + key); Log.d(TAG, &quot;test=&quot; + test); &#125;&#125; 在写一个接口TestServer，申明请求 1234public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用请求1234567891011121314151617181920212223242526272829303132private void testService() &#123; // 实例化一个Retrofit 对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.1.42:8080/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); TestServer service = retrofit.create(TestService.class); service.getObJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Test&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Test test) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125; 开发考虑我们不可能每个请求都重新创建一个Retrofit对象，而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。 1、写一个result实体类1234567891011121314151617181920212223242526272829303132// 因为每一个接口返回的数据结构都不同，肯定要用泛型。public class Result&lt;T&gt; &#123; private final String TAG = &quot;Result ====&quot;; private String msg; private String code = &quot;0&quot;; private T data; public void logCode() &#123; Log.d(TAG, code); &#125; public long getLongCode() &#123; long resultCode = 0; if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123; resultCode = Long.parseLong(code); &#125; return resultCode; &#125; public void log() &#123; Log.d(TAG, &quot;msg:&quot; +msg + &quot;\\n code:&quot; + code + &quot;\\n data:&quot; + data); &#125; public T getResultData() &#123; return data; &#125;&#125; 注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论 然后需要写一个BaseObserver观察者基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里还是因为接口返回数据格式问题，使用泛型。public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123; private final String TAG = &quot;====BaseObserver===&quot;; /** * 请求成功 * @param t */ public abstract void onSuccess(T t); /** * 当返回的code值错误时的默认方法 * @param code */ public void onResultCodeErr(long code) &#123; Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code); &#125; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(Result result) &#123; if(result.getLongCode() != 200) &#123; onResultCodeErr(result.getLongCode()); &#125; else &#123; onSuccess((T)result.getResultData()); &#125; result.log(); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); Log.d(TAG, e.getMessage()); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125;&#125; 然后我们的Server类就变成了如下：123456789public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson(); @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用就变成了这样： 1234567891011121314151617BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123; @Override public void onSuccess(Test test) &#123; Log.d(&quot;======&quot;, &quot;onSuccess&quot;); test.log(); &#125; &#125;; /** Retrofit + Rxjav */ private void testRxjavaService() &#123; Retrofit retrofit = RetrofitUtil.getRetrofit(); TestService ts = retrofit.create(TestService.class); ts.getTestRxjavaJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"Flutter入门（三）布局组件","slug":"Flutter入门（三）布局组件","date":"2019-07-25T03:00:09.000Z","updated":"2019-07-25T03:10:55.549Z","comments":true,"path":"blog/2019/07/Flutter入门（三）布局组件.html","link":"","permalink":"hexo/blog/2019/07/Flutter入门（三）布局组件.html","excerpt":"","text":"Flutter入门（三）布局组件之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！ 查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍 ui组件学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。 Text123456789101112131415Text( &apos;要显示的文本&apos;, &#123; textAlign: TextAlign.center, // 文本横向对齐方式 居中 overflow: TextOverflow.ellipsis, // 文本溢出处理方式 textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left) softWrap: true, // 是否自动换行 textScaleFactor: 2.0, // 字体显示倍率 maxLines: 1, // 文本最大行数 style: new TextStyle( color: Colors.purple, fontSize: 20.0, ), // 文本样式 &#125;)","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"flutter入门  vscode调试及查看日志","slug":"flutter入门-vscode调试及查看日志","date":"2019-07-25T02:55:36.000Z","updated":"2019-07-25T03:12:04.381Z","comments":true,"path":"blog/2019/07/flutter入门-vscode调试及查看日志.html","link":"","permalink":"hexo/blog/2019/07/flutter入门-vscode调试及查看日志.html","excerpt":"","text":"flutter入门 vscode调试及查看日志开发肯定需要调试应用，以及查看日志。 在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。 还有一个print()函数，最终发现这个是可以的。 情景再现a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。 b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出 c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出 正确方法print()日志输出函数通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出 ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。 用vscode调试flutetr一个正常的flutter项目用vscode应该是这样的。之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。 点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目 我打了一个断点，当项目运行起来，如下图。 当我点击按钮，进入断点。如下图可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。 添加断点点击代码左侧的红框区域即可（下图）。 在左上角的调试/新建断点 也可以。","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"Flutter入门（二） 使用vscode编写第一个Flutter应用","slug":"Flutter入门（二）-使用vscode编写第一个Flutter应用","date":"2019-07-25T02:51:37.000Z","updated":"2019-07-25T03:12:34.757Z","comments":true,"path":"blog/2019/07/Flutter入门（二）-使用vscode编写第一个Flutter应用.html","link":"","permalink":"hexo/blog/2019/07/Flutter入门（二）-使用vscode编写第一个Flutter应用.html","excerpt":"","text":"Flutter入门（二） 使用vscode编写第一个Flutter应用在上一篇中我们利用android studio运行了一个hello word项目。作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。 ###1、配置插件需要在vscode中下载插件找到这两个插件下载好并重新加载vscode就可以了。 ###2、运行flutter项目的运行命令是 flutter run但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。 在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。还有有一些提示信息 当你需要热加载的时候按 r，需要重启应用按R。所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。 ###3、写第一个flutter应用。按照flutter中文网（https://flutterchina.club/get-started/codelab/）写我们第一个flutter应用。其中我个人碰到一个问题。就是在第2步、使用外部package中， 在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。然后重新打开vscode才好，应该是vscode对这个以来的读取问题。 然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。 ###个人体会 flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼 fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。没有对state这个做解释、没有state的使用说明，然后那个路由也是。 ##待续","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"Flutter入门（一）环境配置","slug":"Flutter入门（一）环境配置","date":"2019-07-25T02:41:53.000Z","updated":"2019-07-25T03:12:56.177Z","comments":true,"path":"blog/2019/07/Flutter入门（一）环境配置.html","link":"","permalink":"hexo/blog/2019/07/Flutter入门（一）环境配置.html","excerpt":"","text":"Flutter入门（一）环境配置在/flutter/bin目录下执行 flutter doctor命令。 3、android studio插件下载android studio就不说了，打开android studio/file/setting/plugin/输入 flutter查找并install。第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。 在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project hello word按照惯例，接下来我们跑一个hello world。 照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。 项目目录 项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。 运行点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行 第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"flutter数据持久化","slug":"flutter数据持久化","date":"2019-07-25T02:40:34.000Z","updated":"2019-07-25T02:40:56.389Z","comments":true,"path":"blog/2019/07/flutter数据持久化.html","link":"","permalink":"hexo/blog/2019/07/flutter数据持久化.html","excerpt":"","text":"flutter数据持久化shared_preferences本地存储临时数据此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。 添加插件依赖： 123456// 在pubspec.yaml文件中添加依赖dependencies: flutter: sdk: flutter shared_preferences: &quot;&lt;newest version&gt;&quot; 调用： shared_preference 存储方式是根据key-value形式使用便捷，但有限制： a: 只能使用原始类型: int，double，bool，string 和 string list。 b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。 1234567891011import &apos;package:shared_preferences/shared_preferences.dart&apos;;getAsyncData() async &#123; // 获取实例 var prefs = await SharedPreferences.getInstance(); // 获取存储数据 var count = prefs.getInt(&apos;count&apos;) ?? 0 + 1; // 设置存储数据 await prefs.setInt(&apos;count&apos;, count);&#125;","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"dart语言语法糖","slug":"dart语言语法糖","date":"2019-07-25T02:35:05.000Z","updated":"2019-07-25T02:35:29.306Z","comments":true,"path":"blog/2019/07/dart语言语法糖.html","link":"","permalink":"hexo/blog/2019/07/dart语言语法糖.html","excerpt":"","text":"dart语言语法糖a、 以 _命名的变量或函数为强制私有 var _num; b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式 1234int getInt() =&gt; 2;int getInt() =&gt; isTrue ? 2 : 0; c、 运算符 aa ?? bb; ?? 为null 时 d、异步 async await then async、await使用与rn中使用方式一致 .then也是异步操作 12345678910111213141516171819202122232425/// 设置需要填写的内容 _setDefaultData(List&lt;dynamic&gt; list) &#123; Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;); List&lt;dynamic&gt; list1 = []; /// 对jsonStr数据做解析 jsonStr.then((value) &#123; var data = json.decode(value); if(list != null || list.length &gt; 0) &#123; data = list; &#125; print(&apos;data ====&apos; + data.toString()); data.forEach((item) &#123; if(item[&apos;type&apos;] == &apos;1&apos;) &#123; list1.add(item); &#125; &#125;); &#125;); print(&apos;list1======&apos; + list1.toString()); this.setState(() &#123; this.saveList = list1; &#125;); &#125; 如图这种代码会先输出list1的信息，然后在输出data的信息说明jsonStr.then 为异步操作","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"flutter android端 原理解析","slug":"flutter-android端-原理解析","date":"2019-07-25T02:32:54.000Z","updated":"2019-07-25T02:33:34.203Z","comments":true,"path":"blog/2019/07/flutter-android端-原理解析.html","link":"","permalink":"hexo/blog/2019/07/flutter-android端-原理解析.html","excerpt":"","text":"flutter android端 原理解析首先看MainActivity， 继承FlutterActivity 再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory 12345678910111213141516private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);private final FlutterActivityEvents eventDelegate;private final Provider viewProvider;private final PluginRegistry pluginRegistry;public FlutterActivity() &#123; this.eventDelegate = this.delegate; this.viewProvider = this.delegate; this.pluginRegistry = this.delegate;&#125;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.eventDelegate.onCreate(savedInstanceState);&#125; 一看delegate就知道代理模式 在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值， FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。 FlutterActivityDelegate 就是FlutterActivityEvents类的实现. 看FlutterActivityDelegate类中的onCreate函数 123456789101112131415161718192021222324252627282930public void onCreate(Bundle savedInstanceState) &#123; if (VERSION.SDK_INT &gt;= 21) &#123; Window window = this.activity.getWindow(); window.addFlags(-2147483648); window.setStatusBarColor(1073741824); window.getDecorView().setSystemUiVisibility(1280); &#125; String[] args = getArgsFromIntent(this.activity.getIntent()); FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args); this.flutterView = this.viewFactory.createFlutterView(this.activity); if (this.flutterView == null) &#123; FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView(); this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView); this.flutterView.setLayoutParams(matchParent); this.activity.setContentView(this.flutterView); this.launchView = this.createLaunchView(); if (this.launchView != null) &#123; this.addLaunchView(); &#125; &#125; if (!this.loadIntent(this.activity.getIntent())) &#123; String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext()); if (appBundlePath != null) &#123; this.runBundle(appBundlePath); &#125; &#125; &#125; 首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。 android端与dart端通信1、dart端调用android端代码1、原生android代码新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。 重写onMethodCall方法，在此处写需要实现的逻辑代码 最后是将插件绑定。 12345678910111213141516171819202122232425262728293031323334public class TestPlugin implements MethodChannel.MethodCallHandler &#123; public static final String CHANNEL = &quot;plugin/test&quot;; static MethodChannel channel; // 上下文 private Activity activity; private TestPlugin(Activity activity) &#123; this.activity = activity; &#125; public static void registerWith(PluginRegistry.Registrar registrar) &#123; channel = new MethodChannel(registrar.messenger(), CHANNEL); TestPlugin plugin = new TestPlugin(registrar.activity()); // 在此通道上接受方法调用的回调 channel.setMethodCallHandler(plugin); &#125; @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123; if(methodCall.method.equals(&quot;test&quot;)) &#123; Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show(); result.success(&quot;调用成功&quot;); &#125; // 当未找到该函数 result.notImplemented(); &#125;&#125; 在MainActivity中绑定 1234567891011121314151617public class MainActivity extends FlutterActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); registerPlugin(this); &#125; private void registerPlugin(PluginRegistry registry) &#123; TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL)); &#125;&#125; 2、在dart中调用该原生方法1234567static const _platform = const MethodChannel(&apos;plugin/test&apos;);_toast() &#123; /// 调用原生的方法 _platform.invokeMethod(&apos;test&apos;); &#125; 一个原生插件调用就完成了。","categories":[],"tags":[{"name":"flutter","slug":"flutter","permalink":"hexo/tags/flutter/"}]},{"title":"facebook推广api 推广主页","slug":"facebook推广api-推广主页","date":"2019-07-11T02:58:31.000Z","updated":"2019-07-11T03:01:09.159Z","comments":true,"path":"blog/2019/07/facebook推广api-推广主页.html","link":"","permalink":"hexo/blog/2019/07/facebook推广api-推广主页.html","excerpt":"","text":"主页推广","categories":[],"tags":[]},{"title":"maven","slug":"maven","date":"2019-07-08T06:36:59.000Z","updated":"2020-05-13T07:54:35.649Z","comments":true,"path":"blog/2019/07/maven.html","link":"","permalink":"hexo/blog/2019/07/maven.html","excerpt":"","text":"mavenmaven 查看依赖树mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXXcode xxx // 打开xxx文件 // gradle 查看依赖树gradle app:dependency // 查看依赖树关系","categories":[],"tags":[]},{"title":"react发布到javaweb","slug":"react发布到javaweb","date":"2019-07-05T06:29:35.000Z","updated":"2019-07-05T09:33:42.061Z","comments":true,"path":"blog/2019/07/react发布到javaweb.html","link":"","permalink":"hexo/blog/2019/07/react发布到javaweb.html","excerpt":"","text":"react项目发布到javaweb中1、打包react直接执行npm run build命令：发现在build目录下生成资源文件，但是打开index.html发现报错，发现在生成的index.html中引入的文件路径有问题：/static /多余，或者说少了. 正确的路径应该是：static 或者 ./static 发现是%PUBLIC_URL%问题，在构建时应该执行 PUBLIC_URL=./ npm run build 2、集成到javaweb中将上一步生成build目录下的文件都复制放在webapp路径下，启动应用就能直接访问到index.html文件","categories":[],"tags":[{"name":"react+spring","slug":"react-spring","permalink":"hexo/tags/react-spring/"}]},{"title":"facebook 营销api集成","slug":"facebook-营销api集成","date":"2019-06-28T02:15:25.000Z","updated":"2019-07-11T03:08:15.587Z","comments":true,"path":"blog/2019/06/facebook-营销api集成.html","link":"","permalink":"hexo/blog/2019/06/facebook-营销api集成.html","excerpt":"","text":"facebook 营销api集成营销api需要通过后端服务器与facebook服务器交互 1、下载营销api java代码git clone https://github.com/facebook/facebook-java-business-sdk.git 编辑器：IDEA 123456789101112// 在pom.xml中添加依赖&lt;dependency&gt; &lt;groupId&gt;com.facebook.business.sdk&lt;/groupId&gt; &lt;artifactId&gt;facebook-java-business-sdk&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;插件maven-source-plugin 无法下载因缺失版本号添加&lt;version&gt;3.1.0&lt;/version&gt;// 解决idea报错在&lt;build&gt;&lt;/build&gt;标签内添加&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;在&lt;plugins&gt;&lt;/plugins&gt;标签外套一个标签&lt;pluginManagement&gt;&lt;/pluginManagement&gt; 添加java文件123456789101112131415161718192021222324252627282930import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;import com.facebook.ads.sdk.APIException;public class QuickStartExample &#123; public static final String ACCESS_TOKEN = &quot;[Your access token]&quot;;//Your access token public static final Long ACCOUNT_ID = 123456789L; //Your account ID public static final String APP_SECRET = &quot;[Your app secret]&quot;;//Your app secret public static final APIContext context = new APIContext(ACCESS_TOKEN, APP_SECRET); public static void main(String[] args) &#123; try &#123; System.out.println(&quot;==========&quot;); AdAccount account = new AdAccount(ACCOUNT_ID, context); Campaign campaign = account.createCampaign() .setName(&quot;Java SDK Test Campaign&quot;) .setObjective(Campaign.EnumObjective.VALUE_LINK_CLICKS) .setSpendCap(10000L) .setStatus(Campaign.EnumStatus.VALUE_PAUSED) .execute(); System.out.println(campaign.fetch()); &#125; catch (APIException e) &#123; e.printStackTrace(); &#125; &#125;&#125; or 123456789101112131415161718192021222324import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.APINodeList;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;public class TestFBJavaSDK&#123; public static final APIContext context = new APIContext( &quot;your-access-token&quot;, &quot;your-appsecret&quot; ); public static void main(String[] args) &#123; AdAccount account = new AdAccount(&quot;act_&#123;your-adaccount-id&#125;&quot;, context); try &#123; APINodeList&lt;Campaign&gt; campaigns = account.getCampaigns().requestAllFields().execute(); for(Campaign campaign : campaigns) &#123; System.out.println(campaign.getFieldName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行java文件既可发布请求到facebook服务器， 需要安全上网 1、主页推广根据提示一步一步提交，到 沙盒账号，如果之前没有添加则新建，要推广的主页，如果无则新建 到下载示例代码，点下载，将会获得一个java文件，里面含有accessToken、appid、ad_account_id、app_secret等信息，将该下载的SAMPLE_CODE.java文件放于与上面两个java文件同级目录，直接运行该java文件即可，注意此时电脑需要科学上网，不然会报错Timeout","categories":[],"tags":[{"name":"facebook","slug":"facebook","permalink":"hexo/tags/facebook/"}]},{"title":"facebook sdk 集成","slug":"facebook-sdk-集成","date":"2019-06-26T08:52:30.000Z","updated":"2019-12-10T10:14:02.050Z","comments":true,"path":"blog/2019/06/facebook-sdk-集成.html","link":"","permalink":"hexo/blog/2019/06/facebook-sdk-集成.html","excerpt":"","text":"Facebook sdk 集成首先需要在facebook注册一个账号，自通过账号进入facebook的开发者平台 创建应用，只需要填写应用名即可，回生成一个appid。 集成事件功能1、配置远端maven仓库地址 在项目android/build.gradle文件123456789101112131415buildscript&#123; repositories&#123; ... mavenCentral(); // 添加这行 &#125;&#125;allprojects&#123; repositories &#123; ... mavenCentral() // 添加这行 &#125;&#125; 2、添加依赖在app/build.gradle文件中添加依赖123456dependencies&#123; ... implementation &apos;com.facebook.android:facebook-android-sdk:[4,5)&apos; // 添加这行 // 最新sdk版本为 implementation &apos;com.facebook.android:facebook-android-sdk:[5,6)&apos; &#125; 3、添加facebook-app-id在res/values/string.xml中1234&lt;string name=&quot;facebook_app_id&quot;&gt;462119014332748&lt;/string&gt; &lt;string name=&quot;fb_login_protocol_scheme&quot;&gt;fb462119014332748&lt;/string&gt;// 462119014332748为你在facebook应用的appid// fb_login_protocol_scheme应该是用于登陆的 在/app/manifest/AndroidManifest.xml中12345678910111213141516&lt;application&gt; &lt;meta-data android:name=&quot;com.facebook.sdk.ApplicationId&quot; android:value=&quot;@string/facebook_app_id&quot;/&gt; &lt;activity android:name=&quot;com.facebook.FacebookActivity&quot; android:configChanges= &quot;keyboard|keyboardHidden|screenLayout|screenSize|orientation&quot; android:label=&quot;@string/app_name&quot; /&gt; &lt;activity android:name=&quot;com.facebook.CustomTabActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;@string/fb_login_protocol_scheme&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 4、在facebook开发者控制台配置analytics sdk在facebook开发者官网，点击「我的应用」即可进入应用控制台，可以创建应用，只需提供应用名，以及邮箱即可， 点击单个应用即可进入应用控制台进行编辑;上图是应用可添加的功能， 点击Analytics即将功能添加进应用，点设置，前几步都是提示，第四步，填入应用id，app/build.gradle中的applicationid，以及应用默认启动的Actiivty， 第五步，填入密钥散列，注意应该要填入两个，一个开发、一个发布，即debug自带的、一个release时通过jks文件签名生成的。获取方法12345// macos debug ，按下enter键需要输入开机密码keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64// release keytool -exportcert -alias YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl base64 5、发送事件 上面的1、2、3都只是基本配置，下面是手动发送事件 在MainApplication.java中FacebookSdk.sdkInitialize 四个初始化方法都已被遗弃， 看到说是不需要初始化了 在MainApplication.java中 12345678910@Override public void onCreate() &#123; super.onCreate(); // facebook 初始化 FacebookSdk.setIsDebugEnabled(true); AppEventsLogger.activateApp(MainApplication.this); FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS); &#125; 注意facebooksdk回自动收集一些事件,如果不需要自动收集功能需要在清单文件中配置 1234&lt;meta-data android:name=&quot;com.facebook.sdk.AutoLogAppEventsEnabled&quot; android:value=&quot;false&quot;/&gt; 在Actiivty中测试发送自定义事件 123456789101112@Overrideprotected void onResume() &#123; super.onResume(); logEvent();&#125;private void logEvent() &#123; Log.d(&quot;========&quot;, &quot;logEvent&quot;); AppEventsLogger logger = AppEventsLogger.newLogger(this); logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP); logger.logEvent(&quot;Test Event&quot;);&#125; 在测试时发现，当打断点调试时发现，发送事件总是会失败，正常运行却可以在facebook分析工具中看得到提交的事件。 后续：在sdk集成后，可以看到之前定义的事件数据。但是在连接商务平台，想要发布广告时。需要通过自己的事件来定义受众、或者定义类似受众时发现，在商务平台无法获取到自定义事件的数据。甚至都无法获取到我们的应用。后来看官方文档，发现出了自定义事件、自动收集的事件，还有一个标准事件。在我添加了一个标准事件后，就在商务平台上能找到在开发平台提交的app了。但是那些自定义受众、类似受众功能貌似只能绑定到 facebook定义的标准事件，而不能是我们自己的自定义事件 注意，运行时手机需要能连接到facebook后台服务器，大陆用户需要科学上网。","categories":[],"tags":[{"name":"facebook","slug":"facebook","permalink":"hexo/tags/facebook/"}]},{"title":"android okHttp3","slug":"android-okHttp3","date":"2019-06-18T02:52:40.000Z","updated":"2019-07-05T09:34:01.205Z","comments":true,"path":"blog/2019/06/android-okHttp3.html","link":"","permalink":"hexo/blog/2019/06/android-okHttp3.html","excerpt":"","text":"OkHttp3使用","categories":[],"tags":[{"name":"android","slug":"android","permalink":"hexo/tags/android/"}]},{"title":"vscode的常用插件与插件开发","slug":"vscode的常用插件与插件开发","date":"2019-04-28T07:06:57.000Z","updated":"2019-04-28T07:43:46.000Z","comments":true,"path":"blog/2019/04/vscode的常用插件与插件开发.html","link":"","permalink":"hexo/blog/2019/04/vscode的常用插件与插件开发.html","excerpt":"Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。","text":"Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。 nodejs123456curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash. ~/.bashrc#显示有远端的版本nvm ls-remote#安装对应的版本nvm install 对应的版本 安装常用工具： 1234567891011npm install hexo-cli -gnpm install hexo-server -gnpm install hexo-deployer-git -gnpm install yarn -gnpm install http-server -gyarn global add servenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalyarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 常用插件安装以下插件：12345678910111213141516171819202122232425262728293031323334#javascripteslintColor PickernpmDebugger for ChromeEclipse Keymap#reactES7 React/Redux/GraphQL/React-Native snippets#vueVeturVue VSCode Snippets#gitGitLenszerofinance-git#其他公共插件Local HistoryXML ToolsPrettier#https://zhuanlan.zhihu.com/p/54031899koroFileHeaderAutoFileNameImport Cost#javaJava Extension PackSpring Boot Extension PackJava Code GeneratorsDocker#android/ios pluginAndroid iOS EmulatorReact Native Tools#see debug:https://github.com/Microsoft/vscode-react-native/blob/master/doc/debugging.md#debugging-on-ios-device#Install ios-deploy: npm install -g ios-deploy 代码注释koroFileHeader添加注释，在全局的settings.json中添加： 参考： https://code.visualstudio.com/docs/editor/emmet https://www.cnblogs.com/summit7ca/p/6944215.html 12345678910111213141516171819202122232425262728\"editor.fontSize\": 14,\"terminal.integrated.fontSize\": 14,\"emmet.triggerExpansionOnTab\": true,\"emmet.includeLanguages\": &#123; \"javascript\": \"javascriptreact\", \"vue-html\": \"html\", \"razor\": \"html\", \"plaintext\": \"jade\"&#125;,// 注释\"fileheader.configObj\": &#123; // 将该选项设置为true即可开启 \"autoAdd\": false&#125;,// 头部注释\"fileheader.customMade\": &#123; \"Author\": \"dave.zhao\", \"Date\": \"Do not edit\", \"LastEditors\": \"dave.zhao\", \"LastEditTime\": \"Do not edit\", \"Description\": \"\"&#125;,// 函数注释\"fileheader.cursorMode\": &#123; \"Date\": \"Do not edit\", \"description\": \"\", \"param\": \"\"&#125; 注意：Author和LastEditors填写自己的名字 文件头注释快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i 函数注释快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t 常用配置可以放在全局的settings.json中，也可以放在各个项目的settings.json中： 1234567891011121314151617181920&#123; \"eslint.validate\": [\"javascript\", \"javascriptreact\"], \"javascript.updateImportsOnFileMove.enabled\": \"always\", // 代码缩进修改成4个空格 \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.formatOnSave\": true, // 每次保存的时候将代码按eslint格式进行修复 \"eslint.autoFixOnSave\": true, // 让prettier使用eslint的代码格式进行校验 \"prettier.eslintIntegration\": true, // 去掉代码结尾的分号 \"prettier.semi\": false, // 使用带引号替代双引号 \"prettier.singleQuote\": true, \"prettier.tabWidth\": 4, \"prettier.printWidth\": 250, // 让函数(名)和后面的括号之间加个空格 \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true&#125; 插件开发参考代码https://github.com/zhaoxunyong/vs-code-git-plugin 参考 https://segmentfault.com/a/1190000008968904 https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://github.com/steveukx/git-js https://www.jianshu.com/p/2b096d8ad9b8 https://github.com/Microsoft/vscode-extension-samples https://www.jianshu.com/p/520c575e91c3 https://segmentfault.com/a/1190000017279102 https://segmentfault.com/a/1190000014758981 https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path","categories":[{"name":"vscode","slug":"vscode","permalink":"hexo/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"hexo/tags/vscode/"}]}]}