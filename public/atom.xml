<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Happy To Try</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2020-09-28T08:46:16.928Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fragment的懒加载实现，参数传递与保存</title>
    <link href="hexo/blog/2020/09/Fragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%9D%E5%AD%98.html"/>
    <id>hexo/blog/2020/09/Fragment的懒加载实现，参数传递与保存.html</id>
    <published>2020-09-28T08:07:59.000Z</published>
    <updated>2020-09-28T08:46:16.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h1><p>关于Fragment的懒加载，针对ViewPager、ViewPager2又有不同，</p><h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>针对ViewPager，其实是使用Fragment中的setUserVisibleHint函数，通过getUserVisibleHint()获取当前的Fragment是否可见，<br>当不可见时，则不加载，当可见时再创建视图并缓存。<br>这样可以只加载一次，大致原理就是如此。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fragment懒加载&quot;&gt;&lt;a href=&quot;#Fragment懒加载&quot; class=&quot;headerlink&quot; title=&quot;Fragment懒加载&quot;&gt;&lt;/a&gt;Fragment懒加载&lt;/h1&gt;&lt;p&gt;关于Fragment的懒加载，针对ViewPager、ViewPag
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Application生命周期</title>
    <link href="hexo/blog/2020/09/Application%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>hexo/blog/2020/09/Application生命周期.html</id>
    <published>2020-09-28T06:44:45.000Z</published>
    <updated>2020-09-28T07:57:42.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><p>Application是指代一个应用，默认我们在android应用中可以不指定，<br>也可以写一个类，继承Application，在AndroidManifest.xml中指定applictaion类即可</p><p>Application是应用的入口。</p><p>Application的生命周期就是应用的生命周期。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期函数有：<br>onCreate、onLowMemory、onTrimMemory、onTerminate、onConfigurationChanged</p><p>各个生命周期函数解释</p><ul><li>onCreate: 应用被创建时调用，是程序的主入口，在此处做一些初始化操作，不要做耗时操作。</li><li>onLowMemory： 当系统整体内存可用量较少时触发，可以在这里做一些不重要数据的清除、释放资源，避免因内存不足导致App被系统杀掉</li><li>onTrimMemory(int level)： andorid4.0后出的API，用来取代onLowMemory函数的，其中这个函数还有一个入参，来表示等级。</li><li>onTerminate： 当Application结束时，又系统决定调用时机。常规手动kill app进程没有触发此函数</li></ul><h3 id="onTrimMemory"><a href="#onTrimMemory" class="headerlink" title="onTrimMemory"></a>onTrimMemory</h3><p>此函数是在android4.0后引入的，能实现的组件不止Application，还有Activity、Fragment、Service、ContentProvider<br>作用是指导应用程序在不同情况下进行自身的内存释放，以避免被系统杀掉，提高用户体验</p><p>根据不同的情况，在函数中的提现就是 onTrimMemory函数中的 level这个入参。<br>level有7个值，</p><ul><li>TRIM_MEMORY_UI_HIDDEN：表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键、Pause键导致应用的UI界面不可见．这时候应该释放一些资源．</li></ul><p>当app运行在前台时，会回调下面这三个值，内存余量从高到低排列</p><ul><li><p>TRIM_MEMORY_MODERATE：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。</p></li><li><p>TRIM_MEMORY_RUNNING_CRITICAL：表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。<br>这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</p></li><li><p>TRIM_MEMORY_RUNNING_LOW：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，<br>同时这也会直接影响到我们应用程序的性能。</p></li></ul><p>当app缓存在后台时，会回调一下三个值，内存余量从高到低排列</p><ul><li><p>TRIM_MEMORY_BACKGROUND：表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，<br>是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，<br>这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。</p></li><li><p>TRIM_MEMORY_RUNNING_MODERATE： 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。</p></li><li><p>TRIM_MEMORY_COMPLETE：表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，<br>在这个时候应当尽可能地把一切可以释放的东西都进行释放。</p></li></ul><p>onTrimMemory 主要是在考虑内存优化时需要考虑。在此处做数据清除、资源释放</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Application&quot;&gt;&lt;a href=&quot;#Application&quot; class=&quot;headerlink&quot; title=&quot;Application&quot;&gt;&lt;/a&gt;Application&lt;/h1&gt;&lt;p&gt;Application是指代一个应用，默认我们在android应用中
      
    
    </summary>
    
    
      <category term="andorid" scheme="hexo/tags/andorid/"/>
    
  </entry>
  
  <entry>
    <title>Activity的启动模式</title>
    <link href="hexo/blog/2020/09/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>hexo/blog/2020/09/Activity的启动模式.html</id>
    <published>2020-09-25T07:59:03.000Z</published>
    <updated>2020-09-28T06:32:10.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h1><p>首先，Activity有四大启动模式：<br>standard、singleTask、singleTop、singleInstance</p><p>如何设置Activity的启动模式：</p><ul><li><p>静态设置，在AndoridManifest.xml文件中，对Activity设置launchMode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.MainActivity3&quot;</span><br><span class="line">    android:launchMode=&quot;singleInstance&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态设置，在Activity跳转时，intent设置FLAG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var intent = Intent(this, MainActivity::class.java);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure></li></ul><p>并且注意，同时设置了两种方式时，动态设置会覆盖静态设置</p><h2 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard: 标准模式，默认模式，当设置为此模式时，每一次跳入都会重新创建实例</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>singleTask: 栈内复用模式，当设置此模式时，如果栈内没有该Activity就会重新创建，如果已经有了，则会复用栈内已存在的该Activity，而不会重新创建，<br>并会移除之前在栈中处于该Activity上部的所有的Activity。<br>ex：A的启动模式是standard， B的启动模式为singleTask</p><p>A -&gt; B -&gt; A -&gt; B</p><p>A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以不会重新创建b的实例，而是复用之前B的实例，同时会调用onNewIntent生命周期函数，<br>而且会销毁之前处于栈顶的A。<br>最后栈内就是： A、B，B位于栈顶</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop：栈顶复用，与singleTask有部分相似，singleTask是只要在栈内就会复用，而singleTop是只有在栈顶才会复用，<br>如果栈内存在实例，但不处于栈顶，则表现与standard一致，<br>如果站内存在实例，且处于栈顶，则表现与singleTask一致，</p><p>ex：A的启动模式是standard、B的启动模式是singleTop<br>A -&gt; B -&gt; A -&gt; B<br>A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，但之前的B不在栈顶，所以会重新创建一个B的实例</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>singleInstance: 独立运行在一个单独的task中，而且只会存在一个实例<br>在Activity跳转时，注意查看，普通的Activity跳转和Activity Task跳转，两者的动画效果是不同的。</p><p>ex: A的启动模式是standard、B的启动模式是singleInstance<br>A -&gt; B -&gt; A -&gt; B<br>A -&gt; B 时，因为当前Activity栈task A中只有A，会重新创建一个task B并新建一个B的实例放入task B<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例，并放入到task A中<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以会将task B置顶，<br>最后的栈情况为： A -&gt; A -&gt; B，如下图所示：</p><p><img src="../images/activity_stack.png" alt="activity-stack"></p><p>我们可以通过指令：adb shell dumpsys activity<br>查看Activity栈中的Activity task情况</p><p>通过关键字：ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)<br>即可搜索到上述截图情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity启动模式&quot;&gt;&lt;a href=&quot;#Activity启动模式&quot; class=&quot;headerlink&quot; title=&quot;Activity启动模式&quot;&gt;&lt;/a&gt;Activity启动模式&lt;/h1&gt;&lt;p&gt;首先，Activity有四大启动模式：&lt;br&gt;standar
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android生命周期</title>
    <link href="hexo/blog/2020/09/android%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>hexo/blog/2020/09/android生命周期.html</id>
    <published>2020-09-24T06:29:33.000Z</published>
    <updated>2020-09-28T08:02:40.768Z</updated>
    
    <content type="html"><![CDATA[<p>准备对andorid基础性的东西都进行整理，梳理一下。</p><h1 id="android的生命周期"><a href="#android的生命周期" class="headerlink" title="android的生命周期"></a>android的生命周期</h1><p>单个Actiivty正常的生命周期</p><p>onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory</p><p>这就是一个Activity从被创建到被销毁过程。</p><p>其中正常运行状态为onResume</p><p>当Activity从前台被置于后台，<br>onResume -&gt; onPause -&gt; onStop</p><p>当从后台重新置于前台<br>onStop -&gt; onPause -&gt; onResatrt -&gt; onStart-&gt; onResume</p><p>其中可以发现，只要Activity置于前台都会执行onStart函数，所以我们可以考虑在这里做一下需要在前台就处理的逻辑</p><p>各个生命周期函数：<br>onCreate: Activity被创建，此时Activity处于不可见、不可交互<br>onStart: 此时Activity 部分可见不可交互<br>onRestart: Activity从后台重新回到前台，部分可见不可交互<br>onResume: 完全可见可交互，为Activity正常运行状态<br>onPause: Activity处于暂停，从前台被置于后台 部分可见部分不可见，不可交互<br>onStop: 完全置于后台，完全不可见，<br>onDestroy: Activity被销毁</p><p>上面就是一个正常的Activity的生命周期，</p><h2 id="屏幕旋转"><a href="#屏幕旋转" class="headerlink" title="屏幕旋转"></a>屏幕旋转</h2><p>在Activity生命周期中，还设计一些其他：<br>Activity旋转：<br>onCreate -&gt; onStart -&gt; onResume<br>此时被旋转<br>-&gt; onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p><p>可以发现当Activity被旋转时，整个Activity是被销毁然后重新创建的。其中新增调用了两个生命周期函数<br>onSaveInstanceState: 当Activity被系统异常销毁时被调用，用于存储数据，用于系统恢复Activity时恢复数据<br>onRestoreInstanceState: 当Actiivty被系统异常销毁并重新创建时，取出在onSaveInstanceState时存储的数据</p><p>注意，在onCreate函数中，其实也是有参数的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, &quot;onCreate: &quot;)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此处的savedInstanceState也是在onSaveInstanceState时存储的数据，但此处可能为nll，<br>因为在正常的Activity时，此处就是null，只有在Activity被异常销毁然后被系统重新创建时，此处才有值。<br>如果要在此处使用，切记要判空。</p><h2 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h2><p>onNewIntent与Activity的启动模式有关</p><p>当Activity未设置启动模式时，则不会触发该生命周期函数</p><p>当Activity已经处于应用的Activity栈中</p><ul><li>如果Actiivty的LaunchMode为Standard时，即默认模式，此时不会触发该生命周期函数。</li><li>如果Activity的LaunchMode为SignleTop，如果ActivityA已经处于栈顶，再通过StartActivityForResult调用该Activity，<br>此时会触发的生命周期函数为： onPause -&gt; onNewIntent -&gt; onResume</li><li>如果Activity的LainchMode为SingleInstance,SingleTask时，并且ActivityA已经处于Activity栈中，再次通过StartActivityForResult调用该Activity，此时生命周期函数：onNewIntent—&gt;onRestart—&gt;onStart—&gt;onResume</li></ul><p>onNewIntent只会在Activity设置了启动模式，并且Activity被复用时才会调起。</p><p>注意：只对startActivityForResult调起的Activity起作用，statActivity本质调用的也是startActivityForResult，Activity正常的切换前后台时不会触发的。</p><h2 id="Activity交互"><a href="#Activity交互" class="headerlink" title="Activity交互"></a>Activity交互</h2><p>A -&gt; B:<br>A正常运行处于 onResume，打开B</p><p>A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop<br>点击跳入B页面， 首先A进入暂停，B开始创建，到onResume完全可见可交互，于是A被完全遮挡，变成完全不可见、处于后台，进入onStop</p><p>A -&gt; B -&gt;goBack-&gt; A</p><p>在B页再执行返回</p><p>B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B Stop -&gt; B onDestory<br>和A进入B类似，B返回A时，B进入暂停，A变得重新可见到A完全可见，进入onResume，然后B进入停止，并销毁</p><p>B启动模式设置为 SingleTop，B -&gt; B<br>B onPause -&gt; B onNewIntent -&gt; B onResume<br>因为 B已经处于栈顶，启动模式为 SingleTop 则不会重新创建B的实例</p><p>将A的启动模式设置为SingleTask</p><p>可以通过在andorid studio的终端 Terminal中输入：adb shell dumpsys activity<br>查看当前应用的Activity task栈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备对andorid基础性的东西都进行整理，梳理一下。&lt;/p&gt;
&lt;h1 id=&quot;android的生命周期&quot;&gt;&lt;a href=&quot;#android的生命周期&quot; class=&quot;headerlink&quot; title=&quot;android的生命周期&quot;&gt;&lt;/a&gt;android的生命周期&lt;/h
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>react-native 适配androidX</title>
    <link href="hexo/blog/2020/09/react-native-%E9%80%82%E9%85%8DandroidX.html"/>
    <id>hexo/blog/2020/09/react-native-适配androidX.html</id>
    <published>2020-09-15T01:15:50.000Z</published>
    <updated>2020-09-16T01:20:26.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="androidX"><a href="#androidX" class="headerlink" title="androidX"></a>androidX</h1><p>在API28后，android新增androidX依赖，用于解决以前的android.support.v*依赖混乱问题。<br>对v1-v9做了合并处理。</p><p>然后很多使用的第三方依赖中在新版本都适配了androidX，当你需要使用这些插件的较新版本时，只能去适配androidX。</p><p>最近使用react-native-firebase时，被提示必须使用17.0.0+的 Firebase Crashlytics SDK，否则2020年11月15日之后，将不再向firebase发送错误日志。</p><h2 id="适配androidX"><a href="#适配androidX" class="headerlink" title="适配androidX"></a>适配androidX</h2><p>点击andorid studio上方导航栏Refactor/Migrate to AndroidX<br>这时会提示你，gradle tool version 最低3.2.0<br>项目中每一个project的build.gradle都需要修改</p><p>classpath(“com.android.tools.build:gradle:3.2.0”)<br>其中3.2.0为最低版本。</p><p>注意，选择的版本可能maven仓库找不到。<br>如在第三方插件中，设置的maven仓库可能不存在该版本。<br>如： 我使用的是版本：3.4.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:3.4.0&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时会报错，404，找不到。<br>因为在jcenter远程仓库中不存在该版本。</p><p>3.4.0的版本只有google的maven仓库中有，所以需要修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>查看maven插件地址：<a href="https://maven.aliyun.com/mvn/search" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/search</a></p><p>同时需要修改每个project的targetSdkVersion</p><p>将所有project的版本都修改为3.4.0之后，在点即Migrate to AndroidX,<br>此时会提示你需要修改的地方，</p><ul><li>java文件，去除一些v*的引入</li><li>build.gradle 去除一些v*的依赖</li><li>manifest.xml 需要修改一些属性，如配置的FileProvider,修改name属性<br><code>android:name=&quot;androidx.core.content.FileProvider&quot;</code></li></ul><p>修改完后，无报错时直接运行。</p><p>会有一些java文件报错，就是引入的之前的v*的包，需要手动修改，哪里报错改哪里。</p><p>最后运行，运行成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;androidX&quot;&gt;&lt;a href=&quot;#androidX&quot; class=&quot;headerlink&quot; title=&quot;androidX&quot;&gt;&lt;/a&gt;androidX&lt;/h1&gt;&lt;p&gt;在API28后，android新增androidX依赖，用于解决以前的android.sup
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2020/09/java-%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8Eclass.html"/>
    <id>hexo/blog/2020/09/java-反射基本概念与class.html</id>
    <published>2020-09-10T01:26:24.085Z</published>
    <updated>2020-09-10T03:51:39.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 *</li></ul><p>类名    用途<br>Class类    代表类的实体，在运行的Java应用程序中表示类和接口<br>Field类    代表类的成员变量（成员变量也称为类的属性）<br>Method类    代表类的方法<br>Constructor类    代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法    用途<br>asSubclass(Class<u> clazz)    把传递的类的对象转换成代表其子类的对象<br>Cast    把对象转换成代表类或是接口的对象<br>getClassLoader()    获得类的加载器<br>getClasses()    返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses()    返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className)    根据类名返回类的对象<br>getName()    获得类的完整路径名字<br>newInstance()    创建类的实例<br>getPackage()    获得类的包<br>getSimpleName()    获得类的名字<br>getSuperclass()    获得当前类继承的父类的名字<br>getInterfaces()    获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法    用途<br>getField(String name)    获得某个公有的属性对象<br>getFields()    获得所有公有的属性对象<br>getDeclaredField(String name)    获得某个属性对象<br>getDeclaredFields()    获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法    用途<br>getAnnotation(Class<a> annotationClass)    返回该类中与参数类型匹配的公有注解对象<br>getAnnotations()    返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass)    返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations()    返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法    用途<br>getConstructor(Class…&lt;?&gt; parameterTypes)    获得该类中与参数类型匹配的公有构造方法<br>getConstructors()    获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)    获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors()    获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法    用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes)    获得该类某个公有的方法<br>getMethods()    获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)    获得该类某个方法<br>getDeclaredMethods()    获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法    用途<br>isAnnotation()    如果是注解类型则返回true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)    如果是指定类型注解类型则返回true<br>isAnonymousClass()    如果是匿名类则返回true<br>isArray()    如果是一个数组类则返回true<br>isEnum()    如果是枚举类则返回true<br>isInstance(Object obj)    如果obj是该类的实例则返回true<br>isInterface()    如果是接口类则返回true<br>isLocalClass()    如果是局部类则返回true<br>isMemberClass()    如果是内部类则返回true</p><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p>Field代表类的成员变量（成员变量也称为类的属性）。</p><p>方法    用途<br>equals(Object obj)    属性与obj相等则返回true<br>get(Object obj)    获得obj中对应的属性值<br>set(Object obj, Object value)    设置obj中对应属性值</p><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p>Method代表类的方法。</p><p>方法    用途<br>invoke(Object obj, Object… args)    传递object对象及参数调用该对象对应的方法</p><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><p>Constructor代表类的构造方法。</p><p>方法    用途<br>newInstance(Object… initargs)    根据传递的参数创建类的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin 在android老项目中引入kotlin</title>
    <link href="hexo/blog/2020/09/kotlin-%E5%9C%A8android%E8%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5kotlin.html"/>
    <id>hexo/blog/2020/09/kotlin-在android老项目中引入kotlin.html</id>
    <published>2020-09-09T08:31:56.000Z</published>
    <updated>2020-09-09T09:10:39.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在android项目中引入kotlin"><a href="#在android项目中引入kotlin" class="headerlink" title="在android项目中引入kotlin"></a>在android项目中引入kotlin</h1><p>修改项目的build.gradle 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line"></span><br><span class="line">    ext &#123;</span><br><span class="line">        kotlin_version = &quot;1.3.10&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app/build.gradle中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &quot;com.android.application&quot;</span><br><span class="line">// 在顶行下添加</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br></pre></td></tr></table></figure><p>然后同步一下即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在android项目中引入kotlin&quot;&gt;&lt;a href=&quot;#在android项目中引入kotlin&quot; class=&quot;headerlink&quot; title=&quot;在android项目中引入kotlin&quot;&gt;&lt;/a&gt;在android项目中引入kotlin&lt;/h1&gt;&lt;p&gt;修改
      
    
    </summary>
    
    
      <category term="kotlin" scheme="hexo/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>google play 提交要求</title>
    <link href="hexo/blog/2020/09/google-play-%E6%8F%90%E4%BA%A4%E8%A6%81%E6%B1%82.html"/>
    <id>hexo/blog/2020/09/google-play-提交要求.html</id>
    <published>2020-09-09T03:27:05.000Z</published>
    <updated>2020-09-09T05:48:13.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-play-提交要求"><a href="#google-play-提交要求" class="headerlink" title="google play 提交要求"></a>google play 提交要求</h1><p>本文于2020/09/09日起记录在google play提交版本时，google play提出的提交要求</p><h2 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h2><p>在2020/08/05日，提交版本发现多了一个警告<br><img src="../images/google_targetSdkVersion.png" alt="google_targetSdkVersion.png"></p><p>新提交的应用在8月开始，必须设定targetSdkVersion为29或以上，<br>已存在的应用提交新版本时，必须设定targetSdkVersion为29或以上</p><h3 id="关于targetSdkVersion的原理"><a href="#关于targetSdkVersion的原理" class="headerlink" title="关于targetSdkVersion的原理"></a>关于targetSdkVersion的原理</h3><p>targetSdkVersion相当于在编写代码时设定一个假想的运行手机版本，打包后，再运行到真实设备。<br>最终的运行表现取决与targetSdkVersion与真实运行设备版本中的低值。</p><p>targetSdkVersion的预设就相当于预设一个代码运行环境，<br>我们所写的代码功能如果是只有部分版本才有的API，我们需要先判断真实的运行版本是否符合。<br>如在android6.0后引入权限请求，在每次请求权限时，我们需要判断SDK版本是否大于等于23.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void request() &#123;</span><br><span class="line">    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        requestPermissions(new String[]&#123;Manifest.permission.CAMERA&#125;, 101);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，是否需要判断版本其实和minSdkVersion也是有关的，如上面的代码，因为权限请求是23以后的，如果我们直接将minSdkVersion设置为23，则此时就不需要判断版本了，因为肯定是运行在23之后的手机，因为23以前的手机此时会无法安装该应用。</p><p>ex:<br>当我们设定targetSdkVersion=29，即android10，<br>而用户手机为API=23，即android6.0，<br>此时app的表现会是6.0。</p><p>当我们设定targetSdkVersion=23，即android6，<br>而用户手机为API=29，即android10，<br>此时app的表现也会是6.0。</p><h2 id="64位框架"><a href="#64位框架" class="headerlink" title="64位框架"></a>64位框架</h2><p>在去年时，google play要求提及的应用必须支持64位的框架，<br>也就是.so文件必须支持64位架构，<br>在提交审核的apk中，有armeabi-v7a则必须也要有arm64-v8a，如果有x86，则必须也要有x86_64。<br>react-native 原本只有armeabi-v7a，在之后的版本0.59.10中就开始内部源码中支持64位含有arm64-v8a下的.so文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;google-play-提交要求&quot;&gt;&lt;a href=&quot;#google-play-提交要求&quot; class=&quot;headerlink&quot; title=&quot;google play 提交要求&quot;&gt;&lt;/a&gt;google play 提交要求&lt;/h1&gt;&lt;p&gt;本文于2020/09/09日
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="hexo/blog/2020/09/git%E4%BD%BF%E7%94%A8.html"/>
    <id>hexo/blog/2020/09/git使用.html</id>
    <published>2020-09-08T03:11:56.000Z</published>
    <updated>2020-09-09T07:58:34.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>git是一款分布式代码版本控制工具</p><p>初始化使用：<br>当我们在gitlab、github初始化一个项目路径后，<br>需要将本地仓库的代码提交到新建好的远端仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;remoteurl&gt; // 链接远端仓库 &lt;remoteurl&gt;为远端仓库地址</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit info&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>git fetch 拉取代码<br>git merge 合并代码<br>git pull 拉取并合并代码<br>git push 将本地仓库的commit提交到远端仓库</p><p>git checkout <branchname> 切换分支<br>git checkout -b <branchname> 新建分支并切换</branchname></branchname></p><p>git branch -d <branchname> 删除分支 不能删除有未提交commit的分支<br>git branch -D <branchname> 强制删除分支</branchname></branchname></p><p>git push -u origin <branchname> 将本地分支推送到远端，如果远端没有此分支则会创建</branchname></p><p>git reset –hard <commitid> 代码回滚到某个commit commitId可以通过git log查看</commitid></p><p>git log 可以查看每一个的commit，显示的信息有 commit date，commit person，commitId，commit info</p><p>git merge A 将A分支合并到当前分支</p><p>git rebase A 将A分支合并并且将A分支节点置于当前分支之后</p><p>git mv <filename> <filename> 修改文件名，因为git默认忽略文件大小写，<br>如修改文件名 File.js 到 file.js此时是无法检测到更改，需要使用命令：<br>git mv File.js file.js</filename></filename></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h1&gt;&lt;p&gt;git是一款分布式代码版本控制工具&lt;/p&gt;
&lt;p&gt;初始化使用：&lt;br&gt;当我们在gitlab、github初始化一个项目路径后，&lt;br
      
    
    </summary>
    
    
      <category term="git" scheme="hexo/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型 JMM</title>
    <link href="hexo/blog/2020/09/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM.html"/>
    <id>hexo/blog/2020/09/Java内存模型-JMM.html</id>
    <published>2020-09-08T01:41:19.000Z</published>
    <updated>2020-09-08T01:42:00.716Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Lock详解</title>
    <link href="hexo/blog/2020/09/Lock%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2020/09/Lock详解.html</id>
    <published>2020-09-03T07:26:40.000Z</published>
    <updated>2020-09-03T07:26:40.879Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Synchronized详解</title>
    <link href="hexo/blog/2020/09/Synchronized%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2020/09/Synchronized详解.html</id>
    <published>2020-09-03T07:26:31.000Z</published>
    <updated>2020-09-03T07:26:31.918Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java 设计模式</title>
    <link href="hexo/blog/2020/09/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>hexo/blog/2020/09/java-设计模式.html</id>
    <published>2020-09-03T07:13:47.000Z</published>
    <updated>2020-09-03T07:13:47.169Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java IO</title>
    <link href="hexo/blog/2020/09/java-IO.html"/>
    <id>hexo/blog/2020/09/java-IO.html</id>
    <published>2020-09-03T07:13:19.000Z</published>
    <updated>2020-09-03T07:13:19.185Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="hexo/blog/2020/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"/>
    <id>hexo/blog/2020/09/动态代理.html</id>
    <published>2020-09-03T07:13:07.000Z</published>
    <updated>2020-09-03T07:13:07.579Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="hexo/blog/2020/09/%E6%B3%A8%E8%A7%A3.html"/>
    <id>hexo/blog/2020/09/注解.html</id>
    <published>2020-09-03T07:12:37.000Z</published>
    <updated>2020-09-03T07:12:37.204Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据传输与序列化</title>
    <link href="hexo/blog/2020/09/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <id>hexo/blog/2020/09/数据传输与序列化.html</id>
    <published>2020-09-03T07:11:44.000Z</published>
    <updated>2020-09-11T10:37:25.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><ul><li>Serializable java自带</li><li>Parcelable android中</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序列化方式&quot;&gt;&lt;a href=&quot;#序列化方式&quot; class=&quot;headerlink&quot; title=&quot;序列化方式&quot;&gt;&lt;/a&gt;序列化方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Serializable java自带&lt;/li&gt;
&lt;li&gt;Parcelable android中&lt;/li
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Callback Future</title>
    <link href="hexo/blog/2020/09/Callback-Future.html"/>
    <id>hexo/blog/2020/09/Callback-Future.html</id>
    <published>2020-09-03T07:08:01.000Z</published>
    <updated>2020-09-08T07:43:29.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p><strong> Future代表一个异步计算的结果，并且它提供一些方法来让调用者检测异步过程是否完成，或者取得异步计算的结果，或者取消正在执行的异步任务。 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt;future = calcute(9);</span><br><span class="line">        while (!future.isDone())&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System.out.println(&quot;正在执行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            int result = future.get();</span><br><span class="line">            System.out.println(&quot;result = &quot; + result);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Future&lt;Integer&gt;calcute(Integer i) &#123;</span><br><span class="line">        return executorService.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;return future for &quot; + i);</span><br><span class="line">            return i *i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单Future使用用例写完，使用线程池+Callback+Future，完成了一个简单的计算操作。</p><p>Future是一个接口，先看一下内部方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean var1);</span><br><span class="line"></span><br><span class="line">    boolean isCancelled();</span><br><span class="line"></span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    V get() throws ExecutionException, InterruptedException;</span><br><span class="line"></span><br><span class="line">    V get(long var1, TimeUnit var3) throws ExecutionException, InterruptedException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get()函数是返回计算结果，注意get会同步操作，每天返回结果前，会阻塞线程。<br>get还有一个重载函数get(long var1, TimeUnit var3)，第一个参数是时长，第二个是单位。<br>表示在多少时长内获取结果，如果仍未返回，则抛出异常TimeoutException。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    int result2 = future2.get(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; catch(TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cancel(boolean) 表示是否取消该future，</p><p>不能在调用cancel(true)/cancel(false)后，调用get()函数，否则会抛出异常CancellationException</p><p>isCancelled()函数是判断该future是否已取消</p><p>isDone()函数是判断该future是否已完成</p><p>isDone()函数是实时状态读取，不会阻塞线程。</p><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>Callback 是一个接口，内部只有一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callback 可以理解为一个执行任务，如上面例子中的计算</p><h2 id="FutureTask介绍"><a href="#FutureTask介绍" class="headerlink" title="FutureTask介绍"></a>FutureTask介绍</h2><p>Future是一个接口，<br>RunnableFuture也是一个接口，继承Future、Runnable两个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而FutureTask是对RunnableFuture的基本实现</p><p>FutureTask 有一个状态值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 状态值存在如下几种变化：</span><br><span class="line">* Possible state transitions:</span><br><span class="line">* NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">* NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">* NEW -&gt; CANCELLED</span><br><span class="line">* NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line">*/</span><br><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h1&gt;&lt;p&gt;&lt;strong&gt; Future代表一个异步计算的结果，并且它提供一些方法来让调用者检测异步过程是否完成，或者
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android AsyncTask</title>
    <link href="hexo/blog/2020/09/android-AsyncTask.html"/>
    <id>hexo/blog/2020/09/android-AsyncTask.html</id>
    <published>2020-09-03T07:04:59.000Z</published>
    <updated>2020-09-03T07:05:13.298Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="hexo/blog/2020/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"/>
    <id>hexo/blog/2020/09/线程池.html</id>
    <published>2020-09-03T07:04:37.000Z</published>
    <updated>2020-09-10T05:33:10.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-线程池"><a href="#java-线程池" class="headerlink" title="java 线程池"></a>java 线程池</h1><p>线程池是用来管理以及调度线程的容器。</p><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><ul><li>复用线程，避免大量线程重复创建、销毁，降低消耗</li><li>提升效率，当线程池内未饱和时，无需等待线程的重新创建和初始化，便能立即执行</li><li>方便线程并发管理，避免线程无限制的创建，可能造成的OOM、cpu过高等问题，规定了最大并发数</li><li>延时定时执行任务</li></ul><h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize: 核心线程数量，当向线程池提交一个任务时，如果线程数小于核心线程数，不管是否有线程处于空闲状态，都会创建一个新的线程来执行该任务，<br>直到线程池中的线程数大于等于核心线程数量</li><li><p>maximumPoolSize: 最大线程数，线程池中线程数量最大值，当向线程池提交任务，核心线程都已创建完毕，且核心线程都处于工作状态，此时会先将该任务提交到阻塞队列，如果阻塞队列已满， 并线程池中线程数量小于最大线程数时，此时会新创建一个线程执行该任务。如果阻塞队列已满，且线程数也达到最大值，此时会执行线程饱和策略。</p></li><li><p>keepAliveTime：非核心线程可空闲时长，非核心线程处于空闲时，且空闲时长超过keepAliveTime，则该线程会被回收，但不会回收核心线程</p></li><li><p>unit： keepAliveTime的时长单位</p></li><li><p>workQueue： 阻塞队列，用于保存和运输待执行任务的阻塞队列</p></li><li><p>threadFactory：线程工厂，用于创建工作线程，threadFactory也是采用new Thread()形式创建一个新线程，但命名线程名称，格式为：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p></li><li><p>defaultHandler： 线程饱和策略，当线程池和阻塞队列都满了，再添加任务时，会执行此策略</p></li></ul><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p><img src="../images/threadPool.png" alt="提交任务流程">;</p><p>当提交一个任务时，</p><p>1、查询核心线程是否已满，如果未满则新创建核心线程执行该任务</p><p>2、当核心线程已满，判断阻塞队列是否已满，如果阻塞队列未满则将该任务加入到阻塞队列中</p><p>3、当阻塞队列已满时，判断线程池是否已满，如果未满，则新创建线程执行该任务</p><p>4、当线程池已满时，则执行饱和策略</p><h2 id="线程池为何需要使用阻塞队列"><a href="#线程池为何需要使用阻塞队列" class="headerlink" title="线程池为何需要使用阻塞队列"></a>线程池为何需要使用阻塞队列</h2><p>1、因为线程池是管理并调度线程、以完成任务，肯定不可能无限制的创建线程，</p><p>2、提高核心线程的使用效率</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-线程池&quot;&gt;&lt;a href=&quot;#java-线程池&quot; class=&quot;headerlink&quot; title=&quot;java 线程池&quot;&gt;&lt;/a&gt;java 线程池&lt;/h1&gt;&lt;p&gt;线程池是用来管理以及调度线程的容器。&lt;/p&gt;
&lt;h2 id=&quot;线程池的优势&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
</feed>
