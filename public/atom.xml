<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Happy To Try</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2019-12-30T10:08:03.595Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android-自定义View-继承EditText</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFEditText.html"/>
    <id>hexo/blog/2019/12/android-自定义View-继承EditText.html</id>
    <published>2019-12-19T09:59:28.000Z</published>
    <updated>2019-12-30T10:08:03.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-自定义View-继承EditText"><a href="#android-自定义View-继承EditText" class="headerlink" title="android-自定义View-继承EditText"></a>android-自定义View-继承EditText</h1><p>一直觉得flutter中的输入框效果不错。<br>动画，提示标题都有。<br>这次要通过自定义View, 继承重写EditText来实现同样的输入框效果</p><p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>首先确定大致思路<br>两个元素：TextView、EditText，TextView为标题，EditText为输入框展示<br>当未获取焦点时：<br>1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部<br>2、输入框如果没有输入的内容，则输入框展示的提示文本<br>当获取焦点时：<br>不管有无输入内容，提示文本缩小在输入框上部</p><p>TextView并非实质组件，只是绘制Text，当作TextView。</p><h3 id="1、先写一个类继承AppCompatEditText，并实现构造函数"><a href="#1、先写一个类继承AppCompatEditText，并实现构造函数" class="headerlink" title="1、先写一个类继承AppCompatEditText，并实现构造函数"></a>1、先写一个类继承AppCompatEditText，并实现构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AnimatedInput extends AppCompatEditText &#123;</span><br><span class="line"></span><br><span class="line"> public AnimatedInput(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnimatedInput(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initView(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initView(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、重写onFocusChanged函数"><a href="#2、重写onFocusChanged函数" class="headerlink" title="2、重写onFocusChanged函数"></a>2、重写onFocusChanged函数</h3><p>这样获取到 是否获取焦点的标识位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123;</span><br><span class="line">        super.onFocusChanged(focused, direction, previouslyFocusedRect);</span><br><span class="line">        isFocus = focused;</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、重写onTextChanged函数"><a href="#3、重写onTextChanged函数" class="headerlink" title="3、重写onTextChanged函数"></a>3、重写onTextChanged函数</h3><p>这样获取到输入框的内容value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123;</span><br><span class="line">        super.onTextChanged(text, start, lengthBefore, lengthAfter);</span><br><span class="line">        value = text.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="4、绘制提示文本"><a href="#4、绘制提示文本" class="headerlink" title="4、绘制提示文本"></a>4、绘制提示文本</h3><p>这时候要分情况，即是否获取焦点、输入框是否有内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸</span><br><span class="line">    int width = getMeasuredWidth();</span><br><span class="line">    int height = getMeasuredHeight();</span><br><span class="line">    top = getPaddingTop();</span><br><span class="line">    left = getPaddingLeft();</span><br><span class="line">    right = width - left - getPaddingRight();</span><br><span class="line">    bottom = height - top;</span><br><span class="line">    drawTitle(canvas);</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 绘制标题</span><br><span class="line"> * @param canvas</span><br><span class="line"> */</span><br><span class="line">private void drawTitle(Canvas canvas) &#123;</span><br><span class="line">    if(TextUtils.isEmpty(value)) &#123;</span><br><span class="line">        if(isFocus) &#123;</span><br><span class="line">            canvas.drawText(title, left, top + 20, focusTitlePaint);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        canvas.drawText(title, left, top + 20, focusTitlePaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如此就基本实现了我们的预期目标。<br>这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-自定义View-继承EditText&quot;&gt;&lt;a href=&quot;#android-自定义View-继承EditText&quot; class=&quot;headerlink&quot; title=&quot;android-自定义View-继承EditText&quot;&gt;&lt;/a&gt;android-
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android-自定义View 继承ViewGroup</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFViewGroup.html"/>
    <id>hexo/blog/2019/12/android-自定义View-继承ViewGroup.html</id>
    <published>2019-12-12T07:13:45.000Z</published>
    <updated>2019-12-19T10:02:04.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-自定义View-继承ViewGroup"><a href="#android-自定义View-继承ViewGroup" class="headerlink" title="android 自定义View 继承ViewGroup"></a>android 自定义View 继承ViewGroup</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-自定义View-继承ViewGroup&quot;&gt;&lt;a href=&quot;#android-自定义View-继承ViewGroup&quot; class=&quot;headerlink&quot; title=&quot;android 自定义View 继承ViewGroup&quot;&gt;&lt;/a&gt;andro
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 自定义View 继承View</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFView.html"/>
    <id>hexo/blog/2019/12/android-自定义View-继承View.html</id>
    <published>2019-12-11T01:47:36.000Z</published>
    <updated>2019-12-19T09:44:13.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-自定义View-继承View"><a href="#android-自定义View-继承View" class="headerlink" title="android 自定义View 继承View"></a>android 自定义View 继承View</h1><p><a href="android-自定义View.html">上篇关于自定义View的介绍</a><br>接下来将会针对自定义View三种情况一一实现。</p><p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>最后实现效果如下图：</p><p><img src="../../../images/custom_view_final.jpg" style="zoom:20%"></p><h2 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h2><p>创建一个class MyView 继承View</p><p>目标是写一个折线图</p><p>现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;declare-styleable name=&quot;LineView&quot;&gt;</span><br><span class="line">        &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">        &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="先新建一个clas-继承View，-并初始化几个构造函数"><a href="#先新建一个clas-继承View，-并初始化几个构造函数" class="headerlink" title="先新建一个clas 继承View， 并初始化几个构造函数"></a>先新建一个clas 继承View， 并初始化几个构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyView extends View &#123;</span><br><span class="line">    // 代码生成时，才会调用该构造函数</span><br><span class="line">     public MyView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    // xml配置时，会调用这个生命周期</span><br><span class="line">    public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initData(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。</span><br><span class="line">    private void initData(AttributeSet attrs) &#123;</span><br><span class="line">         Log.d(TAG, &quot;initData: &quot;);</span><br><span class="line">        // 获取xml中配置的数据</span><br><span class="line">        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView);</span><br><span class="line">        paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black));</span><br><span class="line"></span><br><span class="line">        // 画笔初始化</span><br><span class="line">        paint = new Paint();</span><br><span class="line">        paint.setColor(context.getResources().getColor(R.color.black));</span><br><span class="line">        paint.setTextSize(40);</span><br><span class="line">        paint.setStrokeWidth(10); // 线条粗细</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在onMeasure函数中对尺寸做约束"><a href="#在onMeasure函数中对尺寸做约束" class="headerlink" title="在onMeasure函数中对尺寸做约束"></a>在onMeasure函数中对尺寸做约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    Log.d(TAG, &quot;onMeasure: &quot;);</span><br><span class="line">    int height = measuretDimension(defaultHeight, heightMeasureSpec);</span><br><span class="line">    int width = measuretDimension(0, widthMeasureSpec);</span><br><span class="line">    top = 0;</span><br><span class="line">    left = 0;</span><br><span class="line">    bottom = top + height;</span><br><span class="line">    right = left + width;</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测量实际尺寸</span><br><span class="line"> * @param defaultSize: 默认尺寸</span><br><span class="line"> * @param measureSpec: 测量规格</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int measureDimension(int defaultSize, int measureSpec) &#123;</span><br><span class="line">    int resultSize = defaultSize;</span><br><span class="line">    int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        // 没有做限制，取默认值</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            resultSize = defaultSize;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // WRAP</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            // 要取默认值和测量值中较小值</span><br><span class="line">            // 当默认值为0时，取最大值, 即宽充满屏幕</span><br><span class="line">            resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // 具体值 或 MATCH</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            resultSize = specSize;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先绘制两个轴线"><a href="#先绘制两个轴线" class="headerlink" title="先绘制两个轴线"></a>先绘制两个轴线</h3><p>注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。<br>这两个里的坐标不要弄混。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制两条轴线 */</span><br><span class="line">private void drawXY(Canvas canvas) &#123;</span><br><span class="line">    Log.d(TAG, &quot;drawXY: &quot;);</span><br><span class="line">    // 绘制x轴</span><br><span class="line">    canvas.drawLine(left + 20, bottom, right, bottom, paint);</span><br><span class="line">    // 绘制y轴</span><br><span class="line">    canvas.drawLine(left + 20, top, left + 20, bottom, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity中配置该视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.justin.customview.MyView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot;</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        app:axieColor=&quot;@color/black&quot;</span><br><span class="line">        android:id=&quot;@+id/myView&quot;</span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p><p>我们直接运行,效果如下：<br><img src="../../../images/view.jpg" style="zoom:20%"></p><p>x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。<br>新增一个方法初始化这些尺寸数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尺寸数据初始化</span><br><span class="line"> */</span><br><span class="line">private void initSize () &#123;</span><br><span class="line">    // 获取padding尺寸</span><br><span class="line">    paddingLeft = getPaddingLeft();</span><br><span class="line">    paddingTop = getPaddingTop();</span><br><span class="line">    paddingRight = getPaddingRight();</span><br><span class="line">    paddingBottom = getPaddingBottom();</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&quot;paddingLeft =&quot;).append(paddingLeft)</span><br><span class="line">            .append(&quot;paddingTop =&quot;).append(paddingTop)</span><br><span class="line">            .append(&quot;paddingRight =&quot;).append(paddingRight)</span><br><span class="line">            .append(&quot;paddingBottom =&quot;).append(paddingBottom);</span><br><span class="line">    Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString()));</span><br><span class="line">    top = paddingTop;</span><br><span class="line">    left = paddingLeft;</span><br><span class="line">    bottom = height - top - paddingBottom;</span><br><span class="line">    right = width - left;</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就对padding做了处理，接下来接着绘制我们需要的图形。<br>我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void drawArrow(Canvas canvas) &#123;</span><br><span class="line">    Path path = new Path();</span><br><span class="line">    // 先绘制x轴三角</span><br><span class="line">    //先移动到三角形一个点</span><br><span class="line">    path.moveTo(right-20, bottom + 20);</span><br><span class="line">    path.lineTo(right-20, bottom - 20); // 画线</span><br><span class="line">    path.lineTo(right, bottom); // 画线</span><br><span class="line">    path.close(); // 图形闭合</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">    // 绘制y轴三角</span><br><span class="line">    path.moveTo(left - 20, top + 20);</span><br><span class="line">    path.lineTo(left + 20, top + 20);</span><br><span class="line">    path.lineTo(left, top);</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。</p><h3 id="设置数据并绘制点"><a href="#设置数据并绘制点" class="headerlink" title="设置数据并绘制点"></a>设置数据并绘制点</h3><p>我们已经完成了绘制两条轴线，现在要开始绘制数据了。<br>首先我们要确认标准线，x轴的标准线肯定就是xValue的值，<br>但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。<br>我们先假设我们的值在0-100以内，取5条标准线，每条间距20.</p><p>先设置两个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数据</span><br><span class="line">   private float[] yValue;</span><br><span class="line">   private String[] xValue;</span><br><span class="line">   private int lineNum = 5;</span><br><span class="line"></span><br><span class="line">   /** 设置数据并刷新 */</span><br><span class="line">   public void setData(float[]yValue, String[]xValue) &#123;</span><br><span class="line">       this.yValue = yValue;</span><br><span class="line">       this.xValue = xValue;</span><br><span class="line">       postInvalidate();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** 设置标准线数目 */</span><br><span class="line">   public void setData(int lineNum) &#123;</span><br><span class="line">       this.lineNum = lineNum;</span><br><span class="line">       postInvalidate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>然后我们开始绘制标准线、各个点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制各个点 */</span><br><span class="line">private void drawPoint(Canvas canvas) &#123;</span><br><span class="line">    if(xValue == null || yValue == null) return;</span><br><span class="line">    // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。</span><br><span class="line">    float maxHeight = (float)((bottom - top) * 0.9);</span><br><span class="line">    float itemHeight = maxHeight / 5;</span><br><span class="line">    for(int i = 1; i &lt;=5; i ++) &#123;</span><br><span class="line">        canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint);</span><br><span class="line">    &#125;</span><br><span class="line">    // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值</span><br><span class="line">    float maxWidth = (float)((right - left) * 0.9);</span><br><span class="line">    float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length;</span><br><span class="line">    for (int i = 1; i &lt;= xValue.length; i ++) &#123;</span><br><span class="line">        float x = left + itemWidth * i;</span><br><span class="line">                // 绘制轴线</span><br><span class="line">        canvas.drawLine(x, bottom, x, bottom - 15, paint);</span><br><span class="line">        // 绘制点</span><br><span class="line">        float y = bottom - maxHeight * yValue[i-1] / yMax;</span><br><span class="line">        canvas.drawCircle(x, y, 5, paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在MainActivity.kt中，我们可以这样使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// kotlin语法</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;)</span><br><span class="line">        var yValue = floatArrayOf(70f, 80f, 90f);</span><br><span class="line">        myView.setData(yValue, xValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的实现效果：</p><p><img src="../../../images/chat.jpg" style="zoom:20%"></p><p>现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些</p><h3 id="绘制x、y轴标准线值，将各个点连接起来。"><a href="#绘制x、y轴标准线值，将各个点连接起来。" class="headerlink" title="绘制x、y轴标准线值，将各个点连接起来。"></a>绘制x、y轴标准线值，将各个点连接起来。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制各个点 */</span><br><span class="line">    private void drawPoint(Canvas canvas) &#123;</span><br><span class="line">        if(xValue == null || yValue == null) return;</span><br><span class="line">        // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。</span><br><span class="line">        float maxHeight = (float)((bottom - top) * 0.9);</span><br><span class="line">        float itemHeight = maxHeight / 5;</span><br><span class="line">        int itemValue = yMax / 5;</span><br><span class="line">        for(int i = 1; i &lt;=5; i ++) &#123;</span><br><span class="line">            canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint);</span><br><span class="line">            // 绘制y轴标准值</span><br><span class="line">            canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值</span><br><span class="line">        float maxWidth = (float)((right - left) * 0.9);</span><br><span class="line">        float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length;</span><br><span class="line">        for (int i = 1; i &lt;= xValue.length; i ++) &#123;</span><br><span class="line">            float x = left + itemWidth * i;</span><br><span class="line">                    // 绘制轴线</span><br><span class="line">            canvas.drawLine(x, bottom, x, bottom - 15, paint);</span><br><span class="line">            // 绘制点</span><br><span class="line">            float y = bottom - maxHeight * yValue[i-1] / yMax;</span><br><span class="line">            canvas.drawCircle(x, y, 10, paint);</span><br><span class="line"></span><br><span class="line">            // 绘制点与点之间的连线</span><br><span class="line">            if(lastX &gt; 0f) &#123;</span><br><span class="line">                canvas.drawLine(lastX, lastY, x, y, paint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 绘制x轴标准值</span><br><span class="line">            canvas.drawText(xValue[i-1], x, bottom + 50, paint);</span><br><span class="line"></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后实现效果如下图：</p><p><img src="../../../images/custom_view_final.jpg" style="zoom:20%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-自定义View-继承View&quot;&gt;&lt;a href=&quot;#android-自定义View-继承View&quot; class=&quot;headerlink&quot; title=&quot;android 自定义View 继承View&quot;&gt;&lt;/a&gt;android 自定义View 继承Vi
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 自定义View</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View.html"/>
    <id>hexo/blog/2019/12/android-自定义View.html</id>
    <published>2019-12-10T07:42:49.000Z</published>
    <updated>2019-12-10T10:07:35.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-自定义View"><a href="#Android-自定义View" class="headerlink" title="Android 自定义View"></a>Android 自定义View</h1><p>自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。</p><p>首页android自定义View有三种类型，<br>1、继承View，多用于实现一些不规则的图形。</p><p>2、继承特定的组件，如TextView，</p><p>3、继承ViewGroup，用于视图组</p><p>在自定义View中有三个关键的方法：<br>onMeasure、onLayout、onDraw</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>测量，<br>ViewGroup 会遍历测量子视图的onMeasure方法。<br>一般view 则是在测量自身。</p><p>在这个方法中，一般是对视图的尺寸做一些要求。<br>如：处理padding、处理wrap_parent</p><p>margin是无需处理的，margin其实是在父容器的onMeasure时处理的。</p><p>在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent</p><p>onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。<br>这两个参数都是父容器传递过来。</p><p>视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec</p><h3 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h3><p>我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：<br>android:layout_width = “wrap_parent | 50dp | match_parent”<br>存在三种情况，<br>wrap_parent： 自适应大小，<br>50dp: 具体尺寸<br>match_parent: 充满父容器-父容器大小</p><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>测量规格，MeasureSpec由size和mode组成</p><p>1.static int getMode(int measureSpec): // 获取mode<br>2.static int getSize(int measureSpec):// 获取size<br>3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec</p><p>specMode存在三种情况:<br>EXACTLY:<br>具体尺寸、具体值<br>AT_MOST：<br>表示子视图最多只能是specSize中指定的大小<br>UNSPECIFIED：<br>可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。</p><p>size：<br>就是LayputParams中指定的大小</p><p>而子视图的大小也就是通过size和specMode获取的，具体关系如下图：</p><table><thead><tr><th></th><th>EXACTLY</th><th>AT_MOST</th><th>UNSPECIFIED</th><th>&lt;-MeasureSpec</th></tr></thead><tbody><tr><td>wrap_parnet</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>match_parent</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>50dp</td><td>50dp</td><td>50dp</td><td>50dp</td><td></td></tr><tr><td>^LayoutParams</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸</p><p>下面会讲具体使用</p><h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><p>布局方法</p><p>在调用onLayout时，onMeasure已经完成，<br>子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。<br>在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>绘制的方法<br>onDraw是在容器的draw方法时调用的。<br>而绘制的顺序为：<br>1.绘制背景<br>2.如果有必要，保存画布的图层，以准备失效<br>3.绘制视图的内容<br>4.绘制子控件<br>5.如果必要，绘制衰落边缘和恢复层<br>6.绘制装饰（比如滚动条）</p><p>onDraw 有一个参数(Canvas cancas),<br>canvas 就是画布，画布的范围就是onLayout布局后确定的区域</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-自定义View&quot;&gt;&lt;a href=&quot;#Android-自定义View&quot; class=&quot;headerlink&quot; title=&quot;Android 自定义View&quot;&gt;&lt;/a&gt;Android 自定义View&lt;/h1&gt;&lt;p&gt;自定义View主要用于：需要一些不规
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>react redux</title>
    <link href="hexo/blog/2019/12/react-redux.html"/>
    <id>hexo/blog/2019/12/react-redux.html</id>
    <published>2019-12-03T01:54:38.000Z</published>
    <updated>2019-12-03T05:34:32.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在react-native中集成redux"><a href="#在react-native中集成redux" class="headerlink" title="在react-native中集成redux"></a>在react-native中集成redux</h1><p>对react框架而言，状态树、dom树是它的一大优势。<br>而redux就是对数据、状态进行管理。</p><h2 id="集成redux"><a href="#集成redux" class="headerlink" title="集成redux"></a>集成redux</h2><p>1、执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install redux --save</span><br><span class="line">npm install react-redux --save</span><br><span class="line">npm install redux-thunk --save</span><br><span class="line">npm i redux-logger --save</span><br></pre></td></tr></table></figure></p><p>以上命令下载关于redux的组件。</p><p>2、store的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// configStore.js</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">import rootReducer from &apos;./reducer&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default configStore =(initState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const store = createStoreWithMiddleware(rootReducer, initState);</span><br><span class="line"></span><br><span class="line">    return store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// rootReducer</span><br><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; reducer as test &#125; from &apos;../Home/store&apos;;</span><br><span class="line"></span><br><span class="line">const appReducer = combineReducers(&#123;</span><br><span class="line">    test,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const rootReducer =(state, action) =&gt; &#123;</span><br><span class="line">    return appReducer(state, action);</span><br><span class="line">&#125;</span><br><span class="line">export default rootReducer;</span><br></pre></td></tr></table></figure><p>test是一个测试的reducer。</p><p>在入口处，绑定store，在入口文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(&apos;projectName&apos;, () =&gt; Root);</span><br><span class="line">// 指向了root.js，在root.js中：</span><br><span class="line"></span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import configStore from &apos;./store/configStore&apos;;</span><br><span class="line"></span><br><span class="line">const store = configStore();</span><br><span class="line"></span><br><span class="line">export default class Root extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt;</span><br><span class="line">                    &#123;...&#125;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// actionType.js</span><br><span class="line">export const TEST_REDUCE = &quot;TEST_REDUCE&quot;;</span><br><span class="line"></span><br><span class="line">// test action.js</span><br><span class="line">import &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const test =() =&gt; (&#123;</span><br><span class="line">    type: TEST_REDUCE,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    test,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test reducer.js</span><br><span class="line">import &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;</span><br><span class="line"></span><br><span class="line">const initState = &#123;</span><br><span class="line">    num: 0,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default reducer = (state = initState, action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line"></span><br><span class="line">        case TEST_REDUCE:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                num: state.num + 1,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...initState,</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件component中使用<br>Test.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; bindActionCreators &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; action &#125; from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test extends Component &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testFunction =() =&gt; &#123;</span><br><span class="line">        this.props.action.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; num &#125; = this.props;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt;</span><br><span class="line">                &lt;TouchableOpacity</span><br><span class="line">                    onPress=&#123;this.testFunction&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;Text&gt;</span><br><span class="line">                        触发按钮</span><br><span class="line">                    &lt;/Text&gt;</span><br><span class="line">                    &lt;Text&gt;&#123;num&#125;&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = (state) =&gt; (&#123;</span><br><span class="line">    num: state.test.num,</span><br><span class="line">&#125;)</span><br><span class="line">const mapActionToProps = dispatch =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        action: bindActionCreators(action, dispatch),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps, mapActionToProps)(Test);</span><br></pre></td></tr></table></figure><p><strong><em> 具体的使用方法已在上面，下面再去讲解redux原理 </em></strong></p><h2 id="redux原理说明"><a href="#redux原理说明" class="headerlink" title="redux原理说明"></a>redux原理说明</h2><p>redux状态管理大致流程：</p><p>component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render</p><p>reducer中数据改变即store中数据改变为何会导致 component props改变呢？<br>其实就是connect函数。</p><p>我们在组件中，<br>export default connect(mapStateToProps, mapActionToProps)(Test);<br>connet是一个柯里化函数。<br>第一组入参两个：<br>第一个mapStateToProps，其实就是将store中的数据绑定到props，<br>第二个mapActionToProps，是将action函数绑定到props，<br>所以我们在使用是，如取store中的值，<br>const { num } = this.props;<br>dispatch action：this.props.action.test();</p><p>第二组入参：当前的Test对象。</p><p>再往深考虑connect 函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在react-native中集成redux&quot;&gt;&lt;a href=&quot;#在react-native中集成redux&quot; class=&quot;headerlink&quot; title=&quot;在react-native中集成redux&quot;&gt;&lt;/a&gt;在react-native中集成redux&lt;/
      
    
    </summary>
    
    
      <category term="react" scheme="hexo/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>android sqlite的使用</title>
    <link href="hexo/blog/2019/11/android-sqlite%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>hexo/blog/2019/11/android-sqlite的使用.html</id>
    <published>2019-11-19T06:01:11.000Z</published>
    <updated>2019-11-21T03:43:42.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-sqlite的使用"><a href="#android-sqlite的使用" class="headerlink" title="android sqlite的使用"></a>android sqlite的使用</h1><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><p>a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法</p><h4 id="onCreate（SQLiteDatabase）"><a href="#onCreate（SQLiteDatabase）" class="headerlink" title="onCreate（SQLiteDatabase）"></a>onCreate（SQLiteDatabase）</h4><p>在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。</p><h4 id="onUpgrade（SQLiteDatabase，int，int）"><a href="#onUpgrade（SQLiteDatabase，int，int）" class="headerlink" title="onUpgrade（SQLiteDatabase，int，int）"></a>onUpgrade（SQLiteDatabase，int，int）</h4><p>当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。</p><h4 id="onOpen（SQLiteDatabase）"><a href="#onOpen（SQLiteDatabase）" class="headerlink" title="onOpen（SQLiteDatabase）"></a>onOpen（SQLiteDatabase）</h4><p>这是当打开数据库时的回调函数，一般在程序中不是很常使用。</p><p>在构造函数中创建数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 数据表名</span><br><span class="line">   private static final String TABLE_NAME = &quot;userlog.db&quot;;</span><br><span class="line"></span><br><span class="line">   public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123;</span><br><span class="line">       super(context, name, factory, version);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public MyDatabase(Context context, int version) &#123;</span><br><span class="line">       this(context, TABLE_NAME, null, version);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在onCreate方法中创建数据表<br>数据库数据类型：<br>NULL：null值<br>INTEGER：整数，1、2、3、4、6、8字节<br>REAL：浮点值，8字节<br>TEXT：字符串<br>BLOB：blob数据<br>DATE：日期 年月日<br>TIME：时刻 时分秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">       Log.d(TAG, &quot;onCreate: onCreate&quot;);</span><br><span class="line">       String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;;</span><br><span class="line">       db.execSQL(sql);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong><em> 然后在需要建表的实话，初始化一个该java类实例即可 </em></strong></p><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="增加-insert-一条数据"><a href="#增加-insert-一条数据" class="headerlink" title="增加 insert 一条数据"></a>增加 insert 一条数据</h4><p>1、使用sql语句插入一条数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;</span><br><span class="line">db.execSQL(sql);</span><br></pre></td></tr></table></figure></p><p>但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’</p><p>此时应该使用 ? 替代符，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123;</span><br><span class="line">    SQLiteDatabase db = getWritableDatabase();</span><br><span class="line">    StringBuilder sql = new StringBuilder();</span><br><span class="line">    sql.append(&quot;insert into &quot;)</span><br><span class="line">            .append(table_name)</span><br><span class="line">            .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;);</span><br><span class="line">    Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;;</span><br><span class="line">    Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString())));</span><br><span class="line">    db.execSQL(sql.toString(), values);</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-sqlite的使用&quot;&gt;&lt;a href=&quot;#android-sqlite的使用&quot; class=&quot;headerlink&quot; title=&quot;android sqlite的使用&quot;&gt;&lt;/a&gt;android sqlite的使用&lt;/h1&gt;&lt;h3 id=&quot;1、创建表
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ValueAnimator</title>
    <link href="hexo/blog/2019/10/ValueAnimator.html"/>
    <id>hexo/blog/2019/10/ValueAnimator.html</id>
    <published>2019-10-22T08:48:04.000Z</published>
    <updated>2019-10-22T08:48:33.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性动画-ValueAnimator"><a href="#属性动画-ValueAnimator" class="headerlink" title="属性动画 ValueAnimator"></a>属性动画 ValueAnimator</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;属性动画-ValueAnimator&quot;&gt;&lt;a href=&quot;#属性动画-ValueAnimator&quot; class=&quot;headerlink&quot; title=&quot;属性动画 ValueAnimator&quot;&gt;&lt;/a&gt;属性动画 ValueAnimator&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>canvas 中的方法</title>
    <link href="hexo/blog/2019/10/canvas-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2019/10/canvas-中的方法.html</id>
    <published>2019-10-22T08:09:46.000Z</published>
    <updated>2019-10-22T08:34:19.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="canvas-中的一些方法"><a href="#canvas-中的一些方法" class="headerlink" title="canvas 中的一些方法"></a>canvas 中的一些方法</h1><p>在canvas中一般使用的方法为<br>drawXXX(): 绘制的方法<br>clipXXX(): 裁剪的方法</p><h3 id="clipRect"><a href="#clipRect" class="headerlink" title="clipRect"></a>clipRect</h3><p>裁剪画布，clipRect(int left, top, right, bottom);<br>clipRectF(float left, top, right, bottom)</p><p>当执行了该方法，如clipRect(0,0,500,500);<br>则后面都只能在(0,0,500,500)区域绘制</p><h3 id="用Rect实现多区域裁剪"><a href="#用Rect实现多区域裁剪" class="headerlink" title="用Rect实现多区域裁剪"></a>用Rect实现多区域裁剪</h3><h4 id="intersect-交集】"><a href="#intersect-交集】" class="headerlink" title="intersect 交集】"></a>intersect 交集】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Rect rect = new Rect(0, 0, 500, 500);  </span><br><span class="line">          </span><br><span class="line">rect.intersect(250, 250, 750, 750); </span><br><span class="line">        </span><br><span class="line">canvas.clipRect(rect);</span><br><span class="line"></span><br><span class="line">// 取到区域(250, 250, 500, 500)</span><br></pre></td></tr></table></figure><p>绘制多个区域相交的区域</p><h4 id="union-合集"><a href="#union-合集" class="headerlink" title="union 合集"></a>union 合集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Rect rect = new Rect(0, 0, 500, 500);  </span><br><span class="line">      </span><br><span class="line">rect.union(250, 250, 750, 750);  </span><br><span class="line">    </span><br><span class="line">canvas.clipRect(rect);</span><br><span class="line"></span><br><span class="line">// 取到的区域为(0, 0, 750, 750)</span><br></pre></td></tr></table></figure><p>绘制多个区域之和</p><h3 id="clipPath-取出某个区域"><a href="#clipPath-取出某个区域" class="headerlink" title="clipPath 取出某个区域"></a>clipPath 取出某个区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 实例化路径</span><br><span class="line">mPath = new Path();</span><br><span class="line">// 移动起点至[50,50]</span><br><span class="line">mPath.moveTo(50, 50);  </span><br><span class="line">mPath.lineTo(75, 23);  </span><br><span class="line">mPath.lineTo(150, 100);  </span><br><span class="line">mPath.lineTo(80, 110);  </span><br><span class="line">// 闭合路径</span><br><span class="line">mPath.close();</span><br><span class="line"></span><br><span class="line">// 按照路径进行裁剪</span><br><span class="line">canvas.clipPath(mPath);</span><br></pre></td></tr></table></figure><p>即是将path区域裁剪出来<br>同样后面在能在该path区域绘制图形</p><h3 id="Region-Op"><a href="#Region-Op" class="headerlink" title="Region.Op"></a>Region.Op</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;canvas-中的一些方法&quot;&gt;&lt;a href=&quot;#canvas-中的一些方法&quot; class=&quot;headerlink&quot; title=&quot;canvas 中的一些方法&quot;&gt;&lt;/a&gt;canvas 中的一些方法&lt;/h1&gt;&lt;p&gt;在canvas中一般使用的方法为&lt;br&gt;drawXX
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>hashMap解析</title>
    <link href="hexo/blog/2019/09/hashMap%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2019/09/hashMap解析.html</id>
    <published>2019-09-03T06:01:51.000Z</published>
    <updated>2019-09-03T07:31:47.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><h3 id="Hash内部类Node："><a href="#Hash内部类Node：" class="headerlink" title="Hash内部类Node："></a>Hash内部类Node：</h3><p>Node(节点)，链表中的节点，当HashMap数据少于6条时，为链表结构，Node为其中的节点。<br>链表数据结构，每一个节点都记录下一个节点的地址。<br>在Node的构造函数中，直接包含了下一个节点，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        // 将下一个节点作为入参放入构造函数中</span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p><p>获取某个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        Node&lt;K,V&gt; first, e;</span><br><span class="line">        int n;</span><br><span class="line">        K k;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                // 当为树结构的时候</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                // 获取树形结构中某个节点</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                // 遍历链表结构    </span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap源码分析&quot;&gt;&lt;a href=&quot;#HashMap源码分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码分析&quot;&gt;&lt;/a&gt;HashMap源码分析&lt;/h1&gt;&lt;h3 id=&quot;Hash内部类Node：&quot;&gt;&lt;a href=&quot;#Hash内
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>升级rn版本适配android64</title>
    <link href="hexo/blog/2019/08/%E5%8D%87%E7%BA%A7rn%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8Dandroid64.html"/>
    <id>hexo/blog/2019/08/升级rn版本适配android64.html</id>
    <published>2019-08-21T01:31:14.000Z</published>
    <updated>2019-08-21T01:38:46.589Z</updated>
    
    <content type="html"><![CDATA[<p>google play在2019/08/01起实施强制支持64位手机的措施。</p><p>因为之前的version为0.55.4,到0.59.1版本更新太多，<br>采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;google play在2019/08/01起实施强制支持64位手机的措施。&lt;/p&gt;
&lt;p&gt;因为之前的version为0.55.4,到0.59.1版本更新太多，&lt;br&gt;采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="react-native" scheme="hexo/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava + Retrofit 实现BaseResult</title>
    <link href="hexo/blog/2019/07/Rxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html"/>
    <id>hexo/blog/2019/07/Rxjava-Retrofit-实现BaseResult.html</id>
    <published>2019-07-25T03:24:56.000Z</published>
    <updated>2019-07-25T03:25:23.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rxjava-Retrofit-实现BaseResult"><a href="#Rxjava-Retrofit-实现BaseResult" class="headerlink" title="Rxjava + Retrofit 实现BaseResult"></a>Rxjava + Retrofit 实现BaseResult</h1><p>最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。<br>答案肯定是可以的。本文只讲使用。</p><h4 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;</span><br><span class="line">implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;</span><br><span class="line">implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;</span><br><span class="line">implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;</span><br><span class="line">implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;</span><br></pre></td></tr></table></figure><h4 id="普通使用案例"><a href="#普通使用案例" class="headerlink" title="普通使用案例"></a>普通使用案例</h4><p>首先创建实体数据类Test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;=====TEST&quot;;</span><br><span class="line"></span><br><span class="line">    String key = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String test = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public void log() &#123;</span><br><span class="line">        Log.d(TAG,&quot;key=&quot;  + key);</span><br><span class="line">        Log.d(TAG, &quot;test=&quot; + test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写一个接口TestServer，申明请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface TestService &#123;</span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Test&gt;getObJson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void testService() &#123;</span><br><span class="line">      // 实例化一个Retrofit 对象</span><br><span class="line">        Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">                .baseUrl(&quot;http://192.168.1.42:8080/&quot;)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        TestServer service = retrofit.create(TestService.class);</span><br><span class="line">         service.getObJson()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(new Observer&lt;Test&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onNext(Test test) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="开发考虑"><a href="#开发考虑" class="headerlink" title="开发考虑"></a>开发考虑</h3><p>我们不可能每个请求都重新创建一个Retrofit对象，<br>而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。<br>所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。</p><h5 id="1、写一个result实体类"><a href="#1、写一个result实体类" class="headerlink" title="1、写一个result实体类"></a>1、写一个result实体类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 因为每一个接口返回的数据结构都不同，肯定要用泛型。</span><br><span class="line">public class Result&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final String TAG = &quot;Result ====&quot;;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    private String code = &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public void logCode() &#123;</span><br><span class="line">        Log.d(TAG, code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getLongCode() &#123;</span><br><span class="line">        long resultCode = 0;</span><br><span class="line">        if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123;</span><br><span class="line">            resultCode = Long.parseLong(code);</span><br><span class="line">        &#125;</span><br><span class="line">        return resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log() &#123;</span><br><span class="line">        Log.d(TAG, &quot;msg:&quot; +msg + &quot;\n code:&quot; + code + &quot;\n data:&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getResultData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论</strong></p><p>然后需要写一个BaseObserver观察者基类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 这里还是因为接口返回数据格式问题，使用泛型。</span><br><span class="line">public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final String TAG = &quot;====BaseObserver===&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求成功</span><br><span class="line">     * @param t</span><br><span class="line">     */</span><br><span class="line">    public abstract void onSuccess(T t);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当返回的code值错误时的默认方法</span><br><span class="line">     * @param code</span><br><span class="line">     */</span><br><span class="line">    public void onResultCodeErr(long code) &#123;</span><br><span class="line">        Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Result result) &#123;</span><br><span class="line">        if(result.getLongCode() != 200) &#123;</span><br><span class="line">            onResultCodeErr(result.getLongCode());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            onSuccess((T)result.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        result.log();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError&quot;);</span><br><span class="line">        Log.d(TAG, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的Server类就变成了如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TestService &#123;</span><br><span class="line"></span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson();</span><br><span class="line"></span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Test&gt;getObJson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(Test test) &#123;</span><br><span class="line">            Log.d(&quot;======&quot;, &quot;onSuccess&quot;);</span><br><span class="line">            test.log();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /** Retrofit + Rxjav */</span><br><span class="line">    private void testRxjavaService() &#123;</span><br><span class="line">        Retrofit retrofit = RetrofitUtil.getRetrofit();</span><br><span class="line">        TestService ts = retrofit.create(TestService.class);</span><br><span class="line">        ts.getTestRxjavaJson()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(observer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rxjava-Retrofit-实现BaseResult&quot;&gt;&lt;a href=&quot;#Rxjava-Retrofit-实现BaseResult&quot; class=&quot;headerlink&quot; title=&quot;Rxjava + Retrofit 实现BaseResult&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门（三）布局组件</title>
    <link href="hexo/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html"/>
    <id>hexo/blog/2019/07/Flutter入门（三）布局组件.html</id>
    <published>2019-07-25T03:00:09.000Z</published>
    <updated>2019-07-25T03:10:55.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter入门（三）布局组件"><a href="#Flutter入门（三）布局组件" class="headerlink" title="Flutter入门（三）布局组件"></a>Flutter入门（三）布局组件</h1><p>之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！</p><p><img src="../images/flutter1.png" alt="fluttercn.png"></p><p>查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍</p><h3 id="ui组件"><a href="#ui组件" class="headerlink" title="ui组件"></a>ui组件</h3><p>学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。</p><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    &apos;要显示的文本&apos;, </span><br><span class="line">    &#123;</span><br><span class="line">        textAlign: TextAlign.center, // 文本横向对齐方式 居中</span><br><span class="line">        overflow: TextOverflow.ellipsis, // 文本溢出处理方式</span><br><span class="line">        textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left)</span><br><span class="line">        softWrap: true, // 是否自动换行</span><br><span class="line">        textScaleFactor: 2.0, // 字体显示倍率</span><br><span class="line">        maxLines: 1, // 文本最大行数</span><br><span class="line">        style: new TextStyle(</span><br><span class="line">            color: Colors.purple,</span><br><span class="line">            fontSize: 20.0,</span><br><span class="line">        ), // 文本样式</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter入门（三）布局组件&quot;&gt;&lt;a href=&quot;#Flutter入门（三）布局组件&quot; class=&quot;headerlink&quot; title=&quot;Flutter入门（三）布局组件&quot;&gt;&lt;/a&gt;Flutter入门（三）布局组件&lt;/h1&gt;&lt;p&gt;之前吐槽过flutter中文
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter入门  vscode调试及查看日志</title>
    <link href="hexo/blog/2019/07/flutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html"/>
    <id>hexo/blog/2019/07/flutter入门-vscode调试及查看日志.html</id>
    <published>2019-07-25T02:55:36.000Z</published>
    <updated>2019-07-25T03:12:04.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flutter入门-vscode调试及查看日志"><a href="#flutter入门-vscode调试及查看日志" class="headerlink" title="flutter入门  vscode调试及查看日志"></a>flutter入门  vscode调试及查看日志</h1><p>开发肯定需要调试应用，以及查看日志。</p><p>在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。</p><p>还有一个print()函数，最终发现这个是可以的。</p><h4 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h4><p>a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。</p><p>b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出</p><p>c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出</p><h4 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h4><p>print()日志输出函数<br>通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出</p><p>ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。</p><h4 id="用vscode调试flutetr"><a href="#用vscode调试flutetr" class="headerlink" title="用vscode调试flutetr"></a>用vscode调试flutetr</h4><p><img src="../images/log1.png" alt="fluttervscode.png"><br>一个正常的flutter项目用vscode应该是这样的。<br>之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。</p><p>点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目<br><img src="../images/log2.png" alt="run.png"></p><p>我打了一个断点，当项目运行起来，如下图。<br><img src="../images/log3.png" alt="debugger.png"></p><p>当我点击按钮，进入断点。如下图<br>可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。<br><img src="../images/log4.png" alt="indebugger.png"></p><p>添加断点点击代码左侧的红框区域即可（下图）。<br><img src="../images/log5.png" alt="adddebugger.png"></p><p>在左上角的调试/新建断点 也可以。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;flutter入门-vscode调试及查看日志&quot;&gt;&lt;a href=&quot;#flutter入门-vscode调试及查看日志&quot; class=&quot;headerlink&quot; title=&quot;flutter入门  vscode调试及查看日志&quot;&gt;&lt;/a&gt;flutter入门  vscod
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门（二） 使用vscode编写第一个Flutter应用</title>
    <link href="hexo/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html"/>
    <id>hexo/blog/2019/07/Flutter入门（二）-使用vscode编写第一个Flutter应用.html</id>
    <published>2019-07-25T02:51:37.000Z</published>
    <updated>2019-07-25T03:12:34.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter入门（二）-使用vscode编写第一个Flutter应用"><a href="#Flutter入门（二）-使用vscode编写第一个Flutter应用" class="headerlink" title="Flutter入门（二） 使用vscode编写第一个Flutter应用"></a>Flutter入门（二） 使用vscode编写第一个Flutter应用</h1><p>在上一篇中我们利用android studio运行了一个hello word项目。<br>作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。</p><p>###1、配置插件<br>需要在vscode中下载插件<br><img src="../images/dart1.png" alt="dartPlugin.png"><br><img src="../images/dart2.png" alt="flutterPlugin.png"><br>找到这两个插件下载好并重新加载vscode就可以了。</p><p>###2、运行<br>flutter项目的运行命令是 flutter run<br>但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。<br>你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。</p><p>在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。<br>还有有一些提示信息<br><img src="../images/dart3.png" alt="tips.png"></p><p>当你需要热加载的时候按 r，需要重启应用按R。<br>所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。</p><p>###3、写第一个flutter应用。<br>按照flutter中文网（<a href="https://flutterchina.club/get-started/codelab/）" target="_blank" rel="noopener">https://flutterchina.club/get-started/codelab/）</a><br>写我们第一个flutter应用。<br>其中我个人碰到一个问题。<br>就是在第2步、使用外部package中，<br><img src="../images/dart4.png" alt="package.png"></p><p>在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。<br>然后重新打开vscode才好，应该是vscode对这个以来的读取问题。</p><p>然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。</p><p>###个人体会</p><p><strong>flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼</strong></p><p>fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。<br>没有对state这个做解释、没有state的使用说明，然后那个路由也是。</p><p>##待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter入门（二）-使用vscode编写第一个Flutter应用&quot;&gt;&lt;a href=&quot;#Flutter入门（二）-使用vscode编写第一个Flutter应用&quot; class=&quot;headerlink&quot; title=&quot;Flutter入门（二） 使用vscode编
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门（一）环境配置</title>
    <link href="hexo/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
    <id>hexo/blog/2019/07/Flutter入门（一）环境配置.html</id>
    <published>2019-07-25T02:41:53.000Z</published>
    <updated>2019-07-25T03:12:56.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter入门（一）环境配置"><a href="#Flutter入门（一）环境配置" class="headerlink" title="Flutter入门（一）环境配置"></a>Flutter入门（一）环境配置</h1><p>在/flutter/bin目录下执行 flutter doctor命令。</p><h3 id="3、android-studio插件"><a href="#3、android-studio插件" class="headerlink" title="3、android studio插件"></a>3、android studio插件</h3><p>下载android studio就不说了，打开android studio/file/setting/plugin/<br><img src="../images/image.png" alt="plugin.png"><br>输入 flutter查找并install。<br>第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。</p><p>在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project<br><img src="../images/image0.png" alt="flutter.png"></p><h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h2><p>按照惯例，接下来我们跑一个hello world。</p><p>照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。</p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p><img src="../images/image1.png" alt="flutterRun.png"></p><p>项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，<br>pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。<br>在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行</p><p><img src="../images/image2.png" alt="hello.png"></p><p>第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter入门（一）环境配置&quot;&gt;&lt;a href=&quot;#Flutter入门（一）环境配置&quot; class=&quot;headerlink&quot; title=&quot;Flutter入门（一）环境配置&quot;&gt;&lt;/a&gt;Flutter入门（一）环境配置&lt;/h1&gt;&lt;p&gt;在/flutter/bin目
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter数据持久化</title>
    <link href="hexo/blog/2019/07/flutter%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>hexo/blog/2019/07/flutter数据持久化.html</id>
    <published>2019-07-25T02:40:34.000Z</published>
    <updated>2019-07-25T02:40:56.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="flutter数据持久化"><a href="#flutter数据持久化" class="headerlink" title="flutter数据持久化"></a>flutter数据持久化</h3><h5 id="shared-preferences"><a href="#shared-preferences" class="headerlink" title="shared_preferences"></a>shared_preferences</h5><p>本地存储临时数据<br>此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。</p><p>添加插件依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在pubspec.yaml文件中添加依赖</span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  shared_preferences: &quot;&lt;newest version&gt;&quot;</span><br></pre></td></tr></table></figure><p>调用：</p><p>shared_preference 存储方式是根据key-value形式<br>使用便捷，但有限制：<br>    a: 只能使用原始类型: int，double，bool，string 和 string list。<br>    b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &apos;package:shared_preferences/shared_preferences.dart&apos;;</span><br><span class="line"></span><br><span class="line">getAsyncData() async &#123;</span><br><span class="line">    // 获取实例</span><br><span class="line">    var prefs = await SharedPreferences.getInstance();</span><br><span class="line">    // 获取存储数据</span><br><span class="line">    var count = prefs.getInt(&apos;count&apos;) ?? 0 + 1;</span><br><span class="line">    // 设置存储数据</span><br><span class="line">    await prefs.setInt(&apos;count&apos;, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;flutter数据持久化&quot;&gt;&lt;a href=&quot;#flutter数据持久化&quot; class=&quot;headerlink&quot; title=&quot;flutter数据持久化&quot;&gt;&lt;/a&gt;flutter数据持久化&lt;/h3&gt;&lt;h5 id=&quot;shared-preferences&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>dart语言语法糖</title>
    <link href="hexo/blog/2019/07/dart%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E7%B3%96.html"/>
    <id>hexo/blog/2019/07/dart语言语法糖.html</id>
    <published>2019-07-25T02:35:05.000Z</published>
    <updated>2019-07-25T02:35:29.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dart语言语法糖"><a href="#dart语言语法糖" class="headerlink" title="dart语言语法糖"></a>dart语言语法糖</h3><p>a、 以 _命名的变量或函数为强制私有</p><p>var _num;</p><p>b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int getInt() =&gt; 2;</span><br><span class="line"></span><br><span class="line">int getInt() =&gt; isTrue ? 2 : 0;</span><br></pre></td></tr></table></figure><p>c、 运算符</p><p>aa ?? bb; ?? 为null 时</p><p>d、异步 </p><p>async await then</p><p>async、await使用与rn中使用方式一致</p><p>.then也是异步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/// 设置需要填写的内容</span><br><span class="line">    _setDefaultData(List&lt;dynamic&gt; list) &#123;</span><br><span class="line">      Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;);</span><br><span class="line">      List&lt;dynamic&gt; list1 = [];</span><br><span class="line"></span><br><span class="line">      /// 对jsonStr数据做解析</span><br><span class="line">      jsonStr.then((value) &#123;</span><br><span class="line">        var data = json.decode(value);</span><br><span class="line">        if(list != null || list.length &gt; 0) &#123;</span><br><span class="line">          data = list;</span><br><span class="line">        &#125;</span><br><span class="line">        print(&apos;data ====&apos; + data.toString());</span><br><span class="line">        data.forEach((item) &#123;</span><br><span class="line">          if(item[&apos;type&apos;] == &apos;1&apos;) &#123;</span><br><span class="line">            list1.add(item);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      print(&apos;list1======&apos; + list1.toString());</span><br><span class="line">      this.setState(() &#123;</span><br><span class="line">        this.saveList = list1;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如图这种代码会先输出list1的信息，然后在输出data的信息<br>说明jsonStr.then 为异步操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;dart语言语法糖&quot;&gt;&lt;a href=&quot;#dart语言语法糖&quot; class=&quot;headerlink&quot; title=&quot;dart语言语法糖&quot;&gt;&lt;/a&gt;dart语言语法糖&lt;/h3&gt;&lt;p&gt;a、 以 _命名的变量或函数为强制私有&lt;/p&gt;
&lt;p&gt;var _num;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter android端 原理解析</title>
    <link href="hexo/blog/2019/07/flutter-android%E7%AB%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2019/07/flutter-android端-原理解析.html</id>
    <published>2019-07-25T02:32:54.000Z</published>
    <updated>2019-07-25T02:33:34.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flutter-android端-原理解析"><a href="#flutter-android端-原理解析" class="headerlink" title="flutter android端 原理解析"></a>flutter android端 原理解析</h1><p>首先看MainActivity，</p><p>继承FlutterActivity</p><p>再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);</span><br><span class="line">private final FlutterActivityEvents eventDelegate;</span><br><span class="line">private final Provider viewProvider;</span><br><span class="line">private final PluginRegistry pluginRegistry;</span><br><span class="line"></span><br><span class="line">public FlutterActivity() &#123;</span><br><span class="line">    this.eventDelegate = this.delegate;</span><br><span class="line">    this.viewProvider = this.delegate;</span><br><span class="line">    this.pluginRegistry = this.delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    this.eventDelegate.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看delegate就知道代理模式</p><p>在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值，</p><p>FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。</p><p>FlutterActivityDelegate 就是FlutterActivityEvents类的实现.</p><p>看FlutterActivityDelegate类中的onCreate函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        if (VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">            Window window = this.activity.getWindow();</span><br><span class="line">            window.addFlags(-2147483648);</span><br><span class="line">            window.setStatusBarColor(1073741824);</span><br><span class="line">            window.getDecorView().setSystemUiVisibility(1280);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] args = getArgsFromIntent(this.activity.getIntent());</span><br><span class="line">        FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args);</span><br><span class="line">        this.flutterView = this.viewFactory.createFlutterView(this.activity);</span><br><span class="line">        if (this.flutterView == null) &#123;</span><br><span class="line">            FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView();</span><br><span class="line">            this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView);</span><br><span class="line">            this.flutterView.setLayoutParams(matchParent);</span><br><span class="line">            this.activity.setContentView(this.flutterView);</span><br><span class="line">            this.launchView = this.createLaunchView();</span><br><span class="line">            if (this.launchView != null) &#123;</span><br><span class="line">                this.addLaunchView();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!this.loadIntent(this.activity.getIntent())) &#123;</span><br><span class="line">            String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext());</span><br><span class="line">            if (appBundlePath != null) &#123;</span><br><span class="line">                this.runBundle(appBundlePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。</p><h2 id="android端与dart端通信"><a href="#android端与dart端通信" class="headerlink" title="android端与dart端通信"></a>android端与dart端通信</h2><h3 id="1、dart端调用android端代码"><a href="#1、dart端调用android端代码" class="headerlink" title="1、dart端调用android端代码"></a>1、dart端调用android端代码</h3><h4 id="1、原生android代码"><a href="#1、原生android代码" class="headerlink" title="1、原生android代码"></a>1、原生android代码</h4><p>新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。</p><p>重写onMethodCall方法，在此处写需要实现的逻辑代码</p><p>最后是将插件绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TestPlugin implements MethodChannel.MethodCallHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static final String CHANNEL = &quot;plugin/test&quot;;</span><br><span class="line"></span><br><span class="line">    static MethodChannel channel;</span><br><span class="line"></span><br><span class="line">    // 上下文</span><br><span class="line">    private Activity activity;</span><br><span class="line"></span><br><span class="line">    private TestPlugin(Activity activity) &#123;</span><br><span class="line">        this.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void registerWith(PluginRegistry.Registrar registrar) &#123;</span><br><span class="line">        channel = new MethodChannel(registrar.messenger(), CHANNEL);</span><br><span class="line">        TestPlugin plugin = new TestPlugin(registrar.activity());</span><br><span class="line">        // 在此通道上接受方法调用的回调</span><br><span class="line">        channel.setMethodCallHandler(plugin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123;</span><br><span class="line"></span><br><span class="line">        if(methodCall.method.equals(&quot;test&quot;)) &#123;</span><br><span class="line">            Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">            result.success(&quot;调用成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 当未找到该函数</span><br><span class="line">        result.notImplemented();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity中绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MainActivity extends FlutterActivity &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    GeneratedPluginRegistrant.registerWith(this);</span><br><span class="line"></span><br><span class="line">    registerPlugin(this);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private void registerPlugin(PluginRegistry registry) &#123;</span><br><span class="line">    TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、在dart中调用该原生方法"><a href="#2、在dart中调用该原生方法" class="headerlink" title="2、在dart中调用该原生方法"></a>2、在dart中调用该原生方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static const _platform = const MethodChannel(&apos;plugin/test&apos;);</span><br><span class="line"></span><br><span class="line">_toast() &#123;</span><br><span class="line">    /// 调用原生的方法</span><br><span class="line">    _platform.invokeMethod(&apos;test&apos;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一个原生插件调用就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;flutter-android端-原理解析&quot;&gt;&lt;a href=&quot;#flutter-android端-原理解析&quot; class=&quot;headerlink&quot; title=&quot;flutter android端 原理解析&quot;&gt;&lt;/a&gt;flutter android端 原理解析&lt;/
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>facebook推广api 推广主页</title>
    <link href="hexo/blog/2019/07/facebook%E6%8E%A8%E5%B9%BFapi-%E6%8E%A8%E5%B9%BF%E4%B8%BB%E9%A1%B5.html"/>
    <id>hexo/blog/2019/07/facebook推广api-推广主页.html</id>
    <published>2019-07-11T02:58:31.000Z</published>
    <updated>2019-07-11T03:01:09.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主页推广"><a href="#主页推广" class="headerlink" title="主页推广"></a>主页推广</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主页推广&quot;&gt;&lt;a href=&quot;#主页推广&quot; class=&quot;headerlink&quot; title=&quot;主页推广&quot;&gt;&lt;/a&gt;主页推广&lt;/h1&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>maven</title>
    <link href="hexo/blog/2019/07/maven.html"/>
    <id>hexo/blog/2019/07/maven.html</id>
    <published>2019-07-08T06:36:59.000Z</published>
    <updated>2019-07-08T06:38:37.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><p>maven 查看依赖树<br>mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXX<br>code xxx // 打开xxx文件</p><p>gradle 查看依赖树<br>gradle app:dependency // 查看依赖树关系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;maven&quot;&gt;&lt;a href=&quot;#maven&quot; class=&quot;headerlink&quot; title=&quot;maven&quot;&gt;&lt;/a&gt;maven&lt;/h1&gt;&lt;p&gt;maven 查看依赖树&lt;br&gt;mvn dependency:tree &amp;gt; xxx // 将maven依赖树关系
      
    
    </summary>
    
    
  </entry>
  
</feed>
