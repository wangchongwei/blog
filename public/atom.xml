<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2022-06-27T08:32:55.268Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>减肥计划</title>
    <link href="hexo/blog/2022/06/%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92.html"/>
    <id>hexo/blog/2022/06/减肥计划.html</id>
    <published>2022-06-27T08:26:27.000Z</published>
    <updated>2022-06-27T08:32:55.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="减肥大计"><a href="#减肥大计" class="headerlink" title="减肥大计"></a>减肥大计</h1><p>暂时定为三个阶段，每个阶段目标均为 -5kg</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>通过修改饮食，加上 低运动量减肥操</p><h3 id="早餐"><a href="#早餐" class="headerlink" title="早餐"></a>早餐</h3><p>两个鸡蛋+ 一杯豆浆/一杯牛奶</p><h3 id="中餐"><a href="#中餐" class="headerlink" title="中餐"></a>中餐</h3><p>一碗米饭 + 青菜 + 适量牛肉、虾，保证蛋白质摄入</p><h3 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h3><p>玉米面/荞面 + 适量牛肉、虾</p><p>零食以 牛肉干、黄瓜 为准。</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>通过饮食， 加上适量有氧运动， 跑步<br>目标：75kg</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>通过饮食， 加上中等有氧运动， 跑步</p><p>目标：70kg</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;减肥大计&quot;&gt;&lt;a href=&quot;#减肥大计&quot; class=&quot;headerlink&quot; title=&quot;减肥大计&quot;&gt;&lt;/a&gt;减肥大计&lt;/h1&gt;&lt;p&gt;暂时定为三个阶段，每个阶段目标均为 -5kg&lt;/p&gt;
&lt;h2 id=&quot;第一阶段&quot;&gt;&lt;a href=&quot;#第一阶段&quot; class
      
    
    </summary>
    
    
      <category term="live" scheme="hexo/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>android API 更新</title>
    <link href="hexo/blog/2022/06/android-API-%E6%9B%B4%E6%96%B0.html"/>
    <id>hexo/blog/2022/06/android-API-更新.html</id>
    <published>2022-06-27T08:05:51.000Z</published>
    <updated>2022-06-27T08:08:54.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-API-更新记录"><a href="#android-API-更新记录" class="headerlink" title="android API 更新记录"></a>android API 更新记录</h1><h2 id="android-API-30-（android11）应用文件管理权限"><a href="#android-API-30-（android11）应用文件管理权限" class="headerlink" title="android API 30 （android11）应用文件管理权限"></a>android API 30 （android11）应用文件管理权限</h2><p>在andorid6之后需要动态请求权限，如针对文件写入、读取权限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">    <span class="keyword">var</span> permissionArray = arrayOf(</span><br><span class="line">        Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">    )</span><br><span class="line">    requestPermissions(permissionArray, <span class="number">101</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在android 11之后，这样也会弹出应用权限请求，但写入文件到sdcrd还是会失败，报错：/storage/emulated/0/io/okio.txt: open failed: ENOENT (No such file or directory)</p><p>需要修改请求权限的方式为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Environment.isExternalStorageManager()) &#123;</span><br><span class="line">    <span class="keyword">var</span> intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">    startActivityForResult(intent, <span class="number">102</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-API-更新记录&quot;&gt;&lt;a href=&quot;#android-API-更新记录&quot; class=&quot;headerlink&quot; title=&quot;android API 更新记录&quot;&gt;&lt;/a&gt;android API 更新记录&lt;/h1&gt;&lt;h2 id=&quot;android-A
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="hexo/blog/2022/06/io.html"/>
    <id>hexo/blog/2022/06/io.html</id>
    <published>2022-06-22T08:51:23.000Z</published>
    <updated>2022-06-27T03:18:42.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO是什么"><a href="#IO是什么" class="headerlink" title="IO是什么"></a>IO是什么</h2><blockquote><p>程序内部和外部进行数据交互的过程，就叫输入输出。</p><blockquote><p>程序内部是谁?内存<br>程序外部是谁?</p><blockquote><p>一般来说是两类:本地文件和网络。<br>也有别的情况，比如你和别的程序做交互，和你交互的程序也属于外部，但一般来说，就是文件和网络这么两种。</p></blockquote></blockquote></blockquote><blockquote><p>从文件里或者从网络上读数据到内存里，就叫输入;从内存里写到文件里或者发送到网络上，就叫输出</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><p>使用流，例如 FileInputStream / FileOutputStream</p></li><li><p>可以用 Reader 和 Writer 来对字符进行读写</p></li><li><p>流的外面还可以套别的流，层层嵌套都可以</p></li><li><p>BufferedXXXX 可以给流加上缓冲。对于输入流，是每次多读一些放在内存 里面，下次再去数据就不用再和外部做交互(即不必做 IO 操作);对于输 出流，是把数据先在内存里面攒一下，攒够一波了再往外部去写。</p></li></ul><p>通过缓存的方式减少和和外部的交互，从而可以提高效率</p><ul><li><p>文件的关闭:close()</p></li><li><p>需要用到的写过的数据，flush() 一下可以保证数据真正写到外部去(读数据 没有这样的担忧)</p></li><li><p>这个就是 Java 的 I/O，它的原理就是内存和外界的交互</p></li></ul><p>IO 又可以分为 BIO、NIO、AIO</p><h2 id="BIO、NIO、AIO-区别"><a href="#BIO、NIO、AIO-区别" class="headerlink" title="BIO、NIO、AIO 区别"></a>BIO、NIO、AIO 区别</h2><h3 id="IO模型主要分类："><a href="#IO模型主要分类：" class="headerlink" title="IO模型主要分类："></a>IO模型主要分类：</h3><ul><li><p>同步(synchronous)IO与异步(asynchronous)IO</p></li><li><p>阻塞(blocking)IO与非阻塞(non-blocking)IO</p></li><li><p>同步阻塞IO(blocking-IO)即为 BIO</p></li><li><p>同步非阻塞IO(non-blocking-IO)即为 NIO</p></li><li><p>异步非阻塞IO(synchronous-non-blocking-IO)即为 AIO</p></li></ul><h3 id="BIO（同步阻塞I-O模式）"><a href="#BIO（同步阻塞I-O模式）" class="headerlink" title="BIO（同步阻塞I/O模式）"></a>BIO（同步阻塞I/O模式）</h3><p>数据的读取、写入等操作必须阻塞在一个线程内等待操作完成</p><h3 id="NIO（同步非阻塞I-O模式）"><a href="#NIO（同步非阻塞I-O模式）" class="headerlink" title="NIO（同步非阻塞I/O模式）"></a>NIO（同步非阻塞I/O模式）</h3><p>同时支持阻塞与非阻塞模式，NIO的做法是叫一个线程不断的轮询IO操作的的状态，看看是否有任务的状态发生了改变，从而进行下一步的操作。</p><p>默认是阻塞式的</p><h3 id="AIO-（异步非阻塞I-O模型）"><a href="#AIO-（异步非阻塞I-O模型）" class="headerlink" title="AIO （异步非阻塞I/O模型）"></a>AIO （异步非阻塞I/O模型）</h3><p>异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p><p>对应到IO操作中就是，为每次IO操作上面装了一个开关，IO操作完毕之后，会自动通知任务完成。</p><h3 id="IO-与-NIO-的区别"><a href="#IO-与-NIO-的区别" class="headerlink" title="IO 与 NIO 的区别"></a>IO 与 NIO 的区别</h3><p>IO 面向流</p><p>NIO 面向缓冲区，具备 选择器(Selectors)</p><h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><ul><li><p>同步</p><ul><li>发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生。</li></ul></li><li><p>异步</p><ul><li>发送一个请求，不等待返回，随时可以再发送下一个请求，可以提高效率，保证并发。</li></ul></li></ul><h3 id="阻塞与非阻塞的区别"><a href="#阻塞与非阻塞的区别" class="headerlink" title="阻塞与非阻塞的区别"></a>阻塞与非阻塞的区别</h3><ul><li>阻塞</li></ul><blockquote><p>传统的IO流都是阻塞式的。也就是说，当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务。在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降。  </p></blockquote><ul><li>非阻塞</li></ul><blockquote><p>JavaNIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。  </p></blockquote><h2 id="NIO-3个核心概念"><a href="#NIO-3个核心概念" class="headerlink" title="NIO 3个核心概念"></a>NIO 3个核心概念</h2><p><img src="../../../images/nio.png" style="zoom:70%"></p><p>NIO重点是把Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系弄清楚。</p><h3 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。  </p><p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。  </p><p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。  </p><p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：  </p><ul><li><p>ByteBuffer：字节缓冲区  </p></li><li><p>CharBuffer:字符缓冲区  </p></li><li><p>ShortBuffer：短整型缓冲区  </p></li><li><p>IntBuffer：整型缓冲区  </p></li><li><p>LongBuffer:长整型缓冲区  </p></li><li><p>FloatBuffer：浮点型缓冲区  </p></li><li><p>DoubleBuffer：双精度浮点型缓冲区  </p></li></ul><h3 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p><p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p><p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p><p>Channel有四种实现：</p><ul><li><p>FileChannel:是从文件中读取数据。</p></li><li><p>DatagramChannel:从UDP网络中读取或者写入数据。</p></li><li><p>SocketChannel:从TCP网络中读取或者写入数据。</p></li><li><p>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</p></li></ul><h3 id="多路复用器Selector"><a href="#多路复用器Selector" class="headerlink" title="多路复用器Selector"></a>多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p><h4 id="关键对象"><a href="#关键对象" class="headerlink" title="关键对象"></a>关键对象</h4><ul><li><p>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</p></li><li><p>SelectorKey：通道监听关键字，通过它来监听通道状态。</p></li></ul><h4 id="监听注册"><a href="#监听注册" class="headerlink" title="监听注册"></a>监听注册</h4><p>监听注册在Selector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><h4 id="监听的事件有"><a href="#监听的事件有" class="headerlink" title="监听的事件有"></a>监听的事件有</h4><ul><li><p>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</p></li><li><p>OP_READ: 读取就绪，socketChannel使用</p></li><li><p>OP_WRITE: 写入就绪，socketChannel使用</p></li><li><p>OP_CONNECT: 连接就绪，socketChannel使用</p></li></ul><h2 id="OKIO"><a href="#OKIO" class="headerlink" title="OKIO"></a>OKIO</h2><p>okhttp框架中，使用的io</p><p>OKio本质上是对Java的NIO的一次扩展，并且做了缓存的优化，</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>它也是基于插管的，而且是单向的，输入源叫 Source，输出目标叫 Sink</li><li>支持 Buffer<ul><li>像 NIO 一样，可以对 Buffer 进行操作</li><li>但不强制使用 Buffer</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;h2 id=&quot;IO是什么&quot;&gt;&lt;a href=&quot;#IO是什么&quot; class=&quot;headerlink&quot; title=&quot;IO是什么&quot;&gt;&lt;/a&gt;IO是什
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jetpack hilt</title>
    <link href="hexo/blog/2022/06/jetpack-hilt.html"/>
    <id>hexo/blog/2022/06/jetpack-hilt.html</id>
    <published>2022-06-16T06:09:19.000Z</published>
    <updated>2022-06-22T08:50:59.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a>Hilt</h1><p>先讲使用，再讲原理</p><p>google文档地址：<a href="https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn</a></p><p><a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/hilt" target="_blank" rel="noopener">示例源码地址</a></p><h2 id="使用示例：-Hilt-ViewModel-Repository"><a href="#使用示例：-Hilt-ViewModel-Repository" class="headerlink" title="使用示例： Hilt + ViewModel + Repository"></a>使用示例： Hilt + ViewModel + Repository</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ul><li>注意事项不要参考google文档中的地址设置版本号，因为文档中使用的是 aplha 版本，API会随时变动，很可能使用此版本但运行结果与文档不同，本人就碰到了，（@HiltViewModel 不可用） *</li></ul><p>在项目根目录的 build.gradle 中添加：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.hilt_version = <span class="string">"2.36"</span></span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">// hilt</span></span><br><span class="line">        classpath <span class="string">"com.google.dagger:hilt-android-gradle-plugin:$hilt_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在需要使用 hilt 的 module 的 build.gradle 文件中添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hilt</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:hilt-android:$hilt_version"</span></span><br><span class="line">kapt <span class="string">"com.google.dagger:hilt-android-compiler:$hilt_version"</span></span><br></pre></td></tr></table></figure><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltAndroidApp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">var</span> repository: HiltRepository,</span><br><span class="line">): ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repository.login()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor"><a href="#注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor" class="headerlink" title="注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()"></a>注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityHiltBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: HiltViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityHiltBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，此时生成 viewModel实例时，无需再次传入参数，也不需要另外使用ViewModelFactory来生成。<br>原因就是在 Repository 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过注解已经提供了生成 HiltRepository 实例的方式。</p><p>以上就是一次简单的使用。</p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hilt&quot;&gt;&lt;a href=&quot;#Hilt&quot; class=&quot;headerlink&quot; title=&quot;Hilt&quot;&gt;&lt;/a&gt;Hilt&lt;/h1&gt;&lt;p&gt;先讲使用，再讲原理&lt;/p&gt;
&lt;p&gt;google文档地址：&lt;a href=&quot;https://developer.android
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CameraX</title>
    <link href="hexo/blog/2022/03/CameraX.html"/>
    <id>hexo/blog/2022/03/CameraX.html</id>
    <published>2022-03-28T07:51:31.000Z</published>
    <updated>2022-03-28T09:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。</p><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> camerax_version = <span class="string">"1.0.2"</span></span><br><span class="line">  <span class="comment">// The following line is optional, as the core library is included indirectly by camera-camera2</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-core:$&#123;camerax_version&#125;"</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-camera2:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Lifecycle library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX VideoCapture library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-video:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX View class</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-view:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Extensions library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-extensions:1.1.0-beta02"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-CameraX-开启预览"><a href="#使用-CameraX-开启预览" class="headerlink" title="使用 CameraX 开启预览"></a>使用 CameraX 开启预览</h2><p>在向应用添加预览时，请使用 PreviewView，这是一种可以剪裁、缩放和旋转以确保正确显示的 View。</p><p>当相机处于活动状态时，图片预览会流式传输到 PreviewView 中的 Surface。</p><h3 id="将-PreviewView-添加到布局"><a href="#将-PreviewView-添加到布局" class="headerlink" title="将 PreviewView 添加到布局"></a>将 PreviewView 添加到布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".camera.CameraActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.camera.view.PreviewView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/previewView"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="请求-CameraProvider"><a href="#请求-CameraProvider" class="headerlink" title="请求 CameraProvider"></a>请求 CameraProvider</h3><p>以下代码展示了如何请求 CameraProvider：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> cameraProviderFuture: ListenableFuture&lt;ProcessCameraProvider&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> dataBinding: ActivityCameraBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        dataBinding = ActivityCameraBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(dataBinding.root)</span><br><span class="line">        cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查-CameraProvider-可用性"><a href="#检查-CameraProvider-可用性" class="headerlink" title="检查 CameraProvider 可用性"></a>检查 CameraProvider 可用性</h3><p>请求 CameraProvider 后，请验证它能否在视图创建后成功初始化。以下代码展示了如何执行此操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">  <span class="keyword">val</span> cameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line">  bindPreview(cameraProvider)</span><br><span class="line"></span><br><span class="line">&#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure><h3 id="选择相机并绑定生命周期和用例"><a href="#选择相机并绑定生命周期和用例" class="headerlink" title="选择相机并绑定生命周期和用例"></a>选择相机并绑定生命周期和用例</h3><p>创建并确认 CameraProvider 后，请执行以下操作:</p><ul><li><p>1、创建 Preview。</p></li><li><p>2、指定所需的相机 LensFacing 选项。</p></li><li><p>3、将所选相机和任意用例绑定到生命周期。</p></li><li><p>4、将 Preview 连接到 PreviewView。</p></li></ul><p>以下代码展示了一个示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindPreview</span><span class="params">(cameraProvider: <span class="type">ProcessCameraProvider</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> preview: Preview = Preview.Builder()</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cameraSelector: CameraSelector = CameraSelector.Builder()</span><br><span class="line">        .requireLensFacing(CameraSelector.LENS_FACING_BACK)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    preview.setSurfaceProvider(dataBinding.previewView.getSurfaceProvider())</span><br><span class="line">    <span class="keyword">var</span> camera = cameraProvider?.bindToLifecycle(<span class="keyword">this</span> <span class="keyword">as</span> LifecycleOwner, cameraSelector, preview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，bindToLifecycle() 会返回一个 Camera 对象。如需详细了解如何控制相机输出（如变焦和曝光），请参阅此指南。</p><p>现在，您已完成实现相机预览的操作。请构建您的应用，然后确认预览是否出现在您的应用中并能按预期工作。</p><p>PS: 记得需要相机权限</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。&lt;/p&gt;
&lt;h2 id=&quot;添加依赖项&quot;&gt;&lt;a href=&quot;#添加依赖项&quot; class=&quot;headerlink&quot; title=&quot;添加依赖项&quot;&gt;&lt;/a&gt;添加依赖项&lt;/h2&gt;&lt;fig
      
    
    </summary>
    
    
      <category term="android-Jetpack" scheme="hexo/tags/android-Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法</title>
    <link href="hexo/blog/2022/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2022/02/常用的排序方法.html</id>
    <published>2022-02-18T03:08:05.000Z</published>
    <updated>2022-02-18T03:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，当前元素与下一个元素对比，将较大值放于右侧，<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//选择排序算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length-<span class="number">1</span> ;i++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;args.length ;j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[min]&gt;args[j])&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=args[i];</span><br><span class="line">            args[i]=args[min];</span><br><span class="line">            args[min]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，取出最小值或者最大值，交互数组位置，使最值位于数组两侧，最后得出一个升序/降序数组<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//插入排序算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[j]&lt;args[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=args[j-<span class="number">1</span>];</span><br><span class="line">                args[j-<span class="number">1</span>]=args[j];</span><br><span class="line">                args[j]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>使用系统自带的排序方法 sorts<br>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的遍历一般根据节点可分为三种：前序、中序、后序遍历<br>根据树的层级又有层级遍历</p><p>下面的代码就是一个树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Node left;</span><br><span class="line"><span class="keyword">private</span> Node right;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node[ no = "</span> + no + <span class="string">", name ="</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>先取父节点，再取左节点，再去右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>先取左节点，再取父节点，再去右节点<br>中序遍历可以得出一个升序结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LDR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>先取左节点，再取右节点，再去父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LRD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-ViewModel</title>
    <link href="hexo/blog/2022/02/jetpack-ViewModel.html"/>
    <id>hexo/blog/2022/02/jetpack-ViewModel.html</id>
    <published>2022-02-08T07:08:05.000Z</published>
    <updated>2022-02-18T02:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考 android developer 中的文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>当 ViewModel 构造函数为有参构造函数时，使用 private val model : OverTimeViewModel by activityViewModels() 会报错<br>此时处理方案为新建一个Factory类<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> dataSource: OverTimeDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span>(modelClass.isAssignableFrom(OverTimeViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OverTimeViewModel(dataSource) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在写一个静态类，作为Factory作为Provider</span></span><br><span class="line"><span class="keyword">object</span> Injection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideUserDataSource</span><span class="params">(context: <span class="type">Context</span>)</span></span>: OverTimeDao &#123;</span><br><span class="line">        <span class="keyword">val</span> database = AppDatabase.getInstance(context)</span><br><span class="line">        <span class="keyword">return</span> database.overTimeDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideViewModelFactory</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ViewModelFactory &#123;</span><br><span class="line">        <span class="keyword">val</span> dataSource = provideUserDataSource(context)</span><br><span class="line">        <span class="keyword">return</span> ViewModelFactory(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModelFactory: ViewModelFactory</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> model : OverTimeViewModel <span class="keyword">by</span> activityViewModels&#123; viewModelFactory &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定的生命函数中实例化ViewModelFactory</span></span><br><span class="line">viewModelFactory = Injection.provideViewModelFactory(activity!!)</span><br></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 android developer 中的文档：&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager2</title>
    <link href="hexo/blog/2022/02/ViewPager2.html"/>
    <id>hexo/blog/2022/02/ViewPager2.html</id>
    <published>2022-02-07T07:59:48.000Z</published>
    <updated>2022-02-07T09:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2</a></p><p>需要对比 ViewPager2 与 ViewPager 的差异、优劣</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deve
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-Navigation</title>
    <link href="hexo/blog/2022/02/jetpack-Navigation.html"/>
    <id>hexo/blog/2022/02/jetpack-Navigation.html</id>
    <published>2022-02-07T07:56:06.000Z</published>
    <updated>2022-02-07T07:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>具体参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-getting-started</a></p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>Navigation 其实是对 Fragment 跳转的管理，而不是 Activity，需要配置到某个 Activity 中。<br>其实是单 Activity 模式</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-getting-started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack Room</title>
    <link href="hexo/blog/2021/12/jetpack-Room.html"/>
    <id>hexo/blog/2021/12/jetpack-Room.html</id>
    <published>2021-12-22T10:44:10.000Z</published>
    <updated>2022-06-09T06:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用 Room 将数据保存到本地数据库</strong></p><p>Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。</p><p>处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的用例是缓存相关数据。这样，当设备无法访问网络时，用户仍可在离线状态下浏览相应内容。设备重新连接到网络后，用户发起的所有内容更改都会同步到服务器。</p><p>由于 Room 负责为您处理这些问题，因此我们强烈建议您使用 Room（而不是 SQLite）。不过，如果您想直接使用 SQLite API，请参阅使用 SQLite 保存数据。</p><p>如需在应用中使用 Room，请将以下依赖项添加到应用的 build.gradle 文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.3.0"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava3 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava3:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers</span></span><br><span class="line">    testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Paging 3 Integration</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-paging:2.4.0-rc01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常情况记录"><a href="#异常情况记录" class="headerlink" title="异常情况记录"></a>异常情况记录</h2><ul><li>Room AppDatabase_Impl does not exist</li></ul><p>使用了 kotlin 构建了项目,并且使用 kotlin 编写 room 创建数据库,在 build.gradle 文件里做如下修改</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.android.library'</span></span><br><span class="line">    id <span class="string">'kotlin-android'</span></span><br><span class="line">    id <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">    id <span class="string">'kotlin-kapt'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略...</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api<span class="string">"android.arch.persistence.room:runtime:$rootProject.room_version"</span></span><br><span class="line">    kapt<span class="string">"android.arch.persistence.room:compiler:$rootProject.room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 annotationProcessor 替换成 kapt,请注意需要导入 id ‘kotlin-kapt’ 才能使用 kapt</p><p>参考地址：<a href="https://www.cnblogs.com/guanxinjing/p/14990401.html" target="_blank" rel="noopener">https://www.cnblogs.com/guanxinjing/p/14990401.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用 Room 将数据保存到本地数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。&lt;/p&gt;
&lt;p&gt;处理大量结构化数据的应用可极大地受益于在本地保留这些
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack DataSource</title>
    <link href="hexo/blog/2021/12/jetpack-DataSource.html"/>
    <id>hexo/blog/2021/12/jetpack-DataSource.html</id>
    <published>2021-12-22T10:29:42.000Z</published>
    <updated>2021-12-22T10:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。</p><p>DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。</p><ul><li>Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。</li><li>Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。&lt;/p&gt;
&lt;p&gt;DataStore 提供两种不同的实现：Preferences 
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack lifecycle</title>
    <link href="hexo/blog/2021/12/jetpack-lifecycle.html"/>
    <id>hexo/blog/2021/12/jetpack-lifecycle.html</id>
    <published>2021-12-22T03:08:25.000Z</published>
    <updated>2021-12-22T03:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 库中用来感知生命周期的组件</p><h2 id="使用生命周期感知型组件处理生命周期"><a href="#使用生命周期感知型组件处理生命周期" class="headerlink" title="使用生命周期感知型组件处理生命周期"></a>使用生命周期感知型组件处理生命周期</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。</p><p>一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。</p><p>androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p><p>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p><p><strong>事件</strong><br>从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。<br><strong>状态</strong><br>由 Lifecycle 对象跟踪的组件的当前状态</p><p><img src="../../../images/lifecycle.svg" style="zoom:60%"></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MainLifecycleObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainLifecycleObserver</span></span>() : LifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> TAG: String  = <span class="string">"MainLifecycleObserver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityCreated: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityResume: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityStopped: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，就可以實現在 Activity 之外獲取到生命週期的變化，避免在 Activity/Fragment 中的生命週期中寫大量業務代碼</p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>LifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。</p><p>此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。</p><p>实现 DefaultLifecycleObserver 的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p><h3 id="自定義-LifecycleOwner"><a href="#自定義-LifecycleOwner" class="headerlink" title="自定義 LifecycleOwner"></a>自定義 LifecycleOwner</h3><p>我們不只是可以綁定視圖的生命週期，可以通過 LifecycleOwner 自定義對應色生命週期<br>如當處於 Activity 的 onCreate、onStart 中都需執行 onStart</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), LifecycleOwner &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LifeCycle 组件实际上并没有带来什么新的功能，他通过观察者模式+注解来让我们更方便的监听 Activity 和 Fragment 的生命周期变化。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle 是 Jetpack 库中用来感知生命周期的组件&lt;/p&gt;
&lt;h2 id=&quot;使用生命周期感知型组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知型组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知型组件处理生命周期
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>kotlin学习指南一</title>
    <link href="hexo/blog/2021/12/kotlin%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80.html"/>
    <id>hexo/blog/2021/12/kotlin学习指南一.html</id>
    <published>2021-12-20T06:22:11.000Z</published>
    <updated>2021-12-22T00:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin 是 google 推出的一門新語言，也是基於 JVM 的。</p><h2 id="kotlin-基础"><a href="#kotlin-基础" class="headerlink" title="kotlin 基础"></a>kotlin 基础</h2><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>新建一个 kt 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主入口 main 方法， 无需新建类即可运行，函数声明用 fun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int, b:Int):Int&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值写在参数之后</p><p>表达式可以作为函数体，返回值类型自动推断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sun(a:Int, b:Int) = a+b;</span><br></pre></td></tr></table></figure><p>返回无意义的值用 Unit 表示</p><p>fun test():Unit {<br>println(“test”);<br>}</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>变量赋值声明关键字：var、val<br>var：声明变量<br>val：声明常量</p><p>var i:Int = 1;<br>val PI:Double = 3.14;</p><p>当声明并赋值时，数据类型可以省略, 会自动推断数据类型<br>var i = 1;<br>val PI = 3.14</p><p>当声明但不赋值时，不能省略数据类型<br>var i:Int;<br>val PI:Double;</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;aaaaa&quot;;</span><br><span class="line">var b = &quot;str = $s&quot;;</span><br><span class="line">var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testIf(a:Int, b:Int):Int &#123;</span><br><span class="line">    if(a &gt; b) return a;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kotlin 中，if 还可以用作表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun max(a:Int, b:Int) = if(a &gt; b) a else b</span><br></pre></td></tr></table></figure><h2 id="空值与-null-检测"><a href="#空值与-null-检测" class="headerlink" title="空值与 null 检测"></a>空值与 null 检测</h2><p>当某个值可以为空时，需要在类型后添加?表示可以为空<br>此时，声明时不能省略类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj:Objects ? = null;</span><br><span class="line">// 表示返回值可以为null</span><br><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型检测与自动类型转换"><a href="#类型检测与自动类型转换" class="headerlink" title="类型检测与自动类型转换"></a>类型检测与自动类型转换</h2><p>is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 </strong></p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);</span><br><span class="line">// 根据元素遍历</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据下标便利</span><br><span class="line">for (item in items.indices) &#123;</span><br><span class="line">    println(items[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = 0;</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(items[index]);</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when-表达式"><a href="#when-表达式" class="headerlink" title="when 表达式"></a>when 表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private fun testWhen(s: Any?) &#123;</span><br><span class="line">        when(s) &#123;</span><br><span class="line">            &quot;a&quot; -&gt; 1;</span><br><span class="line">            &quot;b&quot; -&gt; 2;</span><br><span class="line">            is String -&gt; 3;</span><br><span class="line">            1 -&gt; &quot;n&quot;;</span><br><span class="line">            2 -&gt; &#123;</span><br><span class="line">              println(&quot;222&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            else -&gt; &quot;else&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有点类似 java 中的 switch</p><h2 id="区间-range"><a href="#区间-range" class="headerlink" title="区间 range"></a>区间 range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = 9;</span><br><span class="line">if(x in 0..y) &#123;</span><br><span class="line">    println(&quot;x in 0 - y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间只用于数字</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的迭代可以用的上面的 for in 循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">for(item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断集合中是否包含某元素 用 while in || when</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (&quot;a&quot; in items) &#123;</span><br><span class="line">    println(&quot;items include a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when &#123;</span><br><span class="line">    &quot;a&quot; in items -&gt; println(&quot;aaa&quot;);</span><br><span class="line">    &quot;d&quot; in items -&gt; println(&quot;ddd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 lambda 来过滤和映射集合 ，与 java8 lambda stream 大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125;</span><br><span class="line">    .sortBy&#123; it &#125;</span><br><span class="line">    .map&#123; it.toUpperCase() &#125;</span><br><span class="line">    .forEach&#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>什么是协程？<br>官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。<br>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</p><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。<br>CPU 调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。<br>而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p><p>协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。</p><p>build.gralde 中引入依赖<br>implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1”</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity4 : AppCompatActivity() &#123;</span><br><span class="line">    val TAG = &quot;MainActivity4&quot;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main2)</span><br><span class="line">        test()</span><br><span class="line">        Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun test() = runBlocking &#123;</span><br><span class="line">        repeat(8) &#123;</span><br><span class="line">            Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>协程执行 0 线程 id：1<br>协程执行 1 线程 id：1<br>协程执行 2 线程 id：1<br>协程执行 3 线程 id：1<br>协程执行 4 线程 id：1<br>协程执行 5 线程 id：1<br>协程执行 6 线程 id：1<br>协程执行 7 线程 id：1<br>线程 main ：1</p><p>我们可以得出结论：<br>runBlocking 会阻塞线程，但允许还是在当前线程</p><h3 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch:Job"></a>launch:Job</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testJob() &#123;</span><br><span class="line">        val job = GlobalScope.launch &#123;</span><br><span class="line">            repeat(8) &#123;</span><br><span class="line">                delay(2000)</span><br><span class="line">                Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>testJob: 线程 main：2<br>testJob: 线程 id:6809<br>testJob: 线程 id:6807<br>testJob: 线程 id:6807<br>testJob: 线程 id:6815<br>testJob: 线程 id:6807<br>testJob: 线程 id:6808<br>testJob: 线程 id:6818<br>testJob: 线程 id:6809</p><p>说明使用 GlobalScope.launch</p><ul><li>并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务</li><li>是非阻塞、异步执行，相当于开启了子线程</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun testAsync()&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        var result1 = GlobalScope.async &#123;</span><br><span class="line">            getResult1()</span><br><span class="line">        &#125;</span><br><span class="line">        var result2 = GlobalScope.async &#123;</span><br><span class="line">            getResult2()</span><br><span class="line">        &#125;</span><br><span class="line">        val result = result1.await() + result2.await()</span><br><span class="line">        Log.e(TAG, &quot;testAsync: ThreadId =  $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult1():Int &#123;</span><br><span class="line">    delay(3000)</span><br><span class="line">    Log.e(TAG, &quot;getResult1: ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult2():Int &#123;</span><br><span class="line">    delay(5000)</span><br><span class="line">    Log.e(TAG, &quot;getResult2:  ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>E/MainActivity4: 线程 main ：2<br>E/MainActivity4: getResult1: ThreadId = 7870<br>E/MainActivity4: getResult2: ThreadId = 7870<br>E/MainActivity4: testAsync: ThreadId = 7870 result = 9</p><p>其中当打印 getResult2 后就打印了 testAsync: result = 9<br>阻塞时间为 5 秒，而不是 8 秒，说明 getResult1、getResult2 是并行的。</p><p>而且发现 threadId 都一样，说明处于同一个线程。<br>但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。</p><ul><li>协程并不等于线程，协程内部会根据任务情况自动调度线程。</li></ul><p>launch()有三个入参： 1.协程下上文；2.协程启动模式；3.协程体：block 是一个带接收者的函数字面量，接收者是 CoroutineScope</p><p>我们在线程中执行的代码就是第三个参数</p><h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>上下文可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，Kotlin 协程使用调度器来确定哪些线程用于协程执行，Kotlin 提供了调度器给我们使用：</p><p>Dispatchers.Main：使用这个调度器在 Android 主线程上运行一个协程。可以用来更新 UI 。在 UI 线程中执行</p><p>Dispatchers.IO：这个调度器被优化在主线程之外执行磁盘或网络 I/O。在线程池中执行</p><p>Dispatchers.Default：这个调度器经过优化，可以在主线程之外执行 cpu 密集型的工作。例如对列表进行排序和解析 JSON。在线程池中执行。</p><p>Dispatchers.Unconfined：在调用的线程直接执行。</p><p>调度器实现了 CoroutineContext 接口。</p><p>我们还可以自己自定义调度器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dis = Executors.newCachedThreadPool().asCoroutineDispatcher()</span><br><span class="line">runBlocking &#123;</span><br><span class="line">    launch(dis) &#123;</span><br><span class="line">        println(&quot;dis 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>在 Kotlin 协程当中，启动模式定义在一个枚举类中：</p><p>public enum class CoroutineStart {<br>DEFAULT,<br>LAZY,<br>@ExperimentalCoroutinesApi<br>ATOMIC,<br>@ExperimentalCoroutinesApi<br>UNDISPATCHED;<br>}<br>一共定义了 4 种启动模式，<br>DEFAULT: 默认的模式，立即执行协程体<br>LAZY: 只有在需要的情况下运行<br>ATOMIC: 立即执行协程体，但在开始运行之前无法取消<br>UNDISPATCHED :立即在当前线程执行协程体，直到第一个 suspend 调用</p><h3 id="协程体"><a href="#协程体" class="headerlink" title="协程体"></a>协程体</h3><p>协程体是一个用 suspend 关键字修饰的一个无参，无返回值的函数类型。被 suspend 修饰的函数称为挂起函数,与之对应的是关键字 resume（恢复）<br>注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>Kotlin 的硬关键宇包括:</p><p>as 一一 用于做类型转换或为 import 语句指定别名<br>as?一一类型安全 的类型转换运算符。<br>break 一一中断循环<br>class 一一声明类。<br>continue 一忽略本次循环剩下的语句，重新开始下一次循环。<br>do 一一用于 do while 循环<br>else 一一在 if 分支中使用<br>false 一一在 Boolean 类型中表示假 的直接量。<br>for 一一用于 for 循环<br>fun 一一声 明函数<br>if－在 if 分支中使用<br>in 一一在 for 循环中使用； in 还可作为双目运算符，检查 一个值是否处于区间或集合 内；<br>in 也可 在 when 表达式中使用； in 还可用于修饰泛型参数，表明该泛型参数支持逆变<br>!in 一一可作为双目运算符 的反义词：！in 也可在 when 表达式中使用<br>is 一一用于做类型检查（类 Java instanceof) 或在 when 表达式中使用<br>!is 一一 用于做类型检查（ is 的反义词〉或在 when 表达式中使用<br>null 一一 代表空的直接量。<br>object ——用于声明对象表达式或定义命名对象<br>package 一一用于为当 前文件指定包<br>return 一一声明函数的返回<br>super 一－用于引用父类实现的方法或属性，或者在子类构造器中调用父类构造器<br>this 一一 代表当前类的对象或在构造器中调用当前类的其他构造器<br>throw 一一用于抛出异常<br>true 一一在 Boolean 类型中表示真的直接量。<br>try 一一开始异常处理<br>typealias 一一用于定义类型别名。<br>val 一声明只读属性或变量。<br>var 一一声明可变属性或变量。<br>when 一一用于 when 表达式。while 一一－用于 while 循环或 do while 循环</p><p>Kotlin 的软关键宇包括：</p><p>by 一一用于将接口或祖先类的实现代理给其他对象。<br>catch 一一在异常处理中用于捕捉异常<br>constructor 一一用于声明构造器。<br>delegate 一用于指定该注解修饰委托属性存储其委托实例的字段<br>dynamic 一一主要用于在 Kotlin/JavaScript 中引用 一个动态类型<br>field 一一用于指定该注解修饰属性的幕后字段。<br>file 一一用于指定该注解修饰该源文件本身<br>finally 一一异常处理中的 finally<br>get 一一用于声明属性的 getter 方法，或者用于指定该注解修饰属性的 getter 方法<br>import 一一用于导包。<br>init 一一用于声明初始化块<br>param 一一用于指定该注解修饰构造器参数<br>property 一一用于指定该注解修饰整个属性（这种目标的注解对 Java 不可见，因为 Java<br>并没有真正的属性）。<br>receiveris 一一用于指定该注解修饰扩展方法或扩展属性的接收者<br>set 一一用于声明属性的 setter 方法，或者用于指定该注解修饰属性的 setter 方法<br>setparam 一一用于指定该注解修饰 setter 方法的参数<br>where 一一用于为泛型参数增加限制。</p><p>Kotlin 的修饰符关键宇包括：</p><p>abstract 一一用于修饰抽象类或抽象成员<br>annotation 一一用于修饰一个注解类。<br>companion 一一用于声明一个伴生对象<br>const 一一用于声明编译时常量<br>crossinline 一一用于禁止在传给内联函数的 Lambd 表达式中执行非局部返回<br>data 一一用于声明数据类。<br>enum 一一用于声明枚举<br>external 一一用于声明某个方法不由 Kotlin 实现（与 Java 的 native 相似〉。<br>final 一一用于禁止被重写<br>infix 一一声明该函数能以双目运算符的格式执行<br>inline 一一用于声明内联函数， Lambda 表达式可在内联函数中执行局部返回。<br>inner 一一用于声明内部类，内部类可以访问外部类的实例<br>internal 一一用于表示被修饰的声明只能在当前模块内可见<br>lateinit——-用于修饰 non-null 属性，用于指定该属性可在构造器以外的地方<br>初始化<br>noinline 一一用于禁止内联函数中个别 Lambda 表达式被内联化<br>open 一一用于修饰类，表示该类可派生子类；或者用于修饰成员，表示该成员可以被<br>重写。<br>out 一一用于修饰泛型参数，表明该泛型参数支持协变。<br>override 一一用于声明重写父类的成员<br>private ——private 访问权限<br>protected ——–protected 访问权限<br>public——-public 访问权限。<br>reified 一一用于修饰内联函数中的泛型形参，接下来在该函数中就可像使用普通类型<br>一样使用该类型参数。<br>sealed 一一用于声明一个密封类。<br>suspend 一一用于标识一个函数后 Lambda 表达式可作为暂停。<br>tailrec 一一用于修饰一个函数可作为尾随递归函数使用。<br>vararg 一一用于修饰形参，表明该参数是个数可变的形参。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;kotlin 是 google 推出的一門新語言，也是基於 JVM 的。&lt;/p&gt;
&lt;h2 id=&quot;kotlin-基础&quot;&gt;&lt;a href=&quot;#kotlin-基础&quot; class=&quot;headerlink&quot; title=&quot;kotlin 基础&quot;&gt;&lt;/a&gt;kotlin 基础&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="kotlin" scheme="hexo/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/12/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html"/>
    <id>hexo/blog/2021/12/NDK-C-基础-四.html</id>
    <published>2021-12-08T08:16:22.000Z</published>
    <updated>2021-12-08T08:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>在之前讲过的拷贝构造函数，其实就是一种 浅拷贝<br>但是在浅拷贝中，无法拷贝堆内存中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Student1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student1() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student1(char * name) :Student1(name, 99) &#123; cout &lt;&lt; &quot;一个入参 构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    Student1(char * name, int age) &#123; </span><br><span class="line">cout &lt;&lt; &quot;两个入参构造函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">this-&gt;name = (char *) malloc(sizeof(char * ) * 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line"></span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student1() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上所示，Student 类中，在构造函数中，name 是动态开辟在堆内存上的，在析构函数中，会使用free释放 name 在堆内存的内存空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line">Student1 s1;</span><br><span class="line">Student1 s2 = s1; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行完上述代码时，会运行异常，<br>Student1 s2 = s1;  会执行 拷贝构造函数，将 s2 的值都复制给 s1<br>但是之前说过 <em> 拷贝构造函数是 浅拷贝 </em><br>浅拷贝 是不会拷贝堆内存中的数据的， 所以其实 s2 与 s1 中的 name 指向的同一块堆内存空间，<br>当main函数执行完毕，出栈时，会调用 s2、s1的析构函数，当指向s1的析构函数时，会释放 name 中的堆内存空间。<br>等到执行 s2 的析构函数时，又会执行 free(this-&gt;name); 但此时 this-&gt;name已经是一块指向NULL的指针了，此时就会抛出异常。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>上面讲了深拷贝与浅拷贝的区别，以及默认的拷贝构造函数是一次浅拷贝，接下来手动实现一下 深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student(char * name) :Student(name, 99) &#123;</span><br><span class="line">cout &lt;&lt; &quot;一个参数构造函数 this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(char * name, int age) &#123;</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数 &amp;this-&gt;name:&quot; &lt;&lt; (int)this-&gt;name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(const Student &amp; stu) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;stu的地址 &amp;stu:&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot; this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">// 重新开辟一个堆内存存放新的 stu对象中的 name</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">        // 复制name中的值</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = stu.age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void showStudent(Student stu) &#123;</span><br><span class="line">cout &lt;&lt; &quot;showStudent的内存地址&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot;  &quot; &lt;&lt; stu.name &lt;&lt; &quot;,&quot; &lt;&lt; stu.age&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">Student stu(&quot;justin&quot;, 31);</span><br><span class="line"></span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，在函数 showStudent 中会调用拷贝构造函数 然后执行完毕出栈，调用 析构函数，<br>但上述代码不会出现异常，因为在我们自定义的拷贝构造函数中，我们手动实现了堆内存的拷贝。并每次执行析构函数时，又会释放掉name的堆内存。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅拷贝与深拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝与深拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝与深拷贝&quot;&gt;&lt;/a&gt;浅拷贝与深拷贝&lt;/h2&gt;&lt;p&gt;浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/12/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB.html"/>
    <id>hexo/blog/2021/12/java数据类型汇总.html</id>
    <published>2021-12-08T08:16:22.000Z</published>
    <updated>2021-12-08T08:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>再java中，数据类型可分为两种：集合（Collection）、图（Map）<br>而这两大类中又可以细分，常用的子类为：<br>ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap</p><h2 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h2><p>集合可以细分为三类：List、Set、Queue</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口扩展自Collection，它可以定义一个允许重复的有序集合</p><p>List中常用的子类有：ArrayList、LinkerList、CopyOnWriteArrayList</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList内部的数据结构为数组，当增加元素数量大于初始容量，会触发扩容，即新建一个之前容量两位的数组，并将之前的元素拷贝过来。<br>查询快，增删慢<br><strong><em>非线程安全</em></strong></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList内部的数据结构为链表，双向链表。<br>查询慢，增删快<br><strong><em>非线程安全</em></strong></p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。<br><strong><em>线程安全，通过ReentrantLock实现</em></strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。<br>Set接口有三个具体实现类：散列集HashSet、链式散列集LinkedHashSet、树形集TreeSet</p><p>Set判断是否重复的原理是，先判断Hash，如果Hash相同再判断equals</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>散列集HashSet是一个用于实现Set接口的具体类，<br>有两个名词需要关注，初始容量和客座率。<br>客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，就会触发扩容。</p><p><strong><em>非线程安全</em></strong></p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>内部数据是链表，是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序<br>HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。<br><strong><em>非线程安全</em></strong></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>内部数据结构为树，<br>扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。<br><strong><em>非线程安全</em></strong></p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>数据结构为队列，特点是先进先出，后进后出<br>而关于队列的实现又有多个：优先级队列、异步队列、同步队列、阻塞队列等。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map中常用的子类有: HashMap、HashTable、LinkedHashMap、TreeMap、ConcurrentHashMap</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap在jdk1.8时发生了变更<br>在JDK1.7及以前的版本中：内部数据结构为：数组+链表，并且链表插入数据的方式为 头插法<br>在jdk1.8以及之后的版本中：内部的数据结构为：数组+链表+红黑树，并且链表插入数据的方式为 尾插法</p><p>数据存放方式为 key value，一一对应，key不允许重复<br>大致原理：根据key得出hash值，根据hash值对数组长度取模得出存放数组的下标，每个数组下标对于的为一个链表，将数据放入到链表，当链表长度大于阈值时，则链表转换为红黑树，红黑树节点数减少小于阈值时，则又转换回链表<br>取值大致过程相同：根据key获取hash，然后得出下标，然后再去链表或者红黑树中根据key对比取值</p><p><strong><em>非线程安全</em></strong></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，<br>HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，<br>也可以按它们最后一次被访问的顺序排<br><strong><em>非线程安全</em></strong></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。<br><strong><em>非线程安全</em></strong></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 是并发包concurrent下针对HashMap的一种实现，线程安全<br>同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高</p><p><strong><em>线程安全</em></strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;再java中，数据类型可分为两种：集合（Collection）、图（Map）&lt;br&gt;而这两大类中又可以细分，常用的子类为：&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java 类加载机制</title>
    <link href="hexo/blog/2021/11/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
    <id>hexo/blog/2021/11/java-类加载机制.html</id>
    <published>2021-11-01T10:14:26.000Z</published>
    <updated>2022-02-21T05:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul><li><p>了解 java 类加载机制</p></li><li><p>理解类加载器 ClassLoader</p></li></ul><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ul><li><p>隐式加载 new 创建类的实例,</p></li><li><p>显式加载：loaderClass,forName 等</p></li><li><p>访问类的静态变量，或者为静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>使用反射方式创建某个类或者接口对象的 Class 对象。</p></li><li><p>初始化某个类的子类</p></li><li><p>直接使用 java.exe 命令来运行某个主类</p></li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类加载有五步：<br>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的一个阶段，ClassLoader 通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个 class 对象</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量（static 修饰的字段变量）分配内存并且设置该类变量的初始值，（如 static int i = 5 这里只是将 i 赋值为 0，在初始化的阶段再把 i 赋值为 5)，<br>这里不包含 final 修饰的 static ，因为 final 在编译的时候就已经分配了。<br>这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到 Java 堆中</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这里主要的任务是把常量池中的符号引用替换成直接引用</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。<br>（前面已经对 static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）</p><h2 id="forName-和-loaderClass-区别"><a href="#forName-和-loaderClass-区别" class="headerlink" title="forName 和 loaderClass 区别"></a>forName 和 loaderClass 区别</h2><ul><li><p>Class.forName()得到的 class 是已经初始化完成的</p></li><li><p>ClassLoader.loaderClass 得到的 class 是还没有链接（验证，准备，解析三个过程被称为链接）的。</p></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派模式要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，<br>但是在双亲委派模式中父子关系采取的并不是继承的关系，而是采用组合关系来复用父类加载器的相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>通过 loadClass 加载类时，会先通过 findLoadClass 查找该类是否已加载，<br>如果未加载，会先通过父加载期加载，依次向上递归，到最上级父加载器加载，<br>如果此时还未加载，再依次向下递归调用 findClass</p><p>就是每个儿子都很懒，遇到类加载的活都给它爸爸干，直到爸爸说我也做不来的时候，儿子才会想办法自己去加载。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>采用双亲委派模式的好处就是 Java 类随着它的类加载器一起具备一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类的时候，就没有必要子类加载器（ClassLoader）再加载一次。其次是考虑到安全因素，Java 核心 API 中定义类型不会被随意替换，假设通过网路传递一个名为 java.lang.Integer 的类，通过双亲委派的的模式传递到启动类加载器，而启动类加载器在核心 Java API 发现这个名字类，发现该类已经被加载，并不会重新加载网络传递过来的 java.lang.Integer.而之际返回已经加载过的 Integer.class，这样便可以防止核心 API 库被随意篡改。可能你会想，如果我们在 calsspath 路径下自定义一个名为 java.lang.SingInteger?该类并不存在 java.lang 中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器，最终会通过系统类加载器加载该类，但是这样做是不允许的，因为 java.lang 是核心的 API 包，需要访问权限，强制加载将会报出如下异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException:Prohibited <span class="keyword">package</span> name: java.lang</span><br></pre></td></tr></table></figure><h2 id="类与加载器"><a href="#类与加载器" class="headerlink" title="类与加载器"></a>类与加载器</h2><p>在 JVM 中标识两个 Class 对象，是否是同一个对象存在的两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个 ClassLoader（指 ClassLoader 实例对象）必须相同。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;了解 java 类加载机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解类加载器 ClassLoader&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/11/java-%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8Eclass.html"/>
    <id>hexo/blog/2021/11/java-反射基本概念与class.html</id>
    <published>2021-11-01T10:12:43.000Z</published>
    <updated>2021-11-01T10:12:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 *</li></ul><p>类名 用途<br>Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口<br>Field 类 代表类的成员变量（成员变量也称为类的属性）<br>Method 类 代表类的方法<br>Constructor 类 代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法 用途<br>asSubclass(Class<u> clazz) 把传递的类的对象转换成代表其子类的对象<br>Cast 把对象转换成代表类或是接口的对象<br>getClassLoader() 获得类的加载器<br>getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className) 根据类名返回类的对象<br>getName() 获得类的完整路径名字<br>newInstance() 创建类的实例<br>getPackage() 获得类的包<br>getSimpleName() 获得类的名字<br>getSuperclass() 获得当前类继承的父类的名字<br>getInterfaces() 获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法 用途<br>getField(String name) 获得某个公有的属性对象<br>getFields() 获得所有公有的属性对象<br>getDeclaredField(String name) 获得某个属性对象<br>getDeclaredFields() 获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法 用途<br>getAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的公有注解对象<br>getAnnotations() 返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations() 返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法 用途<br>getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法<br>getConstructors() 获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors() 获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法 用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法<br>getMethods() 获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数<br>getDeclaredMethods() 获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法 用途<br>isAnnotation() 如果是注解类型则返回 true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 true<br>isAnonymousClass() 如果是匿名类则返回 true<br>isArray() 如果是一个数组类则返回 true<br>isEnum() 如果是枚举类则返回 true<br>isInstance(Object obj) 如果 obj 是该类的实例则返回 true<br>isInterface() 如果是接口类则返回 true<br>isLocalClass() 如果是局部类则返回 true<br>isMemberClass() 如果是内部类则返回 true</p><h3 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h3><p>Field 代表类的成员变量（成员变量也称为类的属性）。</p><p>方法 用途<br>equals(Object obj) 属性与 obj 相等则返回 true<br>get(Object obj) 获得 obj 中对应的属性值<br>set(Object obj, Object value) 设置 obj 中对应属性值</p><h3 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h3><p>Method 代表类的方法。</p><p>方法 用途<br>invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法</p><h3 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h3><p>Constructor 代表类的构造方法。</p><p>方法 用途<br>newInstance(Object… initargs) 根据传递的参数创建类的对象</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先写一个被反射调用的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReflex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ExampleReflex.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String LOG = <span class="string">"LOG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String privateName = <span class="string">"privateName"</span>;</span><br><span class="line">    <span class="keyword">public</span> String publicName = <span class="string">"publicName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"defaultName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FINAL_NAME = <span class="string">"FINAL_NAME"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATIC_FINAL_NAME = <span class="string">"STATIC_FINAL_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodNoParams: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodHasParams: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Private No Params getName: "</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethodHasParams</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateMethodHasParams: "</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"size:"</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodNoParams: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"staticMethodNoParams"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodHasParams: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"_____"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">privateStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateStaticMethod: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPrivateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPrivateName: "</span> + privateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPublicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPublicName: "</span> + publicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logStatic: A: "</span> + A + <span class="string">"   LOG: "</span> + LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logFinal: finalName: "</span> + FINAL_NAME + <span class="string">" STATIC_FINAL_NAME: "</span>+ STATIC_FINAL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，其中包含 public、private、static、final 修饰的属性、以及函数</p><h3 id="返回调用函数"><a href="#返回调用函数" class="headerlink" title="返回调用函数"></a>返回调用函数</h3><h4 id="调用-public-函数"><a href="#调用-public-函数" class="headerlink" title="调用 public 函数"></a>调用 public 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取class</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 根据class 获取一个对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象</span></span><br><span class="line">Method method1 = clazz.getMethod(<span class="string">"publicMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">method1.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公有有参函数 第二个参数是入参参数签名</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"publicMethodHasParams"</span>, String.class);</span><br><span class="line">method2.invoke(obj, <span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用-private-函数"><a href="#调用-private-函数" class="headerlink" title="调用 private 函数"></a>调用 private 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取私有函数</span></span><br><span class="line">Method method3 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 私有函数需要设置允许访问 否则会报错</span></span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">String name = (String) method3.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethod Result: "</span> + name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有有参函数</span></span><br><span class="line">Method method4 = clazz.getDeclaredMethod(<span class="string">"privateMethodHasParams"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">method4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String size = (String) method4.invoke(obj, <span class="number">22</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethodHasParams Result: "</span> + size);</span><br></pre></td></tr></table></figure><p>可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。<br>getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数</p><h4 id="调用-static-函数"><a href="#调用-static-函数" class="headerlink" title="调用 static 函数"></a>调用 static 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态无参函数</span></span><br><span class="line">Method method5 = clazz.getDeclaredMethod(<span class="string">"staticMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line">method5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method5.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态有参函数</span></span><br><span class="line">Method method6 = clazz.getDeclaredMethod(<span class="string">"staticMethodHasParams"</span>, String.class);</span><br><span class="line">method6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String result_str6 = (String) method6.invoke(obj, <span class="string">"public static method"</span>);</span><br><span class="line">Log.d(tag, <span class="string">"staticMethodHasParams Result: "</span> + result_str6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有静态函数</span></span><br><span class="line">Method method7 = clazz.getDeclaredMethod(<span class="string">"privateStaticMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">method7.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method7.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>反射调用静态函数与调用私有函数其实没有不同</p><h3 id="调用反射修改属性"><a href="#调用反射修改属性" class="headerlink" title="调用反射修改属性"></a>调用反射修改属性</h3><h4 id="修改-public、private、static-变量"><a href="#修改-public、private、static-变量" class="headerlink" title="修改 public、private、static 变量"></a>修改 public、private、static 变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改public变量，并输出</span></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field publicField = clazz.getDeclaredField(<span class="string">"publicName"</span>);</span><br><span class="line"><span class="comment">// 在obj实例对象上设置属性新值</span></span><br><span class="line">publicField.set(obj, <span class="string">"publicName_New"</span>);</span><br><span class="line">Method method8 = clazz.getDeclaredMethod(<span class="string">"logPublicName"</span>);</span><br><span class="line">method8.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改private变量</span></span><br><span class="line">Field privateField = clazz.getDeclaredField(<span class="string">"privateName"</span>);</span><br><span class="line"><span class="comment">// 私有属性需要设置可访问</span></span><br><span class="line">privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateField.set(obj, <span class="string">"privateName_New"</span>);</span><br><span class="line">Method method9 = clazz.getDeclaredMethod(<span class="string">"logPrivateName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method9.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态属性</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"A"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(obj, <span class="number">2222</span>);</span><br><span class="line">Method method10 = clazz.getDeclaredMethod(<span class="string">"logStatic"</span>, <span class="keyword">null</span>);</span><br><span class="line">method10.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method10.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意，私有变量时需要调用 setAccessible，不然会报错</p><h4 id="修改-final-修饰的常量"><a href="#修改-final-修饰的常量" class="headerlink" title="修改 final 修饰的常量"></a>修改 final 修饰的常量</h4><p>在 java 中，使用 final 修饰的代表常量，不允许修改。<br>当我们通过反射修改时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改final常量</span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method11 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method11.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method11.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。</p><p>针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的修改final常量方式</span></span><br><span class="line">Field field3 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field3.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method12 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method12.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="反射构造函数"><a href="#反射构造函数" class="headerlink" title="反射构造函数"></a>反射构造函数</h3><p>在上面调用生成实例中：<br>Object obj = clazz.newInstance();</p><p>其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。<br>修改 ExampleReflex.java 中的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Constructor ExampleReflex: "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例</p><p>通过 public 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 获取public 有参的构造函数</span></span><br><span class="line">Constructor constructor1 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 通过构造函数生成对象 参数为入参类型class</span></span><br><span class="line">Object obj = constructor1.newInstance(<span class="string">"NNNNN"</span>);</span><br><span class="line">Method method81 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method81.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method81.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>通过 private 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取private 有参构造函数</span></span><br><span class="line">Constructor constructor2 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line">Object obj2 = constructor2.newInstance(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="hexo/blog/2021/10/%E5%8F%8D%E5%B0%84.html"/>
    <id>hexo/blog/2021/10/反射.html</id>
    <published>2021-10-25T07:01:37.000Z</published>
    <updated>2022-02-18T03:55:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 *</li></ul><p>类名 用途<br>Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口<br>Field 类 代表类的成员变量（成员变量也称为类的属性）<br>Method 类 代表类的方法<br>Constructor 类 代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法 用途<br>asSubclass(Class<u> clazz) 把传递的类的对象转换成代表其子类的对象<br>Cast 把对象转换成代表类或是接口的对象<br>getClassLoader() 获得类的加载器<br>getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className) 根据类名返回类的对象<br>getName() 获得类的完整路径名字<br>newInstance() 创建类的实例<br>getPackage() 获得类的包<br>getSimpleName() 获得类的名字<br>getSuperclass() 获得当前类继承的父类的名字<br>getInterfaces() 获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法 用途<br>getField(String name) 获得某个公有的属性对象<br>getFields() 获得所有公有的属性对象<br>getDeclaredField(String name) 获得某个属性对象<br>getDeclaredFields() 获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法 用途<br>getAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的公有注解对象<br>getAnnotations() 返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations() 返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法 用途<br>getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法<br>getConstructors() 获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors() 获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法 用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法<br>getMethods() 获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数<br>getDeclaredMethods() 获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法 用途<br>isAnnotation() 如果是注解类型则返回 true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 true<br>isAnonymousClass() 如果是匿名类则返回 true<br>isArray() 如果是一个数组类则返回 true<br>isEnum() 如果是枚举类则返回 true<br>isInstance(Object obj) 如果 obj 是该类的实例则返回 true<br>isInterface() 如果是接口类则返回 true<br>isLocalClass() 如果是局部类则返回 true<br>isMemberClass() 如果是内部类则返回 true</p><h3 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h3><p>Field 代表类的成员变量（成员变量也称为类的属性）。</p><p>方法 用途<br>equals(Object obj) 属性与 obj 相等则返回 true<br>get(Object obj) 获得 obj 中对应的属性值<br>set(Object obj, Object value) 设置 obj 中对应属性值</p><h3 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h3><p>Method 代表类的方法。</p><p>方法 用途<br>invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法</p><h3 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h3><p>Constructor 代表类的构造方法。</p><p>方法 用途<br>newInstance(Object… initargs) 根据传递的参数创建类的对象</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先写一个被反射调用的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReflex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ExampleReflex.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String LOG = <span class="string">"LOG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String privateName = <span class="string">"privateName"</span>;</span><br><span class="line">    <span class="keyword">public</span> String publicName = <span class="string">"publicName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"defaultName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FINAL_NAME = <span class="string">"FINAL_NAME"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATIC_FINAL_NAME = <span class="string">"STATIC_FINAL_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodNoParams: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodHasParams: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Private No Params getName: "</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethodHasParams</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateMethodHasParams: "</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"size:"</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodNoParams: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"staticMethodNoParams"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodHasParams: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"_____"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">privateStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateStaticMethod: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPrivateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPrivateName: "</span> + privateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPublicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPublicName: "</span> + publicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logStatic: A: "</span> + A + <span class="string">"   LOG: "</span> + LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logFinal: finalName: "</span> + FINAL_NAME + <span class="string">" STATIC_FINAL_NAME: "</span>+ STATIC_FINAL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，其中包含 public、private、static、final 修饰的属性、以及函数</p><h3 id="返回调用函数"><a href="#返回调用函数" class="headerlink" title="返回调用函数"></a>返回调用函数</h3><h4 id="调用-public-函数"><a href="#调用-public-函数" class="headerlink" title="调用 public 函数"></a>调用 public 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取class</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 根据class 获取一个对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象</span></span><br><span class="line">Method method1 = clazz.getMethod(<span class="string">"publicMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">method1.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公有有参函数 第二个参数是入参参数签名</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"publicMethodHasParams"</span>, String.class);</span><br><span class="line">method2.invoke(obj, <span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用-private-函数"><a href="#调用-private-函数" class="headerlink" title="调用 private 函数"></a>调用 private 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取私有函数</span></span><br><span class="line">Method method3 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 私有函数需要设置允许访问 否则会报错</span></span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">String name = (String) method3.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethod Result: "</span> + name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有有参函数</span></span><br><span class="line">Method method4 = clazz.getDeclaredMethod(<span class="string">"privateMethodHasParams"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">method4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String size = (String) method4.invoke(obj, <span class="number">22</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethodHasParams Result: "</span> + size);</span><br></pre></td></tr></table></figure><p>可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。<br>getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数</p><h4 id="调用-static-函数"><a href="#调用-static-函数" class="headerlink" title="调用 static 函数"></a>调用 static 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态无参函数</span></span><br><span class="line">Method method5 = clazz.getDeclaredMethod(<span class="string">"staticMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line">method5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method5.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态有参函数</span></span><br><span class="line">Method method6 = clazz.getDeclaredMethod(<span class="string">"staticMethodHasParams"</span>, String.class);</span><br><span class="line">method6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String result_str6 = (String) method6.invoke(obj, <span class="string">"public static method"</span>);</span><br><span class="line">Log.d(tag, <span class="string">"staticMethodHasParams Result: "</span> + result_str6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有静态函数</span></span><br><span class="line">Method method7 = clazz.getDeclaredMethod(<span class="string">"privateStaticMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">method7.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method7.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>反射调用静态函数与调用私有函数其实没有不同</p><h3 id="调用反射修改属性"><a href="#调用反射修改属性" class="headerlink" title="调用反射修改属性"></a>调用反射修改属性</h3><h4 id="修改-public、private、static-变量"><a href="#修改-public、private、static-变量" class="headerlink" title="修改 public、private、static 变量"></a>修改 public、private、static 变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改public变量，并输出</span></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field publicField = clazz.getDeclaredField(<span class="string">"publicName"</span>);</span><br><span class="line"><span class="comment">// 在obj实例对象上设置属性新值</span></span><br><span class="line">publicField.set(obj, <span class="string">"publicName_New"</span>);</span><br><span class="line">Method method8 = clazz.getDeclaredMethod(<span class="string">"logPublicName"</span>);</span><br><span class="line">method8.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改private变量</span></span><br><span class="line">Field privateField = clazz.getDeclaredField(<span class="string">"privateName"</span>);</span><br><span class="line"><span class="comment">// 私有属性需要设置可访问</span></span><br><span class="line">privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateField.set(obj, <span class="string">"privateName_New"</span>);</span><br><span class="line">Method method9 = clazz.getDeclaredMethod(<span class="string">"logPrivateName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method9.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态属性</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"A"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(obj, <span class="number">2222</span>);</span><br><span class="line">Method method10 = clazz.getDeclaredMethod(<span class="string">"logStatic"</span>, <span class="keyword">null</span>);</span><br><span class="line">method10.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method10.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意，私有变量时需要调用 setAccessible，不然会报错</p><h4 id="修改-final-修饰的常量"><a href="#修改-final-修饰的常量" class="headerlink" title="修改 final 修饰的常量"></a>修改 final 修饰的常量</h4><p>在 java 中，使用 final 修饰的代表常量，不允许修改。<br>当我们通过反射修改时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改final常量</span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method11 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method11.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method11.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。</p><p>针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的修改final常量方式</span></span><br><span class="line">Field field3 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field3.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method12 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method12.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="反射构造函数"><a href="#反射构造函数" class="headerlink" title="反射构造函数"></a>反射构造函数</h3><p>在上面调用生成实例中：<br>Object obj = clazz.newInstance();</p><p>其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。<br>修改 ExampleReflex.java 中的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Constructor ExampleReflex: "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例</p><p>通过 public 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 获取public 有参的构造函数</span></span><br><span class="line">Constructor constructor1 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 通过构造函数生成对象 参数为入参类型class</span></span><br><span class="line">Object obj = constructor1.newInstance(<span class="string">"NNNNN"</span>);</span><br><span class="line">Method method81 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method81.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method81.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>通过 private 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取private 有参构造函数</span></span><br><span class="line">Constructor constructor2 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line">Object obj2 = constructor2.newInstance(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p>在上面其实讲的都是反射的使用，包括函数、属性、构造器等<br>而关于反射能够使用的原理，大概描述：<br>当类被加载时，会将类中的构造器、属性、函数，都缓存到 Class 类的内部类 ReflectionData 中。<br>而反射就是，先判断该类是否加载过，加载过则直接去 ReflectionData 中取，<br>如果没加载过就报错。</p><ol><li><p>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</p></li><li><p>每个类都会有一个与之对应的 Class 实例，从而每个类都可以获取 method 反射方法，并作用到其他实例身上；</p></li><li><p>反射也是考虑了线程安全的，放心使用；</p></li><li><p>反射使用软引用 relectionData 缓存 class 信息，避免每次重新从 jvm 获取带来的开销；</p></li><li><p>反射调用多次生成新代理 Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</p></li><li><p>当找到需要的方法，都会 copy 一份出来，而不是使用原来的实例，从而保证数据隔离；</p></li><li><p>调度反射方法，最终是由 jvm 执行 invoke0()执行；</p></li></ol><p>參考連結：<a href="https://www.cnblogs.com/yougewe/p/10125073.html" target="_blank" rel="noopener">https://www.cnblogs.com/yougewe/p/10125073.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android 复习导航</title>
    <link href="hexo/blog/2021/10/android-%E5%A4%8D%E4%B9%A0%E5%AF%BC%E8%88%AA.html"/>
    <id>hexo/blog/2021/10/android-复习导航.html</id>
    <published>2021-10-18T06:30:39.000Z</published>
    <updated>2021-12-08T08:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-篇"><a href="#java-篇" class="headerlink" title="java 篇"></a>java 篇</h1><ul><li>类加载机制<ul><li>双亲委派机制</li></ul></li><li>反射</li><li>注解</li><li>注入</li><li>序列化</li><li><p>范型</p></li><li><p>集合</p><ul><li>Map</li><li>List</li><li>LinkedList</li><li>Set</li><li>HashMap</li></ul></li><li><p>内存</p><ul><li>内存抖动</li><li>内存泄露</li><li>内存溢出</li><li>GC 算法</li><li>JVM 结构</li><li>JMM（java 内存模型）</li><li>四种引用类型</li></ul></li><li><p>多线程</p><ul><li>线程池</li><li>wait/notify</li><li>锁</li><li>原子类</li><li>ThreadLocal</li><li>线程的状态、转换</li></ul></li></ul><h1 id="android-篇"><a href="#android-篇" class="headerlink" title="android 篇"></a>android 篇</h1><ul><li><p>四大组件</p><ul><li>Activity</li><li>Service</li><li>BroadcastReceiver<br>-LocalBroadcastReceiver (為何更高效)</li><li>Provider</li></ul></li><li><p>生命周期</p><ul><li>Activity 生命周期</li><li>Service 生命周期</li></ul></li><li><p>消息机制</p><ul><li>Handler</li><li>IdleHandler</li><li>Looper</li><li>MessageQueue</li></ul></li><li><p>事件分发机制</p><ul><li>View/ViewGroup</li><li>滑动冲突</li></ul></li><li><p>自定义 View</p><ul><li>onMeasure</li><li>onLayout</li><li>onDraw</li></ul></li><li><p>注入</p></li><li><p>数据持久化 SharePreferences</p></li><li><p>跨进城通信</p><ul><li>AIDL</li><li>Binder</li></ul></li><li><p>设计模式</p><ul><li>MVC</li><li>MVP</li><li>MVVM</li></ul></li><li><p>第三方插件</p><ul><li>GSON</li><li>okHttp</li><li>Rxjava</li><li>Dagger</li><li>Dagger2</li><li>APT</li><li>ARouter</li><li>Glide</li></ul></li><li><p>UI</p><ul><li>ListView</li><li>ViewPager</li><li>Fragment</li><li>Stub</li><li>RecyclerView</li><li>Adapter</li></ul></li></ul><h1 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h1><ul><li>Kotlin</li><li>C/C++</li></ul><h1 id="混合开发平台"><a href="#混合开发平台" class="headerlink" title="混合开发平台"></a>混合开发平台</h1><ul><li>Cordova</li><li>react-native</li><li>Flutter<ul><li>原理</li><li>渲染机制</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-篇&quot;&gt;&lt;a href=&quot;#java-篇&quot; class=&quot;headerlink&quot; title=&quot;java 篇&quot;&gt;&lt;/a&gt;java 篇&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;类加载机制&lt;ul&gt;
&lt;li&gt;双亲委派机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反射&lt;/li
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jvm内存说明</title>
    <link href="hexo/blog/2021/08/jvm%E5%86%85%E5%AD%98%E8%AF%B4%E6%98%8E.html"/>
    <id>hexo/blog/2021/08/jvm内存说明.html</id>
    <published>2021-08-16T09:55:13.000Z</published>
    <updated>2021-08-16T10:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出</p><h2 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h2><p>在一定时间内，频繁的创建对象然后又回收，使内存存在明显的上下波动<br>一般可能发生在循环中大量创建了局部对象</p><p>内存抖动的影响，抖动频繁的话会导致回收也频繁，而频繁的 GC 是会造成性能影响的。<br>因为每次 GC 时会挂起线程两次，二次还会产生内存碎片。</p><p>要考虑多复用对象，涉及模式：享元模式</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在程序运行期间，已经没有被使用的对象，引用却一直被持有，导致该对象无法被回收，此时就会造成内存泄漏</p><p>内存泄漏的影响：会造成无用对象无法被回收，使内存空间越来越小，最终可能会造成内存溢出</p><p>一般示例：Inflater 的创建需要 Context 对象，传入 Actiivty 时创建完后，需要将 Inflater 的实例对象置空，此时就会消除对 Activity 对象引用的持有，不然就会造成 Activity 的内存泄漏</p><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>当创建对象时，JVM 无法分配足够的内存，此时就会执行 GC，清理内存已获取足够的空间。<br>但如果 GC 后仍然无法获取足够的空间时，此时就会抛出异常 OOM（内存溢出），中断程序的运行</p><p>影响：会抛出异常，中断程序的运行<br>与内存抖动、内存泄漏不同，内存抖动、内存泄漏都不会影响程序的运行，最多只会影响程序运行的性能，内存溢出则会直接报错，中断程序的运行。<br>内存溢出是内存泄漏的持续结果。</p><p>解决办法：程序内存溢出后会在特定目录输出 .trace 文件，需要分析文件确定造成内存溢出的代码块。</p><p>常见的内存溢出：流使用完后未关闭、Cursor 使用完后未关闭、短时间创建大量的大内存对象</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出&lt;/p&gt;
&lt;h2 id=&quot;内存抖动&quot;&gt;&lt;a href=&quot;#内存抖动&quot; class=&quot;headerlink&quot; title=&quot;内存抖动&quot;&gt;&lt;/a&gt;内存抖动&lt;/h2&gt;&lt;p&gt;在一定时间内，频繁的创建对象然后又回收，
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
</feed>
