<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Happy To Try</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2021-01-20T01:16:55.400Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>okhttp(二) 拦截器</title>
    <link href="hexo/blog/2021/01/okhttp-%E4%BA%8C-%E6%8B%A6%E6%88%AA%E5%99%A8.html"/>
    <id>hexo/blog/2021/01/okhttp-二-拦截器.html</id>
    <published>2021-01-13T10:29:12.000Z</published>
    <updated>2021-01-20T01:16:55.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="okhttp-二-拦截器"><a href="#okhttp-二-拦截器" class="headerlink" title="okhttp(二) 拦截器"></a>okhttp(二) 拦截器</h1><p>在前文中讲到了okhttp中的分发器</p><p>接下来讲okhttp中的拦截器</p><p>在上文中讲到，同步执行excuet时，会通过 getResponseWithInterceptorChain 获取response，<br>在异步enqueue后，后面会调用AsyncCall中execute，而里面也是通过getResponseWithInterceptorChain 来获取response。</p><p>调用的都是RealCall中的getResponseWithInterceptorChain函数。</p><h2 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain"></a>getResponseWithInterceptorChain</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors()); //自定义拦截器加入到集合</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">            originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个数组，添加各个拦截器，<br>然后初始化一个 Interceptor.Chain 对象，注意第2、3、4个参数都是null，而第5个参数是index：0<br>然后调用proceed函数</p><h2 id="RealInterceptorChain-java"><a href="#RealInterceptorChain-java" class="headerlink" title="RealInterceptorChain.java"></a>RealInterceptorChain.java</h2><p>RealInterceptorChain 实现 Interceptor接口中的Chain接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line">  private final int index;</span><br><span class="line">  private final Request request;</span><br><span class="line">  private final Call call;</span><br><span class="line">  private final EventListener eventListener;</span><br><span class="line">  private final int connectTimeout;</span><br><span class="line">  private final int readTimeout;</span><br><span class="line">  private final int writeTimeout;</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,</span><br><span class="line">      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123;</span><br><span class="line">    this.interceptors = interceptors;</span><br><span class="line">    this.connection = connection;</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line">    this.httpCodec = httpCodec;</span><br><span class="line">    this.index = index;</span><br><span class="line">    this.request = request;</span><br><span class="line">    this.call = call;</span><br><span class="line">    this.eventListener = eventListener;</span><br><span class="line">    this.connectTimeout = connectTimeout;</span><br><span class="line">    this.readTimeout = readTimeout;</span><br><span class="line">    this.writeTimeout = writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int connectTimeoutMillis() &#123;</span><br><span class="line">    return connectTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, millis, readTimeout, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int readTimeoutMillis() &#123;</span><br><span class="line">    return readTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, millis, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int writeTimeoutMillis() &#123;</span><br><span class="line">    return writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, readTimeout, millis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Call call() &#123;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EventListener eventListener() &#123;</span><br><span class="line">    return eventListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Confirm that the intercepted response isn&apos;t null.</span><br><span class="line">    if (response == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (response.body() == null) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是RealInterceptorChain的全部代码，注意看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 最开始index = 0，注意这里构造RealInterceptorChain时，传入的为index+1</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的最前面的，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 RetryAndFollowUpInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>看注释现在可能又点绕，接着往下看，Interceptor是一个接口，没必要看，可以直接先看RetryAndFollowUpInterceptor</p><h2 id="RetryAndFollowUpInterceptor-重试以及重定向拦截器"><a href="#RetryAndFollowUpInterceptor-重试以及重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor 重试以及重定向拦截器"></a>RetryAndFollowUpInterceptor 重试以及重定向拦截器</h2><p>RetryAndFollowUpInterceptor 实现 Interceptor 接口</p><p>查看其中的intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * todo  管理类，维护了 与服务器的连接、数据流与请求三者的关系。真正使用的拦截器为 Connect</span><br><span class="line">         */</span><br><span class="line">        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line"></span><br><span class="line">        // 在这里无限循环，只有抛出异常或者return response才会中断</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (canceled) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            boolean releaseConnection = true;</span><br><span class="line">            try &#123;</span><br><span class="line">                //todo 请求出现了异常，那么releaseConnection依旧为true。</span><br><span class="line">                response = realChain.proceed(request, streamAllocation, null, null);</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">            &#125; catch (RouteException e) &#123;</span><br><span class="line">                //todo 路由异常，连接未成功，请求还没发出去</span><br><span class="line">                //The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">                if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">                    throw e.getLastConnectException();</span><br><span class="line">                &#125;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span><br><span class="line">                // HTTP2才会抛出ConnectionShutdownException。所以对于HTTP1 requestSendStarted一定是true</span><br><span class="line">                //An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">                if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">                //todo 不是前两种的失败，那直接关闭清理所有资源</span><br><span class="line">                if (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed(null);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 如果进过重试/重定向才成功的，则在本次响应中记录上次响应的情况</span><br><span class="line">            //Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder()</span><br><span class="line">                        .priorResponse(</span><br><span class="line">                                priorResponse.newBuilder()</span><br><span class="line">                                        .body(null)</span><br><span class="line">                                        .build()</span><br><span class="line">                        )</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 处理3和4xx的一些状态码，如301 302重定向</span><br><span class="line">            Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                if (!forWebSocket) &#123;</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">            //todo 限制最大 followup 次数为20次</span><br><span class="line">            if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 判断是不是可以复用同一份连接</span><br><span class="line">            if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                        createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">                this.streamAllocation = streamAllocation;</span><br><span class="line">            &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">                        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到此处的主要逻辑，<br>将传入的chain对象转为RealInterceptorChain，<br>无限循环，然后在循环中调用chain.proceed函数，获取response，<br>循环的主要作用为catch异常，并针对RouteException 或者 IOException 做重试操作，其他异常则终止，</p><p>而chain.proceed又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 1； index + 1 = 2；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 1，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 BridgeInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"><a href="#BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应" class="headerlink" title="BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"></a>BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应</h2><p>BridgeInterceptor 也是实现 Interceptor 接口</p><p>同样直接查看intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also</span><br><span class="line">      // decompressing</span><br><span class="line">        // the transfer stream.</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest);</span><br><span class="line"></span><br><span class="line">        if (transparentGzip</span><br><span class="line">                &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">                &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                    .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">                    .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个函数的逻辑，<br>先对请求头信息进行再处理，然后执行chain.proceed获取networkResponse，<br>然后再对networkResponse进行再包装处理</p><p>同RetryAndFollowUpInterceptor一样，又会调用到chain.proceed函数，<br>又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 2； index + 1 = 3；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 2，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CacheInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>再看CacheInterceptor代码</p><h2 id="CacheInterceptor-负责读取缓存以及更新缓存"><a href="#CacheInterceptor-负责读取缓存以及更新缓存" class="headerlink" title="CacheInterceptor 负责读取缓存以及更新缓存"></a>CacheInterceptor 负责读取缓存以及更新缓存</h2><p>CacheInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    //todo 通过url的md5数据 从文件缓存查找 （GET请求才有缓存）</span><br><span class="line">    Response cacheCandidate = cache != null</span><br><span class="line">            ? cache.get(chain.request())</span><br><span class="line">            : null;</span><br><span class="line"></span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    //todo 缓存策略:根据各种条件(请求头)组成 请求与缓存</span><br><span class="line">    CacheStrategy strategy =</span><br><span class="line">            new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    //</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有网络请求也没有缓存</span><br><span class="line">    //If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        return new Response.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(504)</span><br><span class="line">                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-1L)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有请求，肯定就要使用缓存</span><br><span class="line">    //If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">    if (networkRequest == null) &#123;</span><br><span class="line">        return cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 去发起请求</span><br><span class="line">    Response networkResponse = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">        if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">    if (cacheResponse != null) &#123;</span><br><span class="line">        //todo 服务器返回304无修改，那就使用缓存的响应修改了时间等数据后作为本次请求的响应</span><br><span class="line">        if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">            // Update the cache after combining headers but before stripping the</span><br><span class="line">            // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            return response;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 走到这里说明缓存不可用 那就使用网络的响应</span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    //todo 进行缓存</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response,</span><br><span class="line">                networkRequest)) &#123;</span><br><span class="line">            // Offer this request to the cache.</span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; catch (IOException ignored) &#123;</span><br><span class="line">                // The cache cannot be written.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程就是获取一个networlRequets，以及一个缓存的cacheResponse，<br>如果networlRequets与cacheResponse，则直接报504的网络异常<br>如果networlRequets为空，则只能返回cacheResponse，<br>如果networlRequets不为空，则执行网络请求，获取networkResponse，<br>如果cacheResponse 不为空  且 networkResponse响应码304，代表无更改，则可以返回，</p><p>再往下就是对networlRequets进行处理，并加入缓存。</p><p>注意：此处获取networkResponse也是调用chain.proceed，于是与上面一直，也会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 3； index + 1 = 4；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 3，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 ConnectInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>此时会调用到ConnectInterceptor中的intercept函数</p><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>ConnectInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">    public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">        // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">        return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码就是ConnectInterceptor类中所有源码，<br>intercept函数中，重新获取了几个参数，和上面的几个Interceptor实现类不太一样，<br>最后调用的proceed函数是四个参数的，最后还是会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 4； index + 1 = 5；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 4，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CallServerInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>CallServerInterceptor 也是实现 Interceptor 接口，<br>CallServerInterceptor 中 intercept 函数就是直接与服务端通信的，<br>而在这里会获取到真正的response，并返回到上一层，也就是ConnectInterceptor的intercept，同理会依次向上返回。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>在上面看到的，一层一层拦截器向下调用，Interceptor类实现 调用 Interceptor类实现，<br>每一层的拦截器实现自己的功能，然后交付给下一层拦截器，<br>这种设计模式就是责任链模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;okhttp-二-拦截器&quot;&gt;&lt;a href=&quot;#okhttp-二-拦截器&quot; class=&quot;headerlink&quot; title=&quot;okhttp(二) 拦截器&quot;&gt;&lt;/a&gt;okhttp(二) 拦截器&lt;/h1&gt;&lt;p&gt;在前文中讲到了okhttp中的分发器&lt;/p&gt;
&lt;p&gt;接下
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>react Hook</title>
    <link href="hexo/blog/2021/01/react-Hook.html"/>
    <id>hexo/blog/2021/01/react-Hook.html</id>
    <published>2021-01-11T03:27:26.000Z</published>
    <updated>2021-01-11T08:01:07.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><p>Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect 是一个副作用函数，默认在每次渲染之后都会执行。<br>而且保证每次运行effect时，DOM已经渲染完毕。</p><p>传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。<br>事实上这正是我们可以在 effect 中获取最新的 useState中 的值，而不用担心其过期的原因。<br>每次我们重新渲染，都会生成新的 effect，替换掉之前的。<br>某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。</p><ul><li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</li><li></li></ul><p>useEffect提供清除操作，当我们需要在React组件清除时，执行某一些操作，可以在useEffect中，返回清除函数。<br>当React清除时，会执行useEffect中的返回函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</li></ul><p>React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。<br>这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p><p>还可以对useEffect进行优化，useEffect接受两个参数，第二个参数为比较值，当这个值发生了变化，才会执行useEffect。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const [count, setCount] = useState(0)</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><p>这样，只有当count发生变化，即我们调用过 setCount来改变count的值，下一次渲染完毕，才会执行useEffect</p><p>所以，当我们需要执行一些只需执行一次的逻辑时，可以传入一个定值，一般使用空数组[]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    function request() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, []])</span><br></pre></td></tr></table></figure><p>如上所示，request只会在第一次渲染完毕执行一次，remove函数也时只会执行一次</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hook技术&quot;&gt;&lt;a href=&quot;#Hook技术&quot; class=&quot;headerlink&quot; title=&quot;Hook技术&quot;&gt;&lt;/a&gt;Hook技术&lt;/h1&gt;&lt;p&gt;Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及
      
    
    </summary>
    
    
      <category term="react" scheme="hexo/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>IOC</title>
    <link href="hexo/blog/2021/01/IOC.html"/>
    <id>hexo/blog/2021/01/IOC.html</id>
    <published>2021-01-08T02:32:38.000Z</published>
    <updated>2021-01-19T09:32:15.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>android ioc 技术</p><p>dagger2使用：<br>主要使用了工厂模式、APT技术</p><p>利用注解处理器，变异时生成大量代码，完成自动注入</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC&quot;&gt;&lt;/a&gt;IOC&lt;/h1&gt;&lt;p&gt;android ioc 技术&lt;/p&gt;
&lt;p&gt;dagger2使用：&lt;br&gt;主要使用了工厂模式、APT技术&lt;/p&gt;
&lt;p&gt;利用注解处理器
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Glide框架解析</title>
    <link href="hexo/blog/2020/12/Glide%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2020/12/Glide框架解析.html</id>
    <published>2020-12-30T02:50:47.000Z</published>
    <updated>2020-12-30T08:48:55.173Z</updated>
    
    <content type="html"><![CDATA[<p>Glide是android平台中的一个图片加载框架，<br>可以加载本地图片、网络图片、动态图</p><p>Glide的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageView);</span><br></pre></td></tr></table></figure><p>可以看出分成三部分：with、load、into<br>下面我们也分成三部分针对讲解</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with函数其实是对生命周期的管理<br>在Glide源码中，可以看到几个with函数,入参类型各不相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">    return getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Activity activity) &#123;</span><br><span class="line">    return getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull FragmentActivity activity) &#123;</span><br><span class="line">    return getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Fragment fragment) &#123;</span><br><span class="line">    return getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@Deprecated</span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull android.app.Fragment fragment) &#123;</span><br><span class="line">    return getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull View view) &#123;</span><br><span class="line">    return getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>with函数的入参有</p><ul><li>Context</li><li>Activity</li><li>FragmentActivity</li><li>androidX.Fragment</li><li>android.app.Fragment</li><li>View<br>可以看到，在with函数中都是调用getRetriever返回RequestManager对象，而调用getRetriever的入参有两个类型</li><li>1、context</li><li>2、activity</li></ul><p>getRetriever的两种入参类型又是根据上面with函数获取的，<br>针对fragment、fragmentActiivty、Actiivty获取对应的actiivty<br>针对context、view，则获取对应的context</p><p>再看一下getRetriever函数</p><h3 id="getRetriever"><a href="#getRetriever" class="headerlink" title="getRetriever"></a>getRetriever</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;</span><br><span class="line">    Preconditions.checkNotNull(</span><br><span class="line">        context,</span><br><span class="line">        &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span><br><span class="line">            + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span><br><span class="line">            + &quot;is attached or after the Fragment is destroyed).&quot;);</span><br><span class="line">    return Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br><span class="line">@NonNull</span><br><span class="line">public RequestManagerRetriever getRequestManagerRetriever() &#123;</span><br><span class="line">    return requestManagerRetriever;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，getRetriever返回就是一个 RequestManagerRetriever对象</p><p>也就是说 with函数最后调用到了RequestManagerRetriever对象的get函数</p><h3 id="RequestManagerRetriever"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a>RequestManagerRetriever</h3><p>看在Glide.java中的with函数就知道，RequestManagerRetriever中get函数也存在多个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">      if (context instanceof FragmentActivity) &#123;</span><br><span class="line">        return get((FragmentActivity) context);</span><br><span class="line">      &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">        return get((Activity) context);</span><br><span class="line">      &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">        return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">      return supportFragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull Fragment fragment) &#123;</span><br><span class="line">    Preconditions.checkNotNull(fragment.getActivity(),</span><br><span class="line">          &quot;You cannot start a load on a fragment before it is attached or after it is destroyed&quot;);</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(fragment.getActivity().getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      return fragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@NonNull</span><br><span class="line">public RequestManager get(@NonNull View view) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        return get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line">    Preconditions.checkNotNull(view.getContext(),</span><br><span class="line">        &quot;Unable to obtain a request manager for a view without a Context&quot;);</span><br><span class="line">    Activity activity = findActivity(view.getContext());</span><br><span class="line">    if (activity == null) &#123;</span><br><span class="line">        return get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (activity instanceof FragmentActivity) &#123;</span><br><span class="line">        Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);</span><br><span class="line">        return fragment != null ? get(fragment) : get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android.app.Fragment fragment = findFragment(view, activity);</span><br><span class="line">    if (fragment == null) &#123;</span><br><span class="line">        return get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    return get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个get函数，传入context对象，对context做分发，<br>其他的get函数，都是判断当前执行线程是否在main线程，如果不是 则都会走到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return getApplicationManager(context)</span><br></pre></td></tr></table></figure></p><p>在main线程时，会根据传入的参数获取对应的activity，activity为null，则也会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return getApplicationManager(context)</span><br></pre></td></tr></table></figure></p><p>如果activity不为空，则执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">return supportFragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br></pre></td></tr></table></figure></p><p>其中android.app.Fragment会略有差异，因为该Fragment为android包下，已被遗弃，但执行逻辑其实大同小异</p><p>接下来我们再看supportFragmentGet函数</p><h3 id="supportFragmentGet"><a href="#supportFragmentGet" class="headerlink" title="supportFragmentGet()"></a>supportFragmentGet()</h3><p>跟随Fragment的生命周期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">private RequestManager supportFragmentGet(</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull FragmentManager fm,</span><br><span class="line">    @Nullable Fragment parentHint,</span><br><span class="line">    boolean isParentVisible) &#123;</span><br><span class="line"></span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">        // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        requestManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getApplicationManager"><a href="#getApplicationManager" class="headerlink" title="getApplicationManager"></a>getApplicationManager</h3><p>跟随应用的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  private RequestManager getApplicationManager(@NonNull Context context) &#123;</span><br><span class="line">    // Either an application context or we&apos;re on a background thread.</span><br><span class="line">    if (applicationManager == null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        if (applicationManager == null) &#123;</span><br><span class="line">          // Normally pause/resume is taken care of by the fragment we add to the fragment or</span><br><span class="line">          // activity. However, in this case since the manager attached to the application will not</span><br><span class="line">          // receive lifecycle events, we must force the manager to start resumed using</span><br><span class="line">          // ApplicationLifecycle.</span><br><span class="line"></span><br><span class="line">          // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  new ApplicationLifecycle(),</span><br><span class="line">                  new EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样的话，就可以看得出调用with函数时，会绑定到一个requestManaget对象，<br>但是分两种：</p><ul><li>1、子线程，或出入的Context为ApplicationContext —》 applicationManager   —— 跟随应用的生命周期</li><li>2、main线程 &amp; 非ApplicationContext  —-》 requestManager —- 跟随当前Fragment/Activity的生命周期</li></ul><p>接着看RequestManager</p><h2 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h2><p>查看RequestManager的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager(</span><br><span class="line">      @NonNull Glide glide, @NonNull Lifecycle lifecycle,</span><br><span class="line">      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) &#123;</span><br><span class="line">    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory(), context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)</span><br><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">    this.glide = glide;</span><br><span class="line">    this.lifecycle = lifecycle;</span><br><span class="line">    this.treeNode = treeNode;</span><br><span class="line">    this.requestTracker = requestTracker;</span><br><span class="line">    this.context = context;</span><br><span class="line"></span><br><span class="line">    connectivityMonitor =</span><br><span class="line">    factory.build(</span><br><span class="line">        context.getApplicationContext(),</span><br><span class="line">        new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line">    </span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        mainHandler.post(addSelfToLifecycle);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lifecycle.addListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addListener(connectivityMonitor);</span><br><span class="line"></span><br><span class="line">    defaultRequestListeners =</span><br><span class="line">    new CopyOnWriteArrayList&lt;&gt;(glide.getGlideContext().getDefaultRequestListeners());</span><br><span class="line">    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());</span><br><span class="line"></span><br><span class="line">    glide.registerRequestManager(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个构造函数，上面的构造函数会调用到下面的构造函数，只有上面的函数才对外暴露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Glide是android平台中的一个图片加载框架，&lt;br&gt;可以加载本地图片、网络图片、动态图&lt;/p&gt;
&lt;p&gt;Glide的使用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>okhttp解析(一) 执行与分发</title>
    <link href="hexo/blog/2020/12/okhttp%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2020/12/okhttp解析.html</id>
    <published>2020-12-25T03:25:23.000Z</published>
    <updated>2021-01-14T02:09:33.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="okhttp解析"><a href="#okhttp解析" class="headerlink" title="okhttp解析"></a>okhttp解析</h1><p>okhttp 是一个网络框架，是当下android使用最频繁的网络请求框架，由Square公司开源。</p><p>google在Android4.4后开始将源码中的HttpUrlConnection底层实现替换为okhttp，现在流程的Retrofit框架底层同样是使用okhttp的。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>支持http1、http2、Quic以及WebSocket</li><li>连接池复用底层TCP(Socket),减少请求延时</li><li>无缝支持GZIP减少通信数据流量</li><li>缓存相应数据减少重复请求次数</li><li>请求失败自动重试主机其他ip，自动重定向</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>okhttp具体使用可以查看：</p><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>在client执行request时，会调用newCall方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Call newCall(Request request) &#123;</span><br><span class="line">    return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回一个RealCall对象，而RealCall是Call接口的一个实现。</p><p>client调用newCall时，只是返回一个RealCall对象，请求还没有发送出去。<br>需要执行RealCall的execute()或者enqueue()</p><p>这两个方法由什么区别呢，现在看一下。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>这是一个同步方法，即会直接执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">        executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(this);</span><br><span class="line">    try &#123;</span><br><span class="line">        client.dispatcher().executed(this);</span><br><span class="line">        // 发起请求</span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">        if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        eventListener.callFailed(this, e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处会调用client.dispatcher().executed(this); 其实是将当前RealCall对象加入到Dispatch的同步执行队列<br>在最后执行完毕会调用 client.dispatcher().finished(this); 其实是将当前RealCall对象从Dispatch的同步执行队列移除，因为当前RealCall对象的任务已执行完毕</p><p>会获取到response，并直接return</p><h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h3><p>这是一个异步方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">        executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(this);</span><br><span class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的两个方法中，最后都会调用到dispatcher的对应函数，Dispatch是一个分发器</p><p>注意调用dispatch的enqueue函数时，会将responseCallback包装成一个AsyncCall对象，<br>AsyncCall为RealCall的一个内部类</p><h3 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">    private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">        this.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host() &#123;</span><br><span class="line">        return originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request() &#123;</span><br><span class="line">        return originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealCall get() &#123;</span><br><span class="line">        return RealCall.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void execute() &#123;</span><br><span class="line">        boolean signalledCallback = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行请求 （拦截器）</span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line"></span><br><span class="line">            if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                signalledCallback = true;</span><br><span class="line">                responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                signalledCallback = true;</span><br><span class="line">                responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (signalledCallback) &#123;</span><br><span class="line">                // Do not signal the callback twice!</span><br><span class="line">                Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                eventListener.callFailed(RealCall.this, e);</span><br><span class="line">                responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            client.dispatcher().finished(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AysncCall实质上实现的是Runnable，execute执行的是获取response过程，<br>请求成功则执行responseCallback.onResponse，否则执行responseCallback.onFailure</p><p>最后执行client.dispatcher().finished(this); 注意最后传入的this指向是AsyncCall实例对象，</p><h2 id="Dispatch"><a href="#Dispatch" class="headerlink" title="Dispatch"></a>Dispatch</h2><p>Dispatch是okHttp内一个任务分发器，用于管理任务、管理线程池。<br>我们可以自定义Dispatch，如果没有传入自定义的，okHttp内部也有默认的，okhttp3.Dispatcher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">    private int maxRequests = 64;</span><br><span class="line">    private int maxRequestsPerHost = 5;</span><br><span class="line">    private @Nullable</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Executes calls. Created lazily.</span><br><span class="line">    * 内部的线程池</span><br><span class="line">    */</span><br><span class="line">    private @Nullable</span><br><span class="line">    ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Ready async calls in the order they&apos;ll be run.</span><br><span class="line">    * 等待执行的异步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet.</span><br><span class="line">    * 正在执行的异步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Running synchronous calls. Includes canceled calls that haven&apos;t finished yet.</span><br><span class="line">    * 正在执行的同步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在Dispatch内部有一个线程池，有三个队列，这三个队列下面会用的，会根据不同的任务添加到不同的队列</p><p>看一下Dispatch内部的executed以及enqueue函数</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">                new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;,</span><br><span class="line">                false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于线程池的详细解析可以查看之前的文章：<br>线程池第4个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p><ul><li>ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小<br>  当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。<br>  所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。</li><li>LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定<br> 当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的integer.MAX_VALUE,此时添加任务会一直成功。<br> 最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。</li><li>SynchronousQueue: 无容量的队列<br>  使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。<br>  唯一制约就是配置的最大线程数，如果使用Integer.MAX_VALUE就实现了真正的无等待。</li></ul><p>而在okhttp中就采用的SynchronousQueue，但进程内存是有限制的，不能无限添加，所以在Okhttp内部又有maxRequests限制，保证不超过64个。</p><h3 id="executed"><a href="#executed" class="headerlink" title="executed"></a>executed</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在同步函数中，会将call 添加到同步执行队列</p><h3 id="enqueue-1"><a href="#enqueue-1" class="headerlink" title="enqueue"></a>enqueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">    //todo : 1、如果正在执行的请求小于64</span><br><span class="line">    // 2、相同host的请求不能超过5个</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        runningAsyncCalls.add(call);  //正在执行的请求</span><br><span class="line">        executorService().execute(call); //线程池跑任务</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异步执行时，会判断当前正在执行异步队列大大小是否小于64 &amp;&amp; 传入的call的Host在正在执行队列中数量是否小于，<br>如果都满足，则会被放入正在执行异步队列，并且调用线程池执行该任务<br>如果不满足，则会被放入待执行异步队列</p><p>注意：此处的call为一个AsyncCall实例，</p><p>上面在AsyncCall中讲过了，当AsyncCall执行完毕会调用finished（AsyncCall）函数来移除正在执行异步队列中的这个AsyncCall对象</p><h3 id="finished"><a href="#finished" class="headerlink" title="finished"></a>finished</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 异步执行队列移除AsyncCall对象</span><br><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">    finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同步队列移除RealCall对象</span><br><span class="line">void finished(RealCall call) &#123;</span><br><span class="line">    finished(runningSyncCalls, call, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">    int runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">        if (promoteCalls) promoteCalls();</span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = this.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异步执行队列移除AsyncCall对象时，会执行promoteCalls()；<br>而且当this.idleCallback不为空，而且异步执行队列为空时,<br>会执行this.idleCallback.run();</p><h3 id="promoteCalls"><a href="#promoteCalls" class="headerlink" title="promoteCalls"></a>promoteCalls</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从异步等待队列中取任务执行</span><br><span class="line"> */</span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</span><br><span class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall call = i.next();</span><br><span class="line">        // 同一Host请求只能同时有5个</span><br><span class="line">        if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            i.remove();</span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promoteCalls函数主题其实就是从等待异步队列中取任务放入到执行异步任务队列中，并执行。</p><ul><li>先判断异步执行队列大小是否大于64，是则不向下执行</li><li>再判断待执行异步队列是否没有数据，是则不向下执行</li><li>然后遍历readyAsyncCalls队列，判断当前AsyncCall的Host是否在异步执行队列中&lt;5,<br>小于5时，将该任务从待执行异步队列移除，并将该任务添加到执行异步队列，并放入线程池<br>判断异步执行队列大小是否大于64，是的话，终止遍历</li></ul><p>到这里，okHttp的任务执行基本就看完了。</p><p>当然还有任务的取消</p><h3 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void cancelAll() &#123;</span><br><span class="line">    for (AsyncCall call : readyAsyncCalls) &#123;</span><br><span class="line">        call.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (AsyncCall call : runningAsyncCalls) &#123;</span><br><span class="line">        call.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (RealCall call : runningSyncCalls) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是遍历三个队列，调用Call对象的cancel方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;okhttp解析&quot;&gt;&lt;a href=&quot;#okhttp解析&quot; class=&quot;headerlink&quot; title=&quot;okhttp解析&quot;&gt;&lt;/a&gt;okhttp解析&lt;/h1&gt;&lt;p&gt;okhttp 是一个网络框架，是当下android使用最频繁的网络请求框架，由Square公
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android-自定义View-继承Drawable</title>
    <link href="hexo/blog/2020/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFDrawable.html"/>
    <id>hexo/blog/2020/12/android-自定义View-继承Drawable.html</id>
    <published>2020-12-22T02:11:42.000Z</published>
    <updated>2020-12-22T03:00:18.385Z</updated>
    
    <content type="html"><![CDATA[<p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>最后实现效果如下图：</p><p><img src="../../../images/fish.gif" style="zoom:20%"></p><p>思路：<br>1、将正个鱼分成几个部分，鱼头圆，鱼身二阶贝塞尔曲线，鱼尾，鱼鳍<br>2、因为鱼会摆动，需要考虑一个角度问题，需要定义一个点，来确定整个的角度<br>3、以鱼的重心点作为基准点，即鱼身的中心点<br>4、根据鱼的中心点以及每条线的长度获取其他点的坐标，就可以绘制整个图形<br>5、鱼的摆动根据属性动画来绘制，但要考虑鱼头与鱼尾的摆动频率不一致，可以使用三角函数，0-360，鱼头设置一倍，鱼尾设置多倍，<br>此时就能鱼头与鱼尾摆动频率不一致了。<br>6、鱼尾分两段，摆动的方向不一致，一段带动另一段，一个采用正旋sin，一个采用余旋cos</p><p>进阶：鱼能游动<br>7、点击时的水波纹<br>8、鱼回头问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a value=&quot;源码地址&quot; target=&quot;_blank&quot; href=&quot;https://github.com/wangchongwei/customView&quot; style=&quot;font-size:25px; color:blue; font-weight:bold&quot;&gt;源码
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android 嵌套滑动</title>
    <link href="hexo/blog/2020/12/Android-%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8.html"/>
    <id>hexo/blog/2020/12/Android-嵌套滑动.html</id>
    <published>2020-12-17T02:31:48.000Z</published>
    <updated>2020-12-17T02:31:48.218Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android View的事件分发</title>
    <link href="hexo/blog/2020/12/Android-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html"/>
    <id>hexo/blog/2020/12/Android-View的事件分发.html</id>
    <published>2020-12-17T02:11:13.000Z</published>
    <updated>2020-12-18T05:34:44.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h1><p>首先用户的交互事件都是先交给Actiivty，然后再来向下分发事件</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>我们可以查看Activity的dispatchTouchEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要明确一点，ACTION_DOWN是一次完整的交互事件的起点，onUserInteraction是一个空函数可以不要管，</p><p>会将事件分发到window的superDispatchTouchEvent，而window指的是PhoneWindow，在andorid源码中，只有一个window的实现类，就是PhoneWindow，如果window的dispatch返回为true则不向下执行，否则会执行到Activity的onTouchEvent，</p><h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在PhoneWindow.java中 superDispatchTouchEvent函数又代理给DecorView的superDispatchTouchEvent</p><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p>DecorView继承自FrameLayout，FrameLayout继承自ViewGroup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return super.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>DecorView中的superDispatchTouchEvent直接调用父类的dispatchTouchEvent，<br>而在FrameLayout中没有重写dispatchTouchEvent函数，所以会直接调用到ViewGroup的dispatchTouchEvent函数</p><h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>首先，所有的View都是继承自View的，ViewGroup也是继承自View</p><p>在ViewGroup的dispatchTouchEvent函数中，代码太长，先将部分代码收缩起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">       // mInputEventConsistencyVerifier是View中的一个变量，这里是对事件的一些校验</span><br><span class="line">       if (mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If the event targets the accessibility focused view and this is it, start</span><br><span class="line">       // normal event dispatch. Maybe a descendant is what will handle the click.</span><br><span class="line">       // 此处是对一些无障碍功能的设置</span><br><span class="line">       if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">           ev.setTargetAccessibilityFocus(false);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 局部变量，每一个事件分发时，都会重置为false</span><br><span class="line">       boolean handled = false;</span><br><span class="line">       if (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 重新校验</span><br><span class="line">       if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return handled;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其实主要逻辑还是在 if (onFilterTouchEventForSecurity(ev)) { 这个代码区域里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;</span><br><span class="line">    //noinspection RedundantIfStatement</span><br><span class="line">    if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0</span><br><span class="line">            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;</span><br><span class="line">        // Window is obscured, drop this touch.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对事件安全过滤的函数，正常情况都能通过。<br>接着看dispatchTouchEvent函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int action = ev.getAction();</span><br><span class="line">final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">// Handle an initial down.</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    // Throw away all previous state when starting a new touch gesture.</span><br><span class="line">    // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">    // due to an app switch, ANR, or some other state change.</span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是ACTION_DOWN就清除、重置touch事件，因为在上面讲过，ACTION_DOWN是一次交互的起点，在这里将上一次交互的状态都清除掉</p><h3 id="判断事件是否拦截"><a href="#判断事件是否拦截" class="headerlink" title="判断事件是否拦截"></a>判断事件是否拦截</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Check for interception.</span><br><span class="line">final boolean intercepted;</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != null) &#123;</span><br><span class="line">    final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">    if (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); // restore action in case it was changed</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        intercepted = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // There are no touch targets and this action is not an initial down</span><br><span class="line">    // so this view group continues to intercept touches.</span><br><span class="line">    intercepted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是判断是否开启拦截，注意这里的判断逻辑，intercepted是是否拦截标志位<br>disallowIntercept： 是否允许拦截，此处是一个外部拦截，在子视图中设置的，子视图设置是否让父容器拦截事件<br>如果disallowIntercept = false，再取执行内部拦截，onInterceptTouchEvent，查看ViewGroup是否拦截，为内部拦截<br>disallowIntercept为true时，代表子视图不允许父容器拦截，则intercepted = false;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> if (intercepted || mFirstTouchTarget != null) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check for cancelation.</span><br><span class="line">final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">// Update list of touch targets for pointer down, if needed.</span><br><span class="line">final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class="line">TouchTarget newTouchTarget = null;</span><br><span class="line">boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class="line">``` </span><br><span class="line">当被拦截时，或者touchTarget不为空时，设置事件的TargetAccessibilityFocus为false</span><br><span class="line">然后判断事件是否是取消事件</span><br><span class="line">初始化一个变量alreadyDispatchedToNewTouchTarget=false, 是否已经将事件绑定到一个targetView</span><br></pre></td></tr></table></figure><p>if (!canceled &amp;&amp; !intercepted) {<br>    // 当不是取消、没有被拦截时<br>    // If the event is targeting accessibility focus we give it to the<br>    // view that has accessibility focus and if it does not handle it<br>    // we clear the flag and dispatch the event to all children as usual.<br>    // We are looking up the accessibility focused host to avoid keeping<br>    // state since these events are very rare.<br>    // 获取到该事件绑定的view<br>    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()<br>            ? findChildWithAccessibilityFocus() : null;</p><pre><code>......</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在上述代码段中，其实只是执行了一个操作，即遍历子View，获取该事件对应的处理的View。</span><br><span class="line">注意这里有一个函数调用 dispatchTransformedTouchEvent</span><br><span class="line"></span><br><span class="line">当遍历找到需要处理这个事件的View或者确定不存在该View时，即执行这个函数，对这个事件进行重新分发</span><br></pre></td></tr></table></figure></p><p>private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,<br>            View child, int desiredPointerIdBits) {<br>    final boolean handled;</p><pre><code>// Canceling motions is a special case.  We don&apos;t need to perform any transformations// or filtering.  The important part is the action, not the contents.final int oldAction = event.getAction();if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {    event.setAction(MotionEvent.ACTION_CANCEL);    if (child == null) {        // 为空，将事件交给View.dispatchTouchEvent处理        handled = super.dispatchTouchEvent(event);    } else {        // 子View处理        handled = child.dispatchTouchEvent(event);    }    event.setAction(oldAction);    return handled;}// Calculate the number of pointers to deliver.final int oldPointerIdBits = event.getPointerIdBits();final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;// If for some reason we ended up in an inconsistent state where it looks like we// might produce a motion event with no pointers in it, then drop the event.if (newPointerIdBits == 0) {    return false;}// If the number of pointers is the same and we don&apos;t need to perform any fancy// irreversible transformations, then we can reuse the motion event for this// dispatch as long as we are careful to revert any changes we make.// Otherwise we need to make a copy.final MotionEvent transformedEvent;if (newPointerIdBits == oldPointerIdBits) {    if (child == null || child.hasIdentityMatrix()) {        if (child == null) {            handled = super.dispatchTouchEvent(event);        } else {            final float offsetX = mScrollX - child.mLeft;            final float offsetY = mScrollY - child.mTop;            event.offsetLocation(offsetX, offsetY);            handled = child.dispatchTouchEvent(event);            event.offsetLocation(-offsetX, -offsetY);        }        return handled;    }    transformedEvent = MotionEvent.obtain(event);} else {    transformedEvent = event.split(newPointerIdBits);}// Perform any necessary transformations and dispatch.if (child == null) {    handled = super.dispatchTouchEvent(transformedEvent);} else {    final float offsetX = mScrollX - child.mLeft;    final float offsetY = mScrollY - child.mTop;    transformedEvent.offsetLocation(offsetX, offsetY);    if (! child.hasIdentityMatrix()) {        transformedEvent.transform(child.getInverseMatrix());    }    handled = child.dispatchTouchEvent(transformedEvent);}// Done.transformedEvent.recycle();return handled;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">上述函数总结其实就是判断childView是否为空，如果为空的话，就再将事件转交给View.dispatchTouchEvent来处理，</span><br><span class="line">super.dispatchTouchEvent，因为ViewGroup继承自View，此时会调用到View.dispatchTouchEvent</span><br><span class="line">如果childView存在，则执行childView.dispatchTouchEvent，如果childView还是ViewGroup，还会再次执行这个过程，</span><br><span class="line">遍历-找寻子View-分发，注意在分发过程中，如果已经返回为true了，则不会再向下分发。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来看View的dispatchTouchEvent</span><br><span class="line"></span><br><span class="line">## View</span><br></pre></td></tr></table></figure><p>public boolean dispatchTouchEvent(MotionEvent event) {<br>    // If the event should be handled by accessibility focus first.<br>    if (event.isTargetAccessibilityFocus()) {<br>        // We don’t have focus or no virtual descendant has it, do not handle the event.<br>        if (!isAccessibilityFocusedViewOrHost()) {<br>            return false;<br>        }<br>        // We have focus and got the event, then use normal event dispatch.<br>        event.setTargetAccessibilityFocus(false);<br>    }</p><pre><code>boolean result = false;if (mInputEventConsistencyVerifier != null) {    mInputEventConsistencyVerifier.onTouchEvent(event, 0);}final int actionMasked = event.getActionMasked();if (actionMasked == MotionEvent.ACTION_DOWN) {    // Defensive cleanup for new gesture    // 当手指触碰时，停止滚动    stopNestedScroll();}if (onFilterTouchEventForSecurity(event)) {    if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {        result = true;    }    //noinspection SimplifiableIfStatement    // 当onTouch事件返回了true时，此处返回true    ListenerInfo li = mListenerInfo;    if (li != null &amp;&amp; li.mOnTouchListener != null            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED            &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {        result = true;    }    // 当onTouch事件返回了true时，此处返回true    if (!result &amp;&amp; onTouchEvent(event)) {        result = true;    }}if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {    mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);}// Clean up after nested scrolls if this is the end of a gesture;// also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest// of the gesture.// 当手指抬起、取消时，结束滚动if (actionMasked == MotionEvent.ACTION_UP ||        actionMasked == MotionEvent.ACTION_CANCEL ||        (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {    stopNestedScroll();}return result;</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">再看一下onTouchEvent事件，onTouchEvent是对事件的处理</span><br></pre></td></tr></table></figure></p><p>if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {<br>    if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {<br>        setPressed(false);<br>    }<br>    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;<br>    // A disabled view that is clickable still consumes the touch<br>    // events, it just doesn’t respond to them.<br>    return clickable;<br>}<br><code>`</code><br>如果View是不可点击的，如：ImageView,直接return false</p><p>View里因为设置了 onClickListener(), 这样就导致 View是 clickable (或者可以直接在xml里加上android:clickable=”true”)，即可点击，那么View.onTouchEvent就会永远返回 True, 代表View consume了该事件。<br>注意：只要View consume了该事件，那么该事件既不会往下传(不会传给子view)，也不会往上传(后面Activity/ViewGroup 的 onTouchEvent将不会再调用)。</p><p>View中不存在拦截，只有ViewGroup才有拦截</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;View的事件分发&quot;&gt;&lt;a href=&quot;#View的事件分发&quot; class=&quot;headerlink&quot; title=&quot;View的事件分发&quot;&gt;&lt;/a&gt;View的事件分发&lt;/h1&gt;&lt;p&gt;首先用户的交互事件都是先交给Actiivty，然后再来向下分发事件&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>网络通信</title>
    <link href="hexo/blog/2020/12/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html"/>
    <id>hexo/blog/2020/12/网络通信.html</id>
    <published>2020-12-09T06:32:30.000Z</published>
    <updated>2020-12-11T08:26:06.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="计算机网络发展概史"><a href="#计算机网络发展概史" class="headerlink" title="计算机网络发展概史"></a>计算机网络发展概史</h2><p>计算机的发展大致分为以下四个阶段<br>1、诞生阶段，单个计算机为中心的远程联机系统<br>2、ARPANET，多个主机通过通信线路互联起来<br>3、开放性的标准化体系结构，OSI诞生<br>4、Internet互联网</p><p>OSI模型分为7层，tcp/ip模型分为4层，并存在对应关系<br>osi：物理层、链路层、 网络层、 传输层、  会话层、表示层、应用层<br>tcp/ip：链路层、     网络层、 传输层、         应用层</p><p>像我们日常中所说的4G、5G网络，是作用在链路层</p><p>TCP协议的基本特性：<br>面向链接、可靠性、RTT和RTO、数据排序、流量控制、全双工</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP协议中，Client与Server端建立链接会经历三次握手过程</p><p>1、Client 向 Server端发送报文，<br>    含有SYN = 1； seq(序列号)=1234(系统决定，1234是举例)，Client端进入SYN_SENT状态<br>2、Server 接收到 Client端报文，向Client端发送一个确认报文，<br>    含有 SYN = 1；ACK = 1; ack=1235(1234 + 1);seq(序列号)=2637(系统决定，2637是举例)<br>    Server端进入SYN_SYN_RCND状态<br>3、Client端接收到Server的确认报文，向Server端也发送一次确认报文，<br>    含有 ACK = 1；ack=2638(2637+1);<br>    Client与Server端都进入ESTABLISHED状态，通信建立，开始会话</p><p>以上就是三次握手的过程</p><p>问题：<br>为何tcp协议需要三次握手，而不是两次</p><p>因为三次是保证连接可靠、效率最高的次数。<br>第一次：客户端询问服务端能否建立通信<br>第二次：服务端向客户端确认可以通信<br>第三次：客户端向服务端确认可以通信<br>然后建立通信。</p><h3 id="洪泛攻击"><a href="#洪泛攻击" class="headerlink" title="洪泛攻击"></a>洪泛攻击</h3><p>黑客伪造大量虚假ip向服务端发送第一次握手报文，使server端大量通信进入SYN_SYN_RCND状态，消耗server资源，<br>使服务端无法响应其他的请求，甚至宕机。</p><p>处理方案：防火墙、</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>当要断开连接时，客户端与服务端之间将进行四次挥手，来确保数据传输都完毕，确保连接断开。</p><p>1、client向server端发送FIN报文，<br>    含有FIN = 1，seq(序列号)=J(系统决定，J是举例)，Client进入FIN_WAITING<br>2、server收到客户端发送的报文，同时向Server发送一个FIN ACK 确认报文<br>    含有ACK = 1； ack = J + 1; Server进入CLOSE_WAITING<br>3、server向client发送一个FIN报文，<br>    含有FIN = 1； seq = K；Server进入 CLOSE状态<br>4、client收到上述两个server端报文，Client进入TIME_WAITING状态,同时client向server发送一个ACK报文，<br>    含有FIN = 1； ACK = 1； ack = K + 1;<br>    server接收到此报文后，进入CLOSED状态，<br>    而client，在经过2 * MSL的时间段后，client进入CLOSED状态。</p><p>注意：四次挥手设计到四次报文的传输，但在实际中，可能会存在报文合并的现象，就是报文发送的次数可能只有3次甚至两次。<br>MSL理论上是2分钟，可实际一般会被重写为30s，所以最后等待时间为1min-4min。</p><h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><p>因为tcp是全双工(即客户端和服务器端可以相互发送和接收请求)，所以需要双方都确认关闭连接。</p><h3 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME-WAIT状态？"></a>为什么需要TIME-WAIT状态？</h3><p>在第三次报文发送，client接收到时，client会进入TIME_WAIT状态，而且是需要经过经过2 * MSL，才会进入CLOSED状态，<br>为何这么设计呢，因为要考虑最后一个报文的接收，要考虑到Server未接收到时，需要重新发送，还要考虑，如果Client即时进入CLOSED，连接断开，端口可能会有一个新的程序使用，可能存在报文被发送到这个新启动的程序。</p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>使用wireshark可以抓包，查看到连接过程中的每一次数据包的传递</p><p>使用过滤器查看</p><p>tcp udp 可以指定协议</p><p>tcp.port==80 端口</p><p>ip.src==192.168.101.130 ip<br>连接符使用and</p><p>tcp and tcp.port==3306 and ip.src==192.168.101.130</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络通信&quot;&gt;&lt;a href=&quot;#网络通信&quot; class=&quot;headerlink&quot; title=&quot;网络通信&quot;&gt;&lt;/a&gt;网络通信&lt;/h1&gt;&lt;h2 id=&quot;计算机网络发展概史&quot;&gt;&lt;a href=&quot;#计算机网络发展概史&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity一键换肤</title>
    <link href="hexo/blog/2020/12/Activity%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4.html"/>
    <id>hexo/blog/2020/12/Activity一键换肤.html</id>
    <published>2020-12-07T07:51:39.000Z</published>
    <updated>2020-12-11T09:59:44.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity一键换肤"><a href="#Activity一键换肤" class="headerlink" title="Activity一键换肤"></a>Activity一键换肤</h1><h2 id="Activity绘制过程"><a href="#Activity绘制过程" class="headerlink" title="Activity绘制过程"></a>Activity绘制过程</h2><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><p>查看ActivityThread代码源码，<br>performLaunchActivity函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Activity activity = null;</span><br><span class="line">try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">    r.assistToken);</span><br></pre></td></tr></table></figure></p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>我们在看Activity类中的attach函数中的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">mWindow.setWindowControllerCallback(this);</span><br><span class="line">mWindow.setCallback(this);</span><br><span class="line">mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">mWindow.getLayoutInflater().setPrivateFactory(this);</span><br></pre></td></tr></table></figure></p><p>再看我们在Activity中设置布局的setContentView函数在Activity中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看出我们传入的layout布局是设置到window对象上的，继续往里看<br>Window类中的setContentView是一个抽象方法，而getWindow()返回的是我们上面的PhoneWindow对象，我们看PhoneWindow中的setContentView方法</p><h3 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h3><p>PhoneWindow.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">    // before this happens.</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">    // before this happens.</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        final Scene newScene = new Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当初次运行时，肯定会走到installDecor 函数，在此函数中，又会新建一个DecorView绑定到window上。</p><p>也就是说我们的window上还有挂载一个DecorView</p><p>而在installDecor中，会对mContentParent判断，当为空时，会初始化<br>mContentParent = (DecorContentParent) mDecor.findViewById(R.id.decor_content_parent);</p><p>所以其实我们的view的层级其实是：<br>Window -&gt; DecorView -&gt; mContentParent + 我们自己的布局<br>而我们自己的View最后都是调用到LayoutInflater.inflate来加载的。</p><h3 id="LayoutInflater"><a href="#LayoutInflater" class="headerlink" title="LayoutInflater"></a>LayoutInflater</h3><p>最后所有View的加载会走到tryCreateView函数<br>LayoutInflater 中的 tryCreateView函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage(trackingBug = 122360734)</span><br><span class="line">@Nullable</span><br><span class="line">public final View tryCreateView(@Nullable View parent, @NonNull String name,</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull AttributeSet attrs) &#123;</span><br><span class="line">    if (name.equals(TAG_1995)) &#123;</span><br><span class="line">        // Let&apos;s party like it&apos;s 1995!</span><br><span class="line">        return new BlinkLayout(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    if (mFactory2 != null) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; else if (mFactory != null) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        view = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (view == null &amp;&amp; mPrivateFactory != null) &#123;</span><br><span class="line">        view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看得出先判断mFactory2是否存在，存在的话，会通过mFactory2.onCreateView来创建View<br>再判断mFactory是否存在，存在的话，会通过mFactory.onCreateView来创建View<br>如果上面两个都不存在，则会调用mPrivateFactory来创建</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>根据上面的描述，我们知道所有的View创建都会走到LayoutInflater.tryCreateView函数，<br>而且这里有一个工厂类mFactory2，如果我们能创建一个mFactory2对象，并设置上去，那所有的view创建就都会走到我们自己的代码，<br>则我们可以获取到所有的view</p><p>换肤：是替换所有可以替换的颜色、背景，包括背景颜色、背景图片，因为我们替换了背景颜色，所以文本颜色也是需要替换。<br>我们明确了换肤的目标，原理呢就是：<br>换肤插件module中具有的资源名与宿主app的资源名都一致，只是资源值不同，<br>如在宿主app中res/value/colors.xml中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--宿主app--&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#ffce3d3a&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;!--插件module--&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimary&quot;&gt;#1F1F1F&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#373935&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorAccent&quot;&gt;#ffffff&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#FFA500&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>如上所示，所有的资源名称都是一致，只是资源内容不同，图片也是如此。<br>当需要换肤时，通过获取宿主app的资源名称，到插件module中获取该名称的对应资源，然后替换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity一键换肤&quot;&gt;&lt;a href=&quot;#Activity一键换肤&quot; class=&quot;headerlink&quot; title=&quot;Activity一键换肤&quot;&gt;&lt;/a&gt;Activity一键换肤&lt;/h1&gt;&lt;h2 id=&quot;Activity绘制过程&quot;&gt;&lt;a href=&quot;#A
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="hexo/blog/2020/12/%E6%B3%A8%E8%A7%A3.html"/>
    <id>hexo/blog/2020/12/注解.html</id>
    <published>2020-12-03T01:13:53.000Z</published>
    <updated>2021-01-19T10:03:46.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><p>注解作用可以在源码、编译、运行时起作用，</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>新建一个 @interface<br>与java类或接口大致相同的格式要求，但使用关键字 @interface</p><p>可以在自定义注解上使用其他注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public @interface CustomAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h1&gt;&lt;p&gt;Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。&lt;br&gt;Java 语言中的类、方法、变量、
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android消息机制</title>
    <link href="hexo/blog/2020/11/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6.html"/>
    <id>hexo/blog/2020/11/android消息机制.html</id>
    <published>2020-11-24T03:09:22.000Z</published>
    <updated>2020-11-25T10:09:41.994Z</updated>
    
    <content type="html"><![CDATA[<p>在andorid中，系统的行为、用户的输入等事件都会被包装为一个消息，<br>进行消息发送、处理</p><p>关于消息的处理，就离不开Handler、Message、Loop<br>在平时使用时，Handler多用于多线程之间通信。</p><ul><li>那么Handler如何实现多线程通信？</li><li>多线程之间为何不会互相干扰？</li><li>为什么不使用用wait/notify？</li></ul><h2 id="Handler多线程通信"><a href="#Handler多线程通信" class="headerlink" title="Handler多线程通信"></a>Handler多线程通信</h2><p>先看一下普通使用案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyActiivty extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private Handler myHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">                if(msg.what=100) &#123;</span><br><span class="line">                    // TODO</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyThread extends Thread() &#123;</span><br><span class="line">        @Overtide</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            Message message = Message.obtain();</span><br><span class="line">            message.what = 100;</span><br><span class="line">            myHandler.sendMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的在子线程发送消息，回到主线程处理消息的过程，<br>通过在子线程构造一个message对象，在主线程中获取到该message对象，来处理消息。</p><p>所以其实Handler处理多线程通信是通过共享Message对象内存来实现的。<br>内存是不区分线程的，这种通信原理就是在子线程与主线程共享message内存</p><p>所以 那么Handler如何实现多线程通信？<br>通过 内存共享 实现。</p><p>在多线程时，Handler又是如何保证消息如何在正确的线程发送的呢，或者说是如何保证执行的线程是正确的了。<br>这就要引入我们的Loop、消息队列概念了。</p><p>handler处理消息模型:</p><p><img src="../../../images/looper.png" style="zoom:20%"></p><p>handler负责发送、处理消息<br>looper负责一直轮询消息<br>messageQueue消息队列，负责存放、取出消息</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>讲到looper负责一直轮询消息，但是好像在上面的代码中，都没有使用到looper。</p><p>其实是在主线程中，系统已经默认为我们创建了looper，<br>在ActivityThread.java的main方法中（ActivityThread即为主线程）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">        // Install selective syscall interception</span><br><span class="line">        AndroidOs.install();</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">        // It will be in the format &quot;seq=114&quot;</span><br><span class="line">        long startSeq = 0;</span><br><span class="line">        if (args != null) &#123;</span><br><span class="line">            for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，调用了Loop.prepareMainLooper()、Looper.loop()函数，<br>而且在Looper.loop()后面就抛出异常，<br>也就是说主线程中loop一旦停止轮询，则会抛出异常闪退。正常情况时，loop就是一直在轮询。</p><p>查看Looper的这两个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在prepareMainLooper中可以看到，不允许调用两次，否则会抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Run the message queue in this thread. Be sure to call</span><br><span class="line">    * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line">    */</span><br><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    // Allow overriding a threshold with a system prop. e.g.</span><br><span class="line">    // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos;</span><br><span class="line">    final int thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(&quot;log.looper.&quot;</span><br><span class="line">                    + Process.myUid() + &quot;.&quot;</span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + &quot;.slow&quot;, 0);</span><br><span class="line"></span><br><span class="line">    boolean slowDeliveryDetected = false;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        // Make sure the observer won&apos;t change while processing a transaction.</span><br><span class="line">        final Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">        if (thresholdOverride &gt; 0) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);</span><br><span class="line">        final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);</span><br><span class="line"></span><br><span class="line">        final boolean needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">        final boolean needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        final long dispatchEnd;</span><br><span class="line">        Object token = null;</span><br><span class="line">        if (observer != null) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSlowDelivery) &#123;</span><br><span class="line">            if (slowDeliveryDetected) &#123;</span><br><span class="line">                if ((dispatchStart - msg.when) &lt;= 10) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Drained&quot;);</span><br><span class="line">                    slowDeliveryDetected = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    // Once we write a slow delivery log, suppress until the queue drains.</span><br><span class="line">                    slowDeliveryDetected = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop函数中，首先获取通过myLooper()函数获取looper对象，如果looper对象为空，则抛出异常，提示必须在当前线程先执行Looper.prepare()<br>然后获取looper对象持有的messageQueue，<br>然后就是for(;;)无限循环，获取messageQueue下一条消息<br>获取到message后调用msg.target.dispatchMessage(msg);<br>将这条消息发送出去。<br>最后执行msg.recycleUnchecked()，相当于一个回收利用。</p><p>我们看一下myLooper函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说明looper是存放在ThreadLocal中的。<br>关于ThreadLocal，在之前已经大致讲过了。<br>ThreadLocal讲解（<a href="https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）" target="_blank" rel="noopener">https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）</a><br>在每一个线程，都存在一个对应且唯一的值</p><p>我们可以看一下prepare函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到与prepareMainLooper的不同，因为prepareMainLooper是在主线程调用，而主线程很自由一个，<br>所以直接使用sMainLooper来保存主线程的looper，而且主线程中prepare(false)；标示不允许looper退出。</p><p>而在子线程时，就是将looper对象保存到sThreadLocal中，sThreadLocal.get()不为null时，会抛出异常。<br>也就是说子线程中prepare只允许调用一次，保证了每个线程中的looper对象唯一性</p><p>然后看到子线程和主线程的另一个差异prepare(false) &amp;&amp; prepare(true)<br>因为andorid，所有事件如：用户的操作、ui的渲染等都是作为消息发送的，而这些都是在主线程操作的，所以在主线程中是不允许退出loop循环，否则抛出异常。</p><p>而在子线程中prepare(true)，允许退出，其实在子线程中新建handler、looper时，当我们不需要再使用，需要终止loop循环。<br>此时需要调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>在上面中已经讲过Looper，looper中持有一个messageQueue<br>final MessageQueue queue = me.mQueue;<br>mQueue 在Looper的私有构造函数中被初始化</p><p>接下来我们看一下MessageQueue<br>队列是一种数据结果，FIFO先进先出<br>MessageQueue 是一个消息队列，默认也是先进先出，有序执行</p><p>之前说了，MessageQueue主要用于存放、取出消息。<br>在Looper中主要用到了messagequeue的next函数，用于取出下一条消息</p><p>我们先看一下存放消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    if (msg.target == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (msg.isInUse()) &#123;</span><br><span class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = new IllegalStateException(</span><br><span class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">            // New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">            // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">            // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; // invariant: p == prev.next</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程已经退出，mQuitting为true，则抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msg.when = when;</span><br><span class="line">Message p = mMessages;</span><br><span class="line">boolean needWake;</span><br><span class="line">if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">    // New head, wake up the event queue if blocked.</span><br><span class="line">    msg.next = p;</span><br><span class="line">    mMessages = msg;</span><br><span class="line">    needWake = mBlocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当全局变量mMessages为空，或者当前传入的when为0， 或者当前when小于全局变量mMessages.when(即时间在前)<br>其实判断的是两种状态，1:messageQueue队列为空 2:添加的消息执行时间在前<br>此时将该消息置于队首，<br>needWake = mBlocked；<br>如果mBlocked为true，needWake也为true，就是如果之前阻塞则唤醒，反之无需唤醒</p><p>再看不满足上面情况下时,即消息队列中已添加过消息，而且要添加的消息.when在上一次添加的消息之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">    // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">    // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">    needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">    Message prev;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        if (p == null || when &lt; p.when) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">            needWake = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.next = p; // invariant: p == prev.next</span><br><span class="line">    prev.next = msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for循环，遍历链表，当找到节点为null即遍历完 || 传入的when小于遍历节点的when（即传入消息的时间在遍历节点时间之前时）<br>终止循环，将msg.next -&gt; p<br>原来<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; p -&gt; …<br>现在<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; msg.next -&gt; p -&gt; …</p><p>也就是说，message链表是按照when排序的，when越小，在越靠近链头<br>为何要根据when排序了，其实是因为message执行时间是要按时间排序，要执行时间越小，代表时间越早，所以放在链头</p><p>以上是消息队列，入队函数，再看一下出队函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">Message next() &#123;</span><br><span class="line">    // Return here if the message loop has already quit and been disposed.</span><br><span class="line">    // This can happen if the application tries to restart a looper after quit</span><br><span class="line">    // which is not supported.</span><br><span class="line">    final long ptr = mPtr;</span><br><span class="line">    if (ptr == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Got a message.</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // No more messages.</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process the quit message now that all pending messages have been handled.</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If first time idle, then get the number of idlers to run.</span><br><span class="line">            // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">            // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                mBlocked = true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Run the idle handlers.</span><br><span class="line">        // We only ever reach this code block during the first iteration.</span><br><span class="line">        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">            boolean keep = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">        pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">        // While calling an idle handler, a new message could have been delivered</span><br><span class="line">        // so go back and look again for a pending message without waiting.</span><br><span class="line">        nextPollTimeoutMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一段代码可以先不看，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">    do &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一块设计到消息的同步屏障，放到下面再将，我们先只看出队时的逻辑<br>next函数就是取出下一条消息。<br>开启for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">    Binder.flushPendingCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果nextPollTimeoutMillis不等于0时，会阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final long now = SystemClock.uptimeMillis();</span><br><span class="line">Message prevMsg = null;</span><br><span class="line">Message msg = mMessages;</span><br><span class="line">if (msg != null) &#123;</span><br><span class="line">    if (now &lt; msg.when) &#123;</span><br><span class="line">        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Got a message.</span><br><span class="line">        mBlocked = false;</span><br><span class="line">        if (prevMsg != null) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = null;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // No more messages.</span><br><span class="line">    nextPollTimeoutMillis = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当当前message不为空时：<br>如果当前时间小于msg.when，即没到执行时间，则阻塞线程到msg.when时间<br>将msg.next赋值给全局变量mMessages，再将msg.next指向null<br>然后返回msg这一个节点，如此不会返回一个链表</p><p>如果msg为空，说明队列为空，没有消息，此时赋值nextPollTimeoutMillis = -1;下一次循环时，就会阻塞。</p><ul><li>MessageQueue 添加消息、取出消息是线程安全的吗？<br>是，是线程安全的。</li><li><p>如何保证线程安全的？<br>通过锁，存放消息以及取出消息时都有设置synchronized (this)，<br>synchronized 后面修饰的是this，同一个对象在多线程环境调用函数时，只会有一个线程获取到锁，进行操作。<br>synchronized 是内置锁，JVM已经内置处理了锁的获取以及释放</p></li><li><p>为什么不使用用wait/notify？<br>在上述代码可以看到使用了阻塞、锁，阻塞是直接调用native 函数来阻塞，<br>其实在内部已经使用了wait/notif。</p></li></ul><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>上面讲了消息机制中的Handler、Looper、MessageQueue；<br>现在我们再讲一下消息的本体Message</p><p>首先通过我们在上面的分析，可以知道Message在数据结构上看，是一个链表，而且是只有next指针，所以是个单链表。<br>Message中没有什么复杂操作，都是一些赋值函数<br>有两个地址可以注意下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123;</span><br><span class="line">        if (gCheckRecycle) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</span><br><span class="line">                    + &quot;is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    // Mark the message as in use while it remains in the recycled object pool.</span><br><span class="line">    // Clear out all other details.</span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = 0;</span><br><span class="line">    arg1 = 0;</span><br><span class="line">    arg2 = 0;</span><br><span class="line">    obj = null;</span><br><span class="line">    replyTo = null;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = 0;</span><br><span class="line">    target = null;</span><br><span class="line">    callback = null;</span><br><span class="line">    data = null;</span><br><span class="line"></span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = this;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Message的回收函数不是将对象置为空，而是将Message中的变量都还原为默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool != null) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = null;</span><br><span class="line">            m.flags = 0; // clear in-use flag</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message还提供obtain函数，不会直接new 一个Message对象，而是共享之前的对象，改变对象的内部属性。</p><p>所以我们在实际使用中都是使用Message.obtain()来构建message对象，而不是一直使用new ，这样可以避免频繁的生成、回收，避免内存抖动。</p><p>这种设计被成为 <em> 享元设计模式 </em></p><h2 id="Message-同步屏障"><a href="#Message-同步屏障" class="headerlink" title="Message 同步屏障"></a>Message 同步屏障</h2><p>上面讲的消息message链表是根据when时间排序，那如果有紧急的消息必须马上处理呢，这个时候不可能等其他先执行而必须是马上执行的事件时，怎么办？</p><p>这个时候就可以用到 同步屏障</p><p>handler消息机制大概流程：<br>生成Looper对象，生成Handler对象，Lopper.looper循环<br>在Handler构造函数内，获取到上面生成的looper对象，通过ThreadLocal保存到对应的线程，与MessageQueue绑定<br>在需要发送消息的地方调用handler.sendMessage(),在sendMessage时，将message与handler绑定，将message.target赋值为当前handler<br>同时，sendMessage时，调用messageQueue.enqueueMessage将message放入消息队列。<br>同时，Looper.loop()在循环一直取出消息message，然后通过message.target获取到handler对象，最终回调到handler.handlerMessage函数。</p><p>这样消息从产生到处理流程就走完了。</p><p>总结提问：</p><ul><li>Looper.loop()一直在循环，为什么不会导致应用卡死(ANR)?</li></ul><p>答：loop()循环与ANR是两个不相关的事情，loop只是循环事件，ANR是处理事件耗时，导致无法响应用户的下一次输入。<br>系统的ANR弹窗都是通过消息机制发送，并弹出提示窗的。</p><ul><li>fragment生命周期</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在andorid中，系统的行为、用户的输入等事件都会被包装为一个消息，&lt;br&gt;进行消息发送、处理&lt;/p&gt;
&lt;p&gt;关于消息的处理，就离不开Handler、Message、Loop&lt;br&gt;在平时使用时，Handler多用于多线程之间通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那么Hand
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>APT注解处理器</title>
    <link href="hexo/blog/2020/11/APT%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8.html"/>
    <id>hexo/blog/2020/11/APT注解处理器.html</id>
    <published>2020-11-16T03:04:49.000Z</published>
    <updated>2020-11-16T10:01:32.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h1><p>APT(Annotation Processing Tool) 是一种处理注释的工具，它对源代码文件进行检测找出<br>其中的Annotation，根据注解自动生成代码，如果想要自定义的注解处理器能够正常运行，必须要通过<br>APT工具来进行处理。 也可以这样理解，只有通过声明APT工具后，程序在编译期间自定义注解解释器<br>才能执行。 通俗理解：根据规则，帮我们生成代码、生成类文件</p><p>在使用APT在项目编译时期动态生成我们需要的java文件时，有两种方式，<br>传统方式、javapoet</p><p>项目源码(<a href="https://github.com/wangchongwei/apt" target="_blank" rel="noopener">https://github.com/wangchongwei/apt</a>)</p><h2 id="javapoet"><a href="#javapoet" class="headerlink" title="javapoet"></a>javapoet</h2><p>以面向对象(OOP)思维，在编译时，动态生成java文件</p><p>优点：OOP思维，不需要导包<br>缺点：倒序写法，从函数-&gt;类-&gt;包</p><p>这种方式和写作思维不同，从调用链尾部到头部。<br>开源组件butterknife、ARouter都是使用javapoet方式</p><p>example:</p><p>新建一个工程，<br>并在工程新建一个javaLib，在此工程新建一个注解类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE) // 表明注解是添加在类上</span><br><span class="line">@Retention(RetentionPolicy.CLASS) // 表明在编译器执行</span><br><span class="line">public @interface ARouter &#123;</span><br><span class="line"></span><br><span class="line">    String path(); // 声明注解时 必须参数</span><br><span class="line"></span><br><span class="line">    String group() default &quot;&quot;; // 因为已经设置了default值，所以这个是选填参数</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时我们就完成了一个注解的定义<br>然后再新建一个javaLib，在此工程新建一个处理注解的类，而这个类就是我们在编译时生成java类的主要代码部分<br>在此工程build.gradle中添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // 背后的服务 能够监听 你是否在编译中.....</span><br><span class="line">    // AS3.4.1 + Gradle 5.1.1 + auto-service:1.0-rc4</span><br><span class="line">    compileOnly&apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br><span class="line">    annotationProcessor&apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br><span class="line"></span><br><span class="line">    // 帮助我们通过类调用的形式来生成Java代码 [JavaPoet]</span><br><span class="line">    implementation &quot;com.squareup:javapoet:1.9.0&quot;</span><br><span class="line"></span><br><span class="line">    // 依赖注解module</span><br><span class="line">    implementation project(&quot;:annotations&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们开始写监听到注解时需要生成java类的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class) // 启用服务 google 自动服务，一直监控</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;com.justin.annotationprocessor.ARouter&quot;&#125;) // 注解 包名.类名</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_8) // 环境的版本</span><br><span class="line"></span><br><span class="line">@SupportedOptions(&quot;student&quot;) // 接收在app/build.gradle中声明的参数</span><br><span class="line">public class ARouterProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Elements elements;</span><br><span class="line"></span><br><span class="line">    private Messager messager;</span><br><span class="line"></span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    private Types typeTool;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">        elements = processingEnvironment.getElementUtils();</span><br><span class="line">        messager = processingEnvironment.getMessager();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">        typeTool = processingEnvironment.getTypeUtils();</span><br><span class="line"></span><br><span class="line">        // 获取在app/build.gradle中申明的参数</span><br><span class="line">        String value = processingEnvironment.getOptions().get(&quot;student&quot;);</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, &quot;=========&gt;&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        // 此时会运行两次，一次执行，一次检查</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; compiler is running&quot;);</span><br><span class="line"></span><br><span class="line">        if(set.isEmpty()) &#123;</span><br><span class="line">            // 使用注解的类集合为空</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取被 ARouter注解的 &quot;类节点信息&quot;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class);</span><br><span class="line">        for(Element element : elements) &#123;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">                举例我们需要生成这样一个类</span><br><span class="line">             package com.example.helloworld;</span><br><span class="line"></span><br><span class="line">             public final class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">             public static void main(String[] args) &#123;</span><br><span class="line">             System.out.println(&quot;Hello, JavaPoet!&quot;);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             public int add(int a, int b)&#123;</span><br><span class="line">                return 5;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line">            // javapoet生成java文件的方式时，OOP思维，先生成函数，再生成类，最后生成包</span><br><span class="line">            // 1 生成函数</span><br><span class="line">            MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;main&quot;) // 构造一个函数， 函数名</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC) // public 、static</span><br><span class="line">                    .returns(void.class) // 返回值类型</span><br><span class="line">                    .addParameter(String[].class, &quot;args&quot;) // 入参类型</span><br><span class="line">                    .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)// 函数执行语句 不需要添加分号</span><br><span class="line">                    .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, agent!&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 多个函数</span><br><span class="line">            MethodSpec methodSpec1 = MethodSpec.methodBuilder(&quot;add&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                    .returns(int.class)</span><br><span class="line">                    .addParameter(int.class, &quot;a&quot;)</span><br><span class="line">                    .addParameter(int.class, &quot;b&quot;) // 可以添加多个入参</span><br><span class="line">                    .addStatement(&quot;return 5&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 2 生成类</span><br><span class="line">            TypeSpec myClass = TypeSpec.classBuilder(&quot;HelloWorld&quot;) // 构造一个类，类名</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL) // 添加申明 public、final</span><br><span class="line">                    .addMethod(methodSpec) // 绑定函数</span><br><span class="line">                    .addMethod(methodSpec1) // 绑定多个函数</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 3、生成包</span><br><span class="line">            JavaFile myPackage = JavaFile.builder(&quot;com.example.helloworld&quot;, myClass).build();</span><br><span class="line">            try &#123;</span><br><span class="line">                myPackage.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; 创建HelloWorld类失败,异常原因：&quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后使用@ARouter注解<br>在MainActivity中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ARouter(path = &quot;main/MainActivity&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击build项目，即会在app/build/ap_generated_sources/debug下生成对应的包以及java文件</p><p><img src="../../../images/javapoet.jpg" style="zoom:20%"></p><p>在上述方式中，我们只是写成了一个固定的java文件，还没有体现动态生成概念。<br>下面我们就要改造，动态接收参数来生成代码<br>只显示动态生成代码部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 获取被 ARouter注解的 &quot;类节点信息&quot;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class);</span><br><span class="line">        for(Element element : elements) &#123;</span><br><span class="line">            // 动态生成java代码</span><br><span class="line">            // 获取组件class的包路径</span><br><span class="line">            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();</span><br><span class="line">            // 获取注解的类名</span><br><span class="line">            String className = element.getSimpleName().toString();</span><br><span class="line">            // 获取到注解以及注解时的参数</span><br><span class="line">            ARouter aRouter = element.getAnnotation(ARouter.class);</span><br><span class="line">            String path = aRouter.path();</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             模板：</span><br><span class="line">             public class MainActivity3$$$$$$$$$ARouter &#123;</span><br><span class="line">             public static Class findTargetClass(String path) &#123;</span><br><span class="line">             return path.equals(&quot;/app/MainActivity3&quot;) ? MainActivity3.class : null;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             */</span><br><span class="line">            // 1、方法</span><br><span class="line">            MethodSpec method = MethodSpec.methodBuilder(&quot;findTargetClass&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                    .returns(Class.class)</span><br><span class="line">                    .addParameter(String.class, &quot;path&quot;)</span><br><span class="line">                    .addStatement(&quot;return path.equals($S) ? $T.class : null&quot;,</span><br><span class="line">                            path,</span><br><span class="line">                            ClassName.get((TypeElement) element) // 获取注解类的class对象</span><br><span class="line">                    )</span><br><span class="line">                    .build();</span><br><span class="line">            // 2 类</span><br><span class="line">            TypeSpec mineClass = TypeSpec.classBuilder(className + &quot;$$$$$$$$$ARouter&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                    .addMethod(method)</span><br><span class="line">                    .build();</span><br><span class="line">            // 3 包</span><br><span class="line">            JavaFile minePackage = JavaFile</span><br><span class="line">                    .builder(packageName, mineClass)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                minePackage.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + className + &quot;类失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此时我们就完成了自动获取注解类的包名、类名、注解时的path<br>自动生成的类也在相同包名下，获取注解时的path，可以做一些操作</p><h2 id="传统方式生成java文件"><a href="#传统方式生成java文件" class="headerlink" title="传统方式生成java文件"></a>传统方式生成java文件</h2><p>在编译时，一行一行，从头到尾，以写文本的方式写一个java文件</p><p>优点：套版格式，思路清晰<br>缺点：所有代码都需要写，包括导包，如果有任一一个字符错误、分号缺失，都会导致报错。</p><p>这种方式需要及其细心<br>开源组建EventBus就是采用的这种方式</p><p>example：<br>首先自定义注解类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(TYPE) </span><br><span class="line">@Retention(CLASS) // 编译期    XUtil==运行期</span><br><span class="line">public @interface Binding &#123;</span><br><span class="line"></span><br><span class="line">    String router();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后写注解处理类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7) // 环境的版本</span><br><span class="line">@AutoService(Processor.class) // 启用服务</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;com.derry.arouter_annotations.Binding&quot;&#125;) // 注解</span><br><span class="line">public class BindingProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Elements elementTool;</span><br><span class="line">    private Messager messager;</span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">        elementTool = processingEnvironment.getElementUtils();</span><br><span class="line">        messager = processingEnvironment.getMessager();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line"></span><br><span class="line">        if(set.isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Binding.class);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line"></span><br><span class="line">            // 获取包名</span><br><span class="line">            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();</span><br><span class="line">            String className = element.getSimpleName().toString();</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.NOTE, &quot;被@ARetuer注解的类有：&quot; + className);</span><br><span class="line">            String findClassName = className + &quot;$$$$$$$Binding&quot;;</span><br><span class="line"></span><br><span class="line">            Binding binding = element.getAnnotation(Binding.class);</span><br><span class="line">            try &#123;</span><br><span class="line">                JavaFileObject javaFileObject = filer.createSourceFile(packageName + &apos;.&apos; + findClassName, element.getEnclosingElement());</span><br><span class="line">                Writer writer = javaFileObject.openWriter();</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                sb.append(&quot;package &quot;).append(packageName).append(&quot;;\n\n&quot;);</span><br><span class="line">                sb.append(&quot;public class &quot;).append(findClassName).append(&quot;&#123;\n&quot;);</span><br><span class="line">                sb.append(&quot;public String findTargetRouter()&#123;\n&quot;);</span><br><span class="line">//                sb.append(&quot;return &quot; + binding.router().toString()).append(&quot;;\n&quot;);</span><br><span class="line">                sb.append(&quot;return \&quot;test\&quot;;\n&quot;);</span><br><span class="line">                sb.append(&quot;&#125;\n&quot;);</span><br><span class="line">                sb.append(&quot;&#125;\n&quot;);</span><br><span class="line">                writer.write(sb.toString());</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + findClassName + &quot;类失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;APT&quot;&gt;&lt;a href=&quot;#APT&quot; class=&quot;headerlink&quot; title=&quot;APT&quot;&gt;&lt;/a&gt;APT&lt;/h1&gt;&lt;p&gt;APT(Annotation Processing Tool) 是一种处理注释的工具，它对源代码文件进行检测找出&lt;br&gt;其中的Ann
      
    
    </summary>
    
    
      <category term="andorid" scheme="hexo/tags/andorid/"/>
    
  </entry>
  
  <entry>
    <title>android 性能优化</title>
    <link href="hexo/blog/2020/11/android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"/>
    <id>hexo/blog/2020/11/android-性能优化.html</id>
    <published>2020-11-04T05:56:47.000Z</published>
    <updated>2020-11-06T10:13:20.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android性能优化"><a href="#android性能优化" class="headerlink" title="android性能优化"></a>android性能优化</h1><p>性能优化分为几个方向：</p><ul><li>内存优化</li><li>电量优化</li><li>渲染优化</li><li>size大小优化</li><li>异常捕获</li></ul><h2 id="apk瘦身"><a href="#apk瘦身" class="headerlink" title="apk瘦身"></a>apk瘦身</h2><p>针对与apk大小优化而言，<br>首先需要知道apk中主要结构，了解其中是哪些部分比较大。<br>然后来针对性优化。</p><p>一般而言比较占用的是：资源文件、架构文件(.so)</p><h3 id="资源文件优化"><a href="#资源文件优化" class="headerlink" title="资源文件优化"></a>资源文件优化</h3><p>针对资源文件，首先我们去除没有被使用的资源，然后就是降低所用资源的大小。</p><p>在app/build.gradle文件中设置shrinkResources true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">        shrinkResources true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>则会在Gradle打包release apk时，自动忽略未使用的资源文件，包括：图片、xml</p><p>但要注意此时也会忽略隐式调用的资源文件，如通过反射调用，或者react-native中在js调用drawable木土图片，<br>在这两种场景时，都会被忽略。<br>针对这种场景，可以通过keep文件，保持这些资源文件不会被忽略。</p><p>在res目录下新建xml目录，在xml目录下新建文件keep.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources</span><br><span class="line">xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">tools:keep=&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;</span><br><span class="line">tools:discard=&quot;@layout/unused2&quot; /&gt;</span><br></pre></td></tr></table></figure><p>其中tools:keep是强制不忽略，tools:discard是强制忽略</p><p>上面讲述的是去除无用资源，还有我们可以去除无用的代码，如未被调用的函数，未被使用的变量</p><p>minifyEnabled设置为true，设置在与shrinkResources一起的地方。<br>注意shrinkResources需要与minifyEnabled一起使用才会生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">        shrinkResources true</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="针对架构-so优化"><a href="#针对架构-so优化" class="headerlink" title="针对架构.so优化"></a>针对架构.so优化</h3><p>在大型项目，特别时继承第三方过多时，此时.so文件才是占用最多的部分。</p><h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>开发时怕的不是出现问题，而是问题无法重现。<br>因为android碎片化严重 生产上的问题肯定要比开发时问题多。而且很多都是在开发端未必能重现的。<br>此时需要我们记录发生在用户手机上的异常。</p><p>针对异常可以分类，java异常、native异常。<br>native异常即是native函数c++代码异常</p><h3 id="java异常捕获"><a href="#java异常捕获" class="headerlink" title="java异常捕获"></a>java异常捕获</h3><p>在andorid app中捕获java异常，只需要实现Thread.UncaughtExceptionHandler</p><h3 id="native异常"><a href="#native异常" class="headerlink" title="native异常"></a>native异常</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android性能优化&quot;&gt;&lt;a href=&quot;#android性能优化&quot; class=&quot;headerlink&quot; title=&quot;android性能优化&quot;&gt;&lt;/a&gt;android性能优化&lt;/h1&gt;&lt;p&gt;性能优化分为几个方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存优化&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>线程与进程</title>
    <link href="hexo/blog/2020/10/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.html"/>
    <id>hexo/blog/2020/10/线程与进程.html</id>
    <published>2020-10-29T02:35:27.000Z</published>
    <updated>2021-01-20T01:27:03.156Z</updated>
    
    <content type="html"><![CDATA[<p>进程是操作系统资源分配的基本单位，</p><p>线程是处理器（CPU）任务调度和执行的基本单位<br>线程依赖于进程，一个进程可能对应多个线程。</p><p>并发与并行</p><p>1、并发（Concurrent）：指两个或多个事件在同一时间间隔内发生，即交替做不同事的能力，多线程是并发的一种形式。例如垃圾回收时，用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p><p>2、并行（Parallel）：指两个或者多个事件在同一时刻发生，即同时做不同事的能力。例如垃圾回收时，多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>同时能处理的最大线程数取决于CPU内核数量，<br>有些机器还有逻辑处理器，</p><p>能同时处理任务的线程最大数量为CPU内核与逻辑处理器的较大值。</p><p>如内核：4，逻辑处理器：8<br>那么CPU正在能同时处理的任务数量为8。</p><p>但为何我们写代码的时候，设置多线程运行时为何感觉可以同时设置很多个线程数量呢。</p><p>这个就跟CPU的时间轮转片调度算法有关了</p><p>在早期的时间片轮转法中,系统将所有的就绪进程按先来先服务的原则,排成一个队列,每次调度时,把CPU分配给队首进程,并令其执行一个时间片.时间片的大小从几ms到几百ms.当执行的时间片用完时,由一个计时器发出时钟中断请求,调度程序便据此信号来停止该进程的执行,并将它送往就绪队列的末尾;然后,再把处理机分配给就绪队列中新的队首进程,同时也让它执行一个时间片.这样就可以保证就绪队列中的所有进程,在一给定的时间内,均能获得一时间片的处理机执行时间.</p><p>所以我们在多线程运行时，超过内核数量的线程任务在执行时，其实是在切换运行的。<br>只是因为CPU的时间片粒度很小，所以在切换时，很多都是无感的</p><h2 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h2><p>java中的程序天生的多线程的，启动线程有两种方式。</p><ul><li><p>继承Thread类</p></li><li><p>实现Runnable接口 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args) &#123;</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        MyThread2 thread2 = new MyThread2();</span><br><span class="line">        new Thread(thread2).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            System.out.println(&quot;extends Thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class MyThread2 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;implements Runnable&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><p>线程启动了，如何终止呢？<br>Thread类中提供了stop、suspend、resume等函数，但都是已经遗弃的，不提倡使用，<br>在API29时，调用内部就是直接抛出异常UnsupportedOperationException。</p><p>为何遗弃，因为suspend函数，只会终止当前线程，而不会释放线程已经占有的资源(比如锁)，而是占有资源进入睡眠状态，这样容易引发死锁问题。<br>而stop函数也是同理，在终止线程时，不会保证线程资源能够正常释放<br>所以这些函数都已经被遗弃，不提倡使用。</p><p>正确的中断线程的方法，是调用Thread中的interrupt().<br>interrupt()函数不会强制中断线程，而只是改变了一个线程的标志位，线程通过检测自身的标志位是否被置为true来判断是否需要继续执行。</p><p>可以调用isInterrupted()来获取该标志位，判断线程任务是否应该中断，<br>还可以调用Thread中的静态函数interrupted()来判断，但是interrupted()函数调用时，会将标志位重新置于false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            while (!currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(&quot;线程正常运行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">//            while (!Thread.interrupted()) &#123;</span><br><span class="line">//                System.out.println(&quot;线程正常运行&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">            System.out.println(&quot;线程已经被终止   flag ---&quot; + currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果可以看得出isInterrupted()与interrupted()的区别。</p><h2 id="run-start"><a href="#run-start" class="headerlink" title="run() start()"></a>run() start()</h2><p>我们new一个Thread实例对象，只是创建了一个对象，并没有与操作系统的真正的线程挂钩，<br>只有在执行start函数时，才是真正启动了一个线程，执行了其中的run方法</p><p>start()的调用，让线程进入就绪队列等待分配cpu，分到cpu后执行run()方法，start方法不能重复调用，否则抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">         * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">         * to this method in the future may have to also be added to the VM.</span><br><span class="line">         *</span><br><span class="line">         * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">         */</span><br><span class="line">        // Android-changed: Replace unused threadStatus field with started field.</span><br><span class="line">        // The threadStatus field is unused on Android.</span><br><span class="line">        if (started)</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        /* Notify the group that this thread is about to be started</span><br><span class="line">         * so that it can be added to the group&apos;s list of threads</span><br><span class="line">         * and the group&apos;s unstarted count can be decremented. */</span><br><span class="line">        group.add(this);</span><br><span class="line"></span><br><span class="line">        // Android-changed: Use field instead of local variable.</span><br><span class="line">        // It is necessary to remember the state of this across calls to this method so that it</span><br><span class="line">        // can throw an IllegalThreadStateException if this method is called on an already</span><br><span class="line">        // started thread.</span><br><span class="line">        started = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Android-changed: Use Android specific nativeCreate() method to create/start thread.</span><br><span class="line">            // start0();</span><br><span class="line">            nativeCreate(this, stackSize, daemon);</span><br><span class="line">            started = true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                /* do nothing. If start0 threw a Throwable then</span><br><span class="line">                  it will be passed up the call stack */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要逻辑在这个native函数中nativeCreate()</p><h2 id="Thread中其他函数"><a href="#Thread中其他函数" class="headerlink" title="Thread中其他函数"></a>Thread中其他函数</h2><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield(): 使当前让出cpu占有权，但让出时间不可限定，也不会让出锁资源，而且执行yield()的线程也不一定持有锁，我们可以在释放锁后执行这个方法。<br>执行yield()后让出cpu，但也可能在下一个时间片重新获取cpu。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join() ：将指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行，比如在线程B中执行了A线程的join函数，<br>直到A线程执行完毕，才会执行B线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread a = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                System.out.println(&quot;这是a线程在执行&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                    System.out.println(&quot;这是a线程在休眠结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread b = new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                try &#123;</span><br><span class="line">                    a.join();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;这是b线程在执行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>锁，内置锁，具体详情可以查看：</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>只保证可见性，不能保证原子性</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>在每个线程存在副本，各个线程数据互不干扰。<br>具体详情可以查看：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程是操作系统资源分配的基本单位，&lt;/p&gt;
&lt;p&gt;线程是处理器（CPU）任务调度和执行的基本单位&lt;br&gt;线程依赖于进程，一个进程可能对应多个线程。&lt;/p&gt;
&lt;p&gt;并发与并行&lt;/p&gt;
&lt;p&gt;1、并发（Concurrent）：指两个或多个事件在同一时间间隔内发生，即交替做不同事
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android 8.0屏幕朝向</title>
    <link href="hexo/blog/2020/10/android-8-0%E5%B1%8F%E5%B9%95%E6%9C%9D%E5%90%91.html"/>
    <id>hexo/blog/2020/10/android-8-0屏幕朝向.html</id>
    <published>2020-10-28T07:08:43.000Z</published>
    <updated>2020-10-28T08:38:44.140Z</updated>
    
    <content type="html"><![CDATA[<p>在android8.0设备发现一个问题，在androidManifest.xml中已配置了固定的屏幕方向，<br>但是在应用中，点击设备menu键，选择应用时，此时应用仍然可以旋转。</p><p>在MainActivity中通过代码设置 setRequestedOrientation时会报错：Only fullscreen activities can request orientation</p><p>原因是在android8.0 的Activity.java 的代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line"></span><br><span class="line">       if (getApplicationInfo().targetSdkVersion &gt;= O &amp;&amp; mActivityInfo.isFixedOrientation()) &#123;</span><br><span class="line">           final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window);</span><br><span class="line">           final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta);</span><br><span class="line">           ta.recycle();</span><br><span class="line"></span><br><span class="line">           if (isTranslucentOrFloating) &#123;</span><br><span class="line">               throw new IllegalStateException(</span><br><span class="line">                       &quot;Only fullscreen opaque activities can request orientation&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果sdk版本&gt;O &amp;&amp; 当前Activity的屏幕方向固定时，<br>判断当前主题样式，如果包含透明样式，则会抛出该异常。</p><p>很明显这段代码存在问题，sdk&gt;=O其实就是android8.0(26)及以上。<br>而后面两个要求，固定屏幕方向在特定应用时很常见的，而透明样式页比较常见，<br>我们常用透明背景做一个简单的启动优化，避免其他样式导致的闪屏现象。</p><p>而这段代码也在8.0之后的版本修复，但是现在市面存在的手机在andorid8.0的时候基本都存在该问题。</p><p>修复方式时只能去除透明背景，但为了修复26存在的问题，修改应用整个的表现有些得不偿失。</p><p>所以我们可以针对特定版本修改资源。</p><p>首先去掉AndroidManifest.xml中的 android:screenOrientation 配置，</p><p>在res新增values-v26文件夹，这样在sdk26的手机就会在这个文件夹下寻找对应的资源，如果没有才会有主目录values中去找。</p><p>在values-v26中修改styles.xml，去掉此处的透明背景。</p><p>再在代码中调用setRequestedOrientation来固定屏幕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line"></span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时则不会再报错，<br>也不存在之前所说的点击menu键，回到应用会旋转问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在android8.0设备发现一个问题，在androidManifest.xml中已配置了固定的屏幕方向，&lt;br&gt;但是在应用中，点击设备menu键，选择应用时，此时应用仍然可以旋转。&lt;/p&gt;
&lt;p&gt;在MainActivity中通过代码设置 setRequestedOrien
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android内存优化</title>
    <link href="hexo/blog/2020/10/android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html"/>
    <id>hexo/blog/2020/10/android内存优化.html</id>
    <published>2020-10-21T02:08:26.000Z</published>
    <updated>2020-10-21T06:57:09.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><p>内存检测工具 MAT<br>android studio profile</p><p>内存抖动<br>内存泄漏<br>内存溢出</p><p>JMM 内存结果模型</p><p>GC算法</p><p>对象的生命周期：内存分配初始化、不可见、不可达、收集、终结、内存重新分配</p><p>四种引用类型</p><p>incomegoing: 持有该对象的对象<br>outgoing: 该对象持有的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    C c = new C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    C c = new C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">    public C() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    C instance = new C()</span><br><span class="line">    public C getInstance() &#123;</span><br><span class="line">        return c</span><br><span class="line">    &#125;</span><br><span class="line">    D d = new D()</span><br><span class="line">    E e = new E()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 的incomegoing为 A、B、C<br>C 的outgoing为 C、D、E</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存优化&quot;&gt;&lt;a href=&quot;#内存优化&quot; class=&quot;headerlink&quot; title=&quot;内存优化&quot;&gt;&lt;/a&gt;内存优化&lt;/h1&gt;&lt;p&gt;内存检测工具 MAT&lt;br&gt;android studio profile&lt;/p&gt;
&lt;p&gt;内存抖动&lt;br&gt;内存泄漏&lt;br&gt;内存
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ContentProvider</title>
    <link href="hexo/blog/2020/10/ContentProvider.html"/>
    <id>hexo/blog/2020/10/ContentProvider.html</id>
    <published>2020-10-16T01:44:40.000Z</published>
    <updated>2020-10-16T01:51:56.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>ContentProvider 内容提供者 是android四大组件之一，为不同应用、进程之间数据共享，制定统一的接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ContentProvider&quot;&gt;&lt;a href=&quot;#ContentProvider&quot; class=&quot;headerlink&quot; title=&quot;ContentProvider&quot;&gt;&lt;/a&gt;ContentProvider&lt;/h1&gt;&lt;p&gt;ContentProvider 内容
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Service、IntentService</title>
    <link href="hexo/blog/2020/10/Service%E3%80%81IntentService.html"/>
    <id>hexo/blog/2020/10/Service、IntentService.html</id>
    <published>2020-10-09T07:06:04.000Z</published>
    <updated>2020-10-15T09:34:09.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service、IntentService"><a href="#Service、IntentService" class="headerlink" title="Service、IntentService"></a>Service、IntentService</h1><p>Service是android中四大组件之一，用于处理后台任务，不能处理耗时任务，否则会造成ANR<br>而IntentService继承自Service，但是可以处理耗时任务，因为在内部开启了一个子线程。</p><h2 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h2><p>Service的生命周期分为两种情形，一种是通过startService启动，另一种是通过bindService启动。<br>在这两种情况下时，Service的生命周期是有差异的。</p><h3 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h3><p>通过startService去启动一个Service，<br>如果该Service未被创建，则会走onCreate、onStartCommand、onStart生命周期<br>如果该Service已被创建，则不会执行onCreate，只会执行onStartCommand、onStart</p><p>onStart为正常运行时的生命周期</p><p>而且startService可以被多次调用<br>被重复调用后会执行下面的生命周期</p><p>通过startService启动的Service存活不依赖与Activity，即使启动该Service的Activity已经被销毁，但该Service仍然可以存活。<br>通过startService启动的Service需要调用stopService来销毁该Service,此时会执行onDestroy周期函数</p><h3 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h3><p>bindService时，Service是依赖Activity的，当当前Activity被销毁、或者调用unBindService时，Service都会被销毁。</p><p>所以每一次调用bindService时，Service都会被重新创建<br>所以通过bindService去启动一个Service，<br>会走onCreate、onBind生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ServiceConnect() : ServiceConnection &#123;</span><br><span class="line">    override fun onServiceDisconnected(name: ComponentName?) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onServiceDisconnected: &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onServiceConnected(name: ComponentName?, service: IBinder?) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onServiceConnected: &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn_bindService.setOnClickListener &#123;</span><br><span class="line">    var conn = ServiceConnect()</span><br><span class="line">    bindService(Intent(this, MyService::class.java), conn, Context.BIND_AUTO_CREATE)</span><br><span class="line">    hasBind = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行到onBind时，还会执行onServiceConnected</p><p>在Service中，不能执行耗时操作，超过5秒，则会造成程序不响应ANR<br>当我们需要执行耗时操作时，则必须开启子线程，或者使用IntentService</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService有与Service一样的生命周期，<br>只是在内部开启了一个子线程，暴露onHandleIntent来执行耗时任务，<br>当子线程执行完就会终止当前Service</p><p>IntentService中的部分源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">    public ServiceHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Servicehandler是IntentService的一个内部类，当收到消息时调用onHandleIntent,当执行完，则调用stopSelf，终止当前服务</p><p>在OnCreate中，新建了一个HandleThread，并运行。<br>创建一个Servicehandler，而该ServiceHandler的Looper对象为HandleThread线程中创建的，</p><p>当执行到onStart生命周期时，<br>handler发送一条消息，此时就会走到ServiceHandler中的handlerMessage中，也就会执行onHandleIntent中。<br>因为mServiceLooper = thread.getLooper();<br>所以onHandleIntent是运行在HandlerThread中的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Service、IntentService&quot;&gt;&lt;a href=&quot;#Service、IntentService&quot; class=&quot;headerlink&quot; title=&quot;Service、IntentService&quot;&gt;&lt;/a&gt;Service、IntentService&lt;/
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment的懒加载实现，参数传递与保存</title>
    <link href="hexo/blog/2020/09/Fragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%9D%E5%AD%98.html"/>
    <id>hexo/blog/2020/09/Fragment的懒加载实现，参数传递与保存.html</id>
    <published>2020-09-28T08:07:59.000Z</published>
    <updated>2020-09-28T08:54:03.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h1><p>关于Fragment的懒加载，针对ViewPager、ViewPager2又有不同，</p><h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>针对ViewPager，其实是使用Fragment中的setUserVisibleHint函数以及onHiddenChanged函数，通过getUserVisibleHint()获取当前的Fragment是否可见，<br>当不可见时，则不加载，当可见时再创建视图并缓存。<br>这样可以只加载一次，大致原理就是如此。</p><h2 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h2><p>ViewPager是androidX下的包，之前使用的setUserVisibleHint、getUserVisibleHint等都已被申明遗弃，<br>而在ViewPager2时通过FragmentTransaction.setMaxLifecycle() 来实现懒加载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fragment懒加载&quot;&gt;&lt;a href=&quot;#Fragment懒加载&quot; class=&quot;headerlink&quot; title=&quot;Fragment懒加载&quot;&gt;&lt;/a&gt;Fragment懒加载&lt;/h1&gt;&lt;p&gt;关于Fragment的懒加载，针对ViewPager、ViewPag
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
</feed>
