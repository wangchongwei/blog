<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2021-04-26T10:00:08.152Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++基础 五</title>
    <link href="hexo/blog/2021/04/c-%E5%9F%BA%E7%A1%80-%E4%BA%94.html"/>
    <id>hexo/blog/2021/04/c-基础-五.html</id>
    <published>2021-04-26T09:25:50.000Z</published>
    <updated>2021-04-26T10:00:08.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-基础-五"><a href="#c-基础-五" class="headerlink" title="c++基础 五"></a>c++基础 五</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>与kotlin中一样，类的继承使用 : 表示。<br>不同的是，c++继承分为私有继承、公开继承，默认为私有继承</p><ul><li>1.默认是 隐式代码： : private Person</li><li>2.私有继承：在子类里面是可以访问父类的成员，但是在类的外面不行</li><li>3.必须公开继承，才可以访问父类的成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> Father &#123; <span class="comment">// 默认私有 private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19;// 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"son"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daugther</span> :</span> <span class="keyword">public</span> Father &#123; <span class="comment">// 公开继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19; // 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"dauther"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Son son;</span><br><span class="line">    son.setName();</span><br><span class="line"><span class="comment">//    son.name; //报错 'name' is a private member of 'Father'</span></span><br><span class="line">    Daugther daugther;</span><br><span class="line">    daugther.setName();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"daugther.name : "</span> &lt;&lt; daugther.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>子类不能访问父类的私有属性</li><li>子类直接继承为私有继承</li><li>私有继承的子类对象不能访问父类的属性，只能在类中访问</li><li>公开继承的子类对象可以访问父类的属性，在类中同样可以</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-基础-五&quot;&gt;&lt;a href=&quot;#c-基础-五&quot; class=&quot;headerlink&quot; title=&quot;c++基础 五&quot;&gt;&lt;/a&gt;c++基础 五&lt;/h1&gt;&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>NDK C++基础 四</title>
    <link href="hexo/blog/2021/04/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html"/>
    <id>hexo/blog/2021/04/NDK-C-基础-四.html</id>
    <published>2021-04-06T06:30:23.000Z</published>
    <updated>2021-04-26T09:25:49.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-可变参数"><a href="#c-可变参数" class="headerlink" title="c++可变参数"></a>c++可变参数</h2><p>在java中，可变参数使用 int … 需要声明类型<br>在c++中，可变参数直接使用 … 表示，不限制类型，而是在取值时，申明类型<br>在c++，获取可变参数使用 va_list va_start va_arg va_end</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp; <span class="comment">// 可变参数的动作</span></span><br><span class="line">    va_start(vp, count); <span class="comment">// 第二个参数：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num1： "</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sum(<span class="number">666</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 va_start 中第二个参数的解释：</p><ul><li>可变参数获取其实是根据内存地址来获取的，将函数传入的可变参数前的一个参数作为 va_start 的第二个参数，就是获取到前一个参数的地址，就可以获取到可变参数的首地址，然后再根据取值的类型，既可获取存储需要的size，就可以获取到每一个可变参数的值 *</li></ul><p>注意事项：</p><ul><li>取值可变参数多个值时，需要用同一个变量接收，即使用同一个内存地址接收</li><li>当取的值超出了可变参数的长度时，并不会报错，而是取到一个系统内存地址的值，随机</li><li>当取值完毕要调用 va_end 来结束可变参数的获取</li></ul><p>我们在使用可变参数时，必须传递一个具体的参数，用于确定可变参数的内存地址，</p><ul><li>同时为了方便使用，我们可以传递可变参数的长度。这样也就不会存在可变参数越界取到随机值的问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp;</span><br><span class="line">    va_start(vp, count);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        num = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">3</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id; <span class="comment">// statin int id = 99; 会报错 Non-const static data member must be initialized out of line</span></span><br><span class="line">    Person()&#123;</span><br><span class="line">        id = <span class="number">99</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = <span class="number">9</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = <span class="number">87</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::id= <span class="number">88</span>; <span class="comment">// 加上这一句，这样就可以了。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person person;</span><br><span class="line">    person.change();</span><br><span class="line">    Person::update(); <span class="comment">// 类名::可以调用静态函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  person.id &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// id没实现也会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">静态的总结：</span><br><span class="line">* <span class="number">1.</span>可以直接通过类名::静态成员（字段/函数）</span><br><span class="line">* <span class="number">2.</span>静态的属性必须要初始化，然后再实现（规则）</span><br><span class="line">* <span class="number">3.</span>静态的函数只能取操作静态的属性和方法（Java）</span><br><span class="line"></span><br><span class="line">#<span class="meta"># this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> 指当前的对象</span><br><span class="line"></span><br><span class="line">** <span class="keyword">const</span>修饰函数的<span class="keyword">this</span>意义何在。 **</span><br><span class="line">之前讲过常量指针、指针常量、常量指针常量</span><br><span class="line">使用<span class="keyword">const</span> 修饰的函数其实就是对该函数 内部隐式的 <span class="keyword">this</span> 进行<span class="keyword">const</span> 修饰，使当前<span class="keyword">this</span>变为一个 常量指针常量</span><br><span class="line"></span><br><span class="line">* 常量指针 常量是修饰值的，不能修改指，可以修改地址</span><br><span class="line">* 指针常量，不可修改指向的地址，但可以修改指针指向的值</span><br><span class="line">* 常量指针常量 既不能修改指向的地址，也不能修改指针指向的数据，即完全只读</span><br><span class="line"></span><br><span class="line">也就是说使用<span class="keyword">const</span>修饰的函数，既不能修改 当前对象 中属性的值，也不能修改地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = <span class="number">19</span>; <span class="comment">// 报错 Cannot assign to non-static data member within const member function 'test'</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">88</span>;</span><br><span class="line">    &amp;<span class="keyword">this</span> = <span class="literal">NULL</span>; <span class="comment">// 报错 Cannot take the address of an rvalue of type 'const Person *'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>常规来说，private的变量在类之外，都是无法访问的，即使是在外部生成的变量或者子类都是无法修改的。<br>但是在c++中，存在友元函数，可以在友元函数中，类对象可以访问对象的私有属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 友元函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WoRLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person person;</span><br><span class="line"><span class="comment">//    person.age = 10; // 会报错 'age' is a private member of 'Person'</span></span><br><span class="line">    person.setAge(<span class="number">19</span>);</span><br><span class="line">    updateAge(&amp;person, <span class="number">88</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"age: "</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>除了友元函数，还存在友元类，和友元类类似，在友元类中，类对象可以访问私有属性与私有函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>;</span> <span class="comment">// 友元类</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student student;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStudentAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        student.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getStudentAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  student.age;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Class cla;</span><br><span class="line">cla.setStudentAge(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"友元类中输出私有属性："</span> &lt;&lt; cla.getStudentAge() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>重写运算符的逻辑，使用关键字 <em> operator</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对+号做运算符重载</span></span><br><span class="line">Point <span class="keyword">operator</span> + (Point point1, Point point2) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = point1.getX() + point2.getX();</span><br><span class="line">    <span class="keyword">int</span> y = point1.getY() + point2.getY();</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(x, y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象1 + 对象2   C++默认不支持的， Java也不支持，Kotlin也不支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++/Kotlin 运算符重载 + 把+重载掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">point2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Point point = point1 + point2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符+重载 point x:"</span> &lt;&lt; point.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这里的加号还是可以正常运算</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是将 运算符重载函数写在类外，还可以将重载函数写在类的内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对+号重载</span></span><br><span class="line">    <span class="comment">// 系统是这样写的  常量引用：不允许修改，只读模式</span></span><br><span class="line">    <span class="comment">// const 关键字的解释</span></span><br><span class="line">    <span class="comment">// &amp; 性能的提高，如果没有&amp;  运行+ 构建新的副本，会浪费性能</span></span><br><span class="line">    <span class="comment">// 如果增加了&amp; 引用是给这块内存空间取一个别名而已</span></span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp; point) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + point.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + point.y;</span><br><span class="line">        <span class="keyword">return</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对-号重载</span></span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp; point) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x - point.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y - point.y;</span><br><span class="line">        <span class="keyword">return</span>  Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 ++对象 进行重载</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++ () &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"++对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 对象++ 进行重载</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"对象++"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">point2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Point point = point1 + point2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符+重载 point x:"</span> &lt;&lt; point.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    point1++;</span><br><span class="line">    ++point1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符++重载 point1 x:"</span> &lt;&lt; point1.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point1.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 ++对象 与 对象++ 的区别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;c-可变参数&quot;&gt;&lt;a href=&quot;#c-可变参数&quot; class=&quot;headerlink&quot; title=&quot;c++可变参数&quot;&gt;&lt;/a&gt;c++可变参数&lt;/h2&gt;&lt;p&gt;在java中，可变参数使用 int … 需要声明类型&lt;br&gt;在c++中，可变参数直接使用 … 表示，不限
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android aidl</title>
    <link href="hexo/blog/2021/03/android-aidl.html"/>
    <id>hexo/blog/2021/03/android-aidl.html</id>
    <published>2021-03-19T03:48:34.000Z</published>
    <updated>2021-04-26T09:33:11.159Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL: Android Interface Definition Language （android接口定义语言）<br>可以使用AIDL定于跨进程的客户端与服务端通信(IPC)的编程接口.</p><p>主要流程是在项目中新建一个aidl文件，此时会自动在src目录下生成aidl目录，并创建包名路径，并在路径下生成命名的aidl文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.justin.ipc.application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后rebuild project，会在app/build/generated/aidl_source_doutput_dir/denug/out/包名/下生成对应的 IMyAidlInterface.java文件</p><p>会生成大量代码，首先是接口基本代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">/** Default implementation for IMyAidlInterface. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">justin</span>.<span class="title">ipc</span>.<span class="title">application</span>.<span class="title">IMyAidlInterface</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">         * and return values in AIDL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码， 是 IMyAidlInterface.java 文件中代码主体部分，IMyAidlInterface 继承 android.os.IInterface 接口<br>然后有一个默认的静态内部类 Default 实现 IMyAidlInterface 接口，具体的函数实现都是空，没有具体逻辑。<br>注意其中的 asBinder 函数，这是 android.os.IInterface 中的方法</p><h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>然后在 IMyAidlInterface 接口类中，还有一个静态内部抽象类 Stub 继承自 android.os.Binder 实现 IMyAidlInterface 接口<br>而 android.os.Binder 又实现于 IBinder 接口<br>介于 Binder 对象在系统底层的支持下，Stub 对象就具有了远程传输数据的能力，在生成 Stub 对象的时候会调用 asInterface 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检索 Binder 对象是否是本地接口的实现</span></span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.justin.ipc.application.IMyAidlInterface))) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((com.justin.ipc.application.IMyAidlInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Binder 为什么具有远程通信的能力，因为如上面所说 Stub 继承了 Binder 类<br>下面是官网对 IBinder 接口的描述：<br><code>远程对象的基础接口，轻量级远程过程调用机制的核心部分，专为执行进程内和跨进程调用时的高性能而设计。该接口描述了与可远程对象交互的抽象协议。不要直接实现这个接口，而是从Binder扩展。</code><br>这里我们知道 Binder 实现了 IBinder 接口，也就是说 Binder 具备了远程通信的能力，当不同进程之间（远程）之间通信时，显然使用的是 Stub 的代理对象 Proxy ，<br>而在 Proxy 中的具体函数中，只是将数据序列号，然后在系统跨进程支持下最终调用 onTransact() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">    <span class="keyword">switch</span> (code)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        reply.writeString(descriptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_basicTypes:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        <span class="keyword">int</span> _arg0;</span><br><span class="line">        _arg0 = data.readInt();</span><br><span class="line">        <span class="keyword">long</span> _arg1;</span><br><span class="line">        _arg1 = data.readLong();</span><br><span class="line">        <span class="keyword">boolean</span> _arg2;</span><br><span class="line">        _arg2 = (<span class="number">0</span>!=data.readInt());</span><br><span class="line">        <span class="keyword">float</span> _arg3;</span><br><span class="line">        _arg3 = data.readFloat();</span><br><span class="line">        <span class="keyword">double</span> _arg4;</span><br><span class="line">        _arg4 = data.readDouble();</span><br><span class="line">        java.lang.String _arg5;</span><br><span class="line">        _arg5 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_setName:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        java.lang.String _arg0;</span><br><span class="line">        _arg0 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.setName(_arg0);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_getName:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        <span class="keyword">this</span>.getName();</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这个方法在当系统回调给开发者的时候，传递回来的 code 是一个常量，在跨进程时，每个具体的服务（方法）都会对应一个编号<br>，然后根据这个编号来执行相应的服务（业务），这里说到了最后要执行的具体业务，<br>那么这个业务要体现在什么地方呢，从上面可知 Stub 是一个抽象类，那么它所提供的具体业务必然需要一个具体的实现类来完成，<br>而这个类就是需要我们自己手动根据需要来实现</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 是 Stub 中的一个 静态内部类，实现 IMyAidlInterface 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">justin</span>.<span class="title">ipc</span>.<span class="title">application</span>.<span class="title">IMyAidlInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">    Proxy(android.os.IBinder remote)</span><br><span class="line">    &#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">        * and return values in AIDL.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeInt(anInt);</span><br><span class="line">        _data.writeLong(aLong);</span><br><span class="line">        _data.writeInt(((aBoolean)?(<span class="number">1</span>):(<span class="number">0</span>)));</span><br><span class="line">        _data.writeFloat(aFloat);</span><br><span class="line">        _data.writeDouble(aDouble);</span><br><span class="line">        _data.writeString(aString);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().basicTypes(anInt, aLong, aBoolean, aFloat, aDouble, aString);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_setName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().setName(name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().getName();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.IMyAidlInterface sDefaultImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 Proxy 中的几个具体方法，主要是对数据做序列化处理，然后调用 mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0);</p><p>mRemote 在 Proxy 的构造函数内被赋值，而 Proxy 是在 Stub 中的 asInterface 函数， 所以又回到了 上面的逻辑。</p><h3 id="手动实现进程通信"><a href="#手动实现进程通信" class="headerlink" title="手动实现进程通信"></a>手动实现进程通信</h3><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>创建一个Service，并运行在其他进程，模拟跨进程调用Service<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestAIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestAIDLService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAIDLTestImp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在AndroidManifest.xml文件中，配置Service<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyTestAIDLService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中 process=”:remote” 表示运行在另一进程，进程号为： 主进程 + ‘:remote’</p><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><p>写三个按钮，一个绑定服务，一个解绑服务，一个调用服务中的Binder获取数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = MainActivity.class.getName() + <span class="string">"MYTEST："</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button btn_bind, btn_unbind, btn_get;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface interfaces;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isConnected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        btn_bind = findViewById(R.id.bind_server);</span><br><span class="line">        btn_unbind = findViewById(R.id.unbind_server);</span><br><span class="line">        btn_get = findViewById(R.id.btn_getInfo);</span><br><span class="line"></span><br><span class="line">        btn_bind.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">            bindService();</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_unbind.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">           unbindService(); </span><br><span class="line">        &#125;);</span><br><span class="line">        btn_get.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">            getInfo();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isConnected = <span class="keyword">true</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyTestAIDLService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isConnected) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"unbindService: 已解绑，请勿重复提交"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isConnected = <span class="keyword">false</span>;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        Log.d(TAG, <span class="string">"unbindService: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaces.setName(<span class="string">"name"</span>);</span><br><span class="line">            String result = interfaces.getName();</span><br><span class="line">            Log.d(TAG, <span class="string">"getInfo: "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onServiceConnected: "</span>);</span><br><span class="line">            interfaces = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">            System.out.println(TAG + <span class="string">"具体的业务对象："</span>+interfaces);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onServiceDisconnected: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindingDied</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onBindingDied: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们依次点击绑定服务、获取信息，输出如下：<br>onServiceConnected:<br>具体的业务对象：com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157<br>getInfo: name</p><p>当我们在 AndroidManifest.xml 中去除Service的 process 配置，即让 service 与 MainActivity处于同一进程时，<br>输出如下：<br>onServiceConnected:<br>具体的业务对象：com.justin.ipc.application.MyAIDLTestImp@da080a<br>getInfo: name</p><p>对比发现，输出的 interfaces 对象不同<br>原因是在 Stub中 asInterface 函数中 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.justin.ipc.application.IMyAidlInterface))) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((com.justin.ipc.application.IMyAidlInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在同一进程中，queryLocalInterface 返回的 iin不为空，此时获取的就是 om.justin.ipc.application.MyAIDLTestImp@da080a</p><p>而处于跨进程通信时，queryLocalInterface 返回的 iin 为空，此时会返回 new com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);<br>一个新的 Proxy 对象，也就是上面的 com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AIDL: Android Interface Definition Language （android接口定义语言）&lt;br&gt;可以使用AIDL定于跨进程的客户端与服务端通信(IPC)的编程接口.&lt;/p&gt;
&lt;p&gt;主要流程是在项目中新建一个aidl文件，此时会自动在src目录下
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>andorid MVC</title>
    <link href="hexo/blog/2021/03/andorid-MVC.html"/>
    <id>hexo/blog/2021/03/andorid-MVC.html</id>
    <published>2021-03-11T09:42:14.000Z</published>
    <updated>2021-03-11T10:11:47.334Z</updated>
    
    <content type="html"><![CDATA[<p>MVC 模式：</p><p>1）Model (模型层) 在 MVC 中 Model 一般用来保存数据的状态，比如数据存储，网络请求。同时还与View 存在一定的耦合，通过某种事件机制（比如观察者模式） 通知 View 状态的改变来让view 更新。</p><p>2）View (视图层)一般由一些GUI 组建组成，同时响应用户的交互行为并触发 Controller 的逻辑，View 还有可能修改Model 的状态 以使其与 Model 同步，View 还会在model 中注册 model 事件的改变。以此来刷新自己并展示给用户。</p><p>3）Control （控制层）控制器由View 根据用户行为触发并响应来自view 的用户交互，然后根据view 的事件逻辑来修改对应的Model, Control 并不关心 View 如何展示 相关数据或状态，而是通过修改 Model 来实现view 的数据的刷新。</p><p>view 层即指 xml文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MVC 模式：&lt;/p&gt;
&lt;p&gt;1）Model (模型层) 在 MVC 中 Model 一般用来保存数据的状态，比如数据存储，网络请求。同时还与View 存在一定的耦合，通过某种事件机制（比如观察者模式） 通知 View 状态的改变来让view 更新。&lt;/p&gt;
&lt;p&gt;2）Vi
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>NDK-c++基础 三</title>
    <link href="hexo/blog/2021/03/NDK-c-%E5%9F%BA%E7%A1%80-%E4%B8%89.html"/>
    <id>hexo/blog/2021/03/NDK-c-基础-三.html</id>
    <published>2021-03-11T06:20:48.000Z</published>
    <updated>2021-04-26T08:56:35.935Z</updated>
    
    <content type="html"><![CDATA[<p>c++语言基础，<br>c++中能运行c语言，但c语言不能运行c++</p><p>C++语言面向对象 + 标准特性<br>C语言面向过程，函数+结构体<br>C++里面可以运行C语言，可以调用C语言，反之 就不行C语言无法运行C++<br>以后我们85%以上 都是 用C++去写功能</p><p>在c语言中基本运行需要引入<br><code>#include &lt;stdio.h&gt;</code><br>在c++中需要引入<br><code>#include &lt;iostream&gt;</code>    </p><h2 id="打印语句"><a href="#打印语句" class="headerlink" title="打印语句"></a>打印语句</h2><ul><li>cout *<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YYYYYY\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Line1\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"Line2\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"line3\n"</span>;</span><br></pre></td></tr></table></figure></li></ul><p>需要引入<br><code>using namespace std;</code><br>namespace 命名空间</p><p>&lt;&lt; 是一个操作重载符，cout 更正确的写法是： std::cout<br>因为我们已经引入 命名空间，所以可以省略为： cout</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在c或者c++中，常量使用 const 声明，但是在c语言中，常量是个伪命题，因为c中可以直接修改指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">90</span>;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// c++ Cannot initialize a variable of type 'int *' with an rvalue of type 'const int *'</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>i 已经被定义成常量<br>上面这段代码在c语言中可以运行，并能修改i地址处的值为10，达到了修改常量值的目的。<br>但是在c++中会报错，ide工具就会直接报错：Cannot initialize a variable of type ‘int <em>‘ with an rvalue of type ‘const int </em>‘</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>&amp; *</li></ul><p>c++中 &amp; 标示引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a = i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a地址:"</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">"\ni地址:"</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c地址:"</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">"\nd地址:"</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>打印结果：<br>a地址:0x7ffeefbff4c8<br>i地址:0x7ffeefbff4c8<br>c地址:0x7ffeefbff4bc<br>d地址:0x7ffeefbff4b8</p><p>因为 a 是 i 的引用。 a 指向 i， 所以 a 与 i 的地址一致。<br>而c 与 d 不同，c、d都是一个新的对于9的引用。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>c++ 申明类使用关键字 class<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> * name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如此一个基本类就定义完成，成员变量使用private修饰，在外部不可访问，提供public修饰的set、get函数来操作成员变量。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"空构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="keyword">int</span> age): age(age) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"一个参数的构造函数： age"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="keyword">char</span> * name) &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"一个参数的构造函数： name"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="keyword">char</span> * name)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"两个参数的构造函数： name"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上所示，第2个与第三个其实效果是一样的，都是对成员变量直接赋值。<br>还有构造函数的相互调用问题:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">char</span> * name): Person(age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"两个参数的构造函数： name"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>调用两个参数的构造函数时，会调用到一个参数的构造函数，</p><ul><li>而且打印会先打印一个参数的构造函数的日志，然后再打印两个参数构造函数的日志  *</li></ul><h3 id="类的引用"><a href="#类的引用" class="headerlink" title="类的引用"></a>类的引用</h3><p>我们在上面申明了一个类，然后我们可以根据类申明引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO TESTCLASS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Person person;</span><br><span class="line">person.setAge(<span class="number">29</span>);</span><br><span class="line">person.setName(<span class="string">"justin"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; person.getAge() &lt;&lt; <span class="string">",  name:"</span> &lt;&lt; person.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">24</span>, <span class="string">"novia"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; person1.getAge() &lt;&lt; <span class="string">",  name:"</span> &lt;&lt; person1.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br><code>HELLO TESTCLASS空构造函数age:29,  name:justin一个参数的构造函数： age两个参数的构造函数： nameage:24,  name:novia</code></p><p>在上述代码中，生成的person都是普通的引用，数据内存都是在栈区。<br>接下来看一下在C++中如何使用堆区内存</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>与c语言不同，c++中使用 new 生成的对象都存放在堆内存中，而存放在堆内存中的数据，需要自己手动<br>c++使用 delete 释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person * person = <span class="keyword">new</span> Person(<span class="number">29</span>, <span class="string">"justin"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; person-&gt;getAge() &lt;&lt; <span class="string">",  name:"</span> &lt;&lt; person-&gt;getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person;</span><br><span class="line">person = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li><p>QA: 为何栈区内存不需要释放内存<br>我们都知道函数在出栈时，会释放栈区内存，那为何不需要使用delete释放。<br>其实函数并不是没有调用delete来释放，在函数出栈时，有静默的调用了delete，来释放栈区的内存</p></li><li><p>QA：为何调用了delete后，还能调用指针并获取到值<br>因为delete的原理并不是直接清空数据，而是标记该块内存地址为可用，当应用有向堆内存重新申请内存时，就可能申请到这块内存，此时数据才会被修改，<br>如果此块内存一直没有被申请到时，调用该指针后，还是能访问到之前的数据的。<br>当调用 delete 时，该指针即成为悬空指针，继续调用就有可能出现异常，规范用法时指向NULL；</p></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>当对象内存被回收时，会执行对象的析构函数，类似与java对象的finalize函数<br>但与finalize函数不同的是，java对象可以在finalize中实现自我拯救，<br>c++析构函数中，不能实现自我拯救，主要是用于一些数据清除、销毁工作，如解绑、释放堆内存空间，是的，对象中如果也有开辟堆内存时，就需要在此处释放，不然该内存会被一直占用。<br>析构函数的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~Person()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">Person(<span class="keyword">const</span> Person &amp; person)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = person.name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = person.age;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行复制拷贝时，就会执行复制拷贝函数，系统默认的复制拷贝函数会自动完成复制值，<br>手动重写复制拷贝函数时，我们也需要手动赋值</p><p>此时传入的person就是旧对象，this即是拷贝后生成的新对象</p><h4 id="拷贝的场景"><a href="#拷贝的场景" class="headerlink" title="拷贝的场景"></a>拷贝的场景</h4><ul><li>person1 = person2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">24</span>, <span class="string">"novia"</span>)</span></span>;</span><br><span class="line">Person person2 = person1;</span><br></pre></td></tr></table></figure><p>当执行 Person person2 = person1; 即会执行 拷贝构造函数 来对person2赋值，</p><ul><li>参数传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test函数中,参数person的地址: "</span> &lt;&lt; &amp;person &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">24</span>, <span class="string">"novia"</span>)</span></span>;</span><br><span class="line">    Person person2 = person1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person1.age:"</span> &lt;&lt; person1.getAge() &lt;&lt; <span class="string">",  Person1.name:"</span> &lt;&lt; person1.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person2.age:"</span> &lt;&lt; person2.getAge() &lt;&lt; <span class="string">",  Person2.name:"</span> &lt;&lt; person2.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person1地址---"</span> &lt;&lt; &amp;person1 &lt;&lt; <span class="string">"  ,person2地址---"</span> &lt;&lt; &amp;person2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    test(person2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><p>一个参数的构造函数： age<br>两个参数的构造函数： name<br>拷贝构造函数<br>Person1.age:24,  Person1.name:novia<br>Person2.age:24,  Person2.name:novia<br>person1地址—0x7ffeefbff4b8  ,person2地址—0x7ffeefbff4a8<br>拷贝构造函数<br>test函数中,参数person的地址: 0x7ffeefbff488<br>析构函数<br>析构函数<br>析构函数</p><p>可以看到test函数中打印的person地址 与我们调用 test 函数传递的 person2 地址并不相同。这被叫做 <em> 行参 </em></p><p>像避免上面的操作，避免产生大量的副本对象，占用内存，有几个办法，</p><ul><li><p>1、使用引用<br>在上面就讲过引用，引用也是直接执行地址的，所以当我们使用引用时，就不会重新拷贝赋值了。<br>修改一下test函数的入参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Person &amp; person)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test函数中,参数person的地址: "</span> &lt;&lt; &amp;person &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、运算符重载<br>重写 = 运算符，使之返回之前的地址。</p></li></ul><ul><li>注意事项 *<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person2 = person1; <span class="comment">// 1</span></span><br><span class="line">Person person2;</span><br><span class="line">person2 = person1; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><p>方式2是不会调用 拷贝构造函数， 方式1 才会。<br>为什么？</p><p>因为person2其实已经调用了无参构造函数，<br>Person person2; 这一句已经调用了无参构造函数，<br>person2 = person1; 只是重新赋值而已。</p><h3 id="常量指针-常量引用-指针常量-常量指针常量"><a href="#常量指针-常量引用-指针常量-常量指针常量" class="headerlink" title="常量指针 常量引用 指针常量 常量指针常量"></a>常量指针 常量引用 指针常量 常量指针常量</h3><p>之前讲过常量，代表不可更改值</p><p>常量下还有 常量指针 常量引用 指针常量 常量指针常量</p><p>注意常量修饰的位置 </p><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> number2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * a_p  = &amp;number;</span><br><span class="line">*a_p = <span class="number">100</span>; <span class="comment">// 修改值 会报错，</span></span><br><span class="line">a_p = &amp;number2; <span class="comment">// 修改地址 不会报错</span></span><br></pre></td></tr></table></figure><p>const 用来修饰类型，这个指针即为常量指针<br>声明了常量指针 a_p，<br>*a_p = 100; 会提示错误：Read-only variable is not assignable<br>常量代表只读,  常量指针 常量是修饰值的，不可以直接修改指针指向的数据，只能通过修改指针指向的地址来修改值</p><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; a = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>const 用来修饰引用，这个引用即为 常量引用<br>常量引用指向的数据也是不能直接修改的。<br>拷贝构造函数 重的参数就是一个常量引用。</p><h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> b_p = &amp;number;</span><br><span class="line"><span class="comment">//    b_p = &amp;number2; // 会报错 Cannot assign to variable 'b_p' with const-qualified type 'int *const'</span></span><br><span class="line">*b_p = <span class="number">190</span>; <span class="comment">// 不报错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*bp指向的值为"</span> &lt;&lt; *b_p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>const 用来修饰指针，这个指针即是 指针常量<br>上面的输出结果：<br>*bp指向的值为190</p><p>指针常量，不可修改指向的地址，但可以修改指针指向的值</p><h4 id="常量指针常量"><a href="#常量指针常量" class="headerlink" title="常量指针常量"></a>常量指针常量</h4><p>常量指针常量 其实相当于 常量指针 与 指针常量 两个的合并。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;number;</span><br><span class="line">c_p = &amp;number2; <span class="comment">// 报错</span></span><br><span class="line">*c_p = <span class="number">99</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><p>常量指针常量 既不能修改指向的地址，也不能修改指针指向的数据，即完全只读</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;c++语言基础，&lt;br&gt;c++中能运行c语言，但c语言不能运行c++&lt;/p&gt;
&lt;p&gt;C++语言面向对象 + 标准特性&lt;br&gt;C语言面向过程，函数+结构体&lt;br&gt;C++里面可以运行C语言，可以调用C语言，反之 就不行C语言无法运行C++&lt;br&gt;以后我们85%以上 都是 用C+
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android SharedPreferences</title>
    <link href="hexo/blog/2021/03/android-SharedPreferences.html"/>
    <id>hexo/blog/2021/03/android-SharedPreferences.html</id>
    <published>2021-03-09T08:29:28.000Z</published>
    <updated>2021-03-10T03:38:59.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SharedPreferences 存取值原理，其实还是将数据写入到xml文件 以及 缓存中。<br>Context.getSharedPreferences 都是在ContextImpl中实现，但是在API23之前、23之后实现方式却不同</p><h2 id="API-23"><a href="#API-23" class="headerlink" title="API 23"></a>API 23</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 第一次为空时，初始化值</span><br><span class="line">        if (sSharedPrefs == null) &#123;</span><br><span class="line">            sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取对应packageName下的 sp实例集合 也是当前应用第一次使用时初始化</span><br><span class="line">        final String packageName = getPackageName();</span><br><span class="line">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</span><br><span class="line">        if (packagePrefs == null) &#123;</span><br><span class="line">            packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</span><br><span class="line">            sSharedPrefs.put(packageName, packagePrefs);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">                Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            if (name == null) &#123;</span><br><span class="line">                name = &quot;null&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据传入的name获取对应的sp实例，第一次初始化  获取对应的文件</span><br><span class="line">        sp = packagePrefs.get(name);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            File prefsFile = getSharedPrefsFile(name);</span><br><span class="line">            sp = new SharedPreferencesImpl(prefsFile, mode);</span><br><span class="line">            packagePrefs.put(name, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public File getSharedPrefsFile(String name) &#123;</span><br><span class="line">    return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextImpl 中 维护有一个 静态集合 sSharedPrefs = ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;<br>sSharedPrefs 全局唯一</p><p>该map中 key为 应用包名，value 为一个 packagePrefs ArrayMap&lt;String, SharedPreferencesImpl&gt;,</p><p>SharedPreferencesImpl 是单个sp实例信息， 文件、数据map缓存</p><p>packagePrefs 存有一个应用中所有的 sp实例 SharedPreferencesImpl</p><p>sSharedPrefs 存有所有应用关于sp的实例信息</p><p><strong> 存取值其实就是在集合sSharedPrefs中通过包名packageName获取到 packagePrefs，再根据 初入的name获取到指定的 SharedPreferencesImpl实例，然后再通过实例来读写数据 </strong></p><p>getSharedPrefsFile 就是返回 应用data文件夹/shared_prefs/ name.xml</p><h2 id="API-24及以上"><a href="#API-24及以上" class="headerlink" title="API 24及以上"></a>API 24及以上</h2><p>ContextImp 中存在两个 getSharedPreferences函数，<br>public SharedPreferences getSharedPreferences(String name, int mode);<br>public SharedPreferences getSharedPreferences(File file, int mode);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</span><br><span class="line">private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">  </span><br><span class="line">    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (name == null) &#123;</span><br><span class="line">            name = &quot;null&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 获取name 对应的文件</span><br><span class="line">        if (mSharedPrefsPaths == null) &#123;</span><br><span class="line">            mSharedPrefsPaths = new ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file = mSharedPrefsPaths.get(name);</span><br><span class="line">        if (file == null) &#123;</span><br><span class="line">            file = getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 获取当前运行应用的 sp集合</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            checkMode(mode);</span><br><span class="line">            if (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                if (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;SharedPreferences in credential encrypted &quot;</span><br><span class="line">                            + &quot;storage are not available until after user is unlocked&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 新建 SharedPreferencesImpl 对象</span><br><span class="line">            sp = new SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        // If somebody else (some other process) changed the prefs</span><br><span class="line">        // file behind our back, we reload it.  This has been the</span><br><span class="line">        // historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    if (sSharedPrefsCache == null) &#123;</span><br><span class="line">        sSharedPrefsCache = new ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String packageName = getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    if (packagePrefs == null) &#123;</span><br><span class="line">        packagePrefs = new ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在api24以后，ContextImpl中不再维护有静态的sSharedPrefs集合，<br>而是维护有一个ArrayMap mSharedPrefsPaths ，以及一个静态集合ArrayMap sSharedPrefsCache<br>sSharedPrefs key为name，value为文件<br>sSharedPrefsCache ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt;  key为包名packageName， value 为集合ArrayMap&lt;File, SharedPreferencesImpl&gt;</p><p>getSharedPreferences(String name, int mode)函数中，先通过name获取到对应的文件，再调用public SharedPreferences getSharedPreferences(File file, int mode);</p><h2 id="API-23-与-24-的差异"><a href="#API-23-与-24-的差异" class="headerlink" title="API 23 与 24 的差异"></a>API 23 与 24 的差异</h2><p>从上面来看，API23与24差异很小，其实就是将内部的集合的key从 string 改成了 file，<br>在API24中，增多一个mSharedPrefsPaths集合，在集合中就有 name 与 file的映射关系。<br>对于需要频繁获取的sp实例来说，可能略有优化，但是也增加了内存消耗。</p><p>## </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = false;</span><br><span class="line">    mMap = null;</span><br><span class="line">    mThrowable = null;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = false;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mLoaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Debugging</span><br><span class="line">    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = null;</span><br><span class="line">    StructStat stat = null;</span><br><span class="line">    Throwable thrown = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                str = new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16 * 1024);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ErrnoException e) &#123;</span><br><span class="line">        // An errno exception means the stat failed. Treat as empty/non-existing by</span><br><span class="line">        // ignoring.</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = true;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        // It&apos;s important that we always signal waiters, even if we&apos;ll make</span><br><span class="line">        // them fail with an exception. The try-finally is pretty wide, but</span><br><span class="line">        // better safe than sorry.</span><br><span class="line">        try &#123;</span><br><span class="line">            if (thrown == null) &#123;</span><br><span class="line">                if (map != null) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mMap = new HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // In case of a thrown exception, we retain the old map. That allows</span><br><span class="line">            // any open editors to commit and store updates.</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新建 SharedPreferencesImpl 时，会初始化一些变量，并且执行startLoadFromDisk<br>在startLoadFromDisk 中会新开线程执行 loadFromDisk<br>在loadFromDisk 中，会删除原文件，然后将 备份文件重命名 </p><p>然后就是通过文件流读取 文件信息，将读取到的信息赋值给 SharedPreferencesImpl中的 map对象。<br>同时对文件的读取都是加锁操作的。当文件读取完成了，执行mLock.notifyAll();唤醒所有操作线程。 </p><p><code>loadFromDisk 需要新开线程也是互斥的问题，必须保证load 与读写不在同一线程，才能让不会一直await，在加载完能够唤醒读写的操作继续。</code></p><h3 id="getValue"><a href="#getValue" class="headerlink" title="getValue()"></a>getValue()</h3><p>内部有针对不同类型的get方法，基本都一致，看一个就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        return v != null ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读操作也是加锁的，防止读、写同时，导致数据异常，同时也跟上面的 loadFromDisk 中加锁呼应，防止问价还未加载完就进行读写操作</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put操作需要通过内部类EditorImpl来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public Editor edit() &#123;</span><br><span class="line">    // 当文件未加载完，即loadFromDisk未执行完时，会一直等待。</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    // 每次获取edit时都是重新创建一个对象。</span><br><span class="line">    return new EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次获取Edit对象时都是返回一个新的对象，所以尽量将数据操作合并，不要频繁去重新获取edit对象。<br>在看一下put数据的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, Object&gt; mModified = new HashMap&lt;&gt;();</span><br><span class="line">@Override</span><br><span class="line">public Editor putString(String key, @Nullable String value) &#123;</span><br><span class="line">    synchronized (mEditorLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行put方法时，只是将数据提交到 EditorImpl 中的一个HashMap中，<br>只有在commit 或者 apply时，才会将数据合并、写入到文件中。</p><ul><li>QA：为何要设计一个mModified，来保存数据，而不是直接提交合并到文件？<br>这样可以避免频繁操作文件，只有在执行commit、apply时才去操作文件，提高效率，是一种优化手段。</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean commit() &#123;</span><br><span class="line">    long startTime = 0;</span><br><span class="line"></span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    // 合并mModified数据到一个新的集合，并清除mModified数据，并记录哪些key的value发生更改，最后将合并的数据包装成一个MemoryCommitResult对象</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    // 将mcr加入文件写入队列，注意第二个参数为null，标示 直接写入，不需等待</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">        mcr, null /* sync write on this thread okay */);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 等待写入结果</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                    + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 唤醒监听器，发送消息，数据更改操作结束</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime = System.currentTimeMillis();</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 apply、commit两个函数基本相同，主要时在 enqueueDiskWrite 函数执行时，传入的第二个参数不同 </p><h3 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                                  final Runnable postWriteRunnable) &#123;</span><br><span class="line">    // commit时,传入的postWriteRunnable为null， isFromSyncCommit 为true， </span><br><span class="line">    // apply时 postWriteRunnable != null isFromSyncCommit = false</span><br><span class="line"></span><br><span class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</span><br><span class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable != null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // commit 才会进入这个判断，并最终执行writeToDiskRunnable 然后return</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty = false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // apply 会执行此处</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commit、apply差异"><a href="#commit、apply差异" class="headerlink" title="commit、apply差异"></a>commit、apply差异</h3><p>从上面的注释也可以看出， commit会直接在当前线程执行 writeToDiskRunnable.run();<br>而 apply 会将 writeToDiskRunnable 加入队列 QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);等待线程池执行任务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SP是线程安全的，通过锁、await、notifyAll，保证并行时不会读写异常。</p><p>SP通过全局静态ArrayMap维护一个集合，通过packageName、name找到对应的读写文件file、SPImpl实例。</p><p>读操作是加载file完之后，直接在缓存的一个集合Map中根据key读取即可。</p><p>写操作是先将需要写入的数据都缓存到一个HashMap中，再在commit或者apply时与file中的数据合并，并标示哪些key发生改变，包装成一个MemoryCommitResult对象。</p><p>写操作只是修改缓存的HashMap，修改持久化的数据还需要执行commit或者apply。</p><p>commit 是当前线程直接执行，而 apply是添加到任务队列等待线程池执行。</p><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><ul><li><p>不要存放大的key和value在SharedPreferences中，否则会一直存储在内存中得不到释放，内存使用过高会频发引发GC，导致界面丢帧甚至ANR。</p></li><li><p>不相关的配置选项最好不要放在一起，单个文件越大读取速度则越慢。</p></li><li><p>读取频繁的key和不频繁的key尽量不要放在一起（如果整个文件本身就较小则忽略，为了这点性能添加维护得不偿失）。</p></li><li><p>不要每次都edit，因为每次都会创建一个新的EditorImpl对象，最好是批量处理统一提交。否则edit().commit每次创建一个EditorImpl对象并且进行一次IO操作，严重影响性能。</p></li><li><p>commit发生在UI线程中，apply发生在工作线程中，对于数据的提交最好是批量操作统一提交。虽然apply发生在工作线程（不会因为IO阻塞UI线程）但是如果添加任务较多也有可能带来其他严重后果<br>  （参照ActivityThread源码中handleStopActivity方法实现）</p></li><li><p>尽量不要存放json和html，这种可以直接文件缓存。</p></li><li><p>不要指望它能够跨进程通信 Context.PROCESS</p></li><li><p>最好提前初始化SharedPreferences，避免SharedPreferences第一次创建时读取文件线程未结束而出现等待情况。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;SharedPreferences 存取值原理，其实还是将数据写入到xml文件 以及 缓存中。&lt;br&gt;Context.getSharedPr
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 应用启动流程</title>
    <link href="hexo/blog/2021/03/android-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html"/>
    <id>hexo/blog/2021/03/android-应用启动流程.html</id>
    <published>2021-03-09T05:47:56.000Z</published>
    <updated>2021-03-09T05:48:02.584Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>NDK c语言基础 二</title>
    <link href="hexo/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C.html"/>
    <id>hexo/blog/2021/03/NDK-c语言基础-二.html</id>
    <published>2021-03-05T02:40:09.000Z</published>
    <updated>2021-03-09T05:47:34.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>申明关键字 struct</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    </span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似与java中的bean类，kotlin中的data class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    struct Person * person;</span><br><span class="line">    person-&gt;name = &quot;justin&quot;; // xcode可以这样写，其他工具可能需要使用 strcpy 函数来对字符串复制来进行赋值</span><br><span class="line">    person-&gt;age = 29;</span><br><span class="line">    printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以直接在结构体后实例化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; ppp1  = &#123;&quot;9999&quot;, 21&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>在不同的ide工具中，c语言的语法可能略有不同，为了统一，推出一个类型定义，<br>如此保证在不同的ide工具，使用一样的代码运行</p><p>在源码中也是大量使用</p><p>关键字 typedef</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; ppp1  = &#123;&quot;9999&quot;, 21&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">typedef struct Person Person; // 为结构体定义一个类型，后续申明结构体对象就不需要使用struct关键字</span><br><span class="line">typedef Person * Person_; // 为结构体指针定一个类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    Person_ person;</span><br><span class="line">    person-&gt;name = &quot;justin&quot;;</span><br><span class="line">    person-&gt;age = 29;</span><br><span class="line">    printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>file</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;p&gt;申明关键字 struct&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="c语言" scheme="hexo/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>JMM java内存模型</title>
    <link href="hexo/blog/2021/03/JMM-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"/>
    <id>hexo/blog/2021/03/JMM-java内存模型.html</id>
    <published>2021-03-03T06:55:28.000Z</published>
    <updated>2021-03-04T09:34:02.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、现代计算机内存模型"><a href="#一、现代计算机内存模型" class="headerlink" title="一、现代计算机内存模型"></a>一、现代计算机内存模型</h2><p>早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问内存地址的。<br>而在现代计算机中，CPU指令的运行速度远远超过了内存数据的读写速度，为了降低这两者间这高达几个数量级的差距，所以在CPU与主内存之间加入了CPU高速缓存。</p><p>高速缓存可以很好地解决CPU与主内存之间的速度差距，但CPU缓存并不是所有CPU共享的，因此产生了一个新的问题：数据一致性问题。</p><p><img src="../../../images/memory.png" style="zoom:70%"></p><h2 id="二、缓存一致性协议（MESI）"><a href="#二、缓存一致性协议（MESI）" class="headerlink" title="二、缓存一致性协议（MESI）"></a>二、缓存一致性协议（MESI）</h2><h3 id="MESI四种状态"><a href="#MESI四种状态" class="headerlink" title="MESI四种状态"></a>MESI四种状态</h3><p>因为存在多个cpu，也就存在多个cpu缓存，CPU缓存的一致性问题会导致并发处理的不同步。<br>所以引入一种解决办法：缓存一致性协议（MESI）</p><p>MESI 这个名称本身是由：Modified（修改）、Exclusive（独享）、Shared（共享）、Invalid（无效）。<br>这个四个单词也代表了缓存协议中对缓存行（即Cache Line，缓存存储数据的单元）声明的四种状态，用2 bit表示，它们所代表的含义如下所示</p><p>状态 ｜ 描述 ｜ 监听任务<br>Modified（修改 ｜ 这行数据有效，数据被修改了，和内存种的数据不一致，数据只存在于本Cache中 ｜ 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。<br>Exclusive（独享）｜ 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中 ｜ 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。<br>S共享（Shared ｜ 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中 ｜ 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。<br>I无效（Invalid） ｜ 这行数据无效 ｜ 无</p><p>理解： 某数据如果多个缓存读取，则处于S共享状态，如果只是单个则处于E独享状态。<br>    某个CPU2对CPU2缓存中某数据作出修改，则CPU2缓存该数据处于Modified状态，如果该数据是S共享状态，则其他缓存该行数据变成I无效状态。</p><h3 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="headerlink" title="如何保证缓存一致性"></a>如何保证缓存一致性</h3><pre><code>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存中的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</code></pre><h2 id="三、JMM-java-内存模型"><a href="#三、JMM-java-内存模型" class="headerlink" title="三、JMM java 内存模型"></a>三、JMM java 内存模型</h2><p><img src="../../../images/jmm.png" style="zoom:70%"></p><p>线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地工作内存（Local Memory），工作内存中存储了线程以读/写共享变量的副本。<br>（本地工作内存是 JMM 的一个抽象概念，并不真实存在，线程中所谓工作内存其实还是存在于主内存中的。）</p><h3 id="Java内存模型与现代计算机内存模型区分"><a href="#Java内存模型与现代计算机内存模型区分" class="headerlink" title="Java内存模型与现代计算机内存模型区分"></a>Java内存模型与现代计算机内存模型区分</h3><p>Java内存模型和现代计算机内存模型都需要解决一致性问题，但是这个一致性问题在现代计算机内存模型中指代的是缓存一致性问题，MESI协议所设计的目的也是为了解决这个问题。而在Java内存模型中，这个一致性问题则是指代内存一致性问题。两者之间有一定区别。</p><p>缓存一致性</p><p>计算机数据需要经过内存、计算机缓存再到寄存器，计算机缓存一致性是指硬件层面的问题，指的是由于多核计算机中有多套缓存，各个缓存之间的数据不一致问题。缓存一致性协议（如MESI）就是用来解决多个缓存副本之间的数据一致性问题。</p><p>内存一致性</p><p>线程的数据则是放在内存中，共享副本也是，内存一致性保证的是多线程程序并发时的数据一致性问题。我们常见的volatile、synchronized关键字就是用来解决内存一致性问题。这里屏蔽了计算机硬件问题，<br>主要解决原子性、可见性和有序性问题。</p><p>至于内存一致性与缓存一致性问题之间的关系，就是实现内存一致性时需要利用到底层的缓存一致性（之后的volatile关键字会涉及）。</p><h2 id="四、并发编程的特性"><a href="#四、并发编程的特性" class="headerlink" title="四、并发编程的特性"></a>四、并发编程的特性</h2><p>首先我们要先了解并发编程的三大特性：原子性，可见性，有序性；</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指一个操作是不可间断的，即使是多个线程同时执行，该操作也不会被其他线程所干扰。<br>既操作的连续性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 具有原子性，赋值</span><br></pre></td></tr></table></figure></p><p>i++;<br>不具备原子性<br><code>因为i++juyou多部操作1、读取 i 的值到内存空间2、i + 13、刷新结果到内存</code></p><p>多个具备原子性操作放在一起并不具备原子性<br>y=x</p><p>先读取x的值到内存空间 x = 10； 这一步具备原子性<br>在给y赋值 y = 10; 也一步也具备原子性<br>但y=x不具备原子性</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>内存可见性（Memory visibility）是指当某个线程正在使用对象状态而同时另一个线程正在修改该状态，此时需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><p>每个线程都有一个私有的本地工作内存并存储了线程间读/写的共享副本。</p><p>如果某个线程对这个副本中值进行修改，却没有对主内存进行同步，则会导致其他线程访问过时的数据。</p><p>使用volatile关键字就可以保证数据在不同线程副本的可见性，当有线程在副本中进行修改，就会强制修改主内存中值，同步到其他线程的副本中。<br>保证所有线程访问到值都为最新值</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性即程序按照我们代码所书写的那样，按其先后顺序执行。第一次接触这个特性可能会有所疑惑，所以在了解有序性之前我们需要来了解执行重排序以及相关概念。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了提高性能，编译器和处理器会对程序的指令做重排序操作，重排序分为3种类型：</p><ul><li>编译器优化的重排序：属于编译器重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</li><li>指令级并行的重排序：属于处理器重排序，现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序；</li><li>内存系统的重排序：处于处理器重排序由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul><p>指令重排序对于程序执行有利有弊，我们并不是要去完全禁止它。<br>对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型个的内存屏障指令，通过内存屏障指令来禁止特定的处理器重排序。</p><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>不管如何重排序，要保证程序运行的结果保持不变，编译器、runtime和处理器都必须遵循as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 1</span><br><span class="line">int y = 20; // 2</span><br><span class="line">int a = x + y; // 3</span><br></pre></td></tr></table></figure></p><p>明显第3行依赖于第2行、第1行，所以第三行不会重排序，而第1行、第2行可能会被重排序。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>如果说 as-if-serial 是 JMM 提供用来解决单线程间的内存可见性问题的话，那么 happens-before 就是JMM向程序员提供的可跨越线程的内存可见性保证。<br>具体表现为：如果线程A的写操作a与线程B的读操作b之间具有 happens-before 关系，那么JMM将保证这个操作a对操作b可见。<br>此外，happens-before 还有传递关系，表现为：a happens-before b，b happens-before c，那么a happens-before c。</p><p>注意：两个操作之间存在happens-before关系，并不意味着一个操作必须要在后一个操作之前执行，只要求前一个操作执行的结果对后一个操作可见。<br>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不违法（也就是说，JMM允许这种重排序）。</p><p><code>比对 happens-before 与 as-if-serial。</code></p><ul><li><p>1、as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</p></li><li><p>2、as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。</p></li><li><p>3、as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、现代计算机内存模型&quot;&gt;&lt;a href=&quot;#一、现代计算机内存模型&quot; class=&quot;headerlink&quot; title=&quot;一、现代计算机内存模型&quot;&gt;&lt;/a&gt;一、现代计算机内存模型&lt;/h2&gt;&lt;p&gt;早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>NDK c语言基础 (一)</title>
    <link href="hexo/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%80.html"/>
    <id>hexo/blog/2021/03/NDK-c语言基础-一.html</id>
    <published>2021-03-01T08:07:48.000Z</published>
    <updated>2021-03-05T03:32:37.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言基础"><a href="#c语言基础" class="headerlink" title="c语言基础"></a>c语言基础</h1><h2 id="创建C语言程序"><a href="#创建C语言程序" class="headerlink" title="创建C语言程序"></a>创建C语言程序</h2><p>xcode -&gt; create new xcode project -&gt; macos -&gt; command line tools<br>在macos系统即可创建一个c语言程序</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>int 整型，占4个字节<br>double 双精度小数 占8个字节<br>float 单精度小数 占4个字节<br>char 字符 占1个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d\n&quot;, i, sizeof(i));</span><br><span class="line">double db = 1.34;</span><br><span class="line">printf(&quot;db的值:%lf,所占字节%d\n&quot;, db, sizeof(db));</span><br><span class="line">float fl = 1.12;</span><br><span class="line">printf(&quot;fl的值:%f,所占字节%d\n&quot;, fl, sizeof(fl));</span><br><span class="line">char ch = &apos;A&apos;;</span><br><span class="line">printf(&quot;ch的值:%c,所占字节%d\n&quot;, ch, sizeof(ch));</span><br></pre></td></tr></table></figure><p>打印结果：<br>i的值:2,所占字节4<br>db的值:1.340000,所占字节8<br>fl的值:1.120000,所占字节4<br>ch的值:A,所占字节1</p><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>使用 &amp; 变量 即可获取到变量的内存地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d， 内存地址为%p\n&quot;, i, sizeof(i), &amp;i);</span><br></pre></td></tr></table></figure></p><p>i的值:2,所占字节4， 内存地址为0x7ffeefbff4c8</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>&amp;i 既是取出i的内存地址，也是i的指针。<br>或者换个说法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">int * i_p = &amp;i;</span><br></pre></td></tr></table></figure></p><p>取出指针的值使用 *</p><ul><li>i_p 既可取出值 i = 10；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 22;</span><br><span class="line">int * i_p = &amp;i;</span><br><span class="line">printf(&quot;i 的值：%d, i_p指针指向的值: %d \n&quot;, i, *i_p);</span><br><span class="line">printf(&quot;i的地址：%p, i_p的地址%p \n&quot;, i_p, &amp;i_p);</span><br></pre></td></tr></table></figure><p>打印：<br>    i 的值：22, i_p指针指向的值: 22<br>    i的地址：0x7ffeefbff4c8, i_p的地址0x7ffeefbff4c0<br>可以是 &amp; 对指针再次取内存地址</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5];</span><br><span class="line">printf(&quot;a的值：%p， a的内存地址：%p, a[0]的地址%p\n&quot;, a, &amp;a, &amp;a[0]);</span><br></pre></td></tr></table></figure><p>打印结果：a的值：0x7ffeefbff4b0， a的内存地址：0x7ffeefbff4b0, a[0]的地址0x7ffeefbff4b0</p><p>可以看到 打印 a、&amp;a、&amp;a[0]出现的结果都一样。</p><p><strong> 1、为何a与&amp;a一样 </strong><br>因为a是数组，除基本数据类型外的其他变量，变量本身就是指向内存地址的。所以 a == &amp;a<br><strong> 2、为何&amp;a与&amp;a[0]一样 </strong><br>因为a是数组，数组内存连续，所以数组下标为0的内存地址就是数组本身的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int j = 0;</span><br><span class="line">for (j = 0; j &lt; 5; j ++) &#123;</span><br><span class="line">    printf(&quot;当前下标为%d,下标内存地址为%p\n&quot;, j, &amp;a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>    当前下标为0,下标内存地址为0x7ffeefbff4b0<br>    当前下标为1,下标内存地址为0x7ffeefbff4b4<br>    当前下标为2,下标内存地址为0x7ffeefbff4b8<br>    当前下标为3,下标内存地址为0x7ffeefbff4bc<br>    当前下标为4,下标内存地址为0x7ffeefbff4c0<br>可以看到内存地址以每次为4增加，因为这是int数组，int占4个字节，所以每次增加4</p><h2 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * p = &amp;a[j] + 1;</span><br><span class="line">printf(&quot;p的值为:%p\n&quot;, p);</span><br><span class="line">*(&amp;a[j] + 0) = j;</span><br></pre></td></tr></table></figure><p>&amp;a[j] 是取出下标j处的地址。<br>&amp;a[j] + 1 是指针在a[j]处偏移1位，既指向a[j + 1];<br>*(&amp;a[j] + 0) = j; + 0 其实相当于未偏移，就是对a[j]赋值</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>首先函数指针的申明格式：函数返回值类型 (* 指针变量名) (函数参数列表);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void add(int a, int b)&#123;</span><br><span class="line">    printf(&quot;sum = %d\n&quot;, a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(void (*method)(int, int), int a, int b) &#123;</span><br><span class="line">    method(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello \n&quot;);</span><br><span class="line">    test(add, 3, 4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在test函数入参中，有一个函数指针，<br>在main函数中，调用test函数，并将add函数作为入参传递到test函数中。</p><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>指向指针的指针就是多级指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    </span><br><span class="line">    int a = 0;</span><br><span class="line">    int * b = &amp;a;</span><br><span class="line">    int **c = &amp;b;</span><br><span class="line">    int *** d = &amp;c;</span><br><span class="line">    printf(&quot;d的地址%p \n&quot;, d);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用来表示多维数组</p><h2 id="静态分配内存"><a href="#静态分配内存" class="headerlink" title="静态分配内存"></a>静态分配内存</h2><p>在c语言中，内存区域分为栈区、堆区</p><p>函数被调用时，就会进栈，函数执行完毕则会出栈，而在函数中默认方式申明生成的数据都是系统静态分配内存的，<br>当函数执行完毕，出栈后，在该函数中静态分配的内存会被回收，系统会自己执行，无需手动处理。<br>静态分配内存都是在栈区</p><p>栈区总容量较小，大约是2M，各个系统、设备可能不一致，超出会抛出异常</p><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>动态分配内存需要手动调用API才可，动态分配的内存不会自动回收，动态分配的内存都是在堆区。<br>堆区总容量较大，至少超过40M，各个系统、设备可能不一致， 超出也会抛出异常。</p><p>调用动态分配内存：malloc(int size)函数<br>调用回收动态内存：free(void *);</p><p>需要额外引入依赖文件：#include &lt;stdlib.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int num;</span><br><span class="line">    printf(&quot;请输入数字\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">    printf(&quot;num的值为：%d\n&quot;, num);</span><br><span class="line">    </span><br><span class="line">    int * arr = (int *)malloc(sizeof(int) * num);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0; i &lt; num; i ++) &#123;</span><br><span class="line">        arr[i] = i + 10000;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; num; ++i) &#123;</span><br><span class="line">        printf(&quot;%d对应值为%d\n&quot;, i, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重新分配"><a href="#重新分配" class="headerlink" title="重新分配"></a>重新分配</h3><p>就是将之前动态分配的内存重新分配，使用：realloc(void *<strong>ptr, size_t </strong>size);<br>第一个参数：原来的内存指针<br>第二个参数：新的内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int * new_arr = (int *)realloc(arr, sizeof(int) * (num + new_num));</span><br><span class="line">if(new_arr) &#123;</span><br><span class="line">    int j = num;</span><br><span class="line">    for (; j &lt; (num + new_num); j ++) &#123;</span><br><span class="line">        new_arr[j] = j + 100000;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt; (num + new_num); i ++) &#123;</span><br><span class="line">        printf(&quot;新数组第%d个值为%d\n&quot;, i, new_arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(new_arr);</span><br><span class="line">    new_arr = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 题目 </strong><br>截取字符串中指定字符<br>char c = “ABCDEFGHIJK”;</p><p>截取第3位到第6位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void substring(char * result, char *str, int start, int end) &#123;</span><br><span class="line">    for (int i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        printf(&quot;char:%c\n&quot;, *(str + i));</span><br><span class="line">        *(result++) = *(str + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char * str = &quot;ABCDEFGHIJK&quot;;</span><br><span class="line">    char * result;</span><br><span class="line">    substring(result, str, 3, 6);</span><br><span class="line">    printf(&quot;result:%c\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c语言基础&quot;&gt;&lt;a href=&quot;#c语言基础&quot; class=&quot;headerlink&quot; title=&quot;c语言基础&quot;&gt;&lt;/a&gt;c语言基础&lt;/h1&gt;&lt;h2 id=&quot;创建C语言程序&quot;&gt;&lt;a href=&quot;#创建C语言程序&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="c语言" scheme="hexo/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>https详解</title>
    <link href="hexo/blog/2021/02/https%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2021/02/https详解.html</id>
    <published>2021-02-25T07:57:53.000Z</published>
    <updated>2021-02-25T07:59:06.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Https详解"><a href="#Https详解" class="headerlink" title="Https详解"></a>Https详解</h1><h2 id="什么是Https"><a href="#什么是Https" class="headerlink" title="什么是Https"></a>什么是Https</h2><p>在说HTTPS之前先说说什么是HTTP，HTTP就是我们平时浏览网页时候使用的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。<br>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br>SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，<br>之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，<br>但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，<br>今后TLS将会继承SSL优良血统继续为我们进行加密服务。目前TLS的版本是1.2，定义在RFC 5246中，暂时还没有被广泛的使用 ()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Https详解&quot;&gt;&lt;a href=&quot;#Https详解&quot; class=&quot;headerlink&quot; title=&quot;Https详解&quot;&gt;&lt;/a&gt;Https详解&lt;/h1&gt;&lt;h2 id=&quot;什么是Https&quot;&gt;&lt;a href=&quot;#什么是Https&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="hexo/blog/2021/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>hexo/blog/2021/02/观察者模式.html</id>
    <published>2021-02-24T09:37:52.000Z</published>
    <updated>2021-02-25T07:55:59.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式的定义与特点："><a href="#观察者模式的定义与特点：" class="headerlink" title="观察者模式的定义与特点："></a>观察者模式的定义与特点：</h1><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><p>观察者模式是一种对象行为型模式，其主要优点如下：</p><ol><li><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</p></li><li><p>目标与观察者之间建立了一套触发机制。</p></li></ol><p>它的主要缺点如下：</p><ol><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;观察者模式的定义与特点：&quot;&gt;&lt;a href=&quot;#观察者模式的定义与特点：&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的定义与特点：&quot;&gt;&lt;/a&gt;观察者模式的定义与特点：&lt;/h1&gt;&lt;p&gt;观察者（Observer）模式的定义：指多个对象间存在一对多
      
    
    </summary>
    
    
      <category term="设计模式" scheme="hexo/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>android 屏幕渲染</title>
    <link href="hexo/blog/2021/02/android-%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93.html"/>
    <id>hexo/blog/2021/02/android-屏幕渲染.html</id>
    <published>2021-02-23T09:31:33.000Z</published>
    <updated>2021-02-24T05:43:09.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h1><p> CPU负责计算数据，把计算好数据交给GPU,<br> GPU会对图形数据进行渲染，渲染好后放到buffer里存起来<br> display负责将buffer里的数据显示在屏幕</p><p> 简单的说就是CPU/GPU准备好数据，存入buffer，<br> display每隔一段时间去buffer里取数据，然后显示出来。<br> display读取的频率是固定的，比如每个16ms读一次，但是CPU/GPU写数据是完全无规律的</p><p>底层每16ms会发送一次VSync，更新界面</p><p>CPU：执行应用层的measure、layout、draw等操作，绘制完成后将数据提交给GPU<br>GPU：进一步处理数据，并将数据缓存起来<br>屏幕：由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点</p><p>因为display取buffer数据渲染的频率固定，而GPU往buffer写数据却是不固定的，难免存在场景：GPU还在往buffer写数据，但此时display正要显示，此时就会显示异常。</p><p>为避免这种现象，引入一种新方案：双缓存机制</p><h2 id="双缓存机制"><a href="#双缓存机制" class="headerlink" title="双缓存机制"></a>双缓存机制</h2><p>android的渲染机制中引入双缓存机制。新增一个缓存 back buffer, back buffer 会定时与 frame buffer交换数据</p><p><img src="../../../images/buffer.png" style="zoom:70%"></p><p><strong> 当你的应用正在往Back Buffer中填充数据时，系统会将Back Buffer锁定。<br>如果到了GPU交换两个Buffer的时间点，你的应用还在往Back Buffer中填充数据，GPU会发现Back Buffer被锁定了，它会放弃这次交换。 </strong></p><p>这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的丢帧，<br>所以为了避免丢帧的发生，我们就要尽量减少布局层级，减少不必要的View的invalidate调用，减少大量对象的创建（GC也会占用CPU时间）等等</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong> Q1：Android 每隔 16.6 ms 刷新一次屏幕到底指的是什么意思？是指每隔 16.6ms 调用 onDraw() 绘制一次么？<br>Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？</strong></p><p>答：我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面，而这个每一帧的画面数据就是我们 app 在接收到屏幕刷新信号之后去执行遍历绘制 View 树工作所计算出来的屏幕数据。而 app 并不是每隔 16.6ms 的屏幕刷新信号都可以接收到，只有当 app 向底层注册监听下一个屏幕刷新信号之后，才能接收到下一个屏幕刷新信号到来的通知。而只有当某个 View 发起了刷新请求时，app 才会去向底层注册监听下一个屏幕刷新信号。</p><p>也就是说，只有当界面有刷新的需要时，我们 app 才会在下一个屏幕刷新信号来时，遍历绘制 View 树来重新计算屏幕数据。如果界面没有刷新的需要，一直保持不变时，我们 app 就不会去接收每隔 16.6ms 的屏幕刷新信号事件了，但底层仍然会以这个固定频率来切换每一帧的画面，只是后面这些帧的画面都是相同的而已。</p><p><strong> Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？ </strong></p><p>答：我们 app 只负责计算屏幕数据而已，接收到屏幕刷新信号就去计算，计算完毕就计算完毕了。至于屏幕的刷新，这些是由底层以固定的频率来切换屏幕每一帧的画面。所以即使屏幕数据都计算完毕，屏幕会不会马上刷新就取决于底层是否到了要切换下一帧画面的时机了。</p><p><strong> Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？ </strong> </p><p>之所以提了这个问题，是因为之前是以为如果某个 View 发起了刷新请求，比如调用了 invalidte()，那么它的重绘工作就马上开始执行了，所以以前在看网上那些介绍屏幕刷新机制的博客时，经常看见下面这张图：</p><p>那个时候就是不大理解，为什么每一次 CPU 计算的工作都刚刚好是在每一个信号到来的那个瞬间开始的呢？毕竟代码里发起刷新屏幕的操作是动态的，不可能每次都刚刚好那么巧。</p><p>梳理完屏幕刷新机制后就清楚了，代码里调用了某个 View 发起的刷新请求，这个重绘工作并不会马上就开始，而是需要等到下一个屏幕刷新信号来的时候才开始，所以现在回过头来看这些图就清楚多了。</p><p><strong> Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？ </strong></p><p>答：造成丢帧大体上有两类原因，一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms；二是，主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。</p><p>第一个原因就是我们写的布局有问题了，需要进行优化了。而第二个原因则是我们常说的避免在主线程中做耗时的任务。</p><p>针对第二个原因，系统已经引入了同步屏障消息的机制，尽可能的保证遍历绘制 View 树的工作能够及时进行，但仍没办法完全避免，所以我们还是得尽可能避免主线程耗时工作。</p><p>其实第二个原因，可以拿出来细讲的，比如有这种情况， message 不怎么耗时，但数量太多，这同样可能会造成丢帧。如果有使用一些图片框架的，它内部下载图片都是开线程去下载，但当下载完成后需要把图片加载到绑定的 view 上，这个工作就是发了一个 message 切到主线程来做，如果一个界面这种 view 特别多的话，队列里就会有非常多的 message，虽然每个都 message 并不怎么耗时，但经不起量多啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渲染机制&quot;&gt;&lt;a href=&quot;#渲染机制&quot; class=&quot;headerlink&quot; title=&quot;渲染机制&quot;&gt;&lt;/a&gt;渲染机制&lt;/h1&gt;&lt;p&gt; CPU负责计算数据，把计算好数据交给GPU,&lt;br&gt; GPU会对图形数据进行渲染，渲染好后放到buffer里存起来&lt;br&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>面试题答案</title>
    <link href="hexo/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.html"/>
    <id>hexo/blog/2021/02/面试题答案.html</id>
    <published>2021-02-02T06:59:23.000Z</published>
    <updated>2021-02-23T07:23:30.115Z</updated>
    
    <content type="html"><![CDATA[<p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage</p><p>而在MessageQueue的enqueueMessage中。就会根据when大小插入到链表，when越小就在链表越前，其实相当于根据时间排序，越接近的时间越在链头</p><p>Looper中的消息既能同步也能异步，在Handler的构造时传入async = true；即为异步消息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息&lt;/p&gt;
&lt;p&gt;当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&amp;gt; enqueue
      
    
    </summary>
    
    
      <category term="面试" scheme="hexo/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题合集</title>
    <link href="hexo/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html"/>
    <id>hexo/blog/2021/02/面试题合集.html</id>
    <published>2021-02-02T06:54:45.000Z</published>
    <updated>2021-02-02T06:57:54.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android"><a href="#android" class="headerlink" title="android"></a>android</h1><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1、Object的方法有哪些？</p><p>2、为什么要有HashCode方法，hash算法的原理，在Java中哪些地方用到，进而问到了HashMap的源码</p><p>3、Java有几种锁，synchronized与Lock有什么区别，Lock的实现原理，有没有碰到死锁的情况</p><p>4、Android源码中用到了哪些设计模式，举例说明</p><p>5、一个Android正常启动有多少个线程?(这里当时是比较懵逼的，第一反应是一个主线程，然后觉得应该不止这么简单，想到应用Activity启动的话，应该还有2个Binder线程，可能一个管理JVM的线程，面试官接着问还有哪些。。果断放弃不知道…)</p><p>6、Binder机制的实现思想</p><p>7、简单描述Https的实现思路</p><p>8、描述下快速排序的思想，时间复杂度？什么场景对应着最坏情况？</p><p>9、给定无序数组和一个值，找到两个数和为值的元素，不能使用额外空间复杂度（不要使用HashMap）</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面是视频面试，还是个周六下午。。。</p><p>1、TCP/IP四层模型，网络层和传输层有什么区别？网络层的主要工作是什么</p><p>2、socket.accept()函数对应着TCP三次握手中哪一次握手，哪个函数代表连接建立完毕，四次挥手的过程？</p><p>3、有做过哪些优化工作，卡顿优化，内存优化，启动优化，APK体积优化，每个做了哪些工作</p><p>4、JNI开发中有碰到什么问题？怎么定位native crash</p><p>5、递归非递归反转链表</p><p>6、打印回环数组</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>2、事件分发机制的源码</p><p>3、android的屏幕刷新机制，怎么优化UI卡顿情况</p><p>4、有没有使用过插件化框架，实现原理？</p><p>5、你在项目中碰到什么比较棘手的问题？怎么解决的？</p><p>6、找到一个无序数组中第一次出现最多次数的元素</p><h2 id="某手机海外部门（offer）"><a href="#某手机海外部门（offer）" class="headerlink" title="某手机海外部门（offer）"></a>某手机海外部门（offer）</h2><p>上来就是笔试题，其实之前没怎么做过面试题，难道现在都是这个套路了….？20分钟后做完就开始面试了</p><p>1、手写线程安全的观察者模式</p><p>2、找到一个字符串中出现最多的字母</p><p>3、描述Java面对对象六大原则针对项目中谈谈自己的看法</p><p>4、android阅读过哪些源码，举例说明</p><p>5、项目中的优化工作，内存，卡顿优化，leakcanary的原理实现</p><p>6、Tcp/Udp的区别，项目中的C/S端双向认证如何实现</p><p>7、项目中有碰到过哪些比较难解决的问题。</p><p>8、android 8.0，9.0有哪些新特性，有没有了解过</p><h2 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h2><p>1、HashMap的原理以及android中为什么建议用ArrayMap和SpareArray替代HashMap？</p><p>2、android如何保证进程不被杀死</p><p>3、Java怎么与C++进行交互，以及native crash如何定位的</p><p>4、C/S如何保证双向认证（项目中使用到的，可以理解为Https的原理），用到了哪些加密算法</p><p>5、LBS定位如何去除野点（指因为定位偏差过大的点），大数据量如何和后台交互？</p><p>6、设计模式用过哪些，动态代理的原理？</p><p>7、项目中有做过哪些优化，优化成效如何？</p><h2 id="TCL（offer）"><a href="#TCL（offer）" class="headerlink" title="TCL（offer）"></a>TCL（offer）</h2><p>是一个猎头推荐的一个职位，主要应该是做TV上的相关项目，有VR类型类似的项目等等，一面居然是一个妹子和一个男的一起进来的，还是第一次遇到，没问多少基础知识点，更多的是根据自身项目问一些东西</p><p>1、TCP/UDP的区别，有看过具体报文的信息吗</p><p>2、你觉得开发一个SDK，需要注意哪些地方，有没有做过SDK性能测试</p><p>3、有了解过音视频的编解码吗</p><p>4、你觉得你这个项目中比较难的地方在哪里，你是如何解决的</p><p>5、开放题：让你加载一个200M左右的GIF，如何实现及优化，不可降低画质</p><p>6、如何优化一个列表滑动的流畅性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android&quot;&gt;&lt;a href=&quot;#android&quot; class=&quot;headerlink&quot; title=&quot;android&quot;&gt;&lt;/a&gt;android&lt;/h1&gt;&lt;h2 id=&quot;腾讯&quot;&gt;&lt;a href=&quot;#腾讯&quot; class=&quot;headerlink&quot; title=&quot;腾
      
    
    </summary>
    
    
      <category term="面试" scheme="hexo/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="hexo/blog/2021/02/%E5%B9%B6%E5%8F%91.html"/>
    <id>hexo/blog/2021/02/并发.html</id>
    <published>2021-02-01T10:01:22.000Z</published>
    <updated>2021-03-02T07:30:59.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发指单位时间的访问量<br>并行指同一时刻的访问量</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><ul><li><p>ABA问题</p></li><li><p>开销问题</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h1&gt;&lt;p&gt;并发指单位时间的访问量&lt;br&gt;并行指同一时刻的访问量&lt;/p&gt;
&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoinTask</title>
    <link href="hexo/blog/2021/01/ForkJoinTask.html"/>
    <id>hexo/blog/2021/01/ForkJoinTask.html</id>
    <published>2021-01-27T05:59:20.000Z</published>
    <updated>2021-01-27T05:59:46.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h1><p>ForkJoin 是采用分而治之的思维，将一个大任务分解为若干个相互独立的子任务（异步），<br>达到提高运算效率。<br>我们做一个简单的运算 计算1-100000的累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class TestJoinTask &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; task = pool.submit(new MyForkJoinTask(1, 100000));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int result = task.get();</span><br><span class="line">            System.out.println(&quot;result = &quot; + result);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行完毕&quot; + &quot;   time = &quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传入的范型Integer是返回结果类型</span><br><span class="line">     */</span><br><span class="line">    static class MyForkJoinTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private int startValue;</span><br><span class="line"></span><br><span class="line">        private int endValue;</span><br><span class="line"></span><br><span class="line">        private int limitValue = 100;</span><br><span class="line"></span><br><span class="line">        public MyForkJoinTask(int startValue, int endValue) &#123;</span><br><span class="line">            if(startValue &gt; endValue) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;startValue &lt; endValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            this.startValue = startValue;</span><br><span class="line">            this.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Integer compute() &#123;</span><br><span class="line">            if(endValue - startValue &lt;= limitValue) &#123;</span><br><span class="line">                System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行计算&quot;);</span><br><span class="line">                // 两个值在限制值内 进行计算</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for(int i = startValue; i &lt;= endValue; i ++) &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">            MyForkJoinTask task1 = new MyForkJoinTask(startValue, (endValue + startValue) / 2);</span><br><span class="line">            task1.fork();</span><br><span class="line">            MyForkJoinTask task2 = new MyForkJoinTask((endValue + startValue) / 2 + 1, endValue);</span><br><span class="line">            task2.fork();</span><br><span class="line">            return task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们将一个从0 - 100000的累加任务分解为500个子任务：每200位数累加</p><p>在日志打印中，我们可以看到，有多个线程在执行任务，也就是说，分解的任务其实都是提交到线程池中执行，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ForkJoinTask&quot;&gt;&lt;a href=&quot;#ForkJoinTask&quot; class=&quot;headerlink&quot; title=&quot;ForkJoinTask&quot;&gt;&lt;/a&gt;ForkJoinTask&lt;/h1&gt;&lt;p&gt;ForkJoin 是采用分而治之的思维，将一个大任务分解为若
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android ViewPager/ViewPager2解析</title>
    <link href="hexo/blog/2021/01/android-ViewPager-ViewPager2%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-ViewPager-ViewPager2解析.html</id>
    <published>2021-01-22T01:57:40.000Z</published>
    <updated>2021-01-22T02:49:39.745Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android RecyclerView解析</title>
    <link href="hexo/blog/2021/01/android-RecyclerView%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-RecyclerView解析.html</id>
    <published>2021-01-22T01:57:27.000Z</published>
    <updated>2021-01-22T02:49:34.798Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android ListView解析</title>
    <link href="hexo/blog/2021/01/android-ListView%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-ListView解析.html</id>
    <published>2021-01-22T01:57:15.000Z</published>
    <updated>2021-01-22T05:40:53.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ListView解析"><a href="#ListView解析" class="headerlink" title="ListView解析"></a>ListView解析</h1><p>首先是简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ListViewActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_list_view)</span><br><span class="line">        var list = arrayListOf(Person(&quot;novia&quot;, 24), Person(&quot;justin&quot;, 29), Person(&quot;doudou&quot;, 1))</span><br><span class="line">        var adapter = MyListAdapter(list, this)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyListAdapter(var list: ArrayList&lt;Person&gt;, var context: Context) : BaseAdapter() &#123;</span><br><span class="line">        override fun getCount(): Int &#123;</span><br><span class="line">            return list.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getItem(position: Int): Person &#123;</span><br><span class="line">            return list.get(position);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getItemId(position: Int): Long &#123;</span><br><span class="line">            return list.get(position).hashCode().toLong()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123;</span><br><span class="line">            var view = LayoutInflater.from(context).inflate(R.layout.item_listview, parent, false)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_name).setText(getItem(position).name)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_age).setText(&quot;&quot; + getItem(position).age + &quot;岁&quot;)</span><br><span class="line">            return view;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data class Person(var name: String, var age: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是ListView的特点是会将所有条目都渲染出来，当子条目较多时，会存在性能问题，当加载图片时，甚至会导致OOM</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ListView解析&quot;&gt;&lt;a href=&quot;#ListView解析&quot; class=&quot;headerlink&quot; title=&quot;ListView解析&quot;&gt;&lt;/a&gt;ListView解析&lt;/h1&gt;&lt;p&gt;首先是简单使用&lt;br&gt;&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
</feed>
