<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2022-11-22T08:49:43.821Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题</title>
    <link href="hexo/blog/2022/11/%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>hexo/blog/2022/11/面试题.html</id>
    <published>2022-11-22T08:36:37.000Z</published>
    <updated>2022-11-22T08:49:43.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h2><p>1、react生命周期<br>2、是否了解hooks<br>3、react中使用class与hooks的差异<br>4、原型链、原型<br>5、Promise<br>6、ES5、ES6、ES7语法<br>7、Mobx状态管理特点，是否了解redux，两者差异<br>8、高阶组件、高级函数、柯里化函数（<a href="https://blog.csdn.net/weixin_44827418/article/details/121343033）" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44827418/article/details/121343033）</a><br>9、适配，如何响应式布局<br>10、react-native原理，<br>11、原生开发能力<br>12、算法：<br>  有序数组，查找，<br>  判断链表有环，<br>  二叉树非递归先序遍历</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端面试题&quot;&gt;&lt;a href=&quot;#前端面试题&quot; class=&quot;headerlink&quot; title=&quot;前端面试题&quot;&gt;&lt;/a&gt;前端面试题&lt;/h2&gt;&lt;p&gt;1、react生命周期&lt;br&gt;2、是否了解hooks&lt;br&gt;3、react中使用class与hooks的差异&lt;br&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bug记录</title>
    <link href="hexo/blog/2022/09/bug%E8%AE%B0%E5%BD%95.html"/>
    <id>hexo/blog/2022/09/bug记录.html</id>
    <published>2022-09-09T02:08:55.000Z</published>
    <updated>2022-09-09T02:48:26.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-native-TextInput键盘类型"><a href="#react-native-TextInput键盘类型" class="headerlink" title="react-native TextInput键盘类型"></a>react-native TextInput键盘类型</h2><p>在使用 react-native TextInput 限制键盘类型 keyboard： decimal-pad 时，<br>发现在部分手机(LG)时显示的是整数键盘，不能输入小数点</p><p>最后发现跟TextInput的样式有关。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">textInput: &#123;</span><br><span class="line">    position: <span class="string">'absolute'</span>,</span><br><span class="line">    bottom: INPUTBOTTOM,</span><br><span class="line">    left: <span class="number">0</span>,</span><br><span class="line">    color: <span class="string">'#555555'</span>,</span><br><span class="line">    fontSize: <span class="number">16</span>,</span><br><span class="line">    height: LABEL_HEIGHT,</span><br><span class="line">    backgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">    padding: <span class="number">1</span>, <span class="comment">//兼容安卓</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>采用了绝对布局，并设置了居左、居下的距离</p><p>发现有两种修改方案：</p><ul><li>去掉left &amp; backgroundColor样式，即可，默认居左,left 0其实无意义</li><li>去掉 backgroundColor &amp; padding，但是此时input会缩小</li></ul><p>为深究此问题查看源码，</p><ul><li>TextInput对应的原生组件： AndroidTextInput</li><li>相关的类：com.facebook.react.views.textinput.ReactTextInputManager</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react-native-TextInput键盘类型&quot;&gt;&lt;a href=&quot;#react-native-TextInput键盘类型&quot; class=&quot;headerlink&quot; title=&quot;react-native TextInput键盘类型&quot;&gt;&lt;/a&gt;react-na
      
    
    </summary>
    
    
      <category term="bug" scheme="hexo/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>PV操作</title>
    <link href="hexo/blog/2022/08/PV%E6%93%8D%E4%BD%9C.html"/>
    <id>hexo/blog/2022/08/PV操作.html</id>
    <published>2022-08-24T05:46:31.000Z</published>
    <updated>2022-08-24T05:46:54.059Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/feixiang_john/article/details/8102573#comments" target="_blank" rel="noopener">https://blog.csdn.net/feixiang_john/article/details/8102573#comments</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/feixiang_john/article/details/8102573#comments&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/fe
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>android系统启动流程</title>
    <link href="hexo/blog/2022/07/android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html"/>
    <id>hexo/blog/2022/07/android系统启动流程.html</id>
    <published>2022-07-27T02:56:00.000Z</published>
    <updated>2022-07-27T10:06:24.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><ul><li><p>大致启动顺序：</p><ul><li>BootRom-&gt;BootLoader-&gt;Linux Kernel-&gt;Init-&gt;Zygote-&gt;SystemServer-&gt;Launcher</li></ul></li><li><p>BootLoader层：主要包括Boot Rom和Boot Loader</p></li><li>Kernel层：主要是Android内核层</li><li>Native层：主要是包括init进程以及其fork出 来的用户空间的守护 进程、  HAL层、开机动画等</li><li>JAVA Framework层：主要是AMS和PMS等Service的初始化</li><li>Application层：主要指SystemUI、  Launcher的启动</li></ul><h3 id="1-1-大致启动流程"><a href="#1-1-大致启动流程" class="headerlink" title="1.1 大致启动流程"></a>1.1 大致启动流程</h3><ul><li><p>1、手机开机后，引导芯片启动，引导芯片开始从固化在 ROM 里的预设代码执行，加载引导程序到到 RAM，bootloader检 查RAM，初始化硬件参数等功能；</p></li><li><p>2、硬件等参数初始化完成后，进入到Kernel层，  Kernel层  主要加载一些硬件设备驱动，初始化进程管理等操作。在 Kernel 中首先<strong>启动swapper进程(pid=0)</strong>，用于初始化进程管理、内管 管理、加载Driver等操作，再启动 <strong>kthread进程(pid=2)</strong>,这些linux系统的内核进程，<strong>kthread是所有内核进程的鼻祖</strong>；</p></li><li><p>3、Kernel层加载完毕后，硬件设备驱动与HAL层进行交互。初始化进程管理等操作会启动<strong>init进程(pid=1)</strong>，这些在Native层中；</p></li><li><p>4、 <strong>init进程(pid=1，init进程是所有用户进程的鼻祖，第一个启动)</strong>启动后，会启动 adbd，logd 等用户守护进程，并且会启动 ServiceManager(binder服务管家) 等重要服务，同时<strong>fork出 zygote 进程</strong>，这里属于 C++ Framework，代码为C++程序；</p></li><li><p>5、zygote进程是由init进程解析init.rc文件后fork生成，它会加载虚拟机，启动System Server(zygote孵化的第一个进程)； System Server负责启动和管理整个Java Framework，包含 ActivityManager，  WindowManager，  PackageManager， PowerManager等服务；</p></li><li><p>6、zygote同时会启动相关的APP进程，它启动的第一个APP 进程为Launcher，然后启动Email，  SMS等进程，所有的APP进程 都有zygote fork生成。</p></li></ul><h2 id="2、init进程"><a href="#2、init进程" class="headerlink" title="2、init进程"></a>2、init进程</h2><h3 id="2-1、概述"><a href="#2-1、概述" class="headerlink" title="2.1、概述"></a>2.1、概述</h3><ul><li>init进程是linux系统中用户空间的第一个进程，进程号为1.</li></ul><blockquote><p>当bootloader启动后，启动kernel，<br>kernel启动完后，在用户空间启动init进程，<br>再通过init进程，来读取init.rc中的相关配置，从而来启动其他相关进程以及其他操作。</p></blockquote><ul><li>init进程被赋予了很多重要工作，  init进程启动主要分为两个阶段：<ul><li>第一个阶段完成以下内容：<ul><li>ueventd/watchdogd跳转及环境变量设置</li><li>挂载文件系统并创建目录</li><li>初始化日志输出、挂载分区设备</li><li>启用SELinux安全策略</li><li>开始第二阶段前的准备</li></ul></li><li>第二个阶段完成以下内容：<ul><li>初始化属性系统</li><li>执行SELinux第二阶段并恢复一些文件安全上下文</li><li>新建epoll并初始化子进程终止信号处理函数</li><li>设置其他系统属性并开启属性服务</li></ul></li></ul></li></ul><h3 id="2-2-init进程如何被启动？"><a href="#2-2-init进程如何被启动？" class="headerlink" title="2.2 init进程如何被启动？"></a>2.2 init进程如何被启动？</h3><p><img src="../../../images/init1.png" style="zoom:60%"></p><ul><li><p>kernel 启动后，完成一些init的初始化操作，然后去系统根目 录下依次找 <strong>ramdisk_execute_command</strong>和<strong>execute_command</strong>设置的应用程序，如果这两个目录都找不到，就依次去根目录下找  /sbin/init，  /etc/init，  /bin/init,/bin/sh 这四个应用程序进行启动，只要这些应用程序有一个启动了，其他就不启动了。</p></li><li><p>Android系统一般会在根目录下放一个init的可执行文件，也就是 说Linux系统的init进程在内核初始化完成后，就直接执行init这个 文件。</p></li></ul><h3 id="2-3-init启动后，做了哪些事？"><a href="#2-3-init启动后，做了哪些事？" class="headerlink" title="2.3 init启动后，做了哪些事？"></a>2.3 init启动后，做了哪些事？</h3><p><img src="../../../images/init2.png" style="zoom:60%"></p><p>init进程启动后:</p><ul><li>首先挂载文件系统、再挂载相应的分区</li><li>启动SELinux安全策略，启动属性服务，解析rc文件，并启动相应属性服务进程</li><li>初始化epoll，依次设置signal、  property、  keychord 这3个fd可读时相对应的回调函数。</li><li>进入无线循环，用来响应各个 进程的变化与重建。</li></ul><h3 id="2-4-kernel启动init进程-源码分析"><a href="#2-4-kernel启动init进程-源码分析" class="headerlink" title="2.4 kernel启动init进程 源码分析"></a>2.4 kernel启动init进程 源码分析</h3><h2 id="系统启动之-SystemServer进程"><a href="#系统启动之-SystemServer进程" class="headerlink" title="系统启动之 SystemServer进程"></a>系统启动之 SystemServer进程</h2><ul><li>当 zygote进是由init进程解析init.rc文件fork生成后，会加载虚拟机，启动System Server(zygote孵化的第一个进程)；</li></ul><p><img src="../../../images/systemservice.png" style="zoom:60%"></p><h2 id="6-应用进程创建"><a href="#6-应用进程创建" class="headerlink" title="6.应用进程创建"></a>6.应用进程创建</h2><p>App发起进程：点击一个桌面应用(例如微信)， Launcher 加载  应用， LauncherActivity 收到触发事件，组装Intent，通过binder 发送消息给 SystemServer 进程，调用Activity的startActivity()来启 动进程，启动Activity时，受ActivityManagerService-AMS的服务 控制，  AMS属于SystemServer进程，因此SystemServer进行会通 过Process 来向Zygote发送一个Socket。</p><p>Zygote有一个无限循环，  一直在等待Socket请求，  收到 SystemServer 发来新的Socket请求后，  Zygote调用系统的fork函 数来孵化一个新的进程，比如这里的微信。<br>再把启动的入口交给ActivityThread，  进入微信的进程中，  进行详细 的UI展示。</p><p><img src="../../../images/process1.png" style="zoom:60%"></p><ul><li>调用链：</li></ul><p>LauncherActivity.onListItemClick  —–&gt;   Activity.startActivity ——&gt;  Activity.startActivityForResult</p><p>—–&gt; Instrumentation.execStartActivity —–&gt;  ActivityTaskManager.getService<strong>(IBinder)</strong></p><p>同时<br>Instrumentation.execStartActivity —–&gt; ActivityTaskManagerService.startActivity</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大致启动顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BootRom-&amp;gt;BootLoader-&amp;gt;Linux
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ViewStub</title>
    <link href="hexo/blog/2022/07/ViewStub.html"/>
    <id>hexo/blog/2022/07/ViewStub.html</id>
    <published>2022-07-19T08:53:57.000Z</published>
    <updated>2022-07-20T02:00:34.353Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://blog.csdn.net/Demon_T/article/details/113941806" target="_blank" rel="noopener">https://blog.csdn.net/Demon_T/article/details/113941806</a></li><li><a href="https://blog.csdn.net/a740169405/article/details/50351013" target="_blank" rel="noopener">https://blog.csdn.net/a740169405/article/details/50351013</a></li></ul><ul><li>ViewStub 实现懒加载，针对 visible 在初始化时不显示的布局</li></ul><h2 id="ViewStub-优势"><a href="#ViewStub-优势" class="headerlink" title="ViewStub 优势"></a>ViewStub 优势</h2><ul><li>ViewStub可以做到按需加载一个布局,我们可以控制它加载的时机,而不是在Activity的onCreate方法中去加载.即懒加载</li><li>它存在于视图层级中，但只会在setVisibility和inflate方法调用只会才会填充视图，所以不会影响初始化加载速度。</li></ul><p><strong>合理使用ViewStub可以起到优化渲染功效</strong></p><ul><li>将复杂的视图放入ViewStub中，不在初始化中加载</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>ViewStub是一个继承了View类的视图。</li><li>ViewStub是不可见的，实际上是把宽高都设置为0</li><li>可以通过布局文件的android:inflatedId或者调用ViewStub的setInflatedId方法为懒加载视图的跟节点设置ID</li><li>ViewStub视图在首次调用setVisibility或者inflate方法之前，一直存在于视图树中</li><li>只需要调用ViewStub的setVisibility或者inflate方法即可显示懒加载的视图</li><li>调用setVisibility或者inflate方法之后，懒加载的视图会把ViewStub从父节点中替换掉</li><li>ViewStub的inflate只能被调用一次，第二次调用会抛出异常，setVisibility可以被调用多次，但不建议这么做（后面说原因）</li><li>为ViewStub赋值的android:layout_属性会替换待加载布局文件的根节点对应的属性</li><li>inflate方法会返回待加载视图的根节点</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/Demon_T/article/details/113941806&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/D
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock 解析</title>
    <link href="hexo/blog/2022/07/ReentrantLock-%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2022/07/ReentrantLock-解析.html</id>
    <published>2022-07-14T08:42:29.000Z</published>
    <updated>2022-07-20T03:09:24.037Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址： <a href="https://blog.csdn.net/persistence_PSH/article/details/114504207" target="_blank" rel="noopener">https://blog.csdn.net/persistence_PSH/article/details/114504207</a></p><h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1. ReentrantLock"></a>1. ReentrantLock</h2><ul><li>ReentrantLock是基于AQS实现，AQS的基础又是CAS</li></ul><ul><li>ReentrantLock 中有三个内部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认为非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可以通过构建对象时传入的boolean来设定锁是否公平</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//尝试获取锁，参数为尝试的时间和时间单位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上是 ReentrantLock 类中的一些主要结构</p><p>看到 Sync 类其实是继承 AbstractQueuedSynchronizer</p><h2 id="2-AbstractQueuedSynchronizer"><a href="#2-AbstractQueuedSynchronizer" class="headerlink" title="2. AbstractQueuedSynchronizer"></a>2. AbstractQueuedSynchronizer</h2><ul><li><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractQueuedSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-静态内部类Node"><a href="#2-1-静态内部类Node" class="headerlink" title="2.1 静态内部类Node"></a>2.1 静态内部类Node</h3><ul><li>ReentrantLock实现的前提就是AbstractQueuedSynchronizer，简称AQS，是java.util.concurrent的核心，CountDownLatch、FutureTask、Semaphore、ReentrantLock等都有一个内部类是这个抽象类的子类</li></ul><p>AQS内部有一个内部类Node，每个node都是一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//表示Node处于共享模式</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">//表示Node处于独占模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//因为超时或者中断，Node被设置为取消状态，被取消的Node不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态，处于这种状态的Node会被踢出队列，被GC回收</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//表示这个Node的继任Node被阻塞了，到时需要通知它</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//表示这个Node在条件队列中，因为等待某个条件而被阻塞 </span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">       <span class="comment">//使用在共享模式头Node有可能处于这种状态， 表示锁的下一次获取可以无条件传播</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//0，新Node会处于这种状态 </span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="comment">//队列中某个Node之前的Node </span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="comment">//队列中某个Node之后的Node </span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//这个Node持有的线程，表示等待锁的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"><span class="comment">//表示下一个等待condition的Node</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//三个构造器</span></span><br><span class="line">    Node() &#123;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;    </span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看得出来，Node 本身具备一种数据结构 双向链表</p><ul><li>AQS中有的变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FIFO队列中的头Node</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//FIFO队列中的尾Node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步状态，0表示未锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><ul><li>AQS是典型的模板模式的应用，FIFO队列的各种操作在AQS中已经实现，AQS的子类一般只需要重写tryAcquire(int arg)和tryRelease(int arg)两个方法即可。</li></ul><h2 id="3-ReentrantLock的实现"><a href="#3-ReentrantLock的实现" class="headerlink" title="3. ReentrantLock的实现"></a>3. ReentrantLock的实现</h2><ul><li>ReentrantLock根据传入构造方法的布尔型参数实例化出Sync的实现类FairSync和NonfairSync，分别表示公平的Sync和非公平的Sync。</li><li>ReentrantLock使用较多的为是非公平锁，因为非公平锁吞吐量大</li></ul><p>下面都是以非公平锁举例：</p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul><li>假设线程1调用了ReentrantLock的lock()方法，那么线程1将会独占锁：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一个获取锁的线程就做了两件事情：</p><ul><li>1、设置AbstractQueuedSynchronizer的state为1</li><li>2、设置AbstractOwnableSynchronizer的thread为当前线程  </li></ul></li><li><p>这两步做完之后就表示线程1独占了锁。然后线程2也要尝试获取同一个锁，在线程1没有释放锁的情况下，线程2会阻塞。<br>因为锁已被线程1占有，此时 status = 1， 所以在 lock 函数中，会走到 else 中</p></li></ul><p>acquire 函数是在父类 AbstractQueuedSynchronizer 中实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个判断条件尝试获取一次锁，如果获取的结果为false，才会走第二个判断条件添加FIFO等待队列</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 acquire 时，会调用 addWaiter 函数 &amp; acquireQueued 函数</p><ul><li><p>addWaiter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个当前线程的Node，模式为独占模式（因为传入的mode是一个NULL）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line">  <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        <span class="comment">//尾部的node部位不为空，则等待队列不为空，线程2为第一个需要添加到等待队列的，因为多线程并发，所以等待队列有可能不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">              <span class="comment">// oldTail 没有被其他线程修改，此时将 传入的 node 节点放置在 链表的尾部</span></span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 初始化链表</span></span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acquireQueued</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//死循环：</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//再次判断一下线程2能不能获取锁（可能这段时间内线程1已经执行完了把锁释放了，state变为了0）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不能，则调用AQS的shouldParkAfterFailedAcquire(p, node)方法，第一次会得到false,继续循环，第二次才会走第二个判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当线程2仍无法获取到锁时，会调用 shouldParkAfterFailedAcquire &amp;&amp;  parkAndCheckInterrupt 进行判断，是否进行阻塞</p><ul><li><p>shouldParkAfterFailedAcquire</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//第一次这个waitStatus是h的waitStatus，很明显是0，第二次为-1，会返回true</span></span><br><span class="line">     <span class="keyword">int</span> s = pred.waitStatus;</span><br><span class="line">     <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">     node.prev = pred = pred.prev;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">     pred.next = node;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">//把h的waitStatus设置为Noed.SIGNAL即-1并返回false</span></span><br><span class="line">         compareAndSetWaitStatus(pred, <span class="number">0</span>, Node.SIGNAL);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>parkAndCheckInterrupt</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//阻塞住了当前的线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    unsafe.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3><ul><li>在上面的代码中可以看到，tryLock 会执行 tryAcquireNanos 函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line"><span class="comment">//由于state是volatile的，所以state对线程2具有可见性，线程2拿到最新的state</span></span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="comment">//再次判断一下能否持有锁（可能线程1同步代码执行得比较快，这会儿已经释放了锁）</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">          setExclusiveOwnerThread(current);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125; <span class="comment">//判断当前线程和持有锁的线程是否相同</span></span><br><span class="line">    <span class="comment">//让某个线程可以多次调用同一个ReentrantLock，每调用一次给state+1，由于某个线程已经持有了锁，所以这里不会有竞争，因此不需要利用CAS设置state（相当于一个偏向锁*）。从这段代码可以看到，nextc每次加1，当nextc&lt;0的时候抛出error，那么同一个锁最多能重入Integer.MAX_VALUE次</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面部分是加锁部分，接下来看看解锁部分</li></ul><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release 函数会调用到 AbstractQueuedSynchronizer 中的 release<br>会调用 tryRelease 进行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是 tryRelease 会直接抛出异常，也就是说，会调用子类中的 tryRelease 函数</li></ul><p><strong><em>tryRelease 函数为何不写成抽象函数？</em></strong></p><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每次执行该方法，state都会减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//判断当前线程和持有锁的线程是否相等，不相等抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 只有当c==0的时候才会让free=true，这和上面一个线程多次调用lock方法累加state是对应的，</span></span><br><span class="line">    <span class="comment">// 调用了多少次的lock()方法自然必须调用同样次数的unlock()方法才行，这样才把一个锁给全部解开</span></span><br><span class="line">    <span class="comment">// 同一个线程可能持有多次锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//设置占有锁的线程为空</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当返回 free 为 true 时，release 函数中会执行 unparkSuccessor() 函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">//下一个Node，也就是线程2</span></span><br><span class="line">     Node s = node.next;</span><br><span class="line">     <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">             <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                 s = t;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//等待队列不为空，执行unPark</span></span><br><span class="line">     <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">         LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LockSupport.unpark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//jvm进行实现</span></span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>锁被解了怎样保证整个FIFO队列减少一个Node，回到了AQS的acquireQueued方法了</strong></p><p>回到上面讲过的未获取到锁的线程被阻塞的 acquireQueued 函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//死循环：</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//再次判断一下线程2能不能获取锁（可能这段时间内线程1已经执行完了把锁释放了，state变为了0）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不能，则调用AQS的shouldParkAfterFailedAcquire(p, node)方法，第一次会得到false,继续循环，第二次才会走第二个判断条件</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>被阻塞的线程2是被阻塞了，但是此处并没有return语句，所以，阻塞完成线程2依然会进行for循环。</li><li>然后，阻塞完成了，线程2所在的Node的前驱Node是p，线程2尝试tryAcquire，成功，然后线程2就成为了head节点了，把p的next设置为null，这样原头Node里面的所有对象都不指向任何块内存空间，h属于栈内存的内容，方法结束被自动回收，这样随着方法的调用完毕，原头Node也没有任何的引用指向它了，这样它就被GC自动回收了。此时，遇到一个return语句，acquireQueued方法结束</li></ul><ul><li>setHead</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setHead方法里面的前驱Node是Null，也没有线程，那么为什么不用一个在等待的线程作为Head Node呢？</strong></p><blockquote><p>因为一个线程随时有可能因为中断而取消，而取消的话，Node自然就要被GC了，那GC前必然要把头Node的后继Node变为一个新的头而且要应对多种情况，这样就很麻烦。<br>用一个没有thread的Node作为头，相当于起了一个引导作用，因为head没有线程，自然也不会被取消。</p><p>从尾到头遍历，找出离head最近的一个node，对这个node进行unPark操作。</p></blockquote><blockquote><p>个人解读： 因为不知道之前被阻塞的线程会处于何种状态，直接让链表中下一个节点获取锁，可能会发生一些异常。<br>所以直接只释放锁，让各个线程再次抢占，这也是非公平锁的原理。<br>锁释放时，不是直接在阻塞链表中取下一个节点的线程，而且所有节点再次抢占，甚至可能让最新进来的线程获取到锁</p></blockquote><h3 id="ReentrantLock-中的其他函数"><a href="#ReentrantLock-中的其他函数" class="headerlink" title="ReentrantLock 中的其他函数"></a>ReentrantLock 中的其他函数</h3><ul><li><p>getHoldCount 获取state值</p><ul><li>获取到state值，也就知道了锁的状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>getOwner 获取占有锁的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getQueuedThreads 获取所有阻塞的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//从尾到头遍历一下，添加进ArrayList(等待队列)中</span><br><span class="line">public final Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class="line">    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">    for (Node p = tail; p != null; p = p.prev) &#123;</span><br><span class="line">        Thread t = p.thread;</span><br><span class="line">        if (t != null)</span><br><span class="line">            list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><h3 id="如何出现死锁"><a href="#如何出现死锁" class="headerlink" title="如何出现死锁"></a>如何出现死锁</h3><ul><li><p>多个线程获取多个锁，形成了循环依赖锁，导致死锁</p><ul><li>线程A获取到锁1，并尝试获取锁2。</li><li>线程B获取到锁2，并尝试获取锁1。</li><li>线程A获取到锁1时，锁2已经被线程B获取。</li><li>此时就形成了死锁</li></ul></li><li><p>测试的线程类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span></span>(<span class="keyword">var</span> flag: <span class="built_in">Boolean</span>, <span class="keyword">var</span> any1: Any, <span class="keyword">var</span> any2: Any) : Runnable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            synchronized(any1) &#123;</span><br><span class="line">                println(<span class="string">"<span class="subst">$&#123;flag&#125;</span> 线程: 获取到any1的锁"</span>)</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">                synchronized(any2) &#123;</span><br><span class="line">                    println(<span class="string">"<span class="subst">$&#123;flag&#125;</span> 线程: 获取到any2的锁"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            synchronized(any2) &#123;</span><br><span class="line">                println(<span class="string">"<span class="subst">$&#123;flag&#125;</span> 线程: 获取到any2的锁"</span>)</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">                synchronized(any1) &#123;</span><br><span class="line">                    println(<span class="string">"<span class="subst">$&#123;flag&#125;</span> 线程: 获取到any1的锁"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;flag&#125;</span> 线程: 未出现死锁!!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个线程调用锁的地方</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">binding.deadLock.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> any1 = Any()</span><br><span class="line">            <span class="keyword">val</span> any2 = Any()</span><br><span class="line">            <span class="keyword">val</span> thread1: Thread = Thread(TestDeadLock(<span class="literal">true</span>, any1, any2))</span><br><span class="line">            <span class="keyword">val</span> thread2: Thread = Thread(TestDeadLock(<span class="literal">false</span>, any1, any2))</span><br><span class="line"></span><br><span class="line">            thread1.start()</span><br><span class="line">            thread2.start()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后可以发现， “未出现死锁!!!” 这一句输出永远不会出现，<br>因为此时已经死锁</p><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ul><li>synchronized 锁的对象保持顺序一致，<ul><li>如上面示例，将 else 中 any2 与 any1 顺序对调以下即可避免死锁</li></ul></li><li>lock 锁的顺序保持一致</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址： &lt;a href=&quot;https://blog.csdn.net/persistence_PSH/article/details/114504207&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/pers
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP详解</title>
    <link href="hexo/blog/2022/07/HTTP%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2022/07/HTTP详解.html</id>
    <published>2022-07-13T06:54:03.000Z</published>
    <updated>2022-07-13T06:57:03.973Z</updated>
    
    <content type="html"><![CDATA[<ul><li>HTTP: HyperText Transfer Protocol,超文本传输协议，属于应用层</li></ul><p>参考地址：<a href="https://www.jianshu.com/p/a6d086a3997d" target="_blank" rel="noopener">https://www.jianshu.com/p/a6d086a3997d</a></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><img src="../../../images/http1.png" style="zoom:60%"></p><h2 id="2-工作方式"><a href="#2-工作方式" class="headerlink" title="2.工作方式"></a>2.工作方式</h2><ul><li>HTTP协议采用 请求 / 响应 的工作方式</li></ul><p><img src="../../../images/http2.png" style="zoom:60%"></p><h2 id="3-HTTP报文详解"><a href="#3-HTTP报文详解" class="headerlink" title="3.HTTP报文详解"></a>3.HTTP报文详解</h2><ul><li>HTTP在 应用层 交互数据的方式 = 报文</li><li>HTTP的报文分为：请求报文 &amp; 响应报文<blockquote><p>分别用于 发送请求 &amp; 响应请求时</p></blockquote></li></ul><h3 id="3-1-请求报文"><a href="#3-1-请求报文" class="headerlink" title="3.1 请求报文"></a>3.1 请求报文</h3><h4 id="3-1-1-报文结构"><a href="#3-1-1-报文结构" class="headerlink" title="3.1.1 报文结构"></a>3.1.1 报文结构</h4><ul><li>HTTP的请求报文由 请求行、请求头 &amp; 请求体 组成，如下图</li></ul><p><img src="../../../images/http3.png" style="zoom:60%"></p><h4 id="3-1-2-结构详细介绍"><a href="#3-1-2-结构详细介绍" class="headerlink" title="3.1.2 结构详细介绍"></a>3.1.2 结构详细介绍</h4><p><strong>组成1：请求行</strong></p><ul><li>作用：声明 请求方法 、主机域名、资源路径 &amp; 协议版本</li><li>结构：请求行的组成 = 请求方法 + 请求路径 + 协议版本<blockquote><p>注：空格不能省</p></blockquote></li></ul><p><img src="../../../images/http4.png" style="zoom:60%"></p><p><img src="../../../images/http5.png" style="zoom:60%"></p><blockquote><p>此处特意说明GET、PSOT方法的区别：</p></blockquote><p><img src="../../../images/http6.png" style="zoom:60%"></p><ul><li>示例: 设：请求报文采用GET方法、 URL地址 = <a href="http://www.tsinghua.edu.cn/chn/yxsz/index.htm；、HTTP1.1版本" target="_blank" rel="noopener">http://www.tsinghua.edu.cn/chn/yxsz/index.htm；、HTTP1.1版本</a><ul><li>则请求行是：GET /chn/yxsz/index.htm HTTP/1.1</li></ul></li></ul><p><strong>组成2：请求头</strong></p><ul><li>作用：声明 客户端、服务器 / 报文的部分信息</li><li>使用方式：采用”header（字段名）：value（值）“的方式</li><li>常用请求头<br><strong>1. 请求和响应报文的通用Header</strong></li></ul><p><img src="../../../images/http7.png" style="zoom:60%"></p><p><strong>2. 常见请求Header</strong></p><p><img src="../../../images/http8.png" style="zoom:60%"></p><ul><li>举例：<br>(URL地址：<a href="http://www.tsinghua.edu.cn/chn/yxsz/index.htm）" target="_blank" rel="noopener">http://www.tsinghua.edu.cn/chn/yxsz/index.htm）</a><br>Host：<a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> (表示主机域名）<br>User - Agent：Mozilla/5.0 (表示用户代理是使用Netscape浏览器）</li></ul><p><strong>组成3：请求体</strong></p><ul><li><p>作用：存放 需发送给服务器的数据信息</p><blockquote><p>可选部分，如 GET请求就无请求数据</p></blockquote></li><li><p>使用方式：共3种<br><img src="../../../images/http9.png" style="zoom:60%"></p></li><li><p>至此，关于请求报文的请求行、请求头、请求体 均讲解完毕。</p></li></ul><h4 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3 总结"></a>3.1.3 总结</h4><ul><li>关于 请求报文的总结如下</li></ul><p><img src="../../../images/http10.png" style="zoom:60%"></p><ul><li>请求报文示例</li></ul><p><img src="../../../images/http11.png" style="zoom:60%"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;HTTP: HyperText Transfer Protocol,超文本传输协议，属于应用层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考地址：&lt;a href=&quot;https://www.jianshu.com/p/a6d086a3997d&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>ip地址详解</title>
    <link href="hexo/blog/2022/07/ip%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2022/07/ip地址详解.html</id>
    <published>2022-07-11T06:43:38.000Z</published>
    <updated>2022-07-11T07:14:58.081Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址：<a href="https://blog.csdn.net/qq_42499737/article/details/118859015" target="_blank" rel="noopener">https://blog.csdn.net/qq_42499737/article/details/118859015</a></p><p>IP地址是一个唯一标识，是一段网络编码（二进制），由32位组成的，它为互联网上的每一个网络和每一台主机分配一个逻辑地址</p><ul><li><p>常见的IP地址</p><ul><li>IPv4</li><li>IPv6</li></ul></li><li><p>IP地址的形式： x.x.x.x 每个X的范围：0-255</p></li><li><p>IP地址对应于OSI参考模型的第三层 <strong>网络层</strong>，对应TCP/IP体系结构中第二层<strong>网际层</strong><br>工作在网络层的路由器根据目标IP和源IP来判断是否属于同一网段，如果是不同网段，则转发数据包。</p></li></ul><h2 id="IP地址格式-amp-表示"><a href="#IP地址格式-amp-表示" class="headerlink" title="IP地址格式 &amp; 表示"></a>IP地址格式 &amp; 表示</h2><ul><li><p>在计算机二进制中，1个字节 = 8位 = 8bit（比特）</p></li><li><p>IP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）<br>每一段8位二进制，中间使用英文的标点符号“.”隔开</p></li><li><p>由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。</p></li><li><p>IP地址表示为：xxx.xxx.xxx.xxx</p></li></ul><blockquote><p>IP地址的这种表示法叫做“点分十进制表示法”。<br>举例： 210.21.196.6就是一个IP地址的表示。</p></blockquote><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><ul><li><p>局域网通信规则： 在同一个局域网中所有的IP必须在同一网段中才可以互相通信；</p></li><li><p>IP地址构成： 网络位+主机位（网络位相同的地址才能称为同一个网段）</p></li><li><p>子网掩码： 用来确定主机位，常见的有三种：</p><ul><li>255.0.0.0</li><li>255.255.0.0</li><li>255.255.255.0</li></ul></li></ul><p>例如： </p><ul><li><p>10.1.1.1 255.255.255.0</p><ul><li>这个网段是10.1.1 网段，名字叫.1</li></ul></li><li><p>10.1.1.1 255.0.0.0</p><ul><li>这个的网段是10. 名字叫.1.1.1</li></ul></li></ul><h2 id="IP地址详解"><a href="#IP地址详解" class="headerlink" title="IP地址详解"></a>IP地址详解</h2><ul><li><p>国际标准组织ISO定义地址分类：五大类（以IP地址的第一位来进行区分的，与后三位没有关系）</p><ul><li>A类： 1-126 默认子网掩码 255.0.0.0</li><li>B类： 128-191 默认子网掩码 255.255.0.0</li><li>C类： 192-223 默认子网掩码 255.255.255.0</li><li>D类： 224-239 组播地址</li><li>E类： 240-254 科研使用</li></ul></li></ul><blockquote><p>192.168.1.64 C类  因为第一位为192 处于 192-223 区间，所以是C类 ，网段就是 192.168.1  名字是 1<br>10.1.1.8 A类      因为第一位为10 处于 1-126 区间，所以是A类， 网段是 10. 名字叫 .1.1.8</p></blockquote><h3 id="A类地址："><a href="#A类地址：" class="headerlink" title="A类地址："></a>A类地址：</h3><ul><li><p>A类地址范围：1.0.0.0 - 126.255.255.255，其中0和127作为特殊地址。</p></li><li><p>A类网络默认子网掩码为255.0.0.0，也可写作/8。</p></li><li><p>A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址）。</p></li></ul><blockquote><p>在计算机网络中，主机ID全部为0的地址为网络地址，而主机ID全部为1的地址为广播地址，这2个地址是不能分配给主机用的</p></blockquote><h3 id="B类地址："><a href="#B类地址：" class="headerlink" title="B类地址："></a>B类地址：</h3><ul><li>B类地址第1字节（最高位固定是10）和第2字节为网络地址，另外2个字节为主机地址。</li><li>B类地址范围：128.0.0.0 - 191.255.255.255。</li><li>B类网络默认子网掩码为255.255.0.0，也可写作/16。</li><li>B类网络最大主机数量256×256-2=65534。</li></ul><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><ul><li>C类地址第1字节（最高位固定是110）、第2字节和第3个字节，另外1个字节为主机地址。</li><li>C类地址范围：192.0.0.0 - 223.255.255.255。</li><li>C类网络默认子网掩码为255.255.255.0，也可写作/24。</li><li>C类网络最大主机数量256-2=254。</li></ul><h3 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h3><ul><li>D类地址不分网络地址和主机地址，它的第1个字节的最高位固定是1110。</li><li>D类地址用于组播（也称为多播）的地址，无子网掩码。</li><li>D类地址范围：224.0.0.0 - 239.255.255.255。</li></ul><h3 id="E类地址："><a href="#E类地址：" class="headerlink" title="E类地址："></a>E类地址：</h3><ul><li>E类地址也不分网络地址和主机地址，它的第1个字节的最高位固定是11110。</li><li>E类地址范围：240.0.0.0 - 255.255.255.255。</li><li>其中240.0.0.0-255.255.255.254作为保留地址，主要用于Internet试验和开发，255.255.255.255作为广播地址。</li></ul><h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><p>以下这些特殊IP地址都是不能分配给主机用的地址：</p><ul><li>主机ID全为0的地址：特指某个网段，比如：192.168.10.0 255.255.255.0，指192.168.10.0网段。</li><li>主机ID全为1的地址：特指该网段的全部主机，比如：192.168.10.255，如果你的计算机发送数据包使用主机ID全是1的IP地址，数据链层地址用广播地址FF-FF-FF-FF-FF-FF。</li><li>127.0.0.1：是本地环回地址，指本机地址，一般用来测试使用。回送地址(127.x.x.x)是本机回送地址(Loopback Address)，即主机IP堆栈内部的IP地址。</li><li>169.254.0.0：169.254.0.0-169.254.255.255实际上是自动私有IP地址。</li><li>0.0.0.0：如果计算机的IP地址和网络中的其他计算机地址冲突，使用ipconfig命令看到的就是0.0.0.0，子网掩码也是0.0.0.0。</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>10.1.1.1<br>255.255.255.0</p><p>10.1.1.1属于哪个网段，有多少可用IP地址？</p><p>答： 10.1.1.1属于10.1.1.0网段<br>10.1.1.0网段可用IP地址范围： 10.1.1.1-10.1.1.254<br>10.1.1.0 网段的广播地址： 10.1.1.255</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>10.1.1.1<br>255.255.0.0<br>10.1.1.1属于哪个网段，有多少可用IP地址？</p><p>答：<br>答： 10.1.1.1属于10.1.0.0网段<br>10.1.0.0网段可用IP地址范围： 10.1.0.1-10.1.255.254（65534）<br>10.1.0.0 网段的广播地址： 10.1.255.255</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址：&lt;a href=&quot;https://blog.csdn.net/qq_42499737/article/details/118859015&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_424997
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Socket详解</title>
    <link href="hexo/blog/2022/07/Socket%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2022/07/Socket详解.html</id>
    <published>2022-07-11T06:06:33.000Z</published>
    <updated>2022-07-11T06:11:06.695Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Socket在网络通信中扮演及其重要的角色</li></ul><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><ul><li>即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）</li></ul><p><img src="../../../images/socket1.png" style="zoom:60%"></p><blockquote><p>Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）<br>即：通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发<br>对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信</p></blockquote><ul><li>成对出现，一对套接字：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket =&#123;(IP地址<span class="number">1</span>:PORT端口号)，(IP地址<span class="number">2</span>:PORT端口号)\&#125;</span><br></pre></td></tr></table></figure><ul><li>一个 Socket 实例 唯一代表一个主机上的一个应用程序的通信链路</li></ul><h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p>Socket的使用类型主要有两种：</p><ul><li>流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务</li><li>数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务</li></ul><p>具体原理图如下：</p><p><img src="../../../images/socket3.png" style="zoom:60%"></p><h2 id="3、Socket建立连接过程"><a href="#3、Socket建立连接过程" class="headerlink" title="3、Socket建立连接过程"></a>3、Socket建立连接过程</h2><p><img src="../../../images/socket2.png" style="zoom:60%"></p><h2 id="4、Socket-与-Http-对比"><a href="#4、Socket-与-Http-对比" class="headerlink" title="4、Socket 与 Http 对比"></a>4、Socket 与 Http 对比</h2><ul><li>Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题</li><li>HTTP协议 属于 应用层，解决的是如何包装数据</li></ul><p>由于二者不属于同一层面，所以本来是没有可比性的。但随着发展，默认的Http里封装了下面几层的使用，<br>所以才会出现Socket &amp; HTTP协议的对比：（主要是工作方式的不同）：</p><ul><li>Http：采用 请求—响应 方式。</li></ul><blockquote><ul><li>即建立网络连接后，当 客户端 向 服务器 发送请求后，服务器端才能向客户端返回数据。</li><li>可理解为：是客户端有需要才进行通信</li></ul></blockquote><ul><li>Socket：采用 服务器主动发送数据 的方式</li></ul><blockquote><ul><li>即建立网络连接后，服务器可主动发送消息给客户端，而不需要由客户端向服务器发送请求</li><li>可理解为：是服务器端有需要才进行通信</li></ul></blockquote><p>5.使用</p><ul><li>Socket可基于TCP或者UDP协议，但TCP更加常用</li><li>所以下面的使用步骤 &amp; 实例的Socket将基于TCP协议</li></ul><p>在客户端使用示例：<a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/socket" target="_blank" rel="noopener">https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/socket</a></p><h2 id="Socket源码解读"><a href="#Socket源码解读" class="headerlink" title="Socket源码解读"></a>Socket源码解读</h2><h3 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h3><p>当Socket实例创建完毕时，TCP三次握手就已完成，代表实例已创建。</p><p>客户端创建实例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = Socket(<span class="string">"192.168.101.130"</span>, <span class="number">3333</span>)</span><br></pre></td></tr></table></figure></p><ul><li>看一下Socket构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnknownHostException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Android-changed: App compat. Socket ctor should try all addresses. http://b/30007735</span></span><br><span class="line">        <span class="keyword">this</span>(InetAddress.getAllByName(host), port, (SocketAddress) <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里会把传入的主机域名解析成 ip地址集合，然后调用另一个构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(InetAddress[] addresses, <span class="keyword">int</span> port, SocketAddress localAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addresses == <span class="keyword">null</span> || addresses.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 当ip解析为空时，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Impossible: empty address list"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addresses.length; i++) &#123;</span><br><span class="line">            setImpl();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(addresses[i], port);</span><br><span class="line">                createImpl(stream);</span><br><span class="line">                <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bind(localAddr);</span><br><span class="line">                &#125;</span><br><span class="line">                connect(address);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException | SecurityException e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Android-changed: Let ctor call impl.close() instead of overridable close().</span></span><br><span class="line">                    <span class="comment">// Subclasses may not expect a call to close() coming from this constructor.</span></span><br><span class="line">                    impl.close();</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ce) &#123;</span><br><span class="line">                    e.addSuppressed(ce);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Only stop on the last address.</span></span><br><span class="line">                <span class="keyword">if</span> (i == addresses.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Discard the connection state and try again.</span></span><br><span class="line">            impl = <span class="keyword">null</span>;</span><br><span class="line">            created = <span class="keyword">false</span>;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            closed = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，在此处的逻辑中，最主要只有如下四个函数</p><ul><li>setImpl()</li><li>createImpl(stream)</li><li>bind(localAddr)</li><li>connect(address)</li></ul><p>再对以上四个函数进行逐一分析</p><p>先看一下 SocketImpl 及其子类的UML类图<br><img src="../../../images/socketImpl.png" style="zoom:60%"></p><h4 id="setImpl"><a href="#setImpl" class="headerlink" title="setImpl"></a>setImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        impl = factory.createSocketImpl();</span><br><span class="line">        checkOldImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No need to do a checkOldImpl() here, we know it's an up to date</span></span><br><span class="line">        <span class="comment">// SocketImpl!</span></span><br><span class="line">        impl = <span class="keyword">new</span> SocksSocketImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (impl != <span class="keyword">null</span>)</span><br><span class="line">        impl.setSocket(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>factory 默认为空，除非 通过调用 setSocketImplFactory 手动实现自己的 SocketImplFactory</p><p>所以此处的 impl = new SocksSocketImpl();</p><h4 id="createImpl-stream"><a href="#createImpl-stream" class="headerlink" title="createImpl(stream)"></a>createImpl(stream)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createImpl</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (impl == <span class="keyword">null</span>)</span><br><span class="line">        setImpl();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        impl.create(stream);</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说了  impl = new SocksSocketImpl();<br>但 SocksSocketImpl 中并没有实现 create 函数， SocksSocketImpl 是继承自 PlainSocketImpl，而 PlainSocketImpl，而 中也没有实现 create 函数,<br>而 PlainSocketImpl 又是继承自 AbstractPlainSocketImpl</p><p>也就是说最终是调用的 AbstractPlainSocketImpl 中的 create</p><ul><li>AbstractPlainSocketImpl create<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// stream = true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">        <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">            ResourceManager.beforeUdpCreate();</span><br><span class="line">            <span class="comment">// Android-removed: socketCreate should set fd if it succeeds.</span></span><br><span class="line">            <span class="comment">// fd = new FileDescriptor();</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socketCreate(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ResourceManager.afterUdpClose();</span><br><span class="line">                <span class="comment">// Android-changed: Closed sockets use an invalid fd, not null. b/26470377</span></span><br><span class="line">                <span class="comment">// fd = null;</span></span><br><span class="line">                <span class="keyword">throw</span> ioe;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Android-removed: socketCreate should set fd if it succeeds.</span></span><br><span class="line">            <span class="comment">// fd = new FileDescriptor();</span></span><br><span class="line">            socketCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">            socket.setCreated();</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">            serverSocket.setCreated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Android-added: CloseGuard.</span></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span> &amp;&amp; fd.valid()) &#123;</span><br><span class="line">            guard.open(<span class="string">"close"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>此处会调用 socketCreate 但 该函数是一个抽象函数，查看子类是否有实现，</p><ul><li>在   类中，实现了该函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketCreate</span><span class="params">(<span class="keyword">boolean</span> isStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// The fd object must not change after calling bind, because we rely on this undocumented</span></span><br><span class="line">        <span class="comment">// behaviour. See libcore.java.net.SocketTest#testFileDescriptorStaysSame.</span></span><br><span class="line">        fd.setInt$(IoBridge.socket(AF_INET6, isStream ? SOCK_STREAM : SOCK_DGRAM, <span class="number">0</span>).getInt$());</span><br><span class="line">        IoUtils.setFdOwner(fd, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            IoUtils.setBlocking(fd, <span class="keyword">false</span>);</span><br><span class="line">            IoBridge.setSocketOption(fd, SO_REUSEADDR, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>上次的调用还只是 生成一个 SocketImpl 的实例对象</li><li>接下来查看 bind 函数</li></ul><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress bindpoint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Already bound"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bindpoint != <span class="keyword">null</span> &amp;&amp; (!(bindpoint <span class="keyword">instanceof</span> InetSocketAddress)))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) bindpoint;</span><br><span class="line">        <span class="keyword">if</span> (epoint != <span class="keyword">null</span> &amp;&amp; epoint.isUnresolved())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Unresolved address"</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoint == <span class="keyword">null</span>) &#123;</span><br><span class="line">            epoint = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        InetAddress addr = epoint.getAddress();</span><br><span class="line">        <span class="keyword">int</span> port = epoint.getPort();</span><br><span class="line">        checkAddress (addr, <span class="string">"bind"</span>);</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkListen(port);</span><br><span class="line">        &#125;</span><br><span class="line">        getImpl().bind (addr, port);</span><br><span class="line">        bound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getImpl().bind (addr, port);<br>也就是说最终会调用到 AbstractPlainSocketImpl 中的 bind 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(InetAddress address, <span class="keyword">int</span> lport)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!closePending &amp;&amp; (socket == <span class="keyword">null</span> || !socket.isBound())) &#123;</span><br><span class="line">                NetHooks.beforeTcpBind(fd, address, lport);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socketBind(address, lport);</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">            socket.setBound();</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">            serverSocket.setBound();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与 create 函数类似，此处也会调用一个抽象函数， socketBind(address, lport); 该函数的实现在 PlainSocketImpl 类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PlainSocketImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketBind</span><span class="params">(InetAddress address, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="keyword">null</span> || !fd.valid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IoBridge.bind(fd, address, port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Now that we're a connected socket, let's extract the port number that the system</span></span><br><span class="line">            <span class="comment">// chose for us and store it in the Socket object.</span></span><br><span class="line">            localport = IoBridge.getLocalInetSocketAddress(fd).getPort();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            localport = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>bind 函数的主要作用应该是 绑定 地址、端口、fd(FileDescriptor)</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>connect 过程代表的是 TCP 建立连接过程中的 <strong>第一次握手</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress endpoint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        connect(endpoint, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: The address can't be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: timeout can't be negative"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isConnected())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"already connected"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line"></span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) endpoint;</span><br><span class="line">        InetAddress addr = epoint.getAddress ();</span><br><span class="line">        <span class="keyword">int</span> port = epoint.getPort();</span><br><span class="line">        checkAddress(addr, <span class="string">"connect"</span>);</span><br><span class="line"></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">                security.checkConnect(epoint.getHostName(), port);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                security.checkConnect(addr.getHostAddress(), port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!created)</span><br><span class="line">            createImpl(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oldImpl)</span><br><span class="line">            impl.connect(epoint, timeout);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">                impl.connect(addr.getHostName(), port);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                impl.connect(addr, port);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"SocketImpl.connect(addr, timeout)"</span>);</span><br><span class="line">        connected = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the socket was not bound before the connect, it is now because</span></span><br><span class="line"><span class="comment">         * the kernel will have picked an ephemeral port &amp; a local address</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处会调用  impl.connect(addr, port); 最终实现在 AbstractPlainSocketImpl 类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnknownHostException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress address = InetAddress.getByName(host);</span><br><span class="line">            <span class="keyword">this</span>.port = port;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line"></span><br><span class="line">            connectToAddress(address, port, timeout);</span><br><span class="line">            connected = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    <span class="comment">/* Do nothing. If connect threw an exception then</span></span><br><span class="line"><span class="comment">                       it will be passed up the call stack */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectToAddress</span><span class="params">(InetAddress address, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (address.isAnyLocalAddress()) &#123;</span><br><span class="line">            doConnect(InetAddress.getLocalHost(), port, timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doConnect(address, port, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">(InetAddress address, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!closePending &amp;&amp; (socket == <span class="keyword">null</span> || !socket.isBound())) &#123;</span><br><span class="line">                NetHooks.beforeTcpConnect(fd, address, port);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acquireFD();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Android-added: BlockGuard.</span></span><br><span class="line">                BlockGuard.getThreadPolicy().onNetwork();</span><br><span class="line">                socketConnect(address, port, timeout);</span><br><span class="line">                <span class="comment">/* socket may have been closed during poll/select */</span></span><br><span class="line">                <span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (closePending) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException (<span class="string">"Socket closed"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If we have a ref. to the Socket, then sets the flags</span></span><br><span class="line">                <span class="comment">// created, bound &amp; connected to true.</span></span><br><span class="line">                <span class="comment">// This is normally done in Socket.connect() but some</span></span><br><span class="line">                <span class="comment">// subclasses of Socket may call impl.connect() directly!</span></span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    socket.setBound();</span><br><span class="line">                    socket.setConnected();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                releaseFD();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会调用到 socketConnect 函数， 该函数又是抽象函数， 会调用到 PlainSocketImpl 中的 socketConnect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketConnect</span><span class="params">(InetAddress address, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="keyword">null</span> || !fd.valid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IoBridge.connect(fd, address, port, timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localport == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If socket is pending close, fd becomes an AF_UNIX socket and calling</span></span><br><span class="line">            <span class="comment">// getLocalInetSocketAddress will fail.</span></span><br><span class="line">            <span class="comment">// http://b/34645743</span></span><br><span class="line">            <span class="keyword">if</span> (!isClosedOrPending()) &#123;</span><br><span class="line">                localport = IoBridge.getLocalInetSocketAddress(fd).getPort();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时，TCP连接中第一次握手完成，会发送一个  <strong>连接请求</strong> 报文段到服务端，报文段中首部信息：SYN = 1， 并随机一个起始序号 x， seq = x；不携带数据， 客户端进入 SYN_SENT  状态</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Socket在网络通信中扮演及其重要的角色&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、定义&quot;&gt;&lt;a href=&quot;#1、定义&quot; class=&quot;headerlink&quot; title=&quot;1、定义&quot;&gt;&lt;/a&gt;1、定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;即套接字，是应用层 与 TC
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议详解</title>
    <link href="hexo/blog/2022/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2022/07/TCP协议详解.html</id>
    <published>2022-07-07T02:51:44.000Z</published>
    <updated>2022-07-11T06:06:14.662Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址：<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">https://www.jianshu.com/p/65605622234b</a></p><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>Transmission Control Protocol，即 传输控制协议</p><blockquote><ul><li>属于 传输层通信协议</li><li>基于TCP的应用层协议有HTTP、SMTP、FTP、Telnet 和 POP3</li></ul></blockquote><p>位于TCP/IP协议体系结构中的第三层 传输层</p><h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><ul><li>面向连接<ul><li>使用TCP协议传输数据前，必须先建立TCP连接</li></ul></li><li>全双工通信<ul><li>通信双方都可以发送数据</li></ul></li><li>可靠<ul><li>不丢失、无差错、不重复、按序到达</li></ul></li><li>面向字节流<ul><li>一次传输的报文段有长度限制，可分块、分次传输</li></ul></li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h2><ul><li>优点： 可靠，不丢失</li><li>缺点： 效率低，因为每次使用都要建立连接</li></ul><h2 id="4-报文段格式"><a href="#4-报文段格式" class="headerlink" title="4.报文段格式"></a>4.报文段格式</h2><ul><li>TCP虽面向字节流，但传送的数据单元 = 报文段</li><li>报文段 = 首部 + 数据 2部分</li><li>TCP的全部功能体现在它首部中各字段的作用，故下面主要讲解TCP报文段的首部</li></ul><blockquote><p>首部前20个字符固定、后面有4n个字节是根据需而增加的选项<br>故 TCP首部最小长度 = 20字节</p></blockquote><p><img src="../../../images/tcp1.png" style="zoom:60%"><br><img src="../../../images/tcp2.png" style="zoom:60%"></p><h2 id="5-TCP连接建立过程"><a href="#5-TCP连接建立过程" class="headerlink" title="5.TCP连接建立过程"></a>5.TCP连接建立过程</h2><ul><li>TCP协议建立需要经过 三次握手<ul><li>第一次握手：客户端发送一个 <strong>连接请求</strong> 报文段到服务端，报文段中首部信息：SYN = 1， 并随机一个起始序号 x， seq = x；不携带数据， 客户端进入 SYN_SENT  状态</li><li>第二次握手：服务端接收到连接请求报文段，，也向客户端发送一个 <strong>连接确认</strong> 的报文段，报文段中首部信息：SYN = 1，ACK = 1，并随机一个起始序号 y， seq = y，确认号字段，ack = x + 1；不携带数据，服务端进入 SYN_RCVD 状态</li><li>第三次握手：客户端收到服务端发送的连接确认报文段，再向服务端发送一个 <strong>连接确认</strong> 的报文段，报文段首部信息：ACK = 1，seq = x + 1， ack = y + 1，因无SYN = 1，此报文段可携带数据.此时，客户端与服务端都进入ESTABLISHED状态</li></ul></li></ul><p><img src="../../../images/tcp3.png" style="zoom:60%"><br><img src="../../../images/tcp4.png" style="zoom:60%"></p><p><strong>成功进行TCP的三次握手后，就建立起一条TCP连接，即可传送应用层数据</strong></p><blockquote><ul><li>因 TCP提供的是全双工通信，故通信双方的应用进程在任何时候都能发送数据</li><li>三次握手期间，任何1次未收到对面的回复，则都会重发</li></ul></blockquote><h3 id="特别说明：为什么TCP建立连接需三次握手？"><a href="#特别说明：为什么TCP建立连接需三次握手？" class="headerlink" title="特别说明：为什么TCP建立连接需三次握手？"></a>特别说明：为什么TCP建立连接需三次握手？</h3><ul><li><p>answer:</p><ul><li>防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源</li></ul></li><li><p>具体描述<br><img src="../../../images/tcp5.png" style="zoom:60%"></p></li></ul><blockquote><p>SYN洪泛攻击：</p><p>从上可看出：服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时<br>这就使得服务器易于受到SYN洪泛攻击，即同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配 </p></blockquote><h2 id="6-释放连接过程"><a href="#6-释放连接过程" class="headerlink" title="6.释放连接过程"></a>6.释放连接过程</h2><p>在通信结束后，需要释放TCP连接，需经历四次挥手过程，才能断开连接</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>第一次挥手，客户端向服务端发送一个 <strong>释放连接</strong> 的报文段，报文段信息：FIN = 1，seq = u，客户端进入 FIN_WAIT_1 状态</li><li>第二次挥手，服务端收到客户端发送的释放连接的请求报文，想客户端发送一个 <strong>连接释放确认</strong> 报文段，报文段信息： ACK = 1，seq = v，ack = u + 1， 服务端进入 CLOSE_WAIT 状态。<br>此时，客户端 -&gt; 服务端的连接已断开，TCP连接处于半关闭状态</li><li>第三次挥手，服务端向客户端再发送一个 <strong>释放连接</strong> 的报文段，报文段信息：FIN= 1， ACK = 1，seq = w，ack = u + 1；服务端进入 LAST_ACK 状态</li><li>第四次挥手，客户端接收到服务端发送的释放连接报文，再向服务端发送一个 <strong>连接释放确认</strong> 报文段，报文段信息： ACK = 1，seq = u + 1，ack = w + 1。<br>此时客户端进入 TIME_WAIT 状态，服务端进入 CLOSED 状态，此时TCP还未断开，需经过时间等待计时器设置的时间2MSL后，客户端才进入 CLOSED 状态，即服务端比客户端先关闭</li></ul><p><img src="../../../images/tcp6.png" style="zoom:60%"><br><img src="../../../images/tcp7.png" style="zoom:60%"></p><h3 id="特别说明：为什么TCP释放连接需四次挥手？"><a href="#特别说明：为什么TCP释放连接需四次挥手？" class="headerlink" title="特别说明：为什么TCP释放连接需四次挥手？"></a>特别说明：为什么TCP释放连接需四次挥手？</h3><ul><li><p>结论</p><ul><li>为了保证通信双方都能通知对方 需释放 &amp; 断开连接<blockquote><p>即释放连接后，都无法接收 / 发送消息给对方</p></blockquote></li></ul></li><li><p>具体描述<br><img src="../../../images/tcp8.png" style="zoom:60%"></p></li></ul><blockquote><p>延伸疑问：为什么客户端关闭连接前要等待2MSL时间？</p><p>即 TIME - WAIT 状态的作用是什么；<br>MSL = 最长报文段寿命（Maximum Segment Lifetime）</p></blockquote><ul><li><p>原因1：为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接<br><img src="../../../images/tcp9.png" style="zoom:60%"></p></li><li><p>原因2：防止 上文提到的早已失效的连接请求报文 出现在本连接中客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失</p></li></ul><blockquote><p>即 在下1个新的连接中就不会出现早已失效的连接请求报文</p></blockquote><h2 id="7-无差错传输"><a href="#7-无差错传输" class="headerlink" title="7.无差错传输"></a>7.无差错传输</h2><ul><li>对比于UDP，TCP的传输是可靠的、无差错的</li><li>那么，为什么TCP的传输为什么是可靠的、无差错的呢？</li><li>下面，我将详细讲解TCP协议的无差错传输</li></ul><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>无差错：即 传输信道不出差错</li><li>发送 &amp; 接收效率匹配：即 无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据</li></ul><h3 id="基础：滑动窗口-协议"><a href="#基础：滑动窗口-协议" class="headerlink" title="基础：滑动窗口 协议"></a>基础：滑动窗口 协议</h3><ul><li>先理解2个基础概念：发送窗口、接收窗口<br><img src="../../../images/tcp10.png" style="zoom:60%"></li></ul><ul><li>工作原理<ul><li>对于发送端：<ul><li>1、每收到一个确认帧，发送窗口就向前滑动一个帧的距离</li><li>2、当发送窗口内无可发送的帧时（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送</li></ul></li></ul></li></ul><p>具体如下图：</p><p><img src="../../../images/tcp11.png" style="zoom:60%"></p><p>只有收到服务端发送的确认帧，才会继续发送数据帧，否则停止发送</p><ul><li>对于接收端：当收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</li></ul><p><img src="../../../images/tcp12.png" style="zoom:60%"></p><p>也就是说，只有确保当前的数据帧是准确位置窗口的，否则丢弃</p><ul><li>总的流程：<ul><li>1、客户端向服务端发送数据帧</li><li>2、服务端接收数据帧，并判断该数据帧是否属于当前接收窗口，如果不是，则丢弃该数据帧。如果是，则放入该接收窗口，并右移，然后向客户端发送确认帧</li><li>3、客户端接收到确认帧，并检查发出的数据帧是否都收到确认帧，如果没有，则等待接收确认帧。如果都收到确认帧，则又从第1步开始。</li></ul></li></ul><h3 id="滑动窗口-协议的重要特性"><a href="#滑动窗口-协议的重要特性" class="headerlink" title="滑动窗口 协议的重要特性"></a>滑动窗口 协议的重要特性</h3><ul><li>只有接收窗口向前滑动、接收方发送了确认帧时，发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动</li><li>停止-等待协议、后退N帧协议 &amp; 选择重传协议只是在发送窗口大小和接收窗口大小上有所差别：</li></ul><blockquote><p>停止等待协议：发送窗口大小=1，接收窗口大小=1；即 单帧滑动窗口 等于 停止-等待协议<br>后退N帧协议：发送窗口大小&gt;1，接收窗口大小=1。<br>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1。</p></blockquote><ul><li>当接收窗口的大小为1时，可保证帧有序接收。</li><li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意要与TCP的滑动窗口协议区别）</li></ul><h3 id="实现无差错传输的解决方案"><a href="#实现无差错传输的解决方案" class="headerlink" title="实现无差错传输的解决方案"></a>实现无差错传输的解决方案</h3><p>核心思想：采用一些可靠传输协议，使得 </p><ul><li>出现差错时，让发送方重传差错数据：即 出错重传</li><li>当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率：即 速度匹配</li></ul><p>针对上述2个问题，分别采用的解决方案是：自动重传协议 和 流量控制 &amp; 拥塞控制协议</p><p><strong>解决方案1：自动重传请求协议ARQ（针对 出错重传）</strong></p><ul><li><p>定义</p><ul><li>即 Auto Repeat reQuest，具体介绍如下：<br><img src="../../../images/tcp13.png" style="zoom:60%"></li></ul></li><li><p>类型</p></li></ul><p><img src="../../../images/tcp14.png" style="zoom:60%"></p><p>下面，将主要讲解 上述3类协议</p><p><em>类型1：停等式ARQ（Stop-and-Wait）</em> </p><ul><li>原理：（单帧滑动窗口）停止 - 等待协议 + 超时重传</li></ul><blockquote><p>即 ：发送窗口大小=1、接收窗口大小=1</p></blockquote><ul><li>停止 - 等待协议的协议原理如下：</li></ul><blockquote><p>发送方每发送一帧，要等到接收方的应答信号后才能发送下一帧<br>接收方每接收一帧，都要反馈一个应答信号，表示可接下一帧<br>若接收方不反馈应答信号，则发送方必须一直等待</p></blockquote><p><em>类型2：后退N帧协议</em><br>也称：连续ARQ协议</p><ul><li>原理<ul><li>多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传</li></ul></li></ul><blockquote><p>即 ：发送窗口大小&gt;1、接收窗口大小=1</p></blockquote><ul><li>具体描述</li></ul><p>a. 发送方：采用多帧滑动窗口的原理，可连续发送多个数据帧 而不需等待对方确认<br>b. 接收方：采用 累计确认 &amp; 后退N帧的原理，只允许按顺序接收帧。具体原理如下：</p><p><img src="../../../images/tcp15.png" style="zoom:60%"></p><p><em>示例讲解</em></p><p>本示例 = 源站 向 目的站 发送数据帧。具体示例如下：<br><img src="../../../images/tcp16.png" style="zoom:60%"></p><p><strong>类型3：选择重传ARQ（Selective Repeat）</strong></p><ul><li>原理<ul><li>多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传<blockquote><p>即 ：发送窗口大小&gt;1、接收窗口大小&gt;1</p></blockquote></li></ul></li></ul><p>类似于类型2（后退N帧协议），此处仅仅是接收窗口大小的区别，故此处不作过多描述</p><ul><li>特点<ul><li>a. 优：因连续发送数据帧而提高了信道的利用率</li><li>b. 缺：重传时又必须把原来已经传送正确的数据帧进行重传（仅因为这些数据帧前面有一个数据帧出了错），将导致传送效率降低</li></ul></li></ul><blockquote><p>由此可见，若信道传输质量很差，导致误码率较大时，后退N帧协议不一定优于停止-等待协议</p></blockquote><p><strong>解决方案2：流量控制 &amp; 拥塞控制（针对 速度匹配）</strong></p><p><em>措施1：流量控制</em></p><ul><li>简介</li></ul><p><img src="../../../images/tcp17.png" style="zoom:60%"></p><ul><li><p>示例<br><img src="../../../images/tcp18.png" style="zoom:60%"></p></li><li><p>特别注意：死锁问题<br><img src="../../../images/tcp19.png" style="zoom:60%"></p></li><li><p>措施2：拥塞控制 *</p></li><li><p>定义</p><ul><li>防止过多的数据注入到网络中，使得网络中的路由器 &amp; 链路不致于过载<blockquote><p>拥塞：对网络中的资源需求 &gt; 该资源所能提供的部分</p></blockquote></li></ul></li><li><p>与 “流量控制”的区别</p></li></ul><p><img src="../../../images/tcp20.png" style="zoom:60%"></p><ul><li>具体解决方案<ul><li>共分为2个解决方案：慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复<blockquote><p>其中，涉及4种算法，即 慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复</p></blockquote></li></ul></li></ul><h4 id="解决方案1：慢开始-amp-拥塞避免"><a href="#解决方案1：慢开始-amp-拥塞避免" class="headerlink" title="解决方案1：慢开始 &amp; 拥塞避免"></a>解决方案1：慢开始 &amp; 拥塞避免</h4><h5 id="储备知识：拥塞窗口、慢开始算法、拥塞避免算法"><a href="#储备知识：拥塞窗口、慢开始算法、拥塞避免算法" class="headerlink" title="储备知识：拥塞窗口、慢开始算法、拥塞避免算法"></a>储备知识：拥塞窗口、慢开始算法、拥塞避免算法</h5><h6 id="a-拥塞窗口"><a href="#a-拥塞窗口" class="headerlink" title="a. 拥塞窗口"></a>a. 拥塞窗口</h6><ul><li>发送方维持一个状态变量：拥塞窗口（cwnd， congestion window ），具体介绍如下</li></ul><p><img src="../../../images/tcp21.png" style="zoom:60%"></p><h6 id="b-慢开始算法"><a href="#b-慢开始算法" class="headerlink" title="b. 慢开始算法"></a>b. 慢开始算法</h6><ul><li><p>原理</p><ul><li>当主机开始发送数据时，由小到大逐渐增大 拥塞窗口数值（即 发送窗口数值），从而<em> 由小到大 </em>逐渐增大发送报文段</li></ul></li><li><p>目的</p><ul><li>开始传输时，试探网络的拥塞情况</li></ul></li><li><p>具体措施</p></li></ul><p><img src="../../../images/tcp22.png" style="zoom:60%"></p><ul><li>示意图</li></ul><p><img src="../../../images/tcp23.png" style="zoom:60%"></p><ul><li>特别注意<ul><li>慢开始的“慢”指：一开始发送报文段时拥塞窗口（cwnd）设置得较小（为1），使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况）</li></ul></li></ul><blockquote><p>并不是指拥塞窗口（cwnd）的增长速率慢</p></blockquote><h6 id="c-拥塞避免-算法"><a href="#c-拥塞避免-算法" class="headerlink" title="c. 拥塞避免 算法"></a>c. 拥塞避免 算法</h6><ul><li>原理<ul><li>使得拥塞窗口（cwnd）按线性规律 缓慢增长：每经过一个往返时间RTT，发送方的拥塞窗口（cwnd）加1</li></ul></li></ul><blockquote><p>拥塞避免 并不可避免拥塞，只是将拥塞窗口按现行规律缓慢增长，使得网络比较不容易出现拥塞<br>相比慢开始算法的加倍，拥塞窗口增长速率缓慢得多</p></blockquote><ul><li>示意图</li></ul><p><img src="../../../images/tcp24.png" style="zoom:60%"></p><h5 id="解决方案1描述（慢开始-amp-拥塞避免）"><a href="#解决方案1描述（慢开始-amp-拥塞避免）" class="headerlink" title="解决方案1描述（慢开始 &amp; 拥塞避免）"></a>解决方案1描述（慢开始 &amp; 拥塞避免）</h5><ul><li>为了防止拥塞窗口（cwnd）增长过大而引起网络拥塞，采用慢开始 &amp; 拥塞避免 2种算法，具体规则如下</li></ul><p><img src="../../../images/tcp25.png" style="zoom:60%"></p><ul><li>实例说明</li></ul><p><img src="../../../images/tcp26.png" style="zoom:60%"></p><h4 id="解决方案2：快重传-amp-快恢复"><a href="#解决方案2：快重传-amp-快恢复" class="headerlink" title="解决方案2：快重传 &amp; 快恢复"></a>解决方案2：快重传 &amp; 快恢复</h4><p>快重传 &amp; 快恢复的解决方案 是对慢开始 &amp; 拥塞避免算法的改进</p><ul><li>2.1 储备知识：快重传算法、快恢复算法 *</li></ul><h5 id="a-快重传算法"><a href="#a-快重传算法" class="headerlink" title="a. 快重传算法"></a>a. 快重传算法</h5><ul><li><p>原理</p><ul><li>接收方 每收到一个失序的报文段后 就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认</li><li>发送方只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必 继续等待设置的重传计时器到期</li></ul></li><li><p>作用</p><ul><li>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%</li></ul></li><li><p>示意图<br><img src="../../../images/tcp27.png" style="zoom:60%"></p></li></ul><h5 id="b-快恢复"><a href="#b-快恢复" class="headerlink" title="b. 快恢复"></a>b. 快恢复</h5><p>当发送方连续收到3个重复确认后，就：</p><ul><li>执行 乘法减小 算法：把 慢开始门限（ssthresh）设置为 出现拥塞时发送方窗口值的一半 = 拥塞窗口的1半</li><li>将拥塞窗口（cwnd）值设置为 慢开始门限ssthresh减半后的数值 = 拥塞窗口的1半</li><li>执行 加法增大 算法：执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</li></ul><blockquote><p>注：</p><ul><li>由于跳过了拥塞窗口（cwnd）从1起始的慢开始过程，所以称为：快恢复</li><li>此处网络不会发生网络拥塞，因若拥塞，则不会收到多个重复确认报文</li></ul></blockquote><h5 id="解决方案描述（快重传-amp-快恢复）"><a href="#解决方案描述（快重传-amp-快恢复）" class="headerlink" title="解决方案描述（快重传 &amp; 快恢复）"></a>解决方案描述（快重传 &amp; 快恢复）</h5><ul><li>原理<ul><li>为了优化慢开始 &amp; 拥塞避免的解决方案，在上述方案中加入快重传 &amp; 快恢复 2种算法，具体规则如下</li></ul></li></ul><p><img src="../../../images/tcp28.png" style="zoom:60%"></p><ul><li>示意图</li></ul><p><img src="../../../images/tcp29.png" style="zoom:60%"></p><p>至此，关于TCP无差错传输的知识讲解完毕。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址：&lt;a href=&quot;https://www.jianshu.com/p/65605622234b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/65605622234b&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="hexo/blog/2022/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"/>
    <id>hexo/blog/2022/07/计算机网络.html</id>
    <published>2022-07-06T05:54:20.000Z</published>
    <updated>2022-07-11T07:19:20.610Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址：<a href="https://www.jianshu.com/p/45d27f3e1196" target="_blank" rel="noopener">https://www.jianshu.com/p/45d27f3e1196</a></p><h2 id="1、计算机网络结构"><a href="#1、计算机网络结构" class="headerlink" title="1、计算机网络结构"></a>1、计算机网络结构</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul><li><p>定义<br>计算机网络各层 + 其协议的集合</p></li><li><p>作用<br>定义该计算机网络的所能完成的功能</p></li></ul><h3 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h3><p>计算机网络体系结构分为三种：</p><ul><li>OSI体系结构</li><li>TCP/IP体系结构</li><li>五层体系结构</li></ul><blockquote><ul><li>OSI体系结构：概念清楚 &amp; 理念完整，但复杂 &amp; 不实用 </li><li>TCP / IP体系结构：含了一系列构成互联网基础的网络协议，是Internet的核心协议 &amp; 被广泛应用于局域网 和 广域网 </li><li>五层体系结构：融合了OSI 与 TCP / IP的体系结构，目的是为了学习 &amp; 讲解计算机原理 </li></ul></blockquote><table><br>  <tr><br>    <th>OSI体系结构(7层)</th><br>    <th>TCP/IP协议体系(4层)</th><br>    <th>五层体系结构(5层)</th><br>  </tr><br>  <tr><br>    <td>7.应用层</td><br>    <td rowspan="3">4.应用层<br>(HTTP)</td><br>    <td rowspan="3">5.应用层</td><br>  </tr><br>  <tr><br>    <td>6.表示层</td><br>  </tr><br>  <tr><br>    <td>5.会话层</td><br>  </tr><br>  <tr><br>    <td>4.传输层</td><br>    <td>3.运输层<br>(TCP、UDP)</td><br>    <td>4.运输层</td><br>  </tr><br>  <tr><br>    <td>3.网络层</td><br>    <td>2. 网际层<br>(IP)</td><br>    <td>3.网络层</td><br>  </tr><br>  <tr><br>    <td>2.链路层</td><br>    <td rowspan="2">1.网络接口层</td><br>    <td>2.链路层</td><br>  </tr><br>  <tr><br>    <td>1.物理层</td><br>    <td>1.物理层</td><br>  </tr><br></table><blockquote><p>低三层为通信子网，负责数据传输<br>高三层为资源子网，相当于计算机系统，完成数据处理；<br>传输层承上启下 </p></blockquote><h4 id="TCP-IP体系结构详细介绍"><a href="#TCP-IP体系结构详细介绍" class="headerlink" title="TCP/IP体系结构详细介绍"></a>TCP/IP体系结构详细介绍</h4><p>由于 TCP / IP体系结构较为广泛，故主要讲解</p><table><br>  <tr><br>    <th>层级</th><br>    <th>作用</th><br>    <th>传输单位</th><br>    <th>功能</th><br>    <th>具体协议</th><br>  </tr><br>  <tr><br>    <td>1、网络接口层</td><br>    <td>负责与链路(传输媒介)的数据运输工作</td><br>    <td>帧</td><br>    <td><em> 组帧、差错控制、流量控制和运输管理</em></td><br>    <td> EIA-232C、CCITT的X.21<br><br>      <em> SDLC、HDLC、PPP、STP、帧中继<br>    </em></td><br>  </tr><br><br>  <tr><br>    <td>2、网际层</td><br>    <td>为不同主机提供通信服务：网络层的分组数据从源端传到目的端</td><br>    <td>数据报</td><br>    <td> 封装数据成分组/包、路由选择<br>      <br><em> 流量控制、拥塞控制、差错控制 &amp; 网际互连<br>    </em></td><br>    <td> IP协议、ARP协议、RARP协议、ICMP协议、IGMP协议、IPX、OSPF</td><br>  </tr><br><br>  <tr><br>    <td>3、运输层</td><br>    <td>为不同主机进程间提供通信服务</td><br>    <td>报文段TCP、用户数据报UDP</td><br>    <td>为端到端的连接提供可靠的传输服务、流量控制、差错控制、数据传输管理服务</td><br>    <td>TCP协议、UDP协议</td><br>  </tr><br><br>  <tr><br>    <td>4、应用层</td><br>    <td>定义应用进程间通信  &amp; 交互的规则</td><br>    <td>/</td><br>    <td>/</td><br>    <td><br>      HTTP协议<br>      <br><br>      DNS协议<br>      <br><br>      SMTP协议<br>      <br><br>      POP协议<br>      <br><br>      FTP协议<br>      <br><br>      SMB协议<br>      <br><br>      Telnet协议<br>      <br><br>      SSH协议<br>    </td><br>  </tr><br><br></table><h2 id="2、TCP协议"><a href="#2、TCP协议" class="headerlink" title="2、TCP协议"></a>2、TCP协议</h2><p>Transmission Control Protocol，即 传输控制协议</p><blockquote><ul><li>属于 传输层通信协议</li><li>基于TCP的应用层协议有HTTP、SMTP、FTP、Telnet 和 POP3</li></ul></blockquote><p>关于TCP具体信息，可以查看 <a href="TCP协议详解.md">TCP协议</a></p><h2 id="3、UDP协议"><a href="#3、UDP协议" class="headerlink" title="3、UDP协议"></a>3、UDP协议</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>User Datagram Protocol，即 用户数据报协议</p><blockquote><ul><li>属于 传输层通信协议</li><li>基于UDP的应用层协议有 TFTP、SNMP 与 DNS</li></ul></blockquote><h3 id="3-2-特定"><a href="#3-2-特定" class="headerlink" title="3.2 特定"></a>3.2 特定</h3><p>无连接的、不可靠的、面向报文、无拥塞控制，具体介绍如下：</p><table><thead><tr><th>特定</th><th>描述</th></tr></thead><tbody><tr><td>无连接</td><td>使用UDP传输数据前，不需要建立UDP连接</td></tr><tr><td>不可靠</td><td>UDP数据包传输后，不管数据接收包是否接收到</td></tr><tr><td>面向报文</td><td>数据以数据报文的形式传输</td></tr><tr><td>无拥塞控制</td><td>由于是不可靠传输，即不考虑是否接收到数据，所以也就不需要拥塞控制</td></tr></tbody></table><h3 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h3><ul><li>优点：速度快</li><li>缺点：数据容易丢失</li></ul><h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h3><p>要求通信速度高</p><blockquote><ul><li>域名转换：DNS协议</li><li>文件传输：FTP协议</li><li>网络管理：SNMP协议</li><li>远程文件服务器：NFS协议</li></ul></blockquote><h3 id="3-5-TCP-amp-UDP-的区别"><a href="#3-5-TCP-amp-UDP-的区别" class="headerlink" title="3.5 TCP &amp; UDP 的区别"></a>3.5 TCP &amp; UDP 的区别</h3><table><br>  <tr><br>    <th rowspan="2">类型</th><br>    <th colspan="3">特点</th><br>    <th colspan="2">性能</th><br>    <th rowspan="2">应用场景</th><br>    <th rowspan="2">首部字节</th><br>  </tr><br>  <tr><br>    <th>是否面向连接</th><br>    <th>传输可靠性</th><br>    <th>传输形式</th><br>    <th>传输效率</th><br>    <th>所需资源</th><br>  </tr><br>  <tr><br>    <td>TCP</td><br>    <td>面向连接</td><br>    <td>可靠</td><br>    <td>字节流</td><br>    <td>慢</td><br>    <td>多</td><br>    <td>要求通信数据可靠</td><br>    <td>20-60</td><br>  </tr><br>  <tr><br>    <td>UDP</td><br>    <td>无连接</td><br>    <td>不可靠</td><br>    <td>数据报文段</td><br>    <td>快</td><br>    <td>少</td><br>    <td>要求通信速度快</td><br>    <td>8字节，由4个字段组成</td><br>  </tr><br></table><h2 id="4、HTTP协议"><a href="#4、HTTP协议" class="headerlink" title="4、HTTP协议"></a>4、HTTP协议</h2><h2 id="5、Socket"><a href="#5、Socket" class="headerlink" title="5、Socket"></a>5、Socket</h2><h2 id="6、Other"><a href="#6、Other" class="headerlink" title="6、Other"></a>6、Other</h2><h3 id="6-1-在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#6-1-在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="6.1 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>6.1 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h3><blockquote><p>打开一个网页，整个过程会使用哪些协议</p></blockquote><p><img src="../../../images/other.png" style="zoom:60%"></p><h3 id="6-2-IP地址（IPv4地址）"><a href="#6-2-IP地址（IPv4地址）" class="headerlink" title="6.2 IP地址（IPv4地址）"></a>6.2 IP地址（IPv4地址）</h3><ul><li><p>定义<br>连接在Internet中的每一台主机（或 路由器）的全球唯一的标识符</p></li><li><p>组成<br>IP地址 = 32位 = 网络号 + 主机号；即IP地址::={&lt;网络号&gt;，&lt;主机号&gt;}</p></li></ul><blockquote><p>其中：<br>网络号：标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。<br>主机号：标志该主机（或路由器）。一个主机号在它面前的网络号所指明的网络范围必须是唯一的。 </p></blockquote><p>不同类型的IP地址，其主机号 &amp; 网络号所占字节数不同；<em> 故：一个IP地址在整个网络范围内是唯一的 </em></p><ul><li>分类<br>传统的IP地址是分类的地址，分为A，B，C，D，E五类</li></ul><blockquote><p>区别在于网络号 &amp; 主机号占的字节数不同 </p></blockquote><p><img src="../../../images/ip1.png" style="zoom:60%"></p><h3 id="6-3-ICMP协议"><a href="#6-3-ICMP协议" class="headerlink" title="6.3 ICMP协议"></a>6.3 ICMP协议</h3><ul><li>定义<br>Internet Control Message Protocol，即 网际控制报文协议</li></ul><blockquote><ul><li>属于IP层协议 </li><li>注：ICMP报文不是高层协议，而是作为IP层数据报的数据，加上数据报首部，组成IP数据报发出去</li></ul></blockquote><ul><li><p>作用<br>更有效地转发IP数据包 &amp; 提高交付成功的机会</p></li><li><p>分类<br>ICMP差错报告报文 &amp; ICMP询问报文</p></li><li><p>主要应用<br>PING（分组网间探测）、Traceroute（跟踪1个分组从源点到终点的路径，原理 = 从源主机向目的主机发送一连串的IP数据报）</p></li></ul><h3 id="6-4-Ping的过程"><a href="#6-4-Ping的过程" class="headerlink" title="6.4 Ping的过程"></a>6.4 Ping的过程</h3><ul><li>定义<br>Packet InterNet Groper，即分组网间探测</li></ul><blockquote><ul><li>是 ICMP报文的1个重要应用：使用了IPCM回送请求 &amp; 回送回答报文</li><li>是应用层直接使用网络层ICMP的1个例子，无经过传输层的TCP、UDP</li></ul></blockquote><ul><li><p>作用<br>测试2个主机的连通性</p></li><li><p>原理</p><ul><li>向目的主机发送多个ICMP回送请求报文</li><li>根据 目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间</li><li>最终显示的结果：发送到目的主机的IP地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大 &amp; 平均值</li></ul></li></ul><p><img src="../../../images/osi.png" style="zoom:60%"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址：&lt;a href=&quot;https://www.jianshu.com/p/45d27f3e1196&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/45d27f3e1196&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>程序设计语言</title>
    <link href="hexo/blog/2022/07/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80.html"/>
    <id>hexo/blog/2022/07/程序设计语言.html</id>
    <published>2022-07-06T03:29:19.000Z</published>
    <updated>2022-07-06T03:32:17.055Z</updated>
    
    <content type="html"><![CDATA[<p>计算机语言分为高级语言、低级语言</p><p>语言越低级，离01代码越近，中间“翻译”的步骤也就越简洁，计算机执行的越快，对计算机很友好；</p><p>语言越高级，封装程度就越高，人类就可以用更少的代码来实现功能。编写高级语言并不需要知道他是怎么转换为计算机识别的语言；</p><p>越高级，就越”龟速”，能做的事情也就越少，但同样代码量也比较少。</p><p>低级与高级，省时间与省力气的关系。人写的代码少了，CPU处理的代码就多，。</p><ul><li>低级：机器码，汇编，Base语言</li><li>次低级：C，C++</li><li>高级：Java，C#</li><li>更高级：Python，PHP，JavaScript</li></ul><p>高级语言一般为解释型语言：<br>  在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。<br>  最典型的代表语言为JavaScript、Python、Ruby和Perl等 </p><p>低级语言一般为编译型语言：<br>  运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。<br>  最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件</p><p>编译型：<br>  运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。<br>  最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件。 </p><p>解释型：<br>  在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。<br>  最典型的代表语言为JavaScript、Python、Ruby和Perl等 </p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机语言分为高级语言、低级语言&lt;/p&gt;
&lt;p&gt;语言越低级，离01代码越近，中间“翻译”的步骤也就越简洁，计算机执行的越快，对计算机很友好；&lt;/p&gt;
&lt;p&gt;语言越高级，封装程度就越高，人类就可以用更少的代码来实现功能。编写高级语言并不需要知道他是怎么转换为计算机识别的语言；
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="hexo/blog/2022/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>hexo/blog/2022/07/面向对象.html</id>
    <published>2022-07-05T06:33:03.000Z</published>
    <updated>2022-07-05T07:47:49.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h2><p>把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形成类。<br>类中的大多数数据，只能用本类的方法进行处理。<br>类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。</p><blockquote><p>面向对象的三大特征</p><ul><li>封装</li><li>继承</li><li>多态</li></ul></blockquote><p>参考地址： <a href="https://blog.csdn.net/sugar_no1/article/details/86366714" target="_blank" rel="noopener">https://blog.csdn.net/sugar_no1/article/details/86366714</a></p><h2 id="面向对象分析与设计"><a href="#面向对象分析与设计" class="headerlink" title="面向对象分析与设计"></a>面向对象分析与设计</h2><p>参考地址：<a href="https://blog.csdn.net/huangshanchun/article/details/121727557" target="_blank" rel="noopener">https://blog.csdn.net/huangshanchun/article/details/121727557</a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>参考地址：<a href="https://blog.csdn.net/gghhb12/article/details/124269575" target="_blank" rel="noopener">https://blog.csdn.net/gghhb12/article/details/124269575</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象基本概念&quot;&gt;&lt;a href=&quot;#面向对象基本概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象基本概念&quot;&gt;&lt;/a&gt;面向对象基本概念&lt;/h2&gt;&lt;p&gt;把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件工程基础知识</title>
    <link href="hexo/blog/2022/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>hexo/blog/2022/07/软件工程基础知识.html</id>
    <published>2022-07-05T03:35:36.000Z</published>
    <updated>2022-08-24T09:38:53.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h2><p>共有9种开发模型，适用范围各不相同</p><ul><li><p>瀑布模型（Waterfall Model）</p><ul><li>瀑布模型适合应用的项目类型：需求明确 或者 二次开发</li><li>瀑布模型是结构化方法中的模型，一般应用于结构化的开发</li></ul></li><li><p>原型模型（Prototype Model）</p><ul><li>适合应用的项目类型：需求不明确</li><li>强调构造一个简易的系统</li></ul></li><li><p>演化模型（Evolutionary Model）</p><ul><li>系统的原型经过多轮调整最终形成了产品</li></ul></li><li><p>螺旋模型（Spiral Model）</p><ul><li>包含原型模式和瀑布模型，演化模型，它由多个模型组成</li><li>螺旋模型具有风险分析这个特征，这是其他模型所不具备的</li></ul></li><li><p>增量模型（Incremental Model）</p><ul><li>由原型模型的思想 + 瀑布模型的思想构成</li><li>风险低，用户会多次接触到项目的核心模块到，能尽早的发现问题并修正。</li></ul></li><li><p>V模型</p><ul><li>强调测试要伴随着整个软件开发的过程</li><li>需求分析阶段进行验收测试&amp;系统测试</li></ul></li><li><p>喷泉模型（Water Fountain Model）</p><ul><li>面向对象的，具有迭代和无间隙的特点；</li></ul></li><li><p>快速(应用)开发（RAD）模型</p><ul><li>RAD模型是由瀑布模型（SDLC）和构建组装模型（CBSD）组成</li><li>使用VB，Delphi，C#等可以通过拖动控件来快速实现界面地构建</li></ul></li><li><p>构建组装模型（CBSD）</p></li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>6大设计原则：</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p>对类来说，⼀个类应该只负责⼀项职责。如果⼀个类负责两个职责，可能存在职责1变化，引起职责2的变化情况。可以基于抽象逻<br>辑，或者业务逻辑对类进⾏细化。</p></blockquote><h3 id="接⼝隔离原则"><a href="#接⼝隔离原则" class="headerlink" title="接⼝隔离原则"></a>接⼝隔离原则</h3><blockquote><p>客户端不应该依赖它不需要的接⼝，⼀个类对另外⼀个类的依赖，应该建⽴在最⼩的接⼝上。</p></blockquote><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><blockquote><p>⾼层模块不应该依赖低层模块，两者应依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；中⼼思想是⾯向接⼝编程。</p></blockquote><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>假设有以下场景：</p><ul><li>存在类型T1，和实例对象O1</li><li>存在类型T2，和实例对象O2</li></ul><blockquote><p>如果将所有类型T1的对象都替换成类型T2的对象O2，程序的行为不会发生变化。那么类型T2是类型T1的子类型。<br>换句话说，有引用基类的地方必须能透明的使用其子类的对象</p></blockquote><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p>开闭原则是编程中最基础、最重要的设计原则，在代码结构的设计时，应该考虑对扩展开发，对修改关闭，抽象思维搭建结构，具体实现扩展细节。</p></blockquote><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><blockquote><p>迪⽶特原则⼜叫最少知道原则，即⼀个类对⾃⼰依赖的类知道的越要越好。也就是说，对于依赖的类不管多么复杂，都尽量将逻辑封<br>装在类的内部。对外除了提供的public⽅法，不对外开放任何信息。类与类关系越密切，耦合度越⼤，耦合的⽅式很多，依赖，关<br>联，组合，聚合等。</p></blockquote><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>参考地址：<a href="https://blog.csdn.net/weixin_43421142/article/details/108038676" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43421142/article/details/108038676</a></p><h2 id="质量特性"><a href="#质量特性" class="headerlink" title="质量特性"></a>质量特性</h2><p>参考地址：<a href="https://blog.csdn.net/shuaihj/article/details/7599528" target="_blank" rel="noopener">https://blog.csdn.net/shuaihj/article/details/7599528</a></p><h2 id="Pert图"><a href="#Pert图" class="headerlink" title="Pert图"></a>Pert图</h2><p>参考地址：<a href="https://blog.csdn.net/Daisy74RJ/article/details/106593226" target="_blank" rel="noopener">https://blog.csdn.net/Daisy74RJ/article/details/106593226</a></p><h2 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h2><p>参考地址：<a href="https://zhuanlan.zhihu.com/p/431021736" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/431021736</a></p><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p>参考地址：<a href="https://blog.csdn.net/baidu_32492845/article/details/89604337" target="_blank" rel="noopener">https://blog.csdn.net/baidu_32492845/article/details/89604337</a></p><h2 id="各种码"><a href="#各种码" class="headerlink" title="各种码"></a>各种码</h2><p>原码、补码、反码参考地址：<a href="https://blog.csdn.net/lluojian/article/details/119579921" target="_blank" rel="noopener">https://blog.csdn.net/lluojian/article/details/119579921</a></p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数<br>[+127]原 = 0111 1111<br>[-127]原 = 1111 1111<br>数值“0”由两种原码表示形式：<br>[+0]原 = 0000 0000<br>[-0]原 = 1000 0000</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>源码的范围：-128 ~ +127，最高位是符号位，0表示正数，1表示负数</p><p>[+127]补 = 0111 1111<br>[-128]补 = 1000 0000<br>因为 [-127]反 = 1000 0000 而 [-127]补 = 反 + 1 = 1 0000001<br>所以 [-128]补 = 1000 0000</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数</p><p>[+127]反 = 0111 1111<br>[-127]反 = 1000 0000<br>数值“0”由两种反码表示形式：<br>[+0]反 = 0000 0000<br>[-0]反 = 1111 1111</p><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>使用二进制来编码的十进制。<br>分为三种：</p><ul><li>8421码</li><li>余3码（8421码+）</li><li>2421码</li></ul><h4 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h4><p>一种有权码，四个二进制的权值分配分别为8、4、2、1。</p><p>就是直接将10进制的每位数都转化为长度为4的二进制数，如：</p><p>0——0000</p><p>1——0001</p><p>2——0010</p><p>3——0011</p><p>4——0100</p><p>5——0101</p><p>6——0110</p><p>7——0111</p><p>8——1000</p><p>9——1001</p><p>123——0001 0010 0011（就是先把1的8421码写下来，再写2的，最后写3的）</p><blockquote><p>使用8421码表示的数字怎么进行加法运算？<br>步骤：1.二进制加法运算<br>2.落到1010—10010非合法范围加6修正，0000—1001合法范围就不用+6修正<br>举例：1+1         0001+ 0001 =0010 （=2）不用修正<br>     4+7         0100+ 0111 =1011   （=11）不合法要修正    1011+0110=10001 补0 =0001 0001<br>     9+9         1001+1001=1  0010    修正，后四位加6   0010+0110=1000<br>     补0，结果为 0001 1000 （=18）</p></blockquote><h4 id="余3码（8421码-）"><a href="#余3码（8421码-）" class="headerlink" title="余3码（8421码+）"></a>余3码（8421码+）</h4><p>0——0000+0011=0011</p><p>1——0001+0011=0100</p><p>2——0010+0011=0101</p><p>3——0011+0011=0110</p><p>4——0100+0011=0111</p><p>5——0101+0011=1000</p><p>6——0110+0011=1001</p><p>7——0111+0011=1010</p><p>8——1000+0011=1011</p><p>9——1001+0011=1100</p><p>四个二进制位的权值不固定，是无权码</p><h4 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h4><p>有权码</p><p>四个二进制权值分别为2、4、2、1</p><p>0——0000</p><p>1——0001</p><p>2——0010</p><p>3——0011</p><p>4——0100</p><p>在这里加个分隔，why？注意：0-4编码第一位是0，5-9编码第一位是1。</p><p>这又是为什么呢？避免歧义的发生！你看，0100和1010都可以表示4，这就麻烦了，所以规定0-4编码第一位是0，5-9编码第一位是1，从而使表示方法唯一！</p><p>5——1011</p><p>6——1100</p><p>7——1101</p><p>8——1110</p><p>9——1111</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="10进制转为其他任意进制"><a href="#10进制转为其他任意进制" class="headerlink" title="10进制转为其他任意进制"></a>10进制转为其他任意进制</h3><p>如十进制数 m 转换为 n 进制的数， 此时用 m 一直除以 n 并留余，除到商为0时，将 余数 从下往上排列，即为最终结果。</p><h3 id="二进制转换为10进制"><a href="#二进制转换为10进制" class="headerlink" title="二进制转换为10进制"></a>二进制转换为10进制</h3><p>如 1001 0101 1010 转换为 10进制</p><p> 1001 0101 1010  从左往右排列： 0101 1010 1001</p><p>从左往右开始累加计算： 0 <em> 2^0 + 1 </em> 2^1 + 0 <em> 2^2 + 1 </em> 2^3 + 1 <em> 2^4 + 0 </em> 2^5 + ….<br>相当于累加 当前位数n对应的值m(0 或 1) * 2^(n-1) 即为最终的结果</p><p>如上述数据 1001 0101 1010 转为 10进制为 4342</p><h3 id="其他任意进制转为10进制"><a href="#其他任意进制转为10进制" class="headerlink" title="其他任意进制转为10进制"></a>其他任意进制转为10进制</h3><p>与 二进制 转为 10进制类似<br>只不过在二进制转10进制中，都是乘以2的幂等，n进制转换就是乘以n的幂等</p><ul><li>如 9进制表示的数140 转换为 10进制</li></ul><p>0 <em> 9^0 + 4 </em> 9^1 + 1 * 9^2 = 0 + 36 + 81 = 117</p><h3 id="二进制转换为8、16进制"><a href="#二进制转换为8、16进制" class="headerlink" title="二进制转换为8、16进制"></a>二进制转换为8、16进制</h3><ul><li><p>转换为8进制时，直接将数据分割为每3位一段，不足3位的在前面补0，再将每段直接转换为10进制数即可</p><ul><li>如1110101，因只有7位，不是3的倍数，在前面补两个0，再分割。 001 110 101，再将三段转为10进制，最终结果：165</li></ul></li><li><p>转换为16进制，直接将数据分割为每4位一段，不足4位的在前面补0，再将每段直接转换为16进制数即可</p><ul><li>如1110101，因只有7位，不是4的倍数，在前面补1个0，再分割。 0111 0101，再将此两端都转为16进制，最终结果：75H</li></ul></li></ul><p>16进制的数可以使用H后缀、或者 0x前缀标识</p><p>75H = 0x75</p><h3 id="二进制转换为其他进制"><a href="#二进制转换为其他进制" class="headerlink" title="二进制转换为其他进制"></a>二进制转换为其他进制</h3><p>先进二进制转为10进制，再将10进制转为其他进制</p><ul><li>1110101 转为9进制<br>1110101 转为10进制为 117，再将117转换为9进制，即为 140</li></ul><h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><p>参考地址：</p><ul><li><a href="https://blog.csdn.net/yldmkx/article/details/109537911" target="_blank" rel="noopener">https://blog.csdn.net/yldmkx/article/details/109537911</a></li><li><a href="https://www.jianshu.com/p/014f96049fa3" target="_blank" rel="noopener">https://www.jianshu.com/p/014f96049fa3</a></li></ul><p>算术表达式分为：</p><ul><li>中缀表达式</li><li>前缀表达式</li><li>后缀表达式</li></ul><p>一般默认为中缀表达式<br>如：a*(b+c/d)+e</p><h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><ul><li>中缀表达式转换为前缀表达式</li></ul><blockquote><ul><li>1、初始化两个栈：运算符栈S1和储存中间结果的栈S2；</li><li>2、从右至左扫描中缀表达式；</li><li>3、遇到操作数时，将其压入S2；</li><li>4、遇到运算符时，比较其与S1栈顶运算符的优先级：<ul><li>如果S1为空，则直接将此运算符入栈；</li><li>否则，若优先级比栈顶运算符的较高或相等(后缀表达式中是较高,没有相等)或栈顶运算符为右括号“)”，也将运算符压入S1；</li><li>否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；</li></ul></li><li>5、遇到括号时：<ul><li>如果是右括号“)”，则直接压入S1；</li><li>如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃</li></ul></li><li>6、重复步骤(2)至(5)，直到表达式的最左边；</li><li>7、将S1中剩余的运算符依次弹出并压入S2；</li><li>8、依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。</li><li>(后缀表达式这里要将字符串反转输出,这里直接输出即可)</li></ul></blockquote><h4 id="前缀表达式的计算"><a href="#前缀表达式的计算" class="headerlink" title="前缀表达式的计算"></a>前缀表达式的计算</h4><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><ul><li><p>中缀表达式转换为后缀表达式</p><ul><li><p>1.创建运算符栈s1和操作数数组a2，然后扫描中缀表达式；</p></li><li><p>2.如果是操作数，直接放入数组a2；</p></li><li><p>3.如果是运算符，栈s1为空或栈顶符号为左括号，或者优先级比栈顶运算符高，则入栈结束该步骤；否则将s1栈顶运算符弹出放入操作数数组a2，然后重复该步骤3。</p></li><li><p>4.如果是左括号，直接压入运算符栈s1；如果是右括号，依次弹出s1的运算符放入s2，直至遇到左括号结束，并将左、右括号舍弃。</p></li><li><p>5.循环步骤2-4直至表达式扫描结束，将s1的剩余运算符依次弹出放入数组a2，数组a2就是后缀表达式。</p></li></ul></li></ul><ul><li>question: a*(b+c/d)+e转为后缀表达式</li></ul><blockquote><p>1、建立数组a1,栈s1, 遍历字符串”a<em>(b+c/d)+e”<br>2、操作数a,添加到数组a1{a}<br>3、运算符</em>,压入栈s1 [<em>]<br>4、左括号，压入栈s1 [</em>,(]<br>5、操作数b，添加到数组a1{a,b}<br>6、运算符+，因为s1栈顶元素为左括号”(“,所以将+压入栈 s1 [<em>,(,+]<br>7、操作数c，添加到数组a1{a,b,c}<br>8、运算符/，因为s1栈顶元素为+，优先级比栈顶运算符高，所以将/压入栈s1 [</em>,(,+,/]<br>9、操作数d，添加到数组a1{a,b,c,d}<br>10、右括号,弹出s1中的运算符并添加到数组a1中，直到遇到左括号为止,则a1为{a,b,c,d,/,+},此时栈s1为[<em>]<br>11、运算符+，因为s1栈顶元素为</em>，优先级比栈顶运算符低，则将 <em> 弹出加入到数组a1{a,b,c,d,/,+，</em>}, s1[+]<br>12、操作数e,添加到数组a1{a,b,c,d,/,+，<em>,e}<br>13、遍历完成，将s1中都出栈添加到数组a1中，最后得到后缀表达式: **abcd/+</em>e+**</p></blockquote><h4 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h4><p>我们得到后缀表达式 3 11 8 - * 45 98 60 - 10 / 6 + / -，那么怎么计算呢？<br>分为三步：</p><ul><li>创建一个栈，并且从左至右扫描表达式；</li><li>遇到数字，将数字压入栈中；遇到运算符则弹出栈顶的两个元素，使用运算符进行计算（第二个元素在前），然后将计算结果再压入栈中；</li><li>重复步骤2直到表达式扫描结束，最后弹出栈顶元素就是计算结果。</li></ul><h2 id="有限自动机DFA"><a href="#有限自动机DFA" class="headerlink" title="有限自动机DFA"></a>有限自动机DFA</h2><p>参考地址：</p><ul><li><a href="https://www.cnblogs.com/SsoZhNO-1/p/13821002.html" target="_blank" rel="noopener">https://www.cnblogs.com/SsoZhNO-1/p/13821002.html</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开发模型&quot;&gt;&lt;a href=&quot;#开发模型&quot; class=&quot;headerlink&quot; title=&quot;开发模型&quot;&gt;&lt;/a&gt;开发模型&lt;/h2&gt;&lt;p&gt;共有9种开发模型，适用范围各不相同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;瀑布模型（Waterfall Model）&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>UML图</title>
    <link href="hexo/blog/2022/07/UML%E5%9B%BE.html"/>
    <id>hexo/blog/2022/07/UML图.html</id>
    <published>2022-07-04T08:09:13.000Z</published>
    <updated>2022-07-05T03:10:04.473Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UML图有可以分类为</p><ul><li>类图</li><li>状态图</li><li>活动图</li><li>交互图-时序图</li><li>交互图-协作图</li><li>用例图</li><li>ER图</li></ul></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>参考地址：<a href="https://blog.csdn.net/zhaxun/article/details/124048871" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124048871</a></p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>参考地址： <a href="https://blog.csdn.net/zhaxun/article/details/124201040" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124201040</a></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>参考地址： <a href="https://blog.csdn.net/qq_41784749/article/details/112242348" target="_blank" rel="noopener">https://blog.csdn.net/qq_41784749/article/details/112242348</a></p><h2 id="交互图-时序图"><a href="#交互图-时序图" class="headerlink" title="交互图-时序图"></a>交互图-时序图</h2><p>参考地址：<a href="https://blog.csdn.net/qq_23024699/article/details/120444441" target="_blank" rel="noopener">https://blog.csdn.net/qq_23024699/article/details/120444441</a></p><h2 id="交互图-协作图"><a href="#交互图-协作图" class="headerlink" title="交互图-协作图"></a>交互图-协作图</h2><p>参考地址：<a href="https://blog.csdn.net/neusoft2016/article/details/116195191" target="_blank" rel="noopener">https://blog.csdn.net/neusoft2016/article/details/116195191</a></p><p>时序图与协作图的区别与联系：</p><ul><li><p>协作图和时序图都表示出了对象间的交互作用，但是它们侧重点不同。</p></li><li><p>时序图清楚地表示了交互作用中的时间顺序(强调时间)，但没有明确表示对象间的关系。</p></li><li><p>协作图清楚地表示了对象间的关系(强调空间)，但时间顺序必须从顺序号获得。</p></li><li><p>协作图不能体现对象的初始化和消亡的时间</p></li><li><p>协作图和时序图可以相互转化。</p></li></ul><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>参考地址：<a href="https://blog.csdn.net/zhaxun/article/details/124047015" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124047015</a></p><h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p>参考地址：<a href="https://blog.csdn.net/caohongxing/article/details/122398825" target="_blank" rel="noopener">https://blog.csdn.net/caohongxing/article/details/122398825</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;UML图有可以分类为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类图&lt;/li&gt;
&lt;li&gt;状态图&lt;/li&gt;
&lt;li&gt;活动图&lt;/li&gt;
&lt;li&gt;交互图-时序图&lt;/li&gt;
&lt;li&gt;交互图-协作图&lt;/li&gt;
&lt;li&gt;用例图&lt;/li&gt;
&lt;li&gt;ER图&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软考-软件设计师</title>
    <link href="hexo/blog/2022/07/%E8%BD%AF%E8%80%83-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88.html"/>
    <id>hexo/blog/2022/07/软考-软件设计师.html</id>
    <published>2022-07-04T06:39:48.000Z</published>
    <updated>2022-08-24T06:11:19.612Z</updated>
    
    <content type="html"><![CDATA[<p>准备报考2022年下半年的软考-软件设计师，</p><ul><li><p>为什么要考？</p><ul><li>减税</li><li>学习</li><li>考证</li></ul></li><li><p>为什么是软件设计师？</p><ul><li>因为之前没有想过去考证书，这是第一次，准备先考个中级的证书试试水</li><li>中级的证书有多个，只有软件设计师稍微有点符合自己的工作岗位，能使用到自己的一些开发经验，也能起到一定的学习作用</li></ul></li><li><p>怎么备考？</p><ul><li>bilibili</li><li>先了解大纲</li><li>逐一学习各个知识点</li><li>写真题</li></ul></li></ul><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><p>软件工程基础知识</p><ul><li>开发模型</li><li>设计原则</li><li>测试方法</li><li>质量特性</li><li>CMM, Pert图</li><li>风险管理</li><li>PV操作</li></ul></li><li><p>面向对象</p><ul><li>面向对象基本概念</li><li>面向对象分析与设计</li><li>UML</li><li>设计模式</li></ul></li><li><p>数据结构与算法</p><ul><li>数组</li><li>栈</li><li>队列</li><li>树与二叉树</li><li>图</li><li>查找与排序</li><li>常见算法</li></ul></li><li><p>程序设计语言</p><ul><li>文法</li><li>有限自动机</li><li>正规式</li><li>语句的作用</li><li>语句的语义</li><li>程序的控制结构</li><li>函数调用的参数传递</li><li>各种程序语言的特点比较</li></ul></li><li><p>计算机硬件基础</p><ul><li>浮点数运算、溢出</li><li>算术、逻辑运算</li><li>计算机体系结构分类</li><li>指令系统基础</li><li>CISC与RISC</li><li>流水线</li><li>Cache存储器可靠性分析</li><li>校验方法</li></ul></li><li><p>操作系统</p><ul><li>进程状态转换图</li><li>信号量与PV操作</li><li>死锁问题</li><li>银行家算法</li><li>段页式存储</li><li>页面置换算法</li><li>磁盘调度</li><li>树形文件系统</li></ul></li><li><p>数据库系统</p><ul><li>E-R模型</li><li>关系代数</li><li>元组演算</li><li>规范化理论(键、范式、模式分解)</li><li>并发控制</li></ul></li><li><p>计算机网络</p><ul><li>OSI模型</li><li>TCP/IP协议族</li><li>子网划分</li><li>常用的网络命令</li></ul></li><li><p>信息安全知识</p><ul><li>加密解密技术</li><li>网络安全</li><li>计算机病毒</li></ul></li><li><p>多媒体基础</p><ul><li>多媒体基本概念</li><li>计算声音</li><li>图像</li><li>视频文件的容量</li><li>JPEG, MPEG</li></ul></li><li><p>知识产权与标准化</p><ul><li>作品保护时间</li><li>侵权判定</li><li>知识产权归属</li><li>标准的分类</li><li>标准代号</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备报考2022年下半年的软考-软件设计师，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么要考？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减税&lt;/li&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;考证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么是软件设计师？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为之
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>减肥计划</title>
    <link href="hexo/blog/2022/06/%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92.html"/>
    <id>hexo/blog/2022/06/减肥计划.html</id>
    <published>2022-06-27T08:26:27.000Z</published>
    <updated>2022-06-27T08:32:55.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="减肥大计"><a href="#减肥大计" class="headerlink" title="减肥大计"></a>减肥大计</h1><p>暂时定为三个阶段，每个阶段目标均为 -5kg</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>通过修改饮食，加上 低运动量减肥操</p><h3 id="早餐"><a href="#早餐" class="headerlink" title="早餐"></a>早餐</h3><p>两个鸡蛋+ 一杯豆浆/一杯牛奶</p><h3 id="中餐"><a href="#中餐" class="headerlink" title="中餐"></a>中餐</h3><p>一碗米饭 + 青菜 + 适量牛肉、虾，保证蛋白质摄入</p><h3 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h3><p>玉米面/荞面 + 适量牛肉、虾</p><p>零食以 牛肉干、黄瓜 为准。</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>通过饮食， 加上适量有氧运动， 跑步<br>目标：75kg</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>通过饮食， 加上中等有氧运动， 跑步</p><p>目标：70kg</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;减肥大计&quot;&gt;&lt;a href=&quot;#减肥大计&quot; class=&quot;headerlink&quot; title=&quot;减肥大计&quot;&gt;&lt;/a&gt;减肥大计&lt;/h1&gt;&lt;p&gt;暂时定为三个阶段，每个阶段目标均为 -5kg&lt;/p&gt;
&lt;h2 id=&quot;第一阶段&quot;&gt;&lt;a href=&quot;#第一阶段&quot; class
      
    
    </summary>
    
    
      <category term="live" scheme="hexo/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>android API 更新</title>
    <link href="hexo/blog/2022/06/android-API-%E6%9B%B4%E6%96%B0.html"/>
    <id>hexo/blog/2022/06/android-API-更新.html</id>
    <published>2022-06-27T08:05:51.000Z</published>
    <updated>2022-06-27T08:08:54.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-API-更新记录"><a href="#android-API-更新记录" class="headerlink" title="android API 更新记录"></a>android API 更新记录</h1><h2 id="android-API-30-（android11）应用文件管理权限"><a href="#android-API-30-（android11）应用文件管理权限" class="headerlink" title="android API 30 （android11）应用文件管理权限"></a>android API 30 （android11）应用文件管理权限</h2><p>在andorid6之后需要动态请求权限，如针对文件写入、读取权限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">    <span class="keyword">var</span> permissionArray = arrayOf(</span><br><span class="line">        Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">    )</span><br><span class="line">    requestPermissions(permissionArray, <span class="number">101</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在android 11之后，这样也会弹出应用权限请求，但写入文件到sdcrd还是会失败，报错：/storage/emulated/0/io/okio.txt: open failed: ENOENT (No such file or directory)</p><p>需要修改请求权限的方式为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Environment.isExternalStorageManager()) &#123;</span><br><span class="line">    <span class="keyword">var</span> intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">    startActivityForResult(intent, <span class="number">102</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-API-更新记录&quot;&gt;&lt;a href=&quot;#android-API-更新记录&quot; class=&quot;headerlink&quot; title=&quot;android API 更新记录&quot;&gt;&lt;/a&gt;android API 更新记录&lt;/h1&gt;&lt;h2 id=&quot;android-A
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="hexo/blog/2022/06/io.html"/>
    <id>hexo/blog/2022/06/io.html</id>
    <published>2022-06-22T08:51:23.000Z</published>
    <updated>2022-06-27T03:18:42.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO是什么"><a href="#IO是什么" class="headerlink" title="IO是什么"></a>IO是什么</h2><blockquote><p>程序内部和外部进行数据交互的过程，就叫输入输出。</p><blockquote><p>程序内部是谁?内存<br>程序外部是谁?</p><blockquote><p>一般来说是两类:本地文件和网络。<br>也有别的情况，比如你和别的程序做交互，和你交互的程序也属于外部，但一般来说，就是文件和网络这么两种。</p></blockquote></blockquote></blockquote><blockquote><p>从文件里或者从网络上读数据到内存里，就叫输入;从内存里写到文件里或者发送到网络上，就叫输出</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><p>使用流，例如 FileInputStream / FileOutputStream</p></li><li><p>可以用 Reader 和 Writer 来对字符进行读写</p></li><li><p>流的外面还可以套别的流，层层嵌套都可以</p></li><li><p>BufferedXXXX 可以给流加上缓冲。对于输入流，是每次多读一些放在内存 里面，下次再去数据就不用再和外部做交互(即不必做 IO 操作);对于输 出流，是把数据先在内存里面攒一下，攒够一波了再往外部去写。</p></li></ul><p>通过缓存的方式减少和和外部的交互，从而可以提高效率</p><ul><li><p>文件的关闭:close()</p></li><li><p>需要用到的写过的数据，flush() 一下可以保证数据真正写到外部去(读数据 没有这样的担忧)</p></li><li><p>这个就是 Java 的 I/O，它的原理就是内存和外界的交互</p></li></ul><p>IO 又可以分为 BIO、NIO、AIO</p><h2 id="BIO、NIO、AIO-区别"><a href="#BIO、NIO、AIO-区别" class="headerlink" title="BIO、NIO、AIO 区别"></a>BIO、NIO、AIO 区别</h2><h3 id="IO模型主要分类："><a href="#IO模型主要分类：" class="headerlink" title="IO模型主要分类："></a>IO模型主要分类：</h3><ul><li><p>同步(synchronous)IO与异步(asynchronous)IO</p></li><li><p>阻塞(blocking)IO与非阻塞(non-blocking)IO</p></li><li><p>同步阻塞IO(blocking-IO)即为 BIO</p></li><li><p>同步非阻塞IO(non-blocking-IO)即为 NIO</p></li><li><p>异步非阻塞IO(synchronous-non-blocking-IO)即为 AIO</p></li></ul><h3 id="BIO（同步阻塞I-O模式）"><a href="#BIO（同步阻塞I-O模式）" class="headerlink" title="BIO（同步阻塞I/O模式）"></a>BIO（同步阻塞I/O模式）</h3><p>数据的读取、写入等操作必须阻塞在一个线程内等待操作完成</p><h3 id="NIO（同步非阻塞I-O模式）"><a href="#NIO（同步非阻塞I-O模式）" class="headerlink" title="NIO（同步非阻塞I/O模式）"></a>NIO（同步非阻塞I/O模式）</h3><p>同时支持阻塞与非阻塞模式，NIO的做法是叫一个线程不断的轮询IO操作的的状态，看看是否有任务的状态发生了改变，从而进行下一步的操作。</p><p>默认是阻塞式的</p><h3 id="AIO-（异步非阻塞I-O模型）"><a href="#AIO-（异步非阻塞I-O模型）" class="headerlink" title="AIO （异步非阻塞I/O模型）"></a>AIO （异步非阻塞I/O模型）</h3><p>异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p><p>对应到IO操作中就是，为每次IO操作上面装了一个开关，IO操作完毕之后，会自动通知任务完成。</p><h3 id="IO-与-NIO-的区别"><a href="#IO-与-NIO-的区别" class="headerlink" title="IO 与 NIO 的区别"></a>IO 与 NIO 的区别</h3><p>IO 面向流</p><p>NIO 面向缓冲区，具备 选择器(Selectors)</p><h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><ul><li><p>同步</p><ul><li>发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生。</li></ul></li><li><p>异步</p><ul><li>发送一个请求，不等待返回，随时可以再发送下一个请求，可以提高效率，保证并发。</li></ul></li></ul><h3 id="阻塞与非阻塞的区别"><a href="#阻塞与非阻塞的区别" class="headerlink" title="阻塞与非阻塞的区别"></a>阻塞与非阻塞的区别</h3><ul><li>阻塞</li></ul><blockquote><p>传统的IO流都是阻塞式的。也就是说，当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务。在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降。  </p></blockquote><ul><li>非阻塞</li></ul><blockquote><p>JavaNIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。  </p></blockquote><h2 id="NIO-3个核心概念"><a href="#NIO-3个核心概念" class="headerlink" title="NIO 3个核心概念"></a>NIO 3个核心概念</h2><p><img src="../../../images/nio.png" style="zoom:70%"></p><p>NIO重点是把Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系弄清楚。</p><h3 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。  </p><p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。  </p><p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。  </p><p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：  </p><ul><li><p>ByteBuffer：字节缓冲区  </p></li><li><p>CharBuffer:字符缓冲区  </p></li><li><p>ShortBuffer：短整型缓冲区  </p></li><li><p>IntBuffer：整型缓冲区  </p></li><li><p>LongBuffer:长整型缓冲区  </p></li><li><p>FloatBuffer：浮点型缓冲区  </p></li><li><p>DoubleBuffer：双精度浮点型缓冲区  </p></li></ul><h3 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p><p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p><p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p><p>Channel有四种实现：</p><ul><li><p>FileChannel:是从文件中读取数据。</p></li><li><p>DatagramChannel:从UDP网络中读取或者写入数据。</p></li><li><p>SocketChannel:从TCP网络中读取或者写入数据。</p></li><li><p>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</p></li></ul><h3 id="多路复用器Selector"><a href="#多路复用器Selector" class="headerlink" title="多路复用器Selector"></a>多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p><h4 id="关键对象"><a href="#关键对象" class="headerlink" title="关键对象"></a>关键对象</h4><ul><li><p>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</p></li><li><p>SelectorKey：通道监听关键字，通过它来监听通道状态。</p></li></ul><h4 id="监听注册"><a href="#监听注册" class="headerlink" title="监听注册"></a>监听注册</h4><p>监听注册在Selector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><h4 id="监听的事件有"><a href="#监听的事件有" class="headerlink" title="监听的事件有"></a>监听的事件有</h4><ul><li><p>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</p></li><li><p>OP_READ: 读取就绪，socketChannel使用</p></li><li><p>OP_WRITE: 写入就绪，socketChannel使用</p></li><li><p>OP_CONNECT: 连接就绪，socketChannel使用</p></li></ul><h2 id="OKIO"><a href="#OKIO" class="headerlink" title="OKIO"></a>OKIO</h2><p>okhttp框架中，使用的io</p><p>OKio本质上是对Java的NIO的一次扩展，并且做了缓存的优化，</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>它也是基于插管的，而且是单向的，输入源叫 Source，输出目标叫 Sink</li><li>支持 Buffer<ul><li>像 NIO 一样，可以对 Buffer 进行操作</li><li>但不强制使用 Buffer</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;h2 id=&quot;IO是什么&quot;&gt;&lt;a href=&quot;#IO是什么&quot; class=&quot;headerlink&quot; title=&quot;IO是什么&quot;&gt;&lt;/a&gt;IO是什
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jetpack hilt</title>
    <link href="hexo/blog/2022/06/jetpack-hilt.html"/>
    <id>hexo/blog/2022/06/jetpack-hilt.html</id>
    <published>2022-06-16T06:09:19.000Z</published>
    <updated>2022-06-22T08:50:59.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a>Hilt</h1><p>先讲使用，再讲原理</p><p>google文档地址：<a href="https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn</a></p><p><a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/hilt" target="_blank" rel="noopener">示例源码地址</a></p><h2 id="使用示例：-Hilt-ViewModel-Repository"><a href="#使用示例：-Hilt-ViewModel-Repository" class="headerlink" title="使用示例： Hilt + ViewModel + Repository"></a>使用示例： Hilt + ViewModel + Repository</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ul><li>注意事项不要参考google文档中的地址设置版本号，因为文档中使用的是 aplha 版本，API会随时变动，很可能使用此版本但运行结果与文档不同，本人就碰到了，（@HiltViewModel 不可用） *</li></ul><p>在项目根目录的 build.gradle 中添加：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.hilt_version = <span class="string">"2.36"</span></span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">// hilt</span></span><br><span class="line">        classpath <span class="string">"com.google.dagger:hilt-android-gradle-plugin:$hilt_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在需要使用 hilt 的 module 的 build.gradle 文件中添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hilt</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:hilt-android:$hilt_version"</span></span><br><span class="line">kapt <span class="string">"com.google.dagger:hilt-android-compiler:$hilt_version"</span></span><br></pre></td></tr></table></figure><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltAndroidApp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">var</span> repository: HiltRepository,</span><br><span class="line">): ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repository.login()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor"><a href="#注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor" class="headerlink" title="注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()"></a>注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityHiltBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: HiltViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityHiltBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，此时生成 viewModel实例时，无需再次传入参数，也不需要另外使用ViewModelFactory来生成。<br>原因就是在 Repository 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过注解已经提供了生成 HiltRepository 实例的方式。</p><p>以上就是一次简单的使用。</p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hilt&quot;&gt;&lt;a href=&quot;#Hilt&quot; class=&quot;headerlink&quot; title=&quot;Hilt&quot;&gt;&lt;/a&gt;Hilt&lt;/h1&gt;&lt;p&gt;先讲使用，再讲原理&lt;/p&gt;
&lt;p&gt;google文档地址：&lt;a href=&quot;https://developer.android
      
    
    </summary>
    
    
  </entry>
  
</feed>
