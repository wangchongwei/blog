<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2021-03-04T09:34:02.230Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JMM java内存模型</title>
    <link href="hexo/blog/2021/03/JMM-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"/>
    <id>hexo/blog/2021/03/JMM-java内存模型.html</id>
    <published>2021-03-03T06:55:28.000Z</published>
    <updated>2021-03-04T09:34:02.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、现代计算机内存模型"><a href="#一、现代计算机内存模型" class="headerlink" title="一、现代计算机内存模型"></a>一、现代计算机内存模型</h2><p>早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问内存地址的。<br>而在现代计算机中，CPU指令的运行速度远远超过了内存数据的读写速度，为了降低这两者间这高达几个数量级的差距，所以在CPU与主内存之间加入了CPU高速缓存。</p><p>高速缓存可以很好地解决CPU与主内存之间的速度差距，但CPU缓存并不是所有CPU共享的，因此产生了一个新的问题：数据一致性问题。</p><p><img src="../../../images/memory.png" style="zoom:70%"></p><h2 id="二、缓存一致性协议（MESI）"><a href="#二、缓存一致性协议（MESI）" class="headerlink" title="二、缓存一致性协议（MESI）"></a>二、缓存一致性协议（MESI）</h2><h3 id="MESI四种状态"><a href="#MESI四种状态" class="headerlink" title="MESI四种状态"></a>MESI四种状态</h3><p>因为存在多个cpu，也就存在多个cpu缓存，CPU缓存的一致性问题会导致并发处理的不同步。<br>所以引入一种解决办法：缓存一致性协议（MESI）</p><p>MESI 这个名称本身是由：Modified（修改）、Exclusive（独享）、Shared（共享）、Invalid（无效）。<br>这个四个单词也代表了缓存协议中对缓存行（即Cache Line，缓存存储数据的单元）声明的四种状态，用2 bit表示，它们所代表的含义如下所示</p><p>状态 ｜ 描述 ｜ 监听任务<br>Modified（修改 ｜ 这行数据有效，数据被修改了，和内存种的数据不一致，数据只存在于本Cache中 ｜ 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。<br>Exclusive（独享）｜ 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中 ｜ 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。<br>S共享（Shared ｜ 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中 ｜ 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。<br>I无效（Invalid） ｜ 这行数据无效 ｜ 无</p><p>理解： 某数据如果多个缓存读取，则处于S共享状态，如果只是单个则处于E独享状态。<br>    某个CPU2对CPU2缓存中某数据作出修改，则CPU2缓存该数据处于Modified状态，如果该数据是S共享状态，则其他缓存该行数据变成I无效状态。</p><h3 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="headerlink" title="如何保证缓存一致性"></a>如何保证缓存一致性</h3><pre><code>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存中的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</code></pre><h2 id="三、JMM-java-内存模型"><a href="#三、JMM-java-内存模型" class="headerlink" title="三、JMM java 内存模型"></a>三、JMM java 内存模型</h2><p><img src="../../../images/jmm.png" style="zoom:70%"></p><p>线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地工作内存（Local Memory），工作内存中存储了线程以读/写共享变量的副本。<br>（本地工作内存是 JMM 的一个抽象概念，并不真实存在，线程中所谓工作内存其实还是存在于主内存中的。）</p><h3 id="Java内存模型与现代计算机内存模型区分"><a href="#Java内存模型与现代计算机内存模型区分" class="headerlink" title="Java内存模型与现代计算机内存模型区分"></a>Java内存模型与现代计算机内存模型区分</h3><p>Java内存模型和现代计算机内存模型都需要解决一致性问题，但是这个一致性问题在现代计算机内存模型中指代的是缓存一致性问题，MESI协议所设计的目的也是为了解决这个问题。而在Java内存模型中，这个一致性问题则是指代内存一致性问题。两者之间有一定区别。</p><p>缓存一致性</p><p>计算机数据需要经过内存、计算机缓存再到寄存器，计算机缓存一致性是指硬件层面的问题，指的是由于多核计算机中有多套缓存，各个缓存之间的数据不一致问题。缓存一致性协议（如MESI）就是用来解决多个缓存副本之间的数据一致性问题。</p><p>内存一致性</p><p>线程的数据则是放在内存中，共享副本也是，内存一致性保证的是多线程程序并发时的数据一致性问题。我们常见的volatile、synchronized关键字就是用来解决内存一致性问题。这里屏蔽了计算机硬件问题，<br>主要解决原子性、可见性和有序性问题。</p><p>至于内存一致性与缓存一致性问题之间的关系，就是实现内存一致性时需要利用到底层的缓存一致性（之后的volatile关键字会涉及）。</p><h2 id="四、并发编程的特性"><a href="#四、并发编程的特性" class="headerlink" title="四、并发编程的特性"></a>四、并发编程的特性</h2><p>首先我们要先了解并发编程的三大特性：原子性，可见性，有序性；</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指一个操作是不可间断的，即使是多个线程同时执行，该操作也不会被其他线程所干扰。<br>既操作的连续性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 具有原子性，赋值</span><br></pre></td></tr></table></figure></p><p>i++;<br>不具备原子性<br><code>因为i++juyou多部操作1、读取 i 的值到内存空间2、i + 13、刷新结果到内存</code></p><p>多个具备原子性操作放在一起并不具备原子性<br>y=x</p><p>先读取x的值到内存空间 x = 10； 这一步具备原子性<br>在给y赋值 y = 10; 也一步也具备原子性<br>但y=x不具备原子性</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>内存可见性（Memory visibility）是指当某个线程正在使用对象状态而同时另一个线程正在修改该状态，此时需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><p>每个线程都有一个私有的本地工作内存并存储了线程间读/写的共享副本。</p><p>如果某个线程对这个副本中值进行修改，却没有对主内存进行同步，则会导致其他线程访问过时的数据。</p><p>使用volatile关键字就可以保证数据在不同线程副本的可见性，当有线程在副本中进行修改，就会强制修改主内存中值，同步到其他线程的副本中。<br>保证所有线程访问到值都为最新值</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性即程序按照我们代码所书写的那样，按其先后顺序执行。第一次接触这个特性可能会有所疑惑，所以在了解有序性之前我们需要来了解执行重排序以及相关概念。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了提高性能，编译器和处理器会对程序的指令做重排序操作，重排序分为3种类型：</p><ul><li>编译器优化的重排序：属于编译器重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</li><li>指令级并行的重排序：属于处理器重排序，现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序；</li><li>内存系统的重排序：处于处理器重排序由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul><p>指令重排序对于程序执行有利有弊，我们并不是要去完全禁止它。<br>对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型个的内存屏障指令，通过内存屏障指令来禁止特定的处理器重排序。</p><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>不管如何重排序，要保证程序运行的结果保持不变，编译器、runtime和处理器都必须遵循as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 1</span><br><span class="line">int y = 20; // 2</span><br><span class="line">int a = x + y; // 3</span><br></pre></td></tr></table></figure></p><p>明显第3行依赖于第2行、第1行，所以第三行不会重排序，而第1行、第2行可能会被重排序。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>如果说 as-if-serial 是 JMM 提供用来解决单线程间的内存可见性问题的话，那么 happens-before 就是JMM向程序员提供的可跨越线程的内存可见性保证。<br>具体表现为：如果线程A的写操作a与线程B的读操作b之间具有 happens-before 关系，那么JMM将保证这个操作a对操作b可见。<br>此外，happens-before 还有传递关系，表现为：a happens-before b，b happens-before c，那么a happens-before c。</p><p>注意：两个操作之间存在happens-before关系，并不意味着一个操作必须要在后一个操作之前执行，只要求前一个操作执行的结果对后一个操作可见。<br>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不违法（也就是说，JMM允许这种重排序）。</p><p><code>比对 happens-before 与 as-if-serial。</code></p><ul><li><p>1、as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</p></li><li><p>2、as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。</p></li><li><p>3、as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、现代计算机内存模型&quot;&gt;&lt;a href=&quot;#一、现代计算机内存模型&quot; class=&quot;headerlink&quot; title=&quot;一、现代计算机内存模型&quot;&gt;&lt;/a&gt;一、现代计算机内存模型&lt;/h2&gt;&lt;p&gt;早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>NDK c语言基础 (一)</title>
    <link href="hexo/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%80.html"/>
    <id>hexo/blog/2021/03/NDK-c语言基础-一.html</id>
    <published>2021-03-01T08:07:48.000Z</published>
    <updated>2021-03-02T03:36:55.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言基础"><a href="#c语言基础" class="headerlink" title="c语言基础"></a>c语言基础</h1><h2 id="创建C语言程序"><a href="#创建C语言程序" class="headerlink" title="创建C语言程序"></a>创建C语言程序</h2><p>xcode -&gt; create new xcode project -&gt; macos -&gt; command line tools<br>在macos系统即可创建一个c语言程序</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>int 整型，占4个字节<br>double 双精度小数 占8个字节<br>float 单精度小数 占4个字节<br>char 字符 占1个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d\n&quot;, i, sizeof(i));</span><br><span class="line">double db = 1.34;</span><br><span class="line">printf(&quot;db的值:%lf,所占字节%d\n&quot;, db, sizeof(db));</span><br><span class="line">float fl = 1.12;</span><br><span class="line">printf(&quot;fl的值:%f,所占字节%d\n&quot;, fl, sizeof(fl));</span><br><span class="line">char ch = &apos;A&apos;;</span><br><span class="line">printf(&quot;ch的值:%c,所占字节%d\n&quot;, ch, sizeof(ch));</span><br></pre></td></tr></table></figure><p>打印结果：<br>i的值:2,所占字节4<br>db的值:1.340000,所占字节8<br>fl的值:1.120000,所占字节4<br>ch的值:A,所占字节1</p><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>使用 &amp; 变量 即可获取到变量的内存地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d， 内存地址为%p\n&quot;, i, sizeof(i), &amp;i);</span><br></pre></td></tr></table></figure></p><p>i的值:2,所占字节4， 内存地址为0x7ffeefbff4c8</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>&amp;i 既是取出i的内存地址，也是i的指针。<br>或者换个说法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">int * i_p = &amp;i;</span><br></pre></td></tr></table></figure></p><p>取出指针的值使用 *</p><ul><li>i_p 既可取出值 i = 10；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 22;</span><br><span class="line">int * i_p = &amp;i;</span><br><span class="line">printf(&quot;i 的值：%d, i_p指针指向的值: %d \n&quot;, i, *i_p);</span><br><span class="line">printf(&quot;i的地址：%p, i_p的地址%p \n&quot;, i_p, &amp;i_p);</span><br></pre></td></tr></table></figure><p>打印：<br>    i 的值：22, i_p指针指向的值: 22<br>    i的地址：0x7ffeefbff4c8, i_p的地址0x7ffeefbff4c0<br>可以是 &amp; 对指针再次取内存地址</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5];</span><br><span class="line">printf(&quot;a的值：%p， a的内存地址：%p, a[0]的地址%p\n&quot;, a, &amp;a, &amp;a[0]);</span><br></pre></td></tr></table></figure><p>打印结果：a的值：0x7ffeefbff4b0， a的内存地址：0x7ffeefbff4b0, a[0]的地址0x7ffeefbff4b0</p><p>可以看到 打印 a、&amp;a、&amp;a[0]出现的结果都一样。</p><p><strong> 1、为何a与&amp;a一样 </strong><br>因为a是数组，除基本数据类型外的其他变量，变量本身就是指向内存地址的。所以 a == &amp;a<br><strong> 2、为何&amp;a与&amp;a[0]一样 </strong><br>因为a是数组，数组内存连续，所以数组下标为0的内存地址就是数组本身的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int j = 0;</span><br><span class="line">for (j = 0; j &lt; 5; j ++) &#123;</span><br><span class="line">    printf(&quot;当前下标为%d,下标内存地址为%p\n&quot;, j, &amp;a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>    当前下标为0,下标内存地址为0x7ffeefbff4b0<br>    当前下标为1,下标内存地址为0x7ffeefbff4b4<br>    当前下标为2,下标内存地址为0x7ffeefbff4b8<br>    当前下标为3,下标内存地址为0x7ffeefbff4bc<br>    当前下标为4,下标内存地址为0x7ffeefbff4c0<br>可以看到内存地址以每次为4增加，因为这是int数组，int占4个字节，所以每次增加4</p><h2 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * p = &amp;a[j] + 1;</span><br><span class="line">printf(&quot;p的值为:%p\n&quot;, p);</span><br><span class="line">*(&amp;a[j] + 0) = j;</span><br></pre></td></tr></table></figure><p>&amp;a[j] 是取出下标j处的地址。<br>&amp;a[j] + 1 是指针在a[j]处偏移1位，既指向a[j + 1];<br>*(&amp;a[j] + 0) = j; + 0 其实相当于未偏移，就是对a[j]赋值</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>首先函数指针的申明格式：函数返回值类型 (* 指针变量名) (函数参数列表);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void add(int a, int b)&#123;</span><br><span class="line">    printf(&quot;sum = %d\n&quot;, a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(void (*method)(int, int), int a, int b) &#123;</span><br><span class="line">    method(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello \n&quot;);</span><br><span class="line">    test(add, 3, 4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在test函数入参中，有一个函数指针，<br>在main函数中，调用test函数，并将add函数作为入参传递到test函数中。</p><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>指向指针的指针就是多级指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    </span><br><span class="line">    int a = 0;</span><br><span class="line">    int * b = &amp;a;</span><br><span class="line">    int **c = &amp;b;</span><br><span class="line">    int *** d = &amp;c;</span><br><span class="line">    printf(&quot;d的地址%p \n&quot;, d);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用来表示多维数组</p><h2 id="静态分配内存"><a href="#静态分配内存" class="headerlink" title="静态分配内存"></a>静态分配内存</h2><p>在c语言中，内存区域分为栈区、堆区</p><p>函数被调用时，就会进栈，函数执行完毕则会出栈，而在函数中默认方式申明生成的数据都是系统静态分配内存的，<br>当函数执行完毕，出栈后，在该函数中静态分配的内存会被回收，系统会自己执行，无需手动处理。<br>静态分配内存都是在栈区</p><p>栈区总容量较小，大约是2M，各个系统、设备可能不一致，超出会抛出异常</p><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>动态分配内存需要手动调用API才可，动态分配的内存不会自动回收，动态分配的内存都是在堆区。<br>堆区总容量较大，至少超过40M，各个系统、设备可能不一致， 超出也会抛出异常。</p><p>调用动态分配内存：malloc(int size)函数<br>调用回收动态内存：free(void *);</p><p>需要额外引入依赖文件：#include &lt;stdlib.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int num;</span><br><span class="line">    printf(&quot;请输入数字\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">    printf(&quot;num的值为：%d\n&quot;, num);</span><br><span class="line">    </span><br><span class="line">    int * arr = (int *)malloc(sizeof(int) * num);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0; i &lt; num; i ++) &#123;</span><br><span class="line">        arr[i] = i + 10000;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; num; ++i) &#123;</span><br><span class="line">        printf(&quot;%d对应值为%d\n&quot;, i, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重新分配"><a href="#重新分配" class="headerlink" title="重新分配"></a>重新分配</h3><p>就是将之前动态分配的内存重新分配，使用：realloc(void *<strong>ptr, size_t </strong>size);<br>第一个参数：原来的内存指针<br>第二个参数：新的内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int * new_arr = (int *)realloc(arr, sizeof(int) * (num + new_num));</span><br><span class="line">if(new_arr) &#123;</span><br><span class="line">    int j = num;</span><br><span class="line">    for (; j &lt; (num + new_num); j ++) &#123;</span><br><span class="line">        new_arr[j] = j + 100000;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt; (num + new_num); i ++) &#123;</span><br><span class="line">        printf(&quot;新数组第%d个值为%d\n&quot;, i, new_arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(new_arr);</span><br><span class="line">    new_arr = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c语言基础&quot;&gt;&lt;a href=&quot;#c语言基础&quot; class=&quot;headerlink&quot; title=&quot;c语言基础&quot;&gt;&lt;/a&gt;c语言基础&lt;/h1&gt;&lt;h2 id=&quot;创建C语言程序&quot;&gt;&lt;a href=&quot;#创建C语言程序&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="c语言" scheme="hexo/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>https详解</title>
    <link href="hexo/blog/2021/02/https%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2021/02/https详解.html</id>
    <published>2021-02-25T07:57:53.000Z</published>
    <updated>2021-02-25T07:59:06.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Https详解"><a href="#Https详解" class="headerlink" title="Https详解"></a>Https详解</h1><h2 id="什么是Https"><a href="#什么是Https" class="headerlink" title="什么是Https"></a>什么是Https</h2><p>在说HTTPS之前先说说什么是HTTP，HTTP就是我们平时浏览网页时候使用的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。<br>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br>SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，<br>之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，<br>但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，<br>今后TLS将会继承SSL优良血统继续为我们进行加密服务。目前TLS的版本是1.2，定义在RFC 5246中，暂时还没有被广泛的使用 ()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Https详解&quot;&gt;&lt;a href=&quot;#Https详解&quot; class=&quot;headerlink&quot; title=&quot;Https详解&quot;&gt;&lt;/a&gt;Https详解&lt;/h1&gt;&lt;h2 id=&quot;什么是Https&quot;&gt;&lt;a href=&quot;#什么是Https&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="hexo/blog/2021/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>hexo/blog/2021/02/观察者模式.html</id>
    <published>2021-02-24T09:37:52.000Z</published>
    <updated>2021-02-25T07:55:59.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式的定义与特点："><a href="#观察者模式的定义与特点：" class="headerlink" title="观察者模式的定义与特点："></a>观察者模式的定义与特点：</h1><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><p>观察者模式是一种对象行为型模式，其主要优点如下：</p><ol><li><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</p></li><li><p>目标与观察者之间建立了一套触发机制。</p></li></ol><p>它的主要缺点如下：</p><ol><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;观察者模式的定义与特点：&quot;&gt;&lt;a href=&quot;#观察者模式的定义与特点：&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的定义与特点：&quot;&gt;&lt;/a&gt;观察者模式的定义与特点：&lt;/h1&gt;&lt;p&gt;观察者（Observer）模式的定义：指多个对象间存在一对多
      
    
    </summary>
    
    
      <category term="设计模式" scheme="hexo/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>android 屏幕渲染</title>
    <link href="hexo/blog/2021/02/android-%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93.html"/>
    <id>hexo/blog/2021/02/android-屏幕渲染.html</id>
    <published>2021-02-23T09:31:33.000Z</published>
    <updated>2021-02-24T05:43:09.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h1><p> CPU负责计算数据，把计算好数据交给GPU,<br> GPU会对图形数据进行渲染，渲染好后放到buffer里存起来<br> display负责将buffer里的数据显示在屏幕</p><p> 简单的说就是CPU/GPU准备好数据，存入buffer，<br> display每隔一段时间去buffer里取数据，然后显示出来。<br> display读取的频率是固定的，比如每个16ms读一次，但是CPU/GPU写数据是完全无规律的</p><p>底层每16ms会发送一次VSync，更新界面</p><p>CPU：执行应用层的measure、layout、draw等操作，绘制完成后将数据提交给GPU<br>GPU：进一步处理数据，并将数据缓存起来<br>屏幕：由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点</p><p>因为display取buffer数据渲染的频率固定，而GPU往buffer写数据却是不固定的，难免存在场景：GPU还在往buffer写数据，但此时display正要显示，此时就会显示异常。</p><p>为避免这种现象，引入一种新方案：双缓存机制</p><h2 id="双缓存机制"><a href="#双缓存机制" class="headerlink" title="双缓存机制"></a>双缓存机制</h2><p>android的渲染机制中引入双缓存机制。新增一个缓存 back buffer, back buffer 会定时与 frame buffer交换数据</p><p><img src="../../../images/buffer.png" style="zoom:70%"></p><p><strong> 当你的应用正在往Back Buffer中填充数据时，系统会将Back Buffer锁定。<br>如果到了GPU交换两个Buffer的时间点，你的应用还在往Back Buffer中填充数据，GPU会发现Back Buffer被锁定了，它会放弃这次交换。 </strong></p><p>这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的丢帧，<br>所以为了避免丢帧的发生，我们就要尽量减少布局层级，减少不必要的View的invalidate调用，减少大量对象的创建（GC也会占用CPU时间）等等</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong> Q1：Android 每隔 16.6 ms 刷新一次屏幕到底指的是什么意思？是指每隔 16.6ms 调用 onDraw() 绘制一次么？<br>Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？</strong></p><p>答：我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面，而这个每一帧的画面数据就是我们 app 在接收到屏幕刷新信号之后去执行遍历绘制 View 树工作所计算出来的屏幕数据。而 app 并不是每隔 16.6ms 的屏幕刷新信号都可以接收到，只有当 app 向底层注册监听下一个屏幕刷新信号之后，才能接收到下一个屏幕刷新信号到来的通知。而只有当某个 View 发起了刷新请求时，app 才会去向底层注册监听下一个屏幕刷新信号。</p><p>也就是说，只有当界面有刷新的需要时，我们 app 才会在下一个屏幕刷新信号来时，遍历绘制 View 树来重新计算屏幕数据。如果界面没有刷新的需要，一直保持不变时，我们 app 就不会去接收每隔 16.6ms 的屏幕刷新信号事件了，但底层仍然会以这个固定频率来切换每一帧的画面，只是后面这些帧的画面都是相同的而已。</p><p><strong> Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？ </strong></p><p>答：我们 app 只负责计算屏幕数据而已，接收到屏幕刷新信号就去计算，计算完毕就计算完毕了。至于屏幕的刷新，这些是由底层以固定的频率来切换屏幕每一帧的画面。所以即使屏幕数据都计算完毕，屏幕会不会马上刷新就取决于底层是否到了要切换下一帧画面的时机了。</p><p><strong> Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？ </strong> </p><p>之所以提了这个问题，是因为之前是以为如果某个 View 发起了刷新请求，比如调用了 invalidte()，那么它的重绘工作就马上开始执行了，所以以前在看网上那些介绍屏幕刷新机制的博客时，经常看见下面这张图：</p><p>那个时候就是不大理解，为什么每一次 CPU 计算的工作都刚刚好是在每一个信号到来的那个瞬间开始的呢？毕竟代码里发起刷新屏幕的操作是动态的，不可能每次都刚刚好那么巧。</p><p>梳理完屏幕刷新机制后就清楚了，代码里调用了某个 View 发起的刷新请求，这个重绘工作并不会马上就开始，而是需要等到下一个屏幕刷新信号来的时候才开始，所以现在回过头来看这些图就清楚多了。</p><p><strong> Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？ </strong></p><p>答：造成丢帧大体上有两类原因，一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms；二是，主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。</p><p>第一个原因就是我们写的布局有问题了，需要进行优化了。而第二个原因则是我们常说的避免在主线程中做耗时的任务。</p><p>针对第二个原因，系统已经引入了同步屏障消息的机制，尽可能的保证遍历绘制 View 树的工作能够及时进行，但仍没办法完全避免，所以我们还是得尽可能避免主线程耗时工作。</p><p>其实第二个原因，可以拿出来细讲的，比如有这种情况， message 不怎么耗时，但数量太多，这同样可能会造成丢帧。如果有使用一些图片框架的，它内部下载图片都是开线程去下载，但当下载完成后需要把图片加载到绑定的 view 上，这个工作就是发了一个 message 切到主线程来做，如果一个界面这种 view 特别多的话，队列里就会有非常多的 message，虽然每个都 message 并不怎么耗时，但经不起量多啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渲染机制&quot;&gt;&lt;a href=&quot;#渲染机制&quot; class=&quot;headerlink&quot; title=&quot;渲染机制&quot;&gt;&lt;/a&gt;渲染机制&lt;/h1&gt;&lt;p&gt; CPU负责计算数据，把计算好数据交给GPU,&lt;br&gt; GPU会对图形数据进行渲染，渲染好后放到buffer里存起来&lt;br&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>面试题答案</title>
    <link href="hexo/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.html"/>
    <id>hexo/blog/2021/02/面试题答案.html</id>
    <published>2021-02-02T06:59:23.000Z</published>
    <updated>2021-02-23T07:23:30.115Z</updated>
    
    <content type="html"><![CDATA[<p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage</p><p>而在MessageQueue的enqueueMessage中。就会根据when大小插入到链表，when越小就在链表越前，其实相当于根据时间排序，越接近的时间越在链头</p><p>Looper中的消息既能同步也能异步，在Handler的构造时传入async = true；即为异步消息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息&lt;/p&gt;
&lt;p&gt;当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&amp;gt; enqueue
      
    
    </summary>
    
    
      <category term="面试" scheme="hexo/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题合集</title>
    <link href="hexo/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html"/>
    <id>hexo/blog/2021/02/面试题合集.html</id>
    <published>2021-02-02T06:54:45.000Z</published>
    <updated>2021-02-02T06:57:54.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android"><a href="#android" class="headerlink" title="android"></a>android</h1><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1、Object的方法有哪些？</p><p>2、为什么要有HashCode方法，hash算法的原理，在Java中哪些地方用到，进而问到了HashMap的源码</p><p>3、Java有几种锁，synchronized与Lock有什么区别，Lock的实现原理，有没有碰到死锁的情况</p><p>4、Android源码中用到了哪些设计模式，举例说明</p><p>5、一个Android正常启动有多少个线程?(这里当时是比较懵逼的，第一反应是一个主线程，然后觉得应该不止这么简单，想到应用Activity启动的话，应该还有2个Binder线程，可能一个管理JVM的线程，面试官接着问还有哪些。。果断放弃不知道…)</p><p>6、Binder机制的实现思想</p><p>7、简单描述Https的实现思路</p><p>8、描述下快速排序的思想，时间复杂度？什么场景对应着最坏情况？</p><p>9、给定无序数组和一个值，找到两个数和为值的元素，不能使用额外空间复杂度（不要使用HashMap）</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面是视频面试，还是个周六下午。。。</p><p>1、TCP/IP四层模型，网络层和传输层有什么区别？网络层的主要工作是什么</p><p>2、socket.accept()函数对应着TCP三次握手中哪一次握手，哪个函数代表连接建立完毕，四次挥手的过程？</p><p>3、有做过哪些优化工作，卡顿优化，内存优化，启动优化，APK体积优化，每个做了哪些工作</p><p>4、JNI开发中有碰到什么问题？怎么定位native crash</p><p>5、递归非递归反转链表</p><p>6、打印回环数组</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>2、事件分发机制的源码</p><p>3、android的屏幕刷新机制，怎么优化UI卡顿情况</p><p>4、有没有使用过插件化框架，实现原理？</p><p>5、你在项目中碰到什么比较棘手的问题？怎么解决的？</p><p>6、找到一个无序数组中第一次出现最多次数的元素</p><h2 id="某手机海外部门（offer）"><a href="#某手机海外部门（offer）" class="headerlink" title="某手机海外部门（offer）"></a>某手机海外部门（offer）</h2><p>上来就是笔试题，其实之前没怎么做过面试题，难道现在都是这个套路了….？20分钟后做完就开始面试了</p><p>1、手写线程安全的观察者模式</p><p>2、找到一个字符串中出现最多的字母</p><p>3、描述Java面对对象六大原则针对项目中谈谈自己的看法</p><p>4、android阅读过哪些源码，举例说明</p><p>5、项目中的优化工作，内存，卡顿优化，leakcanary的原理实现</p><p>6、Tcp/Udp的区别，项目中的C/S端双向认证如何实现</p><p>7、项目中有碰到过哪些比较难解决的问题。</p><p>8、android 8.0，9.0有哪些新特性，有没有了解过</p><h2 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h2><p>1、HashMap的原理以及android中为什么建议用ArrayMap和SpareArray替代HashMap？</p><p>2、android如何保证进程不被杀死</p><p>3、Java怎么与C++进行交互，以及native crash如何定位的</p><p>4、C/S如何保证双向认证（项目中使用到的，可以理解为Https的原理），用到了哪些加密算法</p><p>5、LBS定位如何去除野点（指因为定位偏差过大的点），大数据量如何和后台交互？</p><p>6、设计模式用过哪些，动态代理的原理？</p><p>7、项目中有做过哪些优化，优化成效如何？</p><h2 id="TCL（offer）"><a href="#TCL（offer）" class="headerlink" title="TCL（offer）"></a>TCL（offer）</h2><p>是一个猎头推荐的一个职位，主要应该是做TV上的相关项目，有VR类型类似的项目等等，一面居然是一个妹子和一个男的一起进来的，还是第一次遇到，没问多少基础知识点，更多的是根据自身项目问一些东西</p><p>1、TCP/UDP的区别，有看过具体报文的信息吗</p><p>2、你觉得开发一个SDK，需要注意哪些地方，有没有做过SDK性能测试</p><p>3、有了解过音视频的编解码吗</p><p>4、你觉得你这个项目中比较难的地方在哪里，你是如何解决的</p><p>5、开放题：让你加载一个200M左右的GIF，如何实现及优化，不可降低画质</p><p>6、如何优化一个列表滑动的流畅性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android&quot;&gt;&lt;a href=&quot;#android&quot; class=&quot;headerlink&quot; title=&quot;android&quot;&gt;&lt;/a&gt;android&lt;/h1&gt;&lt;h2 id=&quot;腾讯&quot;&gt;&lt;a href=&quot;#腾讯&quot; class=&quot;headerlink&quot; title=&quot;腾
      
    
    </summary>
    
    
      <category term="面试" scheme="hexo/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="hexo/blog/2021/02/%E5%B9%B6%E5%8F%91.html"/>
    <id>hexo/blog/2021/02/并发.html</id>
    <published>2021-02-01T10:01:22.000Z</published>
    <updated>2021-03-02T07:30:59.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发指单位时间的访问量<br>并行指同一时刻的访问量</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><ul><li><p>ABA问题</p></li><li><p>开销问题</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h1&gt;&lt;p&gt;并发指单位时间的访问量&lt;br&gt;并行指同一时刻的访问量&lt;/p&gt;
&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoinTask</title>
    <link href="hexo/blog/2021/01/ForkJoinTask.html"/>
    <id>hexo/blog/2021/01/ForkJoinTask.html</id>
    <published>2021-01-27T05:59:20.000Z</published>
    <updated>2021-01-27T05:59:46.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h1><p>ForkJoin 是采用分而治之的思维，将一个大任务分解为若干个相互独立的子任务（异步），<br>达到提高运算效率。<br>我们做一个简单的运算 计算1-100000的累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class TestJoinTask &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; task = pool.submit(new MyForkJoinTask(1, 100000));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int result = task.get();</span><br><span class="line">            System.out.println(&quot;result = &quot; + result);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行完毕&quot; + &quot;   time = &quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传入的范型Integer是返回结果类型</span><br><span class="line">     */</span><br><span class="line">    static class MyForkJoinTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private int startValue;</span><br><span class="line"></span><br><span class="line">        private int endValue;</span><br><span class="line"></span><br><span class="line">        private int limitValue = 100;</span><br><span class="line"></span><br><span class="line">        public MyForkJoinTask(int startValue, int endValue) &#123;</span><br><span class="line">            if(startValue &gt; endValue) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;startValue &lt; endValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            this.startValue = startValue;</span><br><span class="line">            this.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Integer compute() &#123;</span><br><span class="line">            if(endValue - startValue &lt;= limitValue) &#123;</span><br><span class="line">                System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行计算&quot;);</span><br><span class="line">                // 两个值在限制值内 进行计算</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for(int i = startValue; i &lt;= endValue; i ++) &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">            MyForkJoinTask task1 = new MyForkJoinTask(startValue, (endValue + startValue) / 2);</span><br><span class="line">            task1.fork();</span><br><span class="line">            MyForkJoinTask task2 = new MyForkJoinTask((endValue + startValue) / 2 + 1, endValue);</span><br><span class="line">            task2.fork();</span><br><span class="line">            return task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们将一个从0 - 100000的累加任务分解为500个子任务：每200位数累加</p><p>在日志打印中，我们可以看到，有多个线程在执行任务，也就是说，分解的任务其实都是提交到线程池中执行，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ForkJoinTask&quot;&gt;&lt;a href=&quot;#ForkJoinTask&quot; class=&quot;headerlink&quot; title=&quot;ForkJoinTask&quot;&gt;&lt;/a&gt;ForkJoinTask&lt;/h1&gt;&lt;p&gt;ForkJoin 是采用分而治之的思维，将一个大任务分解为若
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android ViewPager/ViewPager2解析</title>
    <link href="hexo/blog/2021/01/android-ViewPager-ViewPager2%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-ViewPager-ViewPager2解析.html</id>
    <published>2021-01-22T01:57:40.000Z</published>
    <updated>2021-01-22T02:49:39.745Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android RecyclerView解析</title>
    <link href="hexo/blog/2021/01/android-RecyclerView%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-RecyclerView解析.html</id>
    <published>2021-01-22T01:57:27.000Z</published>
    <updated>2021-01-22T02:49:34.798Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android ListView解析</title>
    <link href="hexo/blog/2021/01/android-ListView%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-ListView解析.html</id>
    <published>2021-01-22T01:57:15.000Z</published>
    <updated>2021-01-22T05:40:53.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ListView解析"><a href="#ListView解析" class="headerlink" title="ListView解析"></a>ListView解析</h1><p>首先是简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ListViewActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_list_view)</span><br><span class="line">        var list = arrayListOf(Person(&quot;novia&quot;, 24), Person(&quot;justin&quot;, 29), Person(&quot;doudou&quot;, 1))</span><br><span class="line">        var adapter = MyListAdapter(list, this)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyListAdapter(var list: ArrayList&lt;Person&gt;, var context: Context) : BaseAdapter() &#123;</span><br><span class="line">        override fun getCount(): Int &#123;</span><br><span class="line">            return list.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getItem(position: Int): Person &#123;</span><br><span class="line">            return list.get(position);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getItemId(position: Int): Long &#123;</span><br><span class="line">            return list.get(position).hashCode().toLong()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123;</span><br><span class="line">            var view = LayoutInflater.from(context).inflate(R.layout.item_listview, parent, false)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_name).setText(getItem(position).name)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_age).setText(&quot;&quot; + getItem(position).age + &quot;岁&quot;)</span><br><span class="line">            return view;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data class Person(var name: String, var age: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是ListView的特点是会将所有条目都渲染出来，当子条目较多时，会存在性能问题，当加载图片时，甚至会导致OOM</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ListView解析&quot;&gt;&lt;a href=&quot;#ListView解析&quot; class=&quot;headerlink&quot; title=&quot;ListView解析&quot;&gt;&lt;/a&gt;ListView解析&lt;/h1&gt;&lt;p&gt;首先是简单使用&lt;br&gt;&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>okhttp(二) 拦截器</title>
    <link href="hexo/blog/2021/01/okhttp-%E4%BA%8C-%E6%8B%A6%E6%88%AA%E5%99%A8.html"/>
    <id>hexo/blog/2021/01/okhttp-二-拦截器.html</id>
    <published>2021-01-13T10:29:12.000Z</published>
    <updated>2021-01-20T01:16:55.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="okhttp-二-拦截器"><a href="#okhttp-二-拦截器" class="headerlink" title="okhttp(二) 拦截器"></a>okhttp(二) 拦截器</h1><p>在前文中讲到了okhttp中的分发器</p><p>接下来讲okhttp中的拦截器</p><p>在上文中讲到，同步执行excuet时，会通过 getResponseWithInterceptorChain 获取response，<br>在异步enqueue后，后面会调用AsyncCall中execute，而里面也是通过getResponseWithInterceptorChain 来获取response。</p><p>调用的都是RealCall中的getResponseWithInterceptorChain函数。</p><h2 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain"></a>getResponseWithInterceptorChain</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors()); //自定义拦截器加入到集合</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">            originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个数组，添加各个拦截器，<br>然后初始化一个 Interceptor.Chain 对象，注意第2、3、4个参数都是null，而第5个参数是index：0<br>然后调用proceed函数</p><h2 id="RealInterceptorChain-java"><a href="#RealInterceptorChain-java" class="headerlink" title="RealInterceptorChain.java"></a>RealInterceptorChain.java</h2><p>RealInterceptorChain 实现 Interceptor接口中的Chain接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line">  private final int index;</span><br><span class="line">  private final Request request;</span><br><span class="line">  private final Call call;</span><br><span class="line">  private final EventListener eventListener;</span><br><span class="line">  private final int connectTimeout;</span><br><span class="line">  private final int readTimeout;</span><br><span class="line">  private final int writeTimeout;</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,</span><br><span class="line">      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123;</span><br><span class="line">    this.interceptors = interceptors;</span><br><span class="line">    this.connection = connection;</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line">    this.httpCodec = httpCodec;</span><br><span class="line">    this.index = index;</span><br><span class="line">    this.request = request;</span><br><span class="line">    this.call = call;</span><br><span class="line">    this.eventListener = eventListener;</span><br><span class="line">    this.connectTimeout = connectTimeout;</span><br><span class="line">    this.readTimeout = readTimeout;</span><br><span class="line">    this.writeTimeout = writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int connectTimeoutMillis() &#123;</span><br><span class="line">    return connectTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, millis, readTimeout, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int readTimeoutMillis() &#123;</span><br><span class="line">    return readTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, millis, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int writeTimeoutMillis() &#123;</span><br><span class="line">    return writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, readTimeout, millis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Call call() &#123;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EventListener eventListener() &#123;</span><br><span class="line">    return eventListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Confirm that the intercepted response isn&apos;t null.</span><br><span class="line">    if (response == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (response.body() == null) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是RealInterceptorChain的全部代码，注意看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 最开始index = 0，注意这里构造RealInterceptorChain时，传入的为index+1</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的最前面的，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 RetryAndFollowUpInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>看注释现在可能又点绕，接着往下看，Interceptor是一个接口，没必要看，可以直接先看RetryAndFollowUpInterceptor</p><h2 id="RetryAndFollowUpInterceptor-重试以及重定向拦截器"><a href="#RetryAndFollowUpInterceptor-重试以及重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor 重试以及重定向拦截器"></a>RetryAndFollowUpInterceptor 重试以及重定向拦截器</h2><p>RetryAndFollowUpInterceptor 实现 Interceptor 接口</p><p>查看其中的intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * todo  管理类，维护了 与服务器的连接、数据流与请求三者的关系。真正使用的拦截器为 Connect</span><br><span class="line">         */</span><br><span class="line">        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line"></span><br><span class="line">        // 在这里无限循环，只有抛出异常或者return response才会中断</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (canceled) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            boolean releaseConnection = true;</span><br><span class="line">            try &#123;</span><br><span class="line">                //todo 请求出现了异常，那么releaseConnection依旧为true。</span><br><span class="line">                response = realChain.proceed(request, streamAllocation, null, null);</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">            &#125; catch (RouteException e) &#123;</span><br><span class="line">                //todo 路由异常，连接未成功，请求还没发出去</span><br><span class="line">                //The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">                if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">                    throw e.getLastConnectException();</span><br><span class="line">                &#125;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span><br><span class="line">                // HTTP2才会抛出ConnectionShutdownException。所以对于HTTP1 requestSendStarted一定是true</span><br><span class="line">                //An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">                if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">                //todo 不是前两种的失败，那直接关闭清理所有资源</span><br><span class="line">                if (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed(null);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 如果进过重试/重定向才成功的，则在本次响应中记录上次响应的情况</span><br><span class="line">            //Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder()</span><br><span class="line">                        .priorResponse(</span><br><span class="line">                                priorResponse.newBuilder()</span><br><span class="line">                                        .body(null)</span><br><span class="line">                                        .build()</span><br><span class="line">                        )</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 处理3和4xx的一些状态码，如301 302重定向</span><br><span class="line">            Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                if (!forWebSocket) &#123;</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">            //todo 限制最大 followup 次数为20次</span><br><span class="line">            if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 判断是不是可以复用同一份连接</span><br><span class="line">            if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                        createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">                this.streamAllocation = streamAllocation;</span><br><span class="line">            &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">                        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到此处的主要逻辑，<br>将传入的chain对象转为RealInterceptorChain，<br>无限循环，然后在循环中调用chain.proceed函数，获取response，<br>循环的主要作用为catch异常，并针对RouteException 或者 IOException 做重试操作，其他异常则终止，</p><p>而chain.proceed又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 1； index + 1 = 2；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 1，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 BridgeInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"><a href="#BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应" class="headerlink" title="BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"></a>BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应</h2><p>BridgeInterceptor 也是实现 Interceptor 接口</p><p>同样直接查看intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also</span><br><span class="line">      // decompressing</span><br><span class="line">        // the transfer stream.</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest);</span><br><span class="line"></span><br><span class="line">        if (transparentGzip</span><br><span class="line">                &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">                &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                    .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">                    .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个函数的逻辑，<br>先对请求头信息进行再处理，然后执行chain.proceed获取networkResponse，<br>然后再对networkResponse进行再包装处理</p><p>同RetryAndFollowUpInterceptor一样，又会调用到chain.proceed函数，<br>又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 2； index + 1 = 3；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 2，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CacheInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>再看CacheInterceptor代码</p><h2 id="CacheInterceptor-负责读取缓存以及更新缓存"><a href="#CacheInterceptor-负责读取缓存以及更新缓存" class="headerlink" title="CacheInterceptor 负责读取缓存以及更新缓存"></a>CacheInterceptor 负责读取缓存以及更新缓存</h2><p>CacheInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    //todo 通过url的md5数据 从文件缓存查找 （GET请求才有缓存）</span><br><span class="line">    Response cacheCandidate = cache != null</span><br><span class="line">            ? cache.get(chain.request())</span><br><span class="line">            : null;</span><br><span class="line"></span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    //todo 缓存策略:根据各种条件(请求头)组成 请求与缓存</span><br><span class="line">    CacheStrategy strategy =</span><br><span class="line">            new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    //</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有网络请求也没有缓存</span><br><span class="line">    //If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        return new Response.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(504)</span><br><span class="line">                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-1L)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有请求，肯定就要使用缓存</span><br><span class="line">    //If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">    if (networkRequest == null) &#123;</span><br><span class="line">        return cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 去发起请求</span><br><span class="line">    Response networkResponse = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">        if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">    if (cacheResponse != null) &#123;</span><br><span class="line">        //todo 服务器返回304无修改，那就使用缓存的响应修改了时间等数据后作为本次请求的响应</span><br><span class="line">        if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">            // Update the cache after combining headers but before stripping the</span><br><span class="line">            // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            return response;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 走到这里说明缓存不可用 那就使用网络的响应</span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    //todo 进行缓存</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response,</span><br><span class="line">                networkRequest)) &#123;</span><br><span class="line">            // Offer this request to the cache.</span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; catch (IOException ignored) &#123;</span><br><span class="line">                // The cache cannot be written.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程就是获取一个networlRequets，以及一个缓存的cacheResponse，<br>如果networlRequets与cacheResponse，则直接报504的网络异常<br>如果networlRequets为空，则只能返回cacheResponse，<br>如果networlRequets不为空，则执行网络请求，获取networkResponse，<br>如果cacheResponse 不为空  且 networkResponse响应码304，代表无更改，则可以返回，</p><p>再往下就是对networlRequets进行处理，并加入缓存。</p><p>注意：此处获取networkResponse也是调用chain.proceed，于是与上面一直，也会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 3； index + 1 = 4；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 3，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 ConnectInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>此时会调用到ConnectInterceptor中的intercept函数</p><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>ConnectInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">    public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">        // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">        return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码就是ConnectInterceptor类中所有源码，<br>intercept函数中，重新获取了几个参数，和上面的几个Interceptor实现类不太一样，<br>最后调用的proceed函数是四个参数的，最后还是会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 4； index + 1 = 5；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 4，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CallServerInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>CallServerInterceptor 也是实现 Interceptor 接口，<br>CallServerInterceptor 中 intercept 函数就是直接与服务端通信的，<br>而在这里会获取到真正的response，并返回到上一层，也就是ConnectInterceptor的intercept，同理会依次向上返回。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>在上面看到的，一层一层拦截器向下调用，Interceptor类实现 调用 Interceptor类实现，<br>每一层的拦截器实现自己的功能，然后交付给下一层拦截器，<br>这种设计模式就是责任链模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;okhttp-二-拦截器&quot;&gt;&lt;a href=&quot;#okhttp-二-拦截器&quot; class=&quot;headerlink&quot; title=&quot;okhttp(二) 拦截器&quot;&gt;&lt;/a&gt;okhttp(二) 拦截器&lt;/h1&gt;&lt;p&gt;在前文中讲到了okhttp中的分发器&lt;/p&gt;
&lt;p&gt;接下
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>react Hook</title>
    <link href="hexo/blog/2021/01/react-Hook.html"/>
    <id>hexo/blog/2021/01/react-Hook.html</id>
    <published>2021-01-11T03:27:26.000Z</published>
    <updated>2021-01-20T06:34:27.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><p>Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>在这里，useState 就是一个 Hook （等下我们会讲到这是什么意思）。通过在函数组件里调用它来给组件添加一些内部 state。<br>React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。<br>它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">    View,</span><br><span class="line">    Text,</span><br><span class="line">    TouchableOpacity,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default function test() &#123;</span><br><span class="line">    console.log(&apos;------test&apos;);</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    return (</span><br><span class="line">        &lt;View style=&#123;&#123; marginTop: 100 &#125;&#125;&gt;</span><br><span class="line">            &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;</span><br><span class="line">                &lt;Text&gt;点击获取次数：&#123;count&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/TouchableOpacity&gt;</span><br><span class="line">            &lt;Text onPress=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125; style=&#123;&#123; marginTop: 100, fontSize: 30 &#125;&#125;&gt;test&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上图所示，是在react-native中简单使用Hook，使用其中的useState<br>const [count, setCount] = useState(0);<br>结构赋值，第一个count为获取的参数，<br>第二个参数setCount是修改第一个参数的函数，<br>useState(0)中，useState是在react中引入，后面的 0 是 count 的默认数据。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect 是一个副作用函数，默认在每次渲染之后都会执行。<br>而且保证每次运行effect时，DOM已经渲染完毕。</p><p>传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。<br>事实上这正是我们可以在 effect 中获取最新的 useState中 的值，而不用担心其过期的原因。<br>每次我们重新渲染，都会生成新的 effect，替换掉之前的。<br>某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。</p><ul><li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</li><li></li></ul><p>useEffect提供清除操作，当我们需要在React组件清除时，执行某一些操作，可以在useEffect中，返回清除函数。<br>当React清除时，会执行useEffect中的返回函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</li></ul><p>React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。<br>这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p><p>还可以对useEffect进行优化，useEffect接受两个参数，第二个参数为比较值，当这个值发生了变化，才会执行useEffect。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const [count, setCount] = useState(0)</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><p>这样，只有当count发生变化，即我们调用过 setCount来改变count的值，下一次渲染完毕，才会执行useEffect</p><p>所以，当我们需要执行一些只需执行一次的逻辑时，可以传入一个定值，一般使用空数组[]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    function request() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, []])</span><br></pre></td></tr></table></figure><p>如上所示，request只会在第一次渲染完毕执行一次，remove函数也时只会执行一次</p><h2 id="Hook规则"><a href="#Hook规则" class="headerlink" title="Hook规则"></a>Hook规则</h2><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则</p><ul><li><p>只在最顶层使用 Hook<br>  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。<br>  遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</p></li><li><p>只在 React 函数中调用 Hook<br>  不要在普通的 JavaScript 函数中调用 Hook</p></li></ul><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><ul><li>自定义一个Hook函数</li><li>函数命名以use开始</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hook技术&quot;&gt;&lt;a href=&quot;#Hook技术&quot; class=&quot;headerlink&quot; title=&quot;Hook技术&quot;&gt;&lt;/a&gt;Hook技术&lt;/h1&gt;&lt;p&gt;Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及
      
    
    </summary>
    
    
      <category term="react" scheme="hexo/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>IOC</title>
    <link href="hexo/blog/2021/01/IOC.html"/>
    <id>hexo/blog/2021/01/IOC.html</id>
    <published>2021-01-08T02:32:38.000Z</published>
    <updated>2021-01-29T09:14:22.342Z</updated>
    
    <content type="html"><![CDATA[<p>Android 推荐应用架构建议将代码划分为多个类，以从分离关注点这一原则（其中，层次结构的每个类都具有一项已定义的责任）中受益。这就需要将更多更小的类连接在一起，以实现彼此之间的依赖关系。</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>android ioc 技术</p><p>源码地址：<a href="https://github.com/wangchongwei/ioc.git" target="_blank" rel="noopener">https://github.com/wangchongwei/ioc.git</a></p><h2 id="dagger"><a href="#dagger" class="headerlink" title="dagger"></a>dagger</h2><p>dagger使用：<br>主要使用了工厂模式、APT技术</p><p>利用注解处理器，变异时生成大量代码，完成自动注入</p><p>dagger 的使用主要作用：不必编写冗长乏味且容易出错的样板代码。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>Dagger 可以执行以下操作，使您无需再编写冗长乏味又容易出错的样板代码：</p></li><li><p>生成您在手动 DI 部分手动实现的 AppContainer 代码（应用图）。</p></li><li><p>为应用图中提供的类创建 factory。这就是在内部满足依赖关系的方式。</p></li><li><p>重复使用依赖项或创建类型的新实例，具体取决于您如何使用作用域配置该类型。</p></li><li><p>为特定流程创建容器，操作方法与上一部分中使用 Dagger 子组件为登录流程创建容器的方法相同。这样可以释放内存中不再需要的对象，从而提升应用性能。</p></li></ul><p>只要您声明类的依赖项并指定如何使用注释满足它们的依赖关系，Dagger 便会在构建时自动执行以上所有操作。Dagger 生成的代码与您手动编写的代码类似。在内部，Dagger 会创建一个对象图，然后它可以参考该图来找到提供类实例的方式。对于图中的每个类，Dagger 都会生成一个 factory 类型类，它会使用该类在内部获取该类型的实例。</p><p>在构建时，Dagger 会走查您的代码，并执行以下操作：</p><ul><li><p>构建并验证依赖关系图，确保：</p><ul><li>每个对象的依赖关系都可以得到满足，从而避免出现运行时异常。</li><li>不存在任何依赖循环，从而避免出现无限循环。</li></ul></li><li><p>生成在运行时用于创建实际对象及其依赖项的类。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 推荐应用架构建议将代码划分为多个类，以从分离关注点这一原则（其中，层次结构的每个类都具有一项已定义的责任）中受益。这就需要将更多更小的类连接在一起，以实现彼此之间的依赖关系。&lt;/p&gt;
&lt;h1 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Glide框架解析</title>
    <link href="hexo/blog/2020/12/Glide%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2020/12/Glide框架解析.html</id>
    <published>2020-12-30T02:50:47.000Z</published>
    <updated>2020-12-30T08:48:55.173Z</updated>
    
    <content type="html"><![CDATA[<p>Glide是android平台中的一个图片加载框架，<br>可以加载本地图片、网络图片、动态图</p><p>Glide的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageView);</span><br></pre></td></tr></table></figure><p>可以看出分成三部分：with、load、into<br>下面我们也分成三部分针对讲解</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with函数其实是对生命周期的管理<br>在Glide源码中，可以看到几个with函数,入参类型各不相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">    return getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Activity activity) &#123;</span><br><span class="line">    return getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull FragmentActivity activity) &#123;</span><br><span class="line">    return getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Fragment fragment) &#123;</span><br><span class="line">    return getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@Deprecated</span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull android.app.Fragment fragment) &#123;</span><br><span class="line">    return getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull View view) &#123;</span><br><span class="line">    return getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>with函数的入参有</p><ul><li>Context</li><li>Activity</li><li>FragmentActivity</li><li>androidX.Fragment</li><li>android.app.Fragment</li><li>View<br>可以看到，在with函数中都是调用getRetriever返回RequestManager对象，而调用getRetriever的入参有两个类型</li><li>1、context</li><li>2、activity</li></ul><p>getRetriever的两种入参类型又是根据上面with函数获取的，<br>针对fragment、fragmentActiivty、Actiivty获取对应的actiivty<br>针对context、view，则获取对应的context</p><p>再看一下getRetriever函数</p><h3 id="getRetriever"><a href="#getRetriever" class="headerlink" title="getRetriever"></a>getRetriever</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;</span><br><span class="line">    Preconditions.checkNotNull(</span><br><span class="line">        context,</span><br><span class="line">        &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span><br><span class="line">            + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span><br><span class="line">            + &quot;is attached or after the Fragment is destroyed).&quot;);</span><br><span class="line">    return Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br><span class="line">@NonNull</span><br><span class="line">public RequestManagerRetriever getRequestManagerRetriever() &#123;</span><br><span class="line">    return requestManagerRetriever;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，getRetriever返回就是一个 RequestManagerRetriever对象</p><p>也就是说 with函数最后调用到了RequestManagerRetriever对象的get函数</p><h3 id="RequestManagerRetriever"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a>RequestManagerRetriever</h3><p>看在Glide.java中的with函数就知道，RequestManagerRetriever中get函数也存在多个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">      if (context instanceof FragmentActivity) &#123;</span><br><span class="line">        return get((FragmentActivity) context);</span><br><span class="line">      &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">        return get((Activity) context);</span><br><span class="line">      &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">        return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">      return supportFragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull Fragment fragment) &#123;</span><br><span class="line">    Preconditions.checkNotNull(fragment.getActivity(),</span><br><span class="line">          &quot;You cannot start a load on a fragment before it is attached or after it is destroyed&quot;);</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(fragment.getActivity().getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      return fragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@NonNull</span><br><span class="line">public RequestManager get(@NonNull View view) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        return get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line">    Preconditions.checkNotNull(view.getContext(),</span><br><span class="line">        &quot;Unable to obtain a request manager for a view without a Context&quot;);</span><br><span class="line">    Activity activity = findActivity(view.getContext());</span><br><span class="line">    if (activity == null) &#123;</span><br><span class="line">        return get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (activity instanceof FragmentActivity) &#123;</span><br><span class="line">        Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);</span><br><span class="line">        return fragment != null ? get(fragment) : get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android.app.Fragment fragment = findFragment(view, activity);</span><br><span class="line">    if (fragment == null) &#123;</span><br><span class="line">        return get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    return get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个get函数，传入context对象，对context做分发，<br>其他的get函数，都是判断当前执行线程是否在main线程，如果不是 则都会走到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return getApplicationManager(context)</span><br></pre></td></tr></table></figure></p><p>在main线程时，会根据传入的参数获取对应的activity，activity为null，则也会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return getApplicationManager(context)</span><br></pre></td></tr></table></figure></p><p>如果activity不为空，则执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">return supportFragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br></pre></td></tr></table></figure></p><p>其中android.app.Fragment会略有差异，因为该Fragment为android包下，已被遗弃，但执行逻辑其实大同小异</p><p>接下来我们再看supportFragmentGet函数</p><h3 id="supportFragmentGet"><a href="#supportFragmentGet" class="headerlink" title="supportFragmentGet()"></a>supportFragmentGet()</h3><p>跟随Fragment的生命周期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">private RequestManager supportFragmentGet(</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull FragmentManager fm,</span><br><span class="line">    @Nullable Fragment parentHint,</span><br><span class="line">    boolean isParentVisible) &#123;</span><br><span class="line"></span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">        // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        requestManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getApplicationManager"><a href="#getApplicationManager" class="headerlink" title="getApplicationManager"></a>getApplicationManager</h3><p>跟随应用的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  private RequestManager getApplicationManager(@NonNull Context context) &#123;</span><br><span class="line">    // Either an application context or we&apos;re on a background thread.</span><br><span class="line">    if (applicationManager == null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        if (applicationManager == null) &#123;</span><br><span class="line">          // Normally pause/resume is taken care of by the fragment we add to the fragment or</span><br><span class="line">          // activity. However, in this case since the manager attached to the application will not</span><br><span class="line">          // receive lifecycle events, we must force the manager to start resumed using</span><br><span class="line">          // ApplicationLifecycle.</span><br><span class="line"></span><br><span class="line">          // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  new ApplicationLifecycle(),</span><br><span class="line">                  new EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样的话，就可以看得出调用with函数时，会绑定到一个requestManaget对象，<br>但是分两种：</p><ul><li>1、子线程，或出入的Context为ApplicationContext —》 applicationManager   —— 跟随应用的生命周期</li><li>2、main线程 &amp; 非ApplicationContext  —-》 requestManager —- 跟随当前Fragment/Activity的生命周期</li></ul><p>接着看RequestManager</p><h2 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h2><p>查看RequestManager的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager(</span><br><span class="line">      @NonNull Glide glide, @NonNull Lifecycle lifecycle,</span><br><span class="line">      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) &#123;</span><br><span class="line">    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory(), context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)</span><br><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">    this.glide = glide;</span><br><span class="line">    this.lifecycle = lifecycle;</span><br><span class="line">    this.treeNode = treeNode;</span><br><span class="line">    this.requestTracker = requestTracker;</span><br><span class="line">    this.context = context;</span><br><span class="line"></span><br><span class="line">    connectivityMonitor =</span><br><span class="line">    factory.build(</span><br><span class="line">        context.getApplicationContext(),</span><br><span class="line">        new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line">    </span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        mainHandler.post(addSelfToLifecycle);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lifecycle.addListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addListener(connectivityMonitor);</span><br><span class="line"></span><br><span class="line">    defaultRequestListeners =</span><br><span class="line">    new CopyOnWriteArrayList&lt;&gt;(glide.getGlideContext().getDefaultRequestListeners());</span><br><span class="line">    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());</span><br><span class="line"></span><br><span class="line">    glide.registerRequestManager(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个构造函数，上面的构造函数会调用到下面的构造函数，只有上面的函数才对外暴露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Glide是android平台中的一个图片加载框架，&lt;br&gt;可以加载本地图片、网络图片、动态图&lt;/p&gt;
&lt;p&gt;Glide的使用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>okhttp解析(一) 执行与分发</title>
    <link href="hexo/blog/2020/12/okhttp%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2020/12/okhttp解析.html</id>
    <published>2020-12-25T03:25:23.000Z</published>
    <updated>2021-01-14T02:09:33.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="okhttp解析"><a href="#okhttp解析" class="headerlink" title="okhttp解析"></a>okhttp解析</h1><p>okhttp 是一个网络框架，是当下android使用最频繁的网络请求框架，由Square公司开源。</p><p>google在Android4.4后开始将源码中的HttpUrlConnection底层实现替换为okhttp，现在流程的Retrofit框架底层同样是使用okhttp的。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>支持http1、http2、Quic以及WebSocket</li><li>连接池复用底层TCP(Socket),减少请求延时</li><li>无缝支持GZIP减少通信数据流量</li><li>缓存相应数据减少重复请求次数</li><li>请求失败自动重试主机其他ip，自动重定向</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>okhttp具体使用可以查看：</p><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>在client执行request时，会调用newCall方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Call newCall(Request request) &#123;</span><br><span class="line">    return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回一个RealCall对象，而RealCall是Call接口的一个实现。</p><p>client调用newCall时，只是返回一个RealCall对象，请求还没有发送出去。<br>需要执行RealCall的execute()或者enqueue()</p><p>这两个方法由什么区别呢，现在看一下。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>这是一个同步方法，即会直接执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">        executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(this);</span><br><span class="line">    try &#123;</span><br><span class="line">        client.dispatcher().executed(this);</span><br><span class="line">        // 发起请求</span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">        if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        eventListener.callFailed(this, e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处会调用client.dispatcher().executed(this); 其实是将当前RealCall对象加入到Dispatch的同步执行队列<br>在最后执行完毕会调用 client.dispatcher().finished(this); 其实是将当前RealCall对象从Dispatch的同步执行队列移除，因为当前RealCall对象的任务已执行完毕</p><p>会获取到response，并直接return</p><h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h3><p>这是一个异步方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">        executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(this);</span><br><span class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的两个方法中，最后都会调用到dispatcher的对应函数，Dispatch是一个分发器</p><p>注意调用dispatch的enqueue函数时，会将responseCallback包装成一个AsyncCall对象，<br>AsyncCall为RealCall的一个内部类</p><h3 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">    private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">        this.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host() &#123;</span><br><span class="line">        return originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request() &#123;</span><br><span class="line">        return originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealCall get() &#123;</span><br><span class="line">        return RealCall.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void execute() &#123;</span><br><span class="line">        boolean signalledCallback = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行请求 （拦截器）</span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line"></span><br><span class="line">            if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                signalledCallback = true;</span><br><span class="line">                responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                signalledCallback = true;</span><br><span class="line">                responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (signalledCallback) &#123;</span><br><span class="line">                // Do not signal the callback twice!</span><br><span class="line">                Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                eventListener.callFailed(RealCall.this, e);</span><br><span class="line">                responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            client.dispatcher().finished(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AysncCall实质上实现的是Runnable，execute执行的是获取response过程，<br>请求成功则执行responseCallback.onResponse，否则执行responseCallback.onFailure</p><p>最后执行client.dispatcher().finished(this); 注意最后传入的this指向是AsyncCall实例对象，</p><h2 id="Dispatch"><a href="#Dispatch" class="headerlink" title="Dispatch"></a>Dispatch</h2><p>Dispatch是okHttp内一个任务分发器，用于管理任务、管理线程池。<br>我们可以自定义Dispatch，如果没有传入自定义的，okHttp内部也有默认的，okhttp3.Dispatcher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">    private int maxRequests = 64;</span><br><span class="line">    private int maxRequestsPerHost = 5;</span><br><span class="line">    private @Nullable</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Executes calls. Created lazily.</span><br><span class="line">    * 内部的线程池</span><br><span class="line">    */</span><br><span class="line">    private @Nullable</span><br><span class="line">    ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Ready async calls in the order they&apos;ll be run.</span><br><span class="line">    * 等待执行的异步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet.</span><br><span class="line">    * 正在执行的异步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Running synchronous calls. Includes canceled calls that haven&apos;t finished yet.</span><br><span class="line">    * 正在执行的同步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在Dispatch内部有一个线程池，有三个队列，这三个队列下面会用的，会根据不同的任务添加到不同的队列</p><p>看一下Dispatch内部的executed以及enqueue函数</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">                new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;,</span><br><span class="line">                false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于线程池的详细解析可以查看之前的文章：<br>线程池第4个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p><ul><li>ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小<br>  当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。<br>  所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。</li><li>LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定<br> 当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的integer.MAX_VALUE,此时添加任务会一直成功。<br> 最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。</li><li>SynchronousQueue: 无容量的队列<br>  使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。<br>  唯一制约就是配置的最大线程数，如果使用Integer.MAX_VALUE就实现了真正的无等待。</li></ul><p>而在okhttp中就采用的SynchronousQueue，但进程内存是有限制的，不能无限添加，所以在Okhttp内部又有maxRequests限制，保证不超过64个。</p><h3 id="executed"><a href="#executed" class="headerlink" title="executed"></a>executed</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在同步函数中，会将call 添加到同步执行队列</p><h3 id="enqueue-1"><a href="#enqueue-1" class="headerlink" title="enqueue"></a>enqueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">    //todo : 1、如果正在执行的请求小于64</span><br><span class="line">    // 2、相同host的请求不能超过5个</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        runningAsyncCalls.add(call);  //正在执行的请求</span><br><span class="line">        executorService().execute(call); //线程池跑任务</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异步执行时，会判断当前正在执行异步队列大大小是否小于64 &amp;&amp; 传入的call的Host在正在执行队列中数量是否小于，<br>如果都满足，则会被放入正在执行异步队列，并且调用线程池执行该任务<br>如果不满足，则会被放入待执行异步队列</p><p>注意：此处的call为一个AsyncCall实例，</p><p>上面在AsyncCall中讲过了，当AsyncCall执行完毕会调用finished（AsyncCall）函数来移除正在执行异步队列中的这个AsyncCall对象</p><h3 id="finished"><a href="#finished" class="headerlink" title="finished"></a>finished</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 异步执行队列移除AsyncCall对象</span><br><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">    finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同步队列移除RealCall对象</span><br><span class="line">void finished(RealCall call) &#123;</span><br><span class="line">    finished(runningSyncCalls, call, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">    int runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">        if (promoteCalls) promoteCalls();</span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = this.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异步执行队列移除AsyncCall对象时，会执行promoteCalls()；<br>而且当this.idleCallback不为空，而且异步执行队列为空时,<br>会执行this.idleCallback.run();</p><h3 id="promoteCalls"><a href="#promoteCalls" class="headerlink" title="promoteCalls"></a>promoteCalls</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从异步等待队列中取任务执行</span><br><span class="line"> */</span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</span><br><span class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall call = i.next();</span><br><span class="line">        // 同一Host请求只能同时有5个</span><br><span class="line">        if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            i.remove();</span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promoteCalls函数主题其实就是从等待异步队列中取任务放入到执行异步任务队列中，并执行。</p><ul><li>先判断异步执行队列大小是否大于64，是则不向下执行</li><li>再判断待执行异步队列是否没有数据，是则不向下执行</li><li>然后遍历readyAsyncCalls队列，判断当前AsyncCall的Host是否在异步执行队列中&lt;5,<br>小于5时，将该任务从待执行异步队列移除，并将该任务添加到执行异步队列，并放入线程池<br>判断异步执行队列大小是否大于64，是的话，终止遍历</li></ul><p>到这里，okHttp的任务执行基本就看完了。</p><p>当然还有任务的取消</p><h3 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void cancelAll() &#123;</span><br><span class="line">    for (AsyncCall call : readyAsyncCalls) &#123;</span><br><span class="line">        call.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (AsyncCall call : runningAsyncCalls) &#123;</span><br><span class="line">        call.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (RealCall call : runningSyncCalls) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是遍历三个队列，调用Call对象的cancel方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;okhttp解析&quot;&gt;&lt;a href=&quot;#okhttp解析&quot; class=&quot;headerlink&quot; title=&quot;okhttp解析&quot;&gt;&lt;/a&gt;okhttp解析&lt;/h1&gt;&lt;p&gt;okhttp 是一个网络框架，是当下android使用最频繁的网络请求框架，由Square公
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android-自定义View-继承Drawable</title>
    <link href="hexo/blog/2020/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFDrawable.html"/>
    <id>hexo/blog/2020/12/android-自定义View-继承Drawable.html</id>
    <published>2020-12-22T02:11:42.000Z</published>
    <updated>2020-12-22T03:00:18.385Z</updated>
    
    <content type="html"><![CDATA[<p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>最后实现效果如下图：</p><p><img src="../../../images/fish.gif" style="zoom:20%"></p><p>思路：<br>1、将正个鱼分成几个部分，鱼头圆，鱼身二阶贝塞尔曲线，鱼尾，鱼鳍<br>2、因为鱼会摆动，需要考虑一个角度问题，需要定义一个点，来确定整个的角度<br>3、以鱼的重心点作为基准点，即鱼身的中心点<br>4、根据鱼的中心点以及每条线的长度获取其他点的坐标，就可以绘制整个图形<br>5、鱼的摆动根据属性动画来绘制，但要考虑鱼头与鱼尾的摆动频率不一致，可以使用三角函数，0-360，鱼头设置一倍，鱼尾设置多倍，<br>此时就能鱼头与鱼尾摆动频率不一致了。<br>6、鱼尾分两段，摆动的方向不一致，一段带动另一段，一个采用正旋sin，一个采用余旋cos</p><p>进阶：鱼能游动<br>7、点击时的水波纹<br>8、鱼回头问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a value=&quot;源码地址&quot; target=&quot;_blank&quot; href=&quot;https://github.com/wangchongwei/customView&quot; style=&quot;font-size:25px; color:blue; font-weight:bold&quot;&gt;源码
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android 嵌套滑动</title>
    <link href="hexo/blog/2020/12/Android-%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8.html"/>
    <id>hexo/blog/2020/12/Android-嵌套滑动.html</id>
    <published>2020-12-17T02:31:48.000Z</published>
    <updated>2020-12-17T02:31:48.218Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android View的事件分发</title>
    <link href="hexo/blog/2020/12/Android-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html"/>
    <id>hexo/blog/2020/12/Android-View的事件分发.html</id>
    <published>2020-12-17T02:11:13.000Z</published>
    <updated>2020-12-18T05:34:44.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h1><p>首先用户的交互事件都是先交给Actiivty，然后再来向下分发事件</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>我们可以查看Activity的dispatchTouchEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要明确一点，ACTION_DOWN是一次完整的交互事件的起点，onUserInteraction是一个空函数可以不要管，</p><p>会将事件分发到window的superDispatchTouchEvent，而window指的是PhoneWindow，在andorid源码中，只有一个window的实现类，就是PhoneWindow，如果window的dispatch返回为true则不向下执行，否则会执行到Activity的onTouchEvent，</p><h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在PhoneWindow.java中 superDispatchTouchEvent函数又代理给DecorView的superDispatchTouchEvent</p><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p>DecorView继承自FrameLayout，FrameLayout继承自ViewGroup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return super.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>DecorView中的superDispatchTouchEvent直接调用父类的dispatchTouchEvent，<br>而在FrameLayout中没有重写dispatchTouchEvent函数，所以会直接调用到ViewGroup的dispatchTouchEvent函数</p><h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>首先，所有的View都是继承自View的，ViewGroup也是继承自View</p><p>在ViewGroup的dispatchTouchEvent函数中，代码太长，先将部分代码收缩起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">       // mInputEventConsistencyVerifier是View中的一个变量，这里是对事件的一些校验</span><br><span class="line">       if (mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If the event targets the accessibility focused view and this is it, start</span><br><span class="line">       // normal event dispatch. Maybe a descendant is what will handle the click.</span><br><span class="line">       // 此处是对一些无障碍功能的设置</span><br><span class="line">       if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">           ev.setTargetAccessibilityFocus(false);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 局部变量，每一个事件分发时，都会重置为false</span><br><span class="line">       boolean handled = false;</span><br><span class="line">       if (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 重新校验</span><br><span class="line">       if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return handled;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其实主要逻辑还是在 if (onFilterTouchEventForSecurity(ev)) { 这个代码区域里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123;</span><br><span class="line">    //noinspection RedundantIfStatement</span><br><span class="line">    if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0</span><br><span class="line">            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123;</span><br><span class="line">        // Window is obscured, drop this touch.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对事件安全过滤的函数，正常情况都能通过。<br>接着看dispatchTouchEvent函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int action = ev.getAction();</span><br><span class="line">final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">// Handle an initial down.</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    // Throw away all previous state when starting a new touch gesture.</span><br><span class="line">    // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">    // due to an app switch, ANR, or some other state change.</span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是ACTION_DOWN就清除、重置touch事件，因为在上面讲过，ACTION_DOWN是一次交互的起点，在这里将上一次交互的状态都清除掉</p><h3 id="判断事件是否拦截"><a href="#判断事件是否拦截" class="headerlink" title="判断事件是否拦截"></a>判断事件是否拦截</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Check for interception.</span><br><span class="line">final boolean intercepted;</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != null) &#123;</span><br><span class="line">    final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">    if (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); // restore action in case it was changed</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        intercepted = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // There are no touch targets and this action is not an initial down</span><br><span class="line">    // so this view group continues to intercept touches.</span><br><span class="line">    intercepted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是判断是否开启拦截，注意这里的判断逻辑，intercepted是是否拦截标志位<br>disallowIntercept： 是否允许拦截，此处是一个外部拦截，在子视图中设置的，子视图设置是否让父容器拦截事件<br>如果disallowIntercept = false，再取执行内部拦截，onInterceptTouchEvent，查看ViewGroup是否拦截，为内部拦截<br>disallowIntercept为true时，代表子视图不允许父容器拦截，则intercepted = false;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> if (intercepted || mFirstTouchTarget != null) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check for cancelation.</span><br><span class="line">final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">// Update list of touch targets for pointer down, if needed.</span><br><span class="line">final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class="line">TouchTarget newTouchTarget = null;</span><br><span class="line">boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class="line">``` </span><br><span class="line">当被拦截时，或者touchTarget不为空时，设置事件的TargetAccessibilityFocus为false</span><br><span class="line">然后判断事件是否是取消事件</span><br><span class="line">初始化一个变量alreadyDispatchedToNewTouchTarget=false, 是否已经将事件绑定到一个targetView</span><br></pre></td></tr></table></figure><p>if (!canceled &amp;&amp; !intercepted) {<br>    // 当不是取消、没有被拦截时<br>    // If the event is targeting accessibility focus we give it to the<br>    // view that has accessibility focus and if it does not handle it<br>    // we clear the flag and dispatch the event to all children as usual.<br>    // We are looking up the accessibility focused host to avoid keeping<br>    // state since these events are very rare.<br>    // 获取到该事件绑定的view<br>    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()<br>            ? findChildWithAccessibilityFocus() : null;</p><pre><code>......</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在上述代码段中，其实只是执行了一个操作，即遍历子View，获取该事件对应的处理的View。</span><br><span class="line">注意这里有一个函数调用 dispatchTransformedTouchEvent</span><br><span class="line"></span><br><span class="line">当遍历找到需要处理这个事件的View或者确定不存在该View时，即执行这个函数，对这个事件进行重新分发</span><br></pre></td></tr></table></figure></p><p>private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,<br>            View child, int desiredPointerIdBits) {<br>    final boolean handled;</p><pre><code>// Canceling motions is a special case.  We don&apos;t need to perform any transformations// or filtering.  The important part is the action, not the contents.final int oldAction = event.getAction();if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {    event.setAction(MotionEvent.ACTION_CANCEL);    if (child == null) {        // 为空，将事件交给View.dispatchTouchEvent处理        handled = super.dispatchTouchEvent(event);    } else {        // 子View处理        handled = child.dispatchTouchEvent(event);    }    event.setAction(oldAction);    return handled;}// Calculate the number of pointers to deliver.final int oldPointerIdBits = event.getPointerIdBits();final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;// If for some reason we ended up in an inconsistent state where it looks like we// might produce a motion event with no pointers in it, then drop the event.if (newPointerIdBits == 0) {    return false;}// If the number of pointers is the same and we don&apos;t need to perform any fancy// irreversible transformations, then we can reuse the motion event for this// dispatch as long as we are careful to revert any changes we make.// Otherwise we need to make a copy.final MotionEvent transformedEvent;if (newPointerIdBits == oldPointerIdBits) {    if (child == null || child.hasIdentityMatrix()) {        if (child == null) {            handled = super.dispatchTouchEvent(event);        } else {            final float offsetX = mScrollX - child.mLeft;            final float offsetY = mScrollY - child.mTop;            event.offsetLocation(offsetX, offsetY);            handled = child.dispatchTouchEvent(event);            event.offsetLocation(-offsetX, -offsetY);        }        return handled;    }    transformedEvent = MotionEvent.obtain(event);} else {    transformedEvent = event.split(newPointerIdBits);}// Perform any necessary transformations and dispatch.if (child == null) {    handled = super.dispatchTouchEvent(transformedEvent);} else {    final float offsetX = mScrollX - child.mLeft;    final float offsetY = mScrollY - child.mTop;    transformedEvent.offsetLocation(offsetX, offsetY);    if (! child.hasIdentityMatrix()) {        transformedEvent.transform(child.getInverseMatrix());    }    handled = child.dispatchTouchEvent(transformedEvent);}// Done.transformedEvent.recycle();return handled;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">上述函数总结其实就是判断childView是否为空，如果为空的话，就再将事件转交给View.dispatchTouchEvent来处理，</span><br><span class="line">super.dispatchTouchEvent，因为ViewGroup继承自View，此时会调用到View.dispatchTouchEvent</span><br><span class="line">如果childView存在，则执行childView.dispatchTouchEvent，如果childView还是ViewGroup，还会再次执行这个过程，</span><br><span class="line">遍历-找寻子View-分发，注意在分发过程中，如果已经返回为true了，则不会再向下分发。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来看View的dispatchTouchEvent</span><br><span class="line"></span><br><span class="line">## View</span><br></pre></td></tr></table></figure><p>public boolean dispatchTouchEvent(MotionEvent event) {<br>    // If the event should be handled by accessibility focus first.<br>    if (event.isTargetAccessibilityFocus()) {<br>        // We don’t have focus or no virtual descendant has it, do not handle the event.<br>        if (!isAccessibilityFocusedViewOrHost()) {<br>            return false;<br>        }<br>        // We have focus and got the event, then use normal event dispatch.<br>        event.setTargetAccessibilityFocus(false);<br>    }</p><pre><code>boolean result = false;if (mInputEventConsistencyVerifier != null) {    mInputEventConsistencyVerifier.onTouchEvent(event, 0);}final int actionMasked = event.getActionMasked();if (actionMasked == MotionEvent.ACTION_DOWN) {    // Defensive cleanup for new gesture    // 当手指触碰时，停止滚动    stopNestedScroll();}if (onFilterTouchEventForSecurity(event)) {    if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {        result = true;    }    //noinspection SimplifiableIfStatement    // 当onTouch事件返回了true时，此处返回true    ListenerInfo li = mListenerInfo;    if (li != null &amp;&amp; li.mOnTouchListener != null            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED            &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {        result = true;    }    // 当onTouch事件返回了true时，此处返回true    if (!result &amp;&amp; onTouchEvent(event)) {        result = true;    }}if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {    mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);}// Clean up after nested scrolls if this is the end of a gesture;// also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest// of the gesture.// 当手指抬起、取消时，结束滚动if (actionMasked == MotionEvent.ACTION_UP ||        actionMasked == MotionEvent.ACTION_CANCEL ||        (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {    stopNestedScroll();}return result;</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">再看一下onTouchEvent事件，onTouchEvent是对事件的处理</span><br></pre></td></tr></table></figure></p><p>if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {<br>    if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {<br>        setPressed(false);<br>    }<br>    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;<br>    // A disabled view that is clickable still consumes the touch<br>    // events, it just doesn’t respond to them.<br>    return clickable;<br>}<br><code>`</code><br>如果View是不可点击的，如：ImageView,直接return false</p><p>View里因为设置了 onClickListener(), 这样就导致 View是 clickable (或者可以直接在xml里加上android:clickable=”true”)，即可点击，那么View.onTouchEvent就会永远返回 True, 代表View consume了该事件。<br>注意：只要View consume了该事件，那么该事件既不会往下传(不会传给子view)，也不会往上传(后面Activity/ViewGroup 的 onTouchEvent将不会再调用)。</p><p>View中不存在拦截，只有ViewGroup才有拦截</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;View的事件分发&quot;&gt;&lt;a href=&quot;#View的事件分发&quot; class=&quot;headerlink&quot; title=&quot;View的事件分发&quot;&gt;&lt;/a&gt;View的事件分发&lt;/h1&gt;&lt;p&gt;首先用户的交互事件都是先交给Actiivty，然后再来向下分发事件&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
</feed>
