<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Happy To Try</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2020-12-11T08:26:06.828Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络通信</title>
    <link href="hexo/blog/2020/12/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html"/>
    <id>hexo/blog/2020/12/网络通信.html</id>
    <published>2020-12-09T06:32:30.000Z</published>
    <updated>2020-12-11T08:26:06.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="计算机网络发展概史"><a href="#计算机网络发展概史" class="headerlink" title="计算机网络发展概史"></a>计算机网络发展概史</h2><p>计算机的发展大致分为以下四个阶段<br>1、诞生阶段，单个计算机为中心的远程联机系统<br>2、ARPANET，多个主机通过通信线路互联起来<br>3、开放性的标准化体系结构，OSI诞生<br>4、Internet互联网</p><p>OSI模型分为7层，tcp/ip模型分为4层，并存在对应关系<br>osi：物理层、链路层、 网络层、 传输层、  会话层、表示层、应用层<br>tcp/ip：链路层、     网络层、 传输层、         应用层</p><p>像我们日常中所说的4G、5G网络，是作用在链路层</p><p>TCP协议的基本特性：<br>面向链接、可靠性、RTT和RTO、数据排序、流量控制、全双工</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP协议中，Client与Server端建立链接会经历三次握手过程</p><p>1、Client 向 Server端发送报文，<br>    含有SYN = 1； seq(序列号)=1234(系统决定，1234是举例)，Client端进入SYN_SENT状态<br>2、Server 接收到 Client端报文，向Client端发送一个确认报文，<br>    含有 SYN = 1；ACK = 1; ack=1235(1234 + 1);seq(序列号)=2637(系统决定，2637是举例)<br>    Server端进入SYN_SYN_RCND状态<br>3、Client端接收到Server的确认报文，向Server端也发送一次确认报文，<br>    含有 ACK = 1；ack=2638(2637+1);<br>    Client与Server端都进入ESTABLISHED状态，通信建立，开始会话</p><p>以上就是三次握手的过程</p><p>问题：<br>为何tcp协议需要三次握手，而不是两次</p><p>因为三次是保证连接可靠、效率最高的次数。<br>第一次：客户端询问服务端能否建立通信<br>第二次：服务端向客户端确认可以通信<br>第三次：客户端向服务端确认可以通信<br>然后建立通信。</p><h3 id="洪泛攻击"><a href="#洪泛攻击" class="headerlink" title="洪泛攻击"></a>洪泛攻击</h3><p>黑客伪造大量虚假ip向服务端发送第一次握手报文，使server端大量通信进入SYN_SYN_RCND状态，消耗server资源，<br>使服务端无法响应其他的请求，甚至宕机。</p><p>处理方案：防火墙、</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>当要断开连接时，客户端与服务端之间将进行四次挥手，来确保数据传输都完毕，确保连接断开。</p><p>1、client向server端发送FIN报文，<br>    含有FIN = 1，seq(序列号)=J(系统决定，J是举例)，Client进入FIN_WAITING<br>2、server收到客户端发送的报文，同时向Server发送一个FIN ACK 确认报文<br>    含有ACK = 1； ack = J + 1; Server进入CLOSE_WAITING<br>3、server向client发送一个FIN报文，<br>    含有FIN = 1； seq = K；Server进入 CLOSE状态<br>4、client收到上述两个server端报文，Client进入TIME_WAITING状态,同时client向server发送一个ACK报文，<br>    含有FIN = 1； ACK = 1； ack = K + 1;<br>    server接收到此报文后，进入CLOSED状态，<br>    而client，在经过2 * MSL的时间段后，client进入CLOSED状态。</p><p>注意：四次挥手设计到四次报文的传输，但在实际中，可能会存在报文合并的现象，就是报文发送的次数可能只有3次甚至两次。<br>MSL理论上是2分钟，可实际一般会被重写为30s，所以最后等待时间为1min-4min。</p><h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><p>因为tcp是全双工(即客户端和服务器端可以相互发送和接收请求)，所以需要双方都确认关闭连接。</p><h3 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME-WAIT状态？"></a>为什么需要TIME-WAIT状态？</h3><p>在第三次报文发送，client接收到时，client会进入TIME_WAIT状态，而且是需要经过经过2 * MSL，才会进入CLOSED状态，<br>为何这么设计呢，因为要考虑最后一个报文的接收，要考虑到Server未接收到时，需要重新发送，还要考虑，如果Client即时进入CLOSED，连接断开，端口可能会有一个新的程序使用，可能存在报文被发送到这个新启动的程序。</p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>使用wireshark可以抓包，查看到连接过程中的每一次数据包的传递</p><p>使用过滤器查看</p><p>tcp udp 可以指定协议</p><p>tcp.port==80 端口</p><p>ip.src==192.168.101.130 ip<br>连接符使用and</p><p>tcp and tcp.port==3306 and ip.src==192.168.101.130</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络通信&quot;&gt;&lt;a href=&quot;#网络通信&quot; class=&quot;headerlink&quot; title=&quot;网络通信&quot;&gt;&lt;/a&gt;网络通信&lt;/h1&gt;&lt;h2 id=&quot;计算机网络发展概史&quot;&gt;&lt;a href=&quot;#计算机网络发展概史&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity一键换肤</title>
    <link href="hexo/blog/2020/12/Activity%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4.html"/>
    <id>hexo/blog/2020/12/Activity一键换肤.html</id>
    <published>2020-12-07T07:51:39.000Z</published>
    <updated>2020-12-11T09:59:44.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity一键换肤"><a href="#Activity一键换肤" class="headerlink" title="Activity一键换肤"></a>Activity一键换肤</h1><h2 id="Activity绘制过程"><a href="#Activity绘制过程" class="headerlink" title="Activity绘制过程"></a>Activity绘制过程</h2><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><p>查看ActivityThread代码源码，<br>performLaunchActivity函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Activity activity = null;</span><br><span class="line">try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">    r.assistToken);</span><br></pre></td></tr></table></figure></p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>我们在看Activity类中的attach函数中的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">mWindow.setWindowControllerCallback(this);</span><br><span class="line">mWindow.setCallback(this);</span><br><span class="line">mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">mWindow.getLayoutInflater().setPrivateFactory(this);</span><br></pre></td></tr></table></figure></p><p>再看我们在Activity中设置布局的setContentView函数在Activity中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看出我们传入的layout布局是设置到window对象上的，继续往里看<br>Window类中的setContentView是一个抽象方法，而getWindow()返回的是我们上面的PhoneWindow对象，我们看PhoneWindow中的setContentView方法</p><h3 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h3><p>PhoneWindow.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">    // before this happens.</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">    // before this happens.</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        final Scene newScene = new Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当初次运行时，肯定会走到installDecor 函数，在此函数中，又会新建一个DecorView绑定到window上。</p><p>也就是说我们的window上还有挂载一个DecorView</p><p>而在installDecor中，会对mContentParent判断，当为空时，会初始化<br>mContentParent = (DecorContentParent) mDecor.findViewById(R.id.decor_content_parent);</p><p>所以其实我们的view的层级其实是：<br>Window -&gt; DecorView -&gt; mContentParent + 我们自己的布局<br>而我们自己的View最后都是调用到LayoutInflater.inflate来加载的。</p><h3 id="LayoutInflater"><a href="#LayoutInflater" class="headerlink" title="LayoutInflater"></a>LayoutInflater</h3><p>最后所有View的加载会走到tryCreateView函数<br>LayoutInflater 中的 tryCreateView函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage(trackingBug = 122360734)</span><br><span class="line">@Nullable</span><br><span class="line">public final View tryCreateView(@Nullable View parent, @NonNull String name,</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull AttributeSet attrs) &#123;</span><br><span class="line">    if (name.equals(TAG_1995)) &#123;</span><br><span class="line">        // Let&apos;s party like it&apos;s 1995!</span><br><span class="line">        return new BlinkLayout(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    if (mFactory2 != null) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; else if (mFactory != null) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        view = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (view == null &amp;&amp; mPrivateFactory != null) &#123;</span><br><span class="line">        view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看得出先判断mFactory2是否存在，存在的话，会通过mFactory2.onCreateView来创建View<br>再判断mFactory是否存在，存在的话，会通过mFactory.onCreateView来创建View<br>如果上面两个都不存在，则会调用mPrivateFactory来创建</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>根据上面的描述，我们知道所有的View创建都会走到LayoutInflater.tryCreateView函数，<br>而且这里有一个工厂类mFactory2，如果我们能创建一个mFactory2对象，并设置上去，那所有的view创建就都会走到我们自己的代码，<br>则我们可以获取到所有的view</p><p>换肤：是替换所有可以替换的颜色、背景，包括背景颜色、背景图片，因为我们替换了背景颜色，所以文本颜色也是需要替换。<br>我们明确了换肤的目标，原理呢就是：<br>换肤插件module中具有的资源名与宿主app的资源名都一致，只是资源值不同，<br>如在宿主app中res/value/colors.xml中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--宿主app--&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#ffce3d3a&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;!--插件module--&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimary&quot;&gt;#1F1F1F&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#373935&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorAccent&quot;&gt;#ffffff&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#FFA500&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>如上所示，所有的资源名称都是一致，只是资源内容不同，图片也是如此。<br>当需要换肤时，通过获取宿主app的资源名称，到插件module中获取该名称的对应资源，然后替换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity一键换肤&quot;&gt;&lt;a href=&quot;#Activity一键换肤&quot; class=&quot;headerlink&quot; title=&quot;Activity一键换肤&quot;&gt;&lt;/a&gt;Activity一键换肤&lt;/h1&gt;&lt;h2 id=&quot;Activity绘制过程&quot;&gt;&lt;a href=&quot;#A
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title> 注解</title>
    <link href="hexo/blog/2020/12/%E6%B3%A8%E8%A7%A3.html"/>
    <id>hexo/blog/2020/12/注解.html</id>
    <published>2020-12-03T01:13:53.000Z</published>
    <updated>2020-12-03T01:14:21.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android消息机制</title>
    <link href="hexo/blog/2020/11/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6.html"/>
    <id>hexo/blog/2020/11/android消息机制.html</id>
    <published>2020-11-24T03:09:22.000Z</published>
    <updated>2020-11-25T10:09:41.994Z</updated>
    
    <content type="html"><![CDATA[<p>在andorid中，系统的行为、用户的输入等事件都会被包装为一个消息，<br>进行消息发送、处理</p><p>关于消息的处理，就离不开Handler、Message、Loop<br>在平时使用时，Handler多用于多线程之间通信。</p><ul><li>那么Handler如何实现多线程通信？</li><li>多线程之间为何不会互相干扰？</li><li>为什么不使用用wait/notify？</li></ul><h2 id="Handler多线程通信"><a href="#Handler多线程通信" class="headerlink" title="Handler多线程通信"></a>Handler多线程通信</h2><p>先看一下普通使用案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyActiivty extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private Handler myHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">                if(msg.what=100) &#123;</span><br><span class="line">                    // TODO</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyThread extends Thread() &#123;</span><br><span class="line">        @Overtide</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            Message message = Message.obtain();</span><br><span class="line">            message.what = 100;</span><br><span class="line">            myHandler.sendMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的在子线程发送消息，回到主线程处理消息的过程，<br>通过在子线程构造一个message对象，在主线程中获取到该message对象，来处理消息。</p><p>所以其实Handler处理多线程通信是通过共享Message对象内存来实现的。<br>内存是不区分线程的，这种通信原理就是在子线程与主线程共享message内存</p><p>所以 那么Handler如何实现多线程通信？<br>通过 内存共享 实现。</p><p>在多线程时，Handler又是如何保证消息如何在正确的线程发送的呢，或者说是如何保证执行的线程是正确的了。<br>这就要引入我们的Loop、消息队列概念了。</p><p>handler处理消息模型:</p><p><img src="../../../images/looper.png" style="zoom:20%"></p><p>handler负责发送、处理消息<br>looper负责一直轮询消息<br>messageQueue消息队列，负责存放、取出消息</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>讲到looper负责一直轮询消息，但是好像在上面的代码中，都没有使用到looper。</p><p>其实是在主线程中，系统已经默认为我们创建了looper，<br>在ActivityThread.java的main方法中（ActivityThread即为主线程）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line"></span><br><span class="line">        // Install selective syscall interception</span><br><span class="line">        AndroidOs.install();</span><br><span class="line"></span><br><span class="line">        // CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">        // disable it here, but selectively enable it later (via</span><br><span class="line">        // StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">        CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        // Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br><span class="line">        // It will be in the format &quot;seq=114&quot;</span><br><span class="line">        long startSeq = 0;</span><br><span class="line">        if (args != null) &#123;</span><br><span class="line">            for (int i = args.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，调用了Loop.prepareMainLooper()、Looper.loop()函数，<br>而且在Looper.loop()后面就抛出异常，<br>也就是说主线程中loop一旦停止轮询，则会抛出异常闪退。正常情况时，loop就是一直在轮询。</p><p>查看Looper的这两个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">        prepare(false);</span><br><span class="line">        synchronized (Looper.class) &#123;</span><br><span class="line">            if (sMainLooper != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在prepareMainLooper中可以看到，不允许调用两次，否则会抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Run the message queue in this thread. Be sure to call</span><br><span class="line">    * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line">    */</span><br><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    // Allow overriding a threshold with a system prop. e.g.</span><br><span class="line">    // adb shell &apos;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&apos;</span><br><span class="line">    final int thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(&quot;log.looper.&quot;</span><br><span class="line">                    + Process.myUid() + &quot;.&quot;</span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + &quot;.slow&quot;, 0);</span><br><span class="line"></span><br><span class="line">    boolean slowDeliveryDetected = false;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        // Make sure the observer won&apos;t change while processing a transaction.</span><br><span class="line">        final Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">        if (thresholdOverride &gt; 0) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);</span><br><span class="line">        final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);</span><br><span class="line"></span><br><span class="line">        final boolean needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">        final boolean needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        final long dispatchEnd;</span><br><span class="line">        Object token = null;</span><br><span class="line">        if (observer != null) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">            if (observer != null) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSlowDelivery) &#123;</span><br><span class="line">            if (slowDeliveryDetected) &#123;</span><br><span class="line">                if ((dispatchStart - msg.when) &lt;= 10) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Drained&quot;);</span><br><span class="line">                    slowDeliveryDetected = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    // Once we write a slow delivery log, suppress until the queue drains.</span><br><span class="line">                    slowDeliveryDetected = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop函数中，首先获取通过myLooper()函数获取looper对象，如果looper对象为空，则抛出异常，提示必须在当前线程先执行Looper.prepare()<br>然后获取looper对象持有的messageQueue，<br>然后就是for(;;)无限循环，获取messageQueue下一条消息<br>获取到message后调用msg.target.dispatchMessage(msg);<br>将这条消息发送出去。<br>最后执行msg.recycleUnchecked()，相当于一个回收利用。</p><p>我们看一下myLooper函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说明looper是存放在ThreadLocal中的。<br>关于ThreadLocal，在之前已经大致讲过了。<br>ThreadLocal讲解（<a href="https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）" target="_blank" rel="noopener">https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）</a><br>在每一个线程，都存在一个对应且唯一的值</p><p>我们可以看一下prepare函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到与prepareMainLooper的不同，因为prepareMainLooper是在主线程调用，而主线程很自由一个，<br>所以直接使用sMainLooper来保存主线程的looper，而且主线程中prepare(false)；标示不允许looper退出。</p><p>而在子线程时，就是将looper对象保存到sThreadLocal中，sThreadLocal.get()不为null时，会抛出异常。<br>也就是说子线程中prepare只允许调用一次，保证了每个线程中的looper对象唯一性</p><p>然后看到子线程和主线程的另一个差异prepare(false) &amp;&amp; prepare(true)<br>因为andorid，所有事件如：用户的操作、ui的渲染等都是作为消息发送的，而这些都是在主线程操作的，所以在主线程中是不允许退出loop循环，否则抛出异常。</p><p>而在子线程中prepare(true)，允许退出，其实在子线程中新建handler、looper时，当我们不需要再使用，需要终止loop循环。<br>此时需要调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>在上面中已经讲过Looper，looper中持有一个messageQueue<br>final MessageQueue queue = me.mQueue;<br>mQueue 在Looper的私有构造函数中被初始化</p><p>接下来我们看一下MessageQueue<br>队列是一种数据结果，FIFO先进先出<br>MessageQueue 是一个消息队列，默认也是先进先出，有序执行</p><p>之前说了，MessageQueue主要用于存放、取出消息。<br>在Looper中主要用到了messagequeue的next函数，用于取出下一条消息</p><p>我们先看一下存放消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    if (msg.target == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (msg.isInUse()) &#123;</span><br><span class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = new IllegalStateException(</span><br><span class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">            // New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">            // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">            // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; // invariant: p == prev.next</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程已经退出，mQuitting为true，则抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msg.when = when;</span><br><span class="line">Message p = mMessages;</span><br><span class="line">boolean needWake;</span><br><span class="line">if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">    // New head, wake up the event queue if blocked.</span><br><span class="line">    msg.next = p;</span><br><span class="line">    mMessages = msg;</span><br><span class="line">    needWake = mBlocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当全局变量mMessages为空，或者当前传入的when为0， 或者当前when小于全局变量mMessages.when(即时间在前)<br>其实判断的是两种状态，1:messageQueue队列为空 2:添加的消息执行时间在前<br>此时将该消息置于队首，<br>needWake = mBlocked；<br>如果mBlocked为true，needWake也为true，就是如果之前阻塞则唤醒，反之无需唤醒</p><p>再看不满足上面情况下时,即消息队列中已添加过消息，而且要添加的消息.when在上一次添加的消息之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">    // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">    // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">    needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">    Message prev;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        if (p == null || when &lt; p.when) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">            needWake = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.next = p; // invariant: p == prev.next</span><br><span class="line">    prev.next = msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for循环，遍历链表，当找到节点为null即遍历完 || 传入的when小于遍历节点的when（即传入消息的时间在遍历节点时间之前时）<br>终止循环，将msg.next -&gt; p<br>原来<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; p -&gt; …<br>现在<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; msg.next -&gt; p -&gt; …</p><p>也就是说，message链表是按照when排序的，when越小，在越靠近链头<br>为何要根据when排序了，其实是因为message执行时间是要按时间排序，要执行时间越小，代表时间越早，所以放在链头</p><p>以上是消息队列，入队函数，再看一下出队函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">Message next() &#123;</span><br><span class="line">    // Return here if the message loop has already quit and been disposed.</span><br><span class="line">    // This can happen if the application tries to restart a looper after quit</span><br><span class="line">    // which is not supported.</span><br><span class="line">    final long ptr = mPtr;</span><br><span class="line">    if (ptr == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Got a message.</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // No more messages.</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process the quit message now that all pending messages have been handled.</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If first time idle, then get the number of idlers to run.</span><br><span class="line">            // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">            // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                mBlocked = true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Run the idle handlers.</span><br><span class="line">        // We only ever reach this code block during the first iteration.</span><br><span class="line">        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">            boolean keep = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">        pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">        // While calling an idle handler, a new message could have been delivered</span><br><span class="line">        // so go back and look again for a pending message without waiting.</span><br><span class="line">        nextPollTimeoutMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一段代码可以先不看，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">    // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">    do &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这一块设计到消息的同步屏障，放到下面再将，我们先只看出队时的逻辑<br>next函数就是取出下一条消息。<br>开启for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">    Binder.flushPendingCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果nextPollTimeoutMillis不等于0时，会阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final long now = SystemClock.uptimeMillis();</span><br><span class="line">Message prevMsg = null;</span><br><span class="line">Message msg = mMessages;</span><br><span class="line">if (msg != null) &#123;</span><br><span class="line">    if (now &lt; msg.when) &#123;</span><br><span class="line">        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Got a message.</span><br><span class="line">        mBlocked = false;</span><br><span class="line">        if (prevMsg != null) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = null;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // No more messages.</span><br><span class="line">    nextPollTimeoutMillis = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当当前message不为空时：<br>如果当前时间小于msg.when，即没到执行时间，则阻塞线程到msg.when时间<br>将msg.next赋值给全局变量mMessages，再将msg.next指向null<br>然后返回msg这一个节点，如此不会返回一个链表</p><p>如果msg为空，说明队列为空，没有消息，此时赋值nextPollTimeoutMillis = -1;下一次循环时，就会阻塞。</p><ul><li>MessageQueue 添加消息、取出消息是线程安全的吗？<br>是，是线程安全的。</li><li><p>如何保证线程安全的？<br>通过锁，存放消息以及取出消息时都有设置synchronized (this)，<br>synchronized 后面修饰的是this，同一个对象在多线程环境调用函数时，只会有一个线程获取到锁，进行操作。<br>synchronized 是内置锁，JVM已经内置处理了锁的获取以及释放</p></li><li><p>为什么不使用用wait/notify？<br>在上述代码可以看到使用了阻塞、锁，阻塞是直接调用native 函数来阻塞，<br>其实在内部已经使用了wait/notif。</p></li></ul><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>上面讲了消息机制中的Handler、Looper、MessageQueue；<br>现在我们再讲一下消息的本体Message</p><p>首先通过我们在上面的分析，可以知道Message在数据结构上看，是一个链表，而且是只有next指针，所以是个单链表。<br>Message中没有什么复杂操作，都是一些赋值函数<br>有两个地址可以注意下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123;</span><br><span class="line">        if (gCheckRecycle) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</span><br><span class="line">                    + &quot;is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    // Mark the message as in use while it remains in the recycled object pool.</span><br><span class="line">    // Clear out all other details.</span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = 0;</span><br><span class="line">    arg1 = 0;</span><br><span class="line">    arg2 = 0;</span><br><span class="line">    obj = null;</span><br><span class="line">    replyTo = null;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = 0;</span><br><span class="line">    target = null;</span><br><span class="line">    callback = null;</span><br><span class="line">    data = null;</span><br><span class="line"></span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = this;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Message的回收函数不是将对象置为空，而是将Message中的变量都还原为默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool != null) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = null;</span><br><span class="line">            m.flags = 0; // clear in-use flag</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message还提供obtain函数，不会直接new 一个Message对象，而是共享之前的对象，改变对象的内部属性。</p><p>所以我们在实际使用中都是使用Message.obtain()来构建message对象，而不是一直使用new ，这样可以避免频繁的生成、回收，避免内存抖动。</p><p>这种设计被成为 <em> 享元设计模式 </em></p><h2 id="Message-同步屏障"><a href="#Message-同步屏障" class="headerlink" title="Message 同步屏障"></a>Message 同步屏障</h2><p>上面讲的消息message链表是根据when时间排序，那如果有紧急的消息必须马上处理呢，这个时候不可能等其他先执行而必须是马上执行的事件时，怎么办？</p><p>这个时候就可以用到 同步屏障</p><p>handler消息机制大概流程：<br>生成Looper对象，生成Handler对象，Lopper.looper循环<br>在Handler构造函数内，获取到上面生成的looper对象，通过ThreadLocal保存到对应的线程，与MessageQueue绑定<br>在需要发送消息的地方调用handler.sendMessage(),在sendMessage时，将message与handler绑定，将message.target赋值为当前handler<br>同时，sendMessage时，调用messageQueue.enqueueMessage将message放入消息队列。<br>同时，Looper.loop()在循环一直取出消息message，然后通过message.target获取到handler对象，最终回调到handler.handlerMessage函数。</p><p>这样消息从产生到处理流程就走完了。</p><p>总结提问：</p><ul><li>Looper.loop()一直在循环，为什么不会导致应用卡死(ANR)?</li></ul><p>答：loop()循环与ANR是两个不相关的事情，loop只是循环事件，ANR是处理事件耗时，导致无法响应用户的下一次输入。<br>系统的ANR弹窗都是通过消息机制发送，并弹出提示窗的。</p><ul><li>fragment生命周期</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在andorid中，系统的行为、用户的输入等事件都会被包装为一个消息，&lt;br&gt;进行消息发送、处理&lt;/p&gt;
&lt;p&gt;关于消息的处理，就离不开Handler、Message、Loop&lt;br&gt;在平时使用时，Handler多用于多线程之间通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那么Hand
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>APT注解处理器</title>
    <link href="hexo/blog/2020/11/APT%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8.html"/>
    <id>hexo/blog/2020/11/APT注解处理器.html</id>
    <published>2020-11-16T03:04:49.000Z</published>
    <updated>2020-11-16T10:01:32.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h1><p>APT(Annotation Processing Tool) 是一种处理注释的工具，它对源代码文件进行检测找出<br>其中的Annotation，根据注解自动生成代码，如果想要自定义的注解处理器能够正常运行，必须要通过<br>APT工具来进行处理。 也可以这样理解，只有通过声明APT工具后，程序在编译期间自定义注解解释器<br>才能执行。 通俗理解：根据规则，帮我们生成代码、生成类文件</p><p>在使用APT在项目编译时期动态生成我们需要的java文件时，有两种方式，<br>传统方式、javapoet</p><p>项目源码(<a href="https://github.com/wangchongwei/apt" target="_blank" rel="noopener">https://github.com/wangchongwei/apt</a>)</p><h2 id="javapoet"><a href="#javapoet" class="headerlink" title="javapoet"></a>javapoet</h2><p>以面向对象(OOP)思维，在编译时，动态生成java文件</p><p>优点：OOP思维，不需要导包<br>缺点：倒序写法，从函数-&gt;类-&gt;包</p><p>这种方式和写作思维不同，从调用链尾部到头部。<br>开源组件butterknife、ARouter都是使用javapoet方式</p><p>example:</p><p>新建一个工程，<br>并在工程新建一个javaLib，在此工程新建一个注解类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE) // 表明注解是添加在类上</span><br><span class="line">@Retention(RetentionPolicy.CLASS) // 表明在编译器执行</span><br><span class="line">public @interface ARouter &#123;</span><br><span class="line"></span><br><span class="line">    String path(); // 声明注解时 必须参数</span><br><span class="line"></span><br><span class="line">    String group() default &quot;&quot;; // 因为已经设置了default值，所以这个是选填参数</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时我们就完成了一个注解的定义<br>然后再新建一个javaLib，在此工程新建一个处理注解的类，而这个类就是我们在编译时生成java类的主要代码部分<br>在此工程build.gradle中添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // 背后的服务 能够监听 你是否在编译中.....</span><br><span class="line">    // AS3.4.1 + Gradle 5.1.1 + auto-service:1.0-rc4</span><br><span class="line">    compileOnly&apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br><span class="line">    annotationProcessor&apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br><span class="line"></span><br><span class="line">    // 帮助我们通过类调用的形式来生成Java代码 [JavaPoet]</span><br><span class="line">    implementation &quot;com.squareup:javapoet:1.9.0&quot;</span><br><span class="line"></span><br><span class="line">    // 依赖注解module</span><br><span class="line">    implementation project(&quot;:annotations&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们开始写监听到注解时需要生成java类的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class) // 启用服务 google 自动服务，一直监控</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;com.justin.annotationprocessor.ARouter&quot;&#125;) // 注解 包名.类名</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_8) // 环境的版本</span><br><span class="line"></span><br><span class="line">@SupportedOptions(&quot;student&quot;) // 接收在app/build.gradle中声明的参数</span><br><span class="line">public class ARouterProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Elements elements;</span><br><span class="line"></span><br><span class="line">    private Messager messager;</span><br><span class="line"></span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    private Types typeTool;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">        elements = processingEnvironment.getElementUtils();</span><br><span class="line">        messager = processingEnvironment.getMessager();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">        typeTool = processingEnvironment.getTypeUtils();</span><br><span class="line"></span><br><span class="line">        // 获取在app/build.gradle中申明的参数</span><br><span class="line">        String value = processingEnvironment.getOptions().get(&quot;student&quot;);</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, &quot;=========&gt;&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        // 此时会运行两次，一次执行，一次检查</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; compiler is running&quot;);</span><br><span class="line"></span><br><span class="line">        if(set.isEmpty()) &#123;</span><br><span class="line">            // 使用注解的类集合为空</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取被 ARouter注解的 &quot;类节点信息&quot;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class);</span><br><span class="line">        for(Element element : elements) &#123;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">                举例我们需要生成这样一个类</span><br><span class="line">             package com.example.helloworld;</span><br><span class="line"></span><br><span class="line">             public final class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">             public static void main(String[] args) &#123;</span><br><span class="line">             System.out.println(&quot;Hello, JavaPoet!&quot;);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             public int add(int a, int b)&#123;</span><br><span class="line">                return 5;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line">            // javapoet生成java文件的方式时，OOP思维，先生成函数，再生成类，最后生成包</span><br><span class="line">            // 1 生成函数</span><br><span class="line">            MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;main&quot;) // 构造一个函数， 函数名</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC) // public 、static</span><br><span class="line">                    .returns(void.class) // 返回值类型</span><br><span class="line">                    .addParameter(String[].class, &quot;args&quot;) // 入参类型</span><br><span class="line">                    .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)// 函数执行语句 不需要添加分号</span><br><span class="line">                    .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, agent!&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 多个函数</span><br><span class="line">            MethodSpec methodSpec1 = MethodSpec.methodBuilder(&quot;add&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                    .returns(int.class)</span><br><span class="line">                    .addParameter(int.class, &quot;a&quot;)</span><br><span class="line">                    .addParameter(int.class, &quot;b&quot;) // 可以添加多个入参</span><br><span class="line">                    .addStatement(&quot;return 5&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 2 生成类</span><br><span class="line">            TypeSpec myClass = TypeSpec.classBuilder(&quot;HelloWorld&quot;) // 构造一个类，类名</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL) // 添加申明 public、final</span><br><span class="line">                    .addMethod(methodSpec) // 绑定函数</span><br><span class="line">                    .addMethod(methodSpec1) // 绑定多个函数</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 3、生成包</span><br><span class="line">            JavaFile myPackage = JavaFile.builder(&quot;com.example.helloworld&quot;, myClass).build();</span><br><span class="line">            try &#123;</span><br><span class="line">                myPackage.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; 创建HelloWorld类失败,异常原因：&quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后使用@ARouter注解<br>在MainActivity中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ARouter(path = &quot;main/MainActivity&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击build项目，即会在app/build/ap_generated_sources/debug下生成对应的包以及java文件</p><p><img src="../../../images/javapoet.jpg" style="zoom:20%"></p><p>在上述方式中，我们只是写成了一个固定的java文件，还没有体现动态生成概念。<br>下面我们就要改造，动态接收参数来生成代码<br>只显示动态生成代码部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 获取被 ARouter注解的 &quot;类节点信息&quot;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class);</span><br><span class="line">        for(Element element : elements) &#123;</span><br><span class="line">            // 动态生成java代码</span><br><span class="line">            // 获取组件class的包路径</span><br><span class="line">            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();</span><br><span class="line">            // 获取注解的类名</span><br><span class="line">            String className = element.getSimpleName().toString();</span><br><span class="line">            // 获取到注解以及注解时的参数</span><br><span class="line">            ARouter aRouter = element.getAnnotation(ARouter.class);</span><br><span class="line">            String path = aRouter.path();</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             模板：</span><br><span class="line">             public class MainActivity3$$$$$$$$$ARouter &#123;</span><br><span class="line">             public static Class findTargetClass(String path) &#123;</span><br><span class="line">             return path.equals(&quot;/app/MainActivity3&quot;) ? MainActivity3.class : null;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             */</span><br><span class="line">            // 1、方法</span><br><span class="line">            MethodSpec method = MethodSpec.methodBuilder(&quot;findTargetClass&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                    .returns(Class.class)</span><br><span class="line">                    .addParameter(String.class, &quot;path&quot;)</span><br><span class="line">                    .addStatement(&quot;return path.equals($S) ? $T.class : null&quot;,</span><br><span class="line">                            path,</span><br><span class="line">                            ClassName.get((TypeElement) element) // 获取注解类的class对象</span><br><span class="line">                    )</span><br><span class="line">                    .build();</span><br><span class="line">            // 2 类</span><br><span class="line">            TypeSpec mineClass = TypeSpec.classBuilder(className + &quot;$$$$$$$$$ARouter&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                    .addMethod(method)</span><br><span class="line">                    .build();</span><br><span class="line">            // 3 包</span><br><span class="line">            JavaFile minePackage = JavaFile</span><br><span class="line">                    .builder(packageName, mineClass)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                minePackage.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + className + &quot;类失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此时我们就完成了自动获取注解类的包名、类名、注解时的path<br>自动生成的类也在相同包名下，获取注解时的path，可以做一些操作</p><h2 id="传统方式生成java文件"><a href="#传统方式生成java文件" class="headerlink" title="传统方式生成java文件"></a>传统方式生成java文件</h2><p>在编译时，一行一行，从头到尾，以写文本的方式写一个java文件</p><p>优点：套版格式，思路清晰<br>缺点：所有代码都需要写，包括导包，如果有任一一个字符错误、分号缺失，都会导致报错。</p><p>这种方式需要及其细心<br>开源组建EventBus就是采用的这种方式</p><p>example：<br>首先自定义注解类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(TYPE) </span><br><span class="line">@Retention(CLASS) // 编译期    XUtil==运行期</span><br><span class="line">public @interface Binding &#123;</span><br><span class="line"></span><br><span class="line">    String router();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后写注解处理类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7) // 环境的版本</span><br><span class="line">@AutoService(Processor.class) // 启用服务</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;com.derry.arouter_annotations.Binding&quot;&#125;) // 注解</span><br><span class="line">public class BindingProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Elements elementTool;</span><br><span class="line">    private Messager messager;</span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">        elementTool = processingEnvironment.getElementUtils();</span><br><span class="line">        messager = processingEnvironment.getMessager();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line"></span><br><span class="line">        if(set.isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Binding.class);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line"></span><br><span class="line">            // 获取包名</span><br><span class="line">            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();</span><br><span class="line">            String className = element.getSimpleName().toString();</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.NOTE, &quot;被@ARetuer注解的类有：&quot; + className);</span><br><span class="line">            String findClassName = className + &quot;$$$$$$$Binding&quot;;</span><br><span class="line"></span><br><span class="line">            Binding binding = element.getAnnotation(Binding.class);</span><br><span class="line">            try &#123;</span><br><span class="line">                JavaFileObject javaFileObject = filer.createSourceFile(packageName + &apos;.&apos; + findClassName, element.getEnclosingElement());</span><br><span class="line">                Writer writer = javaFileObject.openWriter();</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                sb.append(&quot;package &quot;).append(packageName).append(&quot;;\n\n&quot;);</span><br><span class="line">                sb.append(&quot;public class &quot;).append(findClassName).append(&quot;&#123;\n&quot;);</span><br><span class="line">                sb.append(&quot;public String findTargetRouter()&#123;\n&quot;);</span><br><span class="line">//                sb.append(&quot;return &quot; + binding.router().toString()).append(&quot;;\n&quot;);</span><br><span class="line">                sb.append(&quot;return \&quot;test\&quot;;\n&quot;);</span><br><span class="line">                sb.append(&quot;&#125;\n&quot;);</span><br><span class="line">                sb.append(&quot;&#125;\n&quot;);</span><br><span class="line">                writer.write(sb.toString());</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + findClassName + &quot;类失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;APT&quot;&gt;&lt;a href=&quot;#APT&quot; class=&quot;headerlink&quot; title=&quot;APT&quot;&gt;&lt;/a&gt;APT&lt;/h1&gt;&lt;p&gt;APT(Annotation Processing Tool) 是一种处理注释的工具，它对源代码文件进行检测找出&lt;br&gt;其中的Ann
      
    
    </summary>
    
    
      <category term="andorid" scheme="hexo/tags/andorid/"/>
    
  </entry>
  
  <entry>
    <title>android 性能优化</title>
    <link href="hexo/blog/2020/11/android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"/>
    <id>hexo/blog/2020/11/android-性能优化.html</id>
    <published>2020-11-04T05:56:47.000Z</published>
    <updated>2020-11-06T10:13:20.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android性能优化"><a href="#android性能优化" class="headerlink" title="android性能优化"></a>android性能优化</h1><p>性能优化分为几个方向：</p><ul><li>内存优化</li><li>电量优化</li><li>渲染优化</li><li>size大小优化</li><li>异常捕获</li></ul><h2 id="apk瘦身"><a href="#apk瘦身" class="headerlink" title="apk瘦身"></a>apk瘦身</h2><p>针对与apk大小优化而言，<br>首先需要知道apk中主要结构，了解其中是哪些部分比较大。<br>然后来针对性优化。</p><p>一般而言比较占用的是：资源文件、架构文件(.so)</p><h3 id="资源文件优化"><a href="#资源文件优化" class="headerlink" title="资源文件优化"></a>资源文件优化</h3><p>针对资源文件，首先我们去除没有被使用的资源，然后就是降低所用资源的大小。</p><p>在app/build.gradle文件中设置shrinkResources true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">        shrinkResources true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>则会在Gradle打包release apk时，自动忽略未使用的资源文件，包括：图片、xml</p><p>但要注意此时也会忽略隐式调用的资源文件，如通过反射调用，或者react-native中在js调用drawable木土图片，<br>在这两种场景时，都会被忽略。<br>针对这种场景，可以通过keep文件，保持这些资源文件不会被忽略。</p><p>在res目录下新建xml目录，在xml目录下新建文件keep.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources</span><br><span class="line">xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">tools:keep=&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;</span><br><span class="line">tools:discard=&quot;@layout/unused2&quot; /&gt;</span><br></pre></td></tr></table></figure><p>其中tools:keep是强制不忽略，tools:discard是强制忽略</p><p>上面讲述的是去除无用资源，还有我们可以去除无用的代码，如未被调用的函数，未被使用的变量</p><p>minifyEnabled设置为true，设置在与shrinkResources一起的地方。<br>注意shrinkResources需要与minifyEnabled一起使用才会生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">        shrinkResources true</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="针对架构-so优化"><a href="#针对架构-so优化" class="headerlink" title="针对架构.so优化"></a>针对架构.so优化</h3><p>在大型项目，特别时继承第三方过多时，此时.so文件才是占用最多的部分。</p><h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>开发时怕的不是出现问题，而是问题无法重现。<br>因为android碎片化严重 生产上的问题肯定要比开发时问题多。而且很多都是在开发端未必能重现的。<br>此时需要我们记录发生在用户手机上的异常。</p><p>针对异常可以分类，java异常、native异常。<br>native异常即是native函数c++代码异常</p><h3 id="java异常捕获"><a href="#java异常捕获" class="headerlink" title="java异常捕获"></a>java异常捕获</h3><p>在andorid app中捕获java异常，只需要实现Thread.UncaughtExceptionHandler</p><h3 id="native异常"><a href="#native异常" class="headerlink" title="native异常"></a>native异常</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android性能优化&quot;&gt;&lt;a href=&quot;#android性能优化&quot; class=&quot;headerlink&quot; title=&quot;android性能优化&quot;&gt;&lt;/a&gt;android性能优化&lt;/h1&gt;&lt;p&gt;性能优化分为几个方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存优化&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>线程与进程</title>
    <link href="hexo/blog/2020/10/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.html"/>
    <id>hexo/blog/2020/10/线程与进程.html</id>
    <published>2020-10-29T02:35:27.000Z</published>
    <updated>2020-10-29T03:16:36.830Z</updated>
    
    <content type="html"><![CDATA[<p>进程是操作系统资源分配的基本单位，</p><p>线程是处理器（CPU）任务调度和执行的基本单位<br>线程依赖于进程，一个进程可能对应多个线程。</p><p>并发与并行</p><p>1、并发（Concurrent）：指两个或多个事件在同一时间间隔内发生，即交替做不同事的能力，多线程是并发的一种形式。例如垃圾回收时，用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p><p>2、并行（Parallel）：指两个或者多个事件在同一时刻发生，即同时做不同事的能力。例如垃圾回收时，多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>同时能处理的最大线程数取决于CPU内核数量，<br>有些机器还有逻辑处理器，</p><p>能同时处理任务的线程最大数量为CPU内核与逻辑处理器的较大值。</p><p>如内核：4，逻辑处理器：8<br>那么CPU正在能同时处理的任务数量为8。</p><p>但为何我们写代码的时候，设置多线程运行时为何感觉可以同时设置很多个线程数量呢。</p><p>这个就跟CPU的时间轮转片调度算法有关了</p><p>在早期的时间片轮转法中,系统将所有的就绪进程按先来先服务的原则,排成一个队列,每次调度时,把CPU分配给队首进程,并令其执行一个时间片.时间片的大小从几ms到几百ms.当执行的时间片用完时,由一个计时器发出时钟中断请求,调度程序便据此信号来停止该进程的执行,并将它送往就绪队列的末尾;然后,再把处理机分配给就绪队列中新的队首进程,同时也让它执行一个时间片.这样就可以保证就绪队列中的所有进程,在一给定的时间内,均能获得一时间片的处理机执行时间.</p><p>所以我们在多线程运行时，超过内核数量的线程任务在执行时，其实是在切换运行的。<br>只是因为CPU的时间片粒度很小，所以在切换时，很多都是无感的</p><p>java中的程序天生的多线程的，启动线程有两种方式。</p><ul><li><p>继承Thread类</p></li><li><p>实现Runnable接口 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args) &#123;</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        MyThread2 thread2 = new MyThread2();</span><br><span class="line">        new Thread(thread2).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            System.out.println(&quot;extends Thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class MyThread2 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;implements Runnable&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程是操作系统资源分配的基本单位，&lt;/p&gt;
&lt;p&gt;线程是处理器（CPU）任务调度和执行的基本单位&lt;br&gt;线程依赖于进程，一个进程可能对应多个线程。&lt;/p&gt;
&lt;p&gt;并发与并行&lt;/p&gt;
&lt;p&gt;1、并发（Concurrent）：指两个或多个事件在同一时间间隔内发生，即交替做不同事
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android 8.0屏幕朝向</title>
    <link href="hexo/blog/2020/10/android-8-0%E5%B1%8F%E5%B9%95%E6%9C%9D%E5%90%91.html"/>
    <id>hexo/blog/2020/10/android-8-0屏幕朝向.html</id>
    <published>2020-10-28T07:08:43.000Z</published>
    <updated>2020-10-28T08:38:44.140Z</updated>
    
    <content type="html"><![CDATA[<p>在android8.0设备发现一个问题，在androidManifest.xml中已配置了固定的屏幕方向，<br>但是在应用中，点击设备menu键，选择应用时，此时应用仍然可以旋转。</p><p>在MainActivity中通过代码设置 setRequestedOrientation时会报错：Only fullscreen activities can request orientation</p><p>原因是在android8.0 的Activity.java 的代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line"></span><br><span class="line">       if (getApplicationInfo().targetSdkVersion &gt;= O &amp;&amp; mActivityInfo.isFixedOrientation()) &#123;</span><br><span class="line">           final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window);</span><br><span class="line">           final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta);</span><br><span class="line">           ta.recycle();</span><br><span class="line"></span><br><span class="line">           if (isTranslucentOrFloating) &#123;</span><br><span class="line">               throw new IllegalStateException(</span><br><span class="line">                       &quot;Only fullscreen opaque activities can request orientation&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果sdk版本&gt;O &amp;&amp; 当前Activity的屏幕方向固定时，<br>判断当前主题样式，如果包含透明样式，则会抛出该异常。</p><p>很明显这段代码存在问题，sdk&gt;=O其实就是android8.0(26)及以上。<br>而后面两个要求，固定屏幕方向在特定应用时很常见的，而透明样式页比较常见，<br>我们常用透明背景做一个简单的启动优化，避免其他样式导致的闪屏现象。</p><p>而这段代码也在8.0之后的版本修复，但是现在市面存在的手机在andorid8.0的时候基本都存在该问题。</p><p>修复方式时只能去除透明背景，但为了修复26存在的问题，修改应用整个的表现有些得不偿失。</p><p>所以我们可以针对特定版本修改资源。</p><p>首先去掉AndroidManifest.xml中的 android:screenOrientation 配置，</p><p>在res新增values-v26文件夹，这样在sdk26的手机就会在这个文件夹下寻找对应的资源，如果没有才会有主目录values中去找。</p><p>在values-v26中修改styles.xml，去掉此处的透明背景。</p><p>再在代码中调用setRequestedOrientation来固定屏幕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line"></span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时则不会再报错，<br>也不存在之前所说的点击menu键，回到应用会旋转问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在android8.0设备发现一个问题，在androidManifest.xml中已配置了固定的屏幕方向，&lt;br&gt;但是在应用中，点击设备menu键，选择应用时，此时应用仍然可以旋转。&lt;/p&gt;
&lt;p&gt;在MainActivity中通过代码设置 setRequestedOrien
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android内存优化</title>
    <link href="hexo/blog/2020/10/android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html"/>
    <id>hexo/blog/2020/10/android内存优化.html</id>
    <published>2020-10-21T02:08:26.000Z</published>
    <updated>2020-10-21T06:57:09.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><p>内存检测工具 MAT<br>android studio profile</p><p>内存抖动<br>内存泄漏<br>内存溢出</p><p>JMM 内存结果模型</p><p>GC算法</p><p>对象的生命周期：内存分配初始化、不可见、不可达、收集、终结、内存重新分配</p><p>四种引用类型</p><p>incomegoing: 持有该对象的对象<br>outgoing: 该对象持有的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    C c = new C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    C c = new C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">    public C() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    C instance = new C()</span><br><span class="line">    public C getInstance() &#123;</span><br><span class="line">        return c</span><br><span class="line">    &#125;</span><br><span class="line">    D d = new D()</span><br><span class="line">    E e = new E()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 的incomegoing为 A、B、C<br>C 的outgoing为 C、D、E</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存优化&quot;&gt;&lt;a href=&quot;#内存优化&quot; class=&quot;headerlink&quot; title=&quot;内存优化&quot;&gt;&lt;/a&gt;内存优化&lt;/h1&gt;&lt;p&gt;内存检测工具 MAT&lt;br&gt;android studio profile&lt;/p&gt;
&lt;p&gt;内存抖动&lt;br&gt;内存泄漏&lt;br&gt;内存
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ContentProvider</title>
    <link href="hexo/blog/2020/10/ContentProvider.html"/>
    <id>hexo/blog/2020/10/ContentProvider.html</id>
    <published>2020-10-16T01:44:40.000Z</published>
    <updated>2020-10-16T01:51:56.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>ContentProvider 内容提供者 是android四大组件之一，为不同应用、进程之间数据共享，制定统一的接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ContentProvider&quot;&gt;&lt;a href=&quot;#ContentProvider&quot; class=&quot;headerlink&quot; title=&quot;ContentProvider&quot;&gt;&lt;/a&gt;ContentProvider&lt;/h1&gt;&lt;p&gt;ContentProvider 内容
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Service、IntentService</title>
    <link href="hexo/blog/2020/10/Service%E3%80%81IntentService.html"/>
    <id>hexo/blog/2020/10/Service、IntentService.html</id>
    <published>2020-10-09T07:06:04.000Z</published>
    <updated>2020-10-15T09:34:09.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service、IntentService"><a href="#Service、IntentService" class="headerlink" title="Service、IntentService"></a>Service、IntentService</h1><p>Service是android中四大组件之一，用于处理后台任务，不能处理耗时任务，否则会造成ANR<br>而IntentService继承自Service，但是可以处理耗时任务，因为在内部开启了一个子线程。</p><h2 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h2><p>Service的生命周期分为两种情形，一种是通过startService启动，另一种是通过bindService启动。<br>在这两种情况下时，Service的生命周期是有差异的。</p><h3 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h3><p>通过startService去启动一个Service，<br>如果该Service未被创建，则会走onCreate、onStartCommand、onStart生命周期<br>如果该Service已被创建，则不会执行onCreate，只会执行onStartCommand、onStart</p><p>onStart为正常运行时的生命周期</p><p>而且startService可以被多次调用<br>被重复调用后会执行下面的生命周期</p><p>通过startService启动的Service存活不依赖与Activity，即使启动该Service的Activity已经被销毁，但该Service仍然可以存活。<br>通过startService启动的Service需要调用stopService来销毁该Service,此时会执行onDestroy周期函数</p><h3 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h3><p>bindService时，Service是依赖Activity的，当当前Activity被销毁、或者调用unBindService时，Service都会被销毁。</p><p>所以每一次调用bindService时，Service都会被重新创建<br>所以通过bindService去启动一个Service，<br>会走onCreate、onBind生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ServiceConnect() : ServiceConnection &#123;</span><br><span class="line">    override fun onServiceDisconnected(name: ComponentName?) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onServiceDisconnected: &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onServiceConnected(name: ComponentName?, service: IBinder?) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onServiceConnected: &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn_bindService.setOnClickListener &#123;</span><br><span class="line">    var conn = ServiceConnect()</span><br><span class="line">    bindService(Intent(this, MyService::class.java), conn, Context.BIND_AUTO_CREATE)</span><br><span class="line">    hasBind = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行到onBind时，还会执行onServiceConnected</p><p>在Service中，不能执行耗时操作，超过5秒，则会造成程序不响应ANR<br>当我们需要执行耗时操作时，则必须开启子线程，或者使用IntentService</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService有与Service一样的生命周期，<br>只是在内部开启了一个子线程，暴露onHandleIntent来执行耗时任务，<br>当子线程执行完就会终止当前Service</p><p>IntentService中的部分源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">    public ServiceHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Servicehandler是IntentService的一个内部类，当收到消息时调用onHandleIntent,当执行完，则调用stopSelf，终止当前服务</p><p>在OnCreate中，新建了一个HandleThread，并运行。<br>创建一个Servicehandler，而该ServiceHandler的Looper对象为HandleThread线程中创建的，</p><p>当执行到onStart生命周期时，<br>handler发送一条消息，此时就会走到ServiceHandler中的handlerMessage中，也就会执行onHandleIntent中。<br>因为mServiceLooper = thread.getLooper();<br>所以onHandleIntent是运行在HandlerThread中的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Service、IntentService&quot;&gt;&lt;a href=&quot;#Service、IntentService&quot; class=&quot;headerlink&quot; title=&quot;Service、IntentService&quot;&gt;&lt;/a&gt;Service、IntentService&lt;/
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment的懒加载实现，参数传递与保存</title>
    <link href="hexo/blog/2020/09/Fragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%9D%E5%AD%98.html"/>
    <id>hexo/blog/2020/09/Fragment的懒加载实现，参数传递与保存.html</id>
    <published>2020-09-28T08:07:59.000Z</published>
    <updated>2020-09-28T08:54:03.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h1><p>关于Fragment的懒加载，针对ViewPager、ViewPager2又有不同，</p><h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>针对ViewPager，其实是使用Fragment中的setUserVisibleHint函数以及onHiddenChanged函数，通过getUserVisibleHint()获取当前的Fragment是否可见，<br>当不可见时，则不加载，当可见时再创建视图并缓存。<br>这样可以只加载一次，大致原理就是如此。</p><h2 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h2><p>ViewPager是androidX下的包，之前使用的setUserVisibleHint、getUserVisibleHint等都已被申明遗弃，<br>而在ViewPager2时通过FragmentTransaction.setMaxLifecycle() 来实现懒加载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fragment懒加载&quot;&gt;&lt;a href=&quot;#Fragment懒加载&quot; class=&quot;headerlink&quot; title=&quot;Fragment懒加载&quot;&gt;&lt;/a&gt;Fragment懒加载&lt;/h1&gt;&lt;p&gt;关于Fragment的懒加载，针对ViewPager、ViewPag
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Application生命周期</title>
    <link href="hexo/blog/2020/09/Application%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>hexo/blog/2020/09/Application生命周期.html</id>
    <published>2020-09-28T06:44:45.000Z</published>
    <updated>2020-09-28T07:57:42.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><p>Application是指代一个应用，默认我们在android应用中可以不指定，<br>也可以写一个类，继承Application，在AndroidManifest.xml中指定applictaion类即可</p><p>Application是应用的入口。</p><p>Application的生命周期就是应用的生命周期。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期函数有：<br>onCreate、onLowMemory、onTrimMemory、onTerminate、onConfigurationChanged</p><p>各个生命周期函数解释</p><ul><li>onCreate: 应用被创建时调用，是程序的主入口，在此处做一些初始化操作，不要做耗时操作。</li><li>onLowMemory： 当系统整体内存可用量较少时触发，可以在这里做一些不重要数据的清除、释放资源，避免因内存不足导致App被系统杀掉</li><li>onTrimMemory(int level)： andorid4.0后出的API，用来取代onLowMemory函数的，其中这个函数还有一个入参，来表示等级。</li><li>onTerminate： 当Application结束时，又系统决定调用时机。常规手动kill app进程没有触发此函数</li></ul><h3 id="onTrimMemory"><a href="#onTrimMemory" class="headerlink" title="onTrimMemory"></a>onTrimMemory</h3><p>此函数是在android4.0后引入的，能实现的组件不止Application，还有Activity、Fragment、Service、ContentProvider<br>作用是指导应用程序在不同情况下进行自身的内存释放，以避免被系统杀掉，提高用户体验</p><p>根据不同的情况，在函数中的提现就是 onTrimMemory函数中的 level这个入参。<br>level有7个值，</p><ul><li>TRIM_MEMORY_UI_HIDDEN：表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键、Pause键导致应用的UI界面不可见．这时候应该释放一些资源．</li></ul><p>当app运行在前台时，会回调下面这三个值，内存余量从高到低排列</p><ul><li><p>TRIM_MEMORY_MODERATE：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。</p></li><li><p>TRIM_MEMORY_RUNNING_CRITICAL：表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。<br>这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</p></li><li><p>TRIM_MEMORY_RUNNING_LOW：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，<br>同时这也会直接影响到我们应用程序的性能。</p></li></ul><p>当app缓存在后台时，会回调一下三个值，内存余量从高到低排列</p><ul><li><p>TRIM_MEMORY_BACKGROUND：表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，<br>是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，<br>这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。</p></li><li><p>TRIM_MEMORY_RUNNING_MODERATE： 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。</p></li><li><p>TRIM_MEMORY_COMPLETE：表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，<br>在这个时候应当尽可能地把一切可以释放的东西都进行释放。</p></li></ul><p>onTrimMemory 主要是在考虑内存优化时需要考虑。在此处做数据清除、资源释放</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Application&quot;&gt;&lt;a href=&quot;#Application&quot; class=&quot;headerlink&quot; title=&quot;Application&quot;&gt;&lt;/a&gt;Application&lt;/h1&gt;&lt;p&gt;Application是指代一个应用，默认我们在android应用中
      
    
    </summary>
    
    
      <category term="andorid" scheme="hexo/tags/andorid/"/>
    
  </entry>
  
  <entry>
    <title>Activity的启动模式</title>
    <link href="hexo/blog/2020/09/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>hexo/blog/2020/09/Activity的启动模式.html</id>
    <published>2020-09-25T07:59:03.000Z</published>
    <updated>2020-09-28T06:32:10.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h1><p>首先，Activity有四大启动模式：<br>standard、singleTask、singleTop、singleInstance</p><p>如何设置Activity的启动模式：</p><ul><li><p>静态设置，在AndoridManifest.xml文件中，对Activity设置launchMode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.MainActivity3&quot;</span><br><span class="line">    android:launchMode=&quot;singleInstance&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态设置，在Activity跳转时，intent设置FLAG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var intent = Intent(this, MainActivity::class.java);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure></li></ul><p>并且注意，同时设置了两种方式时，动态设置会覆盖静态设置</p><h2 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard: 标准模式，默认模式，当设置为此模式时，每一次跳入都会重新创建实例</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>singleTask: 栈内复用模式，当设置此模式时，如果栈内没有该Activity就会重新创建，如果已经有了，则会复用栈内已存在的该Activity，而不会重新创建，<br>并会移除之前在栈中处于该Activity上部的所有的Activity。<br>ex：A的启动模式是standard， B的启动模式为singleTask</p><p>A -&gt; B -&gt; A -&gt; B</p><p>A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以不会重新创建b的实例，而是复用之前B的实例，同时会调用onNewIntent生命周期函数，<br>而且会销毁之前处于栈顶的A。<br>最后栈内就是： A、B，B位于栈顶</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop：栈顶复用，与singleTask有部分相似，singleTask是只要在栈内就会复用，而singleTop是只有在栈顶才会复用，<br>如果栈内存在实例，但不处于栈顶，则表现与standard一致，<br>如果站内存在实例，且处于栈顶，则表现与singleTask一致，</p><p>ex：A的启动模式是standard、B的启动模式是singleTop<br>A -&gt; B -&gt; A -&gt; B<br>A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，但之前的B不在栈顶，所以会重新创建一个B的实例</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>singleInstance: 独立运行在一个单独的task中，而且只会存在一个实例<br>在Activity跳转时，注意查看，普通的Activity跳转和Activity Task跳转，两者的动画效果是不同的。</p><p>ex: A的启动模式是standard、B的启动模式是singleInstance<br>A -&gt; B -&gt; A -&gt; B<br>A -&gt; B 时，因为当前Activity栈task A中只有A，会重新创建一个task B并新建一个B的实例放入task B<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例，并放入到task A中<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以会将task B置顶，<br>最后的栈情况为： A -&gt; A -&gt; B，如下图所示：</p><p><img src="../images/activity_stack.png" alt="activity-stack"></p><p>我们可以通过指令：adb shell dumpsys activity<br>查看Activity栈中的Activity task情况</p><p>通过关键字：ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)<br>即可搜索到上述截图情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Activity启动模式&quot;&gt;&lt;a href=&quot;#Activity启动模式&quot; class=&quot;headerlink&quot; title=&quot;Activity启动模式&quot;&gt;&lt;/a&gt;Activity启动模式&lt;/h1&gt;&lt;p&gt;首先，Activity有四大启动模式：&lt;br&gt;standar
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android生命周期</title>
    <link href="hexo/blog/2020/09/android%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>hexo/blog/2020/09/android生命周期.html</id>
    <published>2020-09-24T06:29:33.000Z</published>
    <updated>2020-09-28T08:02:40.768Z</updated>
    
    <content type="html"><![CDATA[<p>准备对andorid基础性的东西都进行整理，梳理一下。</p><h1 id="android的生命周期"><a href="#android的生命周期" class="headerlink" title="android的生命周期"></a>android的生命周期</h1><p>单个Actiivty正常的生命周期</p><p>onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory</p><p>这就是一个Activity从被创建到被销毁过程。</p><p>其中正常运行状态为onResume</p><p>当Activity从前台被置于后台，<br>onResume -&gt; onPause -&gt; onStop</p><p>当从后台重新置于前台<br>onStop -&gt; onPause -&gt; onResatrt -&gt; onStart-&gt; onResume</p><p>其中可以发现，只要Activity置于前台都会执行onStart函数，所以我们可以考虑在这里做一下需要在前台就处理的逻辑</p><p>各个生命周期函数：<br>onCreate: Activity被创建，此时Activity处于不可见、不可交互<br>onStart: 此时Activity 部分可见不可交互<br>onRestart: Activity从后台重新回到前台，部分可见不可交互<br>onResume: 完全可见可交互，为Activity正常运行状态<br>onPause: Activity处于暂停，从前台被置于后台 部分可见部分不可见，不可交互<br>onStop: 完全置于后台，完全不可见，<br>onDestroy: Activity被销毁</p><p>上面就是一个正常的Activity的生命周期，</p><h2 id="屏幕旋转"><a href="#屏幕旋转" class="headerlink" title="屏幕旋转"></a>屏幕旋转</h2><p>在Activity生命周期中，还设计一些其他：<br>Activity旋转：<br>onCreate -&gt; onStart -&gt; onResume<br>此时被旋转<br>-&gt; onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p><p>可以发现当Activity被旋转时，整个Activity是被销毁然后重新创建的。其中新增调用了两个生命周期函数<br>onSaveInstanceState: 当Activity被系统异常销毁时被调用，用于存储数据，用于系统恢复Activity时恢复数据<br>onRestoreInstanceState: 当Actiivty被系统异常销毁并重新创建时，取出在onSaveInstanceState时存储的数据</p><p>注意，在onCreate函数中，其实也是有参数的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, &quot;onCreate: &quot;)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此处的savedInstanceState也是在onSaveInstanceState时存储的数据，但此处可能为nll，<br>因为在正常的Activity时，此处就是null，只有在Activity被异常销毁然后被系统重新创建时，此处才有值。<br>如果要在此处使用，切记要判空。</p><h2 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h2><p>onNewIntent与Activity的启动模式有关</p><p>当Activity未设置启动模式时，则不会触发该生命周期函数</p><p>当Activity已经处于应用的Activity栈中</p><ul><li>如果Actiivty的LaunchMode为Standard时，即默认模式，此时不会触发该生命周期函数。</li><li>如果Activity的LaunchMode为SignleTop，如果ActivityA已经处于栈顶，再通过StartActivityForResult调用该Activity，<br>此时会触发的生命周期函数为： onPause -&gt; onNewIntent -&gt; onResume</li><li>如果Activity的LainchMode为SingleInstance,SingleTask时，并且ActivityA已经处于Activity栈中，再次通过StartActivityForResult调用该Activity，此时生命周期函数：onNewIntent—&gt;onRestart—&gt;onStart—&gt;onResume</li></ul><p>onNewIntent只会在Activity设置了启动模式，并且Activity被复用时才会调起。</p><p>注意：只对startActivityForResult调起的Activity起作用，statActivity本质调用的也是startActivityForResult，Activity正常的切换前后台时不会触发的。</p><h2 id="Activity交互"><a href="#Activity交互" class="headerlink" title="Activity交互"></a>Activity交互</h2><p>A -&gt; B:<br>A正常运行处于 onResume，打开B</p><p>A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop<br>点击跳入B页面， 首先A进入暂停，B开始创建，到onResume完全可见可交互，于是A被完全遮挡，变成完全不可见、处于后台，进入onStop</p><p>A -&gt; B -&gt;goBack-&gt; A</p><p>在B页再执行返回</p><p>B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B Stop -&gt; B onDestory<br>和A进入B类似，B返回A时，B进入暂停，A变得重新可见到A完全可见，进入onResume，然后B进入停止，并销毁</p><p>B启动模式设置为 SingleTop，B -&gt; B<br>B onPause -&gt; B onNewIntent -&gt; B onResume<br>因为 B已经处于栈顶，启动模式为 SingleTop 则不会重新创建B的实例</p><p>将A的启动模式设置为SingleTask</p><p>可以通过在andorid studio的终端 Terminal中输入：adb shell dumpsys activity<br>查看当前应用的Activity task栈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备对andorid基础性的东西都进行整理，梳理一下。&lt;/p&gt;
&lt;h1 id=&quot;android的生命周期&quot;&gt;&lt;a href=&quot;#android的生命周期&quot; class=&quot;headerlink&quot; title=&quot;android的生命周期&quot;&gt;&lt;/a&gt;android的生命周期&lt;/h
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>react-native 适配androidX</title>
    <link href="hexo/blog/2020/09/react-native-%E9%80%82%E9%85%8DandroidX.html"/>
    <id>hexo/blog/2020/09/react-native-适配androidX.html</id>
    <published>2020-09-15T01:15:50.000Z</published>
    <updated>2020-09-16T01:20:26.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="androidX"><a href="#androidX" class="headerlink" title="androidX"></a>androidX</h1><p>在API28后，android新增androidX依赖，用于解决以前的android.support.v*依赖混乱问题。<br>对v1-v9做了合并处理。</p><p>然后很多使用的第三方依赖中在新版本都适配了androidX，当你需要使用这些插件的较新版本时，只能去适配androidX。</p><p>最近使用react-native-firebase时，被提示必须使用17.0.0+的 Firebase Crashlytics SDK，否则2020年11月15日之后，将不再向firebase发送错误日志。</p><h2 id="适配androidX"><a href="#适配androidX" class="headerlink" title="适配androidX"></a>适配androidX</h2><p>点击andorid studio上方导航栏Refactor/Migrate to AndroidX<br>这时会提示你，gradle tool version 最低3.2.0<br>项目中每一个project的build.gradle都需要修改</p><p>classpath(“com.android.tools.build:gradle:3.2.0”)<br>其中3.2.0为最低版本。</p><p>注意，选择的版本可能maven仓库找不到。<br>如在第三方插件中，设置的maven仓库可能不存在该版本。<br>如： 我使用的是版本：3.4.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:3.4.0&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时会报错，404，找不到。<br>因为在jcenter远程仓库中不存在该版本。</p><p>3.4.0的版本只有google的maven仓库中有，所以需要修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>查看maven插件地址：<a href="https://maven.aliyun.com/mvn/search" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/search</a></p><p>同时需要修改每个project的targetSdkVersion</p><p>将所有project的版本都修改为3.4.0之后，在点即Migrate to AndroidX,<br>此时会提示你需要修改的地方，</p><ul><li>java文件，去除一些v*的引入</li><li>build.gradle 去除一些v*的依赖</li><li>manifest.xml 需要修改一些属性，如配置的FileProvider,修改name属性<br><code>android:name=&quot;androidx.core.content.FileProvider&quot;</code></li></ul><p>修改完后，无报错时直接运行。</p><p>会有一些java文件报错，就是引入的之前的v*的包，需要手动修改，哪里报错改哪里。</p><p>最后运行，运行成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;androidX&quot;&gt;&lt;a href=&quot;#androidX&quot; class=&quot;headerlink&quot; title=&quot;androidX&quot;&gt;&lt;/a&gt;androidX&lt;/h1&gt;&lt;p&gt;在API28后，android新增androidX依赖，用于解决以前的android.sup
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2020/09/java-%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8Eclass.html"/>
    <id>hexo/blog/2020/09/java-反射基本概念与class.html</id>
    <published>2020-09-10T01:26:24.085Z</published>
    <updated>2020-09-10T03:51:39.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 *</li></ul><p>类名    用途<br>Class类    代表类的实体，在运行的Java应用程序中表示类和接口<br>Field类    代表类的成员变量（成员变量也称为类的属性）<br>Method类    代表类的方法<br>Constructor类    代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法    用途<br>asSubclass(Class<u> clazz)    把传递的类的对象转换成代表其子类的对象<br>Cast    把对象转换成代表类或是接口的对象<br>getClassLoader()    获得类的加载器<br>getClasses()    返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses()    返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className)    根据类名返回类的对象<br>getName()    获得类的完整路径名字<br>newInstance()    创建类的实例<br>getPackage()    获得类的包<br>getSimpleName()    获得类的名字<br>getSuperclass()    获得当前类继承的父类的名字<br>getInterfaces()    获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法    用途<br>getField(String name)    获得某个公有的属性对象<br>getFields()    获得所有公有的属性对象<br>getDeclaredField(String name)    获得某个属性对象<br>getDeclaredFields()    获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法    用途<br>getAnnotation(Class<a> annotationClass)    返回该类中与参数类型匹配的公有注解对象<br>getAnnotations()    返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass)    返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations()    返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法    用途<br>getConstructor(Class…&lt;?&gt; parameterTypes)    获得该类中与参数类型匹配的公有构造方法<br>getConstructors()    获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)    获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors()    获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法    用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes)    获得该类某个公有的方法<br>getMethods()    获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)    获得该类某个方法<br>getDeclaredMethods()    获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法    用途<br>isAnnotation()    如果是注解类型则返回true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)    如果是指定类型注解类型则返回true<br>isAnonymousClass()    如果是匿名类则返回true<br>isArray()    如果是一个数组类则返回true<br>isEnum()    如果是枚举类则返回true<br>isInstance(Object obj)    如果obj是该类的实例则返回true<br>isInterface()    如果是接口类则返回true<br>isLocalClass()    如果是局部类则返回true<br>isMemberClass()    如果是内部类则返回true</p><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p>Field代表类的成员变量（成员变量也称为类的属性）。</p><p>方法    用途<br>equals(Object obj)    属性与obj相等则返回true<br>get(Object obj)    获得obj中对应的属性值<br>set(Object obj, Object value)    设置obj中对应属性值</p><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p>Method代表类的方法。</p><p>方法    用途<br>invoke(Object obj, Object… args)    传递object对象及参数调用该对象对应的方法</p><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><p>Constructor代表类的构造方法。</p><p>方法    用途<br>newInstance(Object… initargs)    根据传递的参数创建类的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin 在android老项目中引入kotlin</title>
    <link href="hexo/blog/2020/09/kotlin-%E5%9C%A8android%E8%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5kotlin.html"/>
    <id>hexo/blog/2020/09/kotlin-在android老项目中引入kotlin.html</id>
    <published>2020-09-09T08:31:56.000Z</published>
    <updated>2020-11-16T06:17:22.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在android项目中引入kotlin"><a href="#在android项目中引入kotlin" class="headerlink" title="在android项目中引入kotlin"></a>在android项目中引入kotlin</h1><p>修改项目的build.gradle 文件中</p><p>buildscript {</p><pre><code>ext {    kotlin_version = &quot;1.3.10&quot;}dependencies {    classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;}</code></pre><p>}</p><p>在app/build.gradle中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &quot;com.android.application&quot;</span><br><span class="line">// 在顶行下添加</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br></pre></td></tr></table></figure><p>然后同步一下即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在android项目中引入kotlin&quot;&gt;&lt;a href=&quot;#在android项目中引入kotlin&quot; class=&quot;headerlink&quot; title=&quot;在android项目中引入kotlin&quot;&gt;&lt;/a&gt;在android项目中引入kotlin&lt;/h1&gt;&lt;p&gt;修改
      
    
    </summary>
    
    
      <category term="kotlin" scheme="hexo/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>google play 提交要求</title>
    <link href="hexo/blog/2020/09/google-play-%E6%8F%90%E4%BA%A4%E8%A6%81%E6%B1%82.html"/>
    <id>hexo/blog/2020/09/google-play-提交要求.html</id>
    <published>2020-09-09T03:27:05.000Z</published>
    <updated>2020-09-09T05:48:13.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-play-提交要求"><a href="#google-play-提交要求" class="headerlink" title="google play 提交要求"></a>google play 提交要求</h1><p>本文于2020/09/09日起记录在google play提交版本时，google play提出的提交要求</p><h2 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h2><p>在2020/08/05日，提交版本发现多了一个警告<br><img src="../images/google_targetSdkVersion.png" alt="google_targetSdkVersion.png"></p><p>新提交的应用在8月开始，必须设定targetSdkVersion为29或以上，<br>已存在的应用提交新版本时，必须设定targetSdkVersion为29或以上</p><h3 id="关于targetSdkVersion的原理"><a href="#关于targetSdkVersion的原理" class="headerlink" title="关于targetSdkVersion的原理"></a>关于targetSdkVersion的原理</h3><p>targetSdkVersion相当于在编写代码时设定一个假想的运行手机版本，打包后，再运行到真实设备。<br>最终的运行表现取决与targetSdkVersion与真实运行设备版本中的低值。</p><p>targetSdkVersion的预设就相当于预设一个代码运行环境，<br>我们所写的代码功能如果是只有部分版本才有的API，我们需要先判断真实的运行版本是否符合。<br>如在android6.0后引入权限请求，在每次请求权限时，我们需要判断SDK版本是否大于等于23.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void request() &#123;</span><br><span class="line">    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        requestPermissions(new String[]&#123;Manifest.permission.CAMERA&#125;, 101);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，是否需要判断版本其实和minSdkVersion也是有关的，如上面的代码，因为权限请求是23以后的，如果我们直接将minSdkVersion设置为23，则此时就不需要判断版本了，因为肯定是运行在23之后的手机，因为23以前的手机此时会无法安装该应用。</p><p>ex:<br>当我们设定targetSdkVersion=29，即android10，<br>而用户手机为API=23，即android6.0，<br>此时app的表现会是6.0。</p><p>当我们设定targetSdkVersion=23，即android6，<br>而用户手机为API=29，即android10，<br>此时app的表现也会是6.0。</p><h2 id="64位框架"><a href="#64位框架" class="headerlink" title="64位框架"></a>64位框架</h2><p>在去年时，google play要求提及的应用必须支持64位的框架，<br>也就是.so文件必须支持64位架构，<br>在提交审核的apk中，有armeabi-v7a则必须也要有arm64-v8a，如果有x86，则必须也要有x86_64。<br>react-native 原本只有armeabi-v7a，在之后的版本0.59.10中就开始内部源码中支持64位含有arm64-v8a下的.so文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;google-play-提交要求&quot;&gt;&lt;a href=&quot;#google-play-提交要求&quot; class=&quot;headerlink&quot; title=&quot;google play 提交要求&quot;&gt;&lt;/a&gt;google play 提交要求&lt;/h1&gt;&lt;p&gt;本文于2020/09/09日
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="hexo/blog/2020/09/git%E4%BD%BF%E7%94%A8.html"/>
    <id>hexo/blog/2020/09/git使用.html</id>
    <published>2020-09-08T03:11:56.000Z</published>
    <updated>2020-11-16T06:19:45.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>git是一款分布式代码版本控制工具</p><p>初始化使用：<br>当我们在gitlab、github初始化一个项目路径后，<br>需要将本地仓库的代码提交到新建好的远端仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;remoteurl&gt; // 链接远端仓库 &lt;remoteurl&gt;为远端仓库地址</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit info&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>git fetch 拉取代码<br>git merge 合并代码<br>git pull 拉取并合并代码<br>git push 将本地仓库的commit提交到远端仓库</p><p>git checkout <branchname> 切换分支<br>git checkout -b <branchname> 新建分支并切换</branchname></branchname></p><p>git branch -d <branchname> 删除分支 不能删除有未提交commit的分支<br>git branch -D <branchname> 强制删除分支</branchname></branchname></p><p>git push -u origin <branchname> 将本地分支推送到远端，如果远端没有此分支则会创建</branchname></p><p>git reset –hard <commitid> 代码回滚到某个commit commitId可以通过git log查看</commitid></p><p>git log 可以查看每一个的commit，显示的信息有 commit date，commit person，commitId，commit info</p><p>git merge A 将A分支合并到当前分支</p><p>git rebase A 将A分支合并并且将A分支节点置于当前分支之后</p><p>git mv <filename> <filename> 修改文件名，因为git默认忽略文件大小写，<br>如修改文件名 File.js 到 file.js此时是无法检测到更改，需要使用命令：<br>git mv File.js file.js</filename></filename></p><h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>在github中已修改默认分支为main 而不再是master</p><p>此时针对命令为<br>git init<br>git remote add origin <remoteurl> // 链接远端仓库 <remoteurl>为远端仓库地址<br>git branch -M main<br>git push -u origin main</remoteurl></remoteurl></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h1&gt;&lt;p&gt;git是一款分布式代码版本控制工具&lt;/p&gt;
&lt;p&gt;初始化使用：&lt;br&gt;当我们在gitlab、github初始化一个项目路径后，&lt;br
      
    
    </summary>
    
    
      <category term="git" scheme="hexo/tags/git/"/>
    
  </entry>
  
</feed>
