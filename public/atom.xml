<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2022-07-07T06:57:24.323Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP协议详解</title>
    <link href="hexo/blog/2022/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2022/07/TCP协议详解.html</id>
    <published>2022-07-07T02:51:44.000Z</published>
    <updated>2022-07-07T06:57:24.323Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址：<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">https://www.jianshu.com/p/65605622234b</a></p><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>Transmission Control Protocol，即 传输控制协议</p><blockquote><ul><li>属于 传输层通信协议</li><li>基于TCP的应用层协议有HTTP、SMTP、FTP、Telnet 和 POP3</li></ul></blockquote><p>位于TCP/IP协议体系结构中的第三层 传输层</p><h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><ul><li>面向连接<ul><li>使用TCP协议传输数据前，必须先建立TCP连接</li></ul></li><li>全双工通信<ul><li>通信双方都可以发送数据</li></ul></li><li>可靠<ul><li>不丢失、无差错、不重复、按序到达</li></ul></li><li>面向字节流<ul><li>一次传输的报文段有长度限制，可分块、分次传输</li></ul></li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h2><ul><li>优点： 可靠，不丢失</li><li>缺点： 效率低，因为每次使用都要建立连接</li></ul><h2 id="4-报文段格式"><a href="#4-报文段格式" class="headerlink" title="4.报文段格式"></a>4.报文段格式</h2><ul><li>TCP虽面向字节流，但传送的数据单元 = 报文段</li><li>报文段 = 首部 + 数据 2部分</li><li>TCP的全部功能体现在它首部中各字段的作用，故下面主要讲解TCP报文段的首部</li></ul><blockquote><p>首部前20个字符固定、后面有4n个字节是根据需而增加的选项<br>故 TCP首部最小长度 = 20字节</p></blockquote><p><img src="../../../images/tcp1.png" style="zoom:60%"><br><img src="../../../images/tcp2.png" style="zoom:60%"></p><h2 id="5-TCP连接建立过程"><a href="#5-TCP连接建立过程" class="headerlink" title="5.TCP连接建立过程"></a>5.TCP连接建立过程</h2><ul><li>TCP协议建立需要经过 三次握手<ul><li>第一次握手：客户端发送一个 <em> 连接请求 </em> 报文段到服务端，报文段中首部信息：SYN = 1， 并随机一个起始序号 x， seq = x；不携带数据， 客户端进入 SYN_SENT  状态</li><li>第二次握手：服务端接收到连接请求报文段，，也向客户端发送一个 <em> 连接确认 </em> 的报文段，报文段中首部信息：SYN = 1，ACK = 1，并随机一个起始序号 y， seq = y，确认号字段，ack = x + 1；不携带数据，服务端进入 SYN_RCVD 状态</li><li>第三次握手：客户端收到服务端发送的连接确认报文段，再向服务端发送一个 <em> 连接确认 </em> 的报文段，报文段首部信息：ACK = 1，seq = x + 1， ack = y + 1，因无SYN = 1，此报文段可携带数据.此时，客户端与服务端都进入ESTABLISHED状态</li></ul></li></ul><p><img src="../../../images/tcp3.png" style="zoom:60%"><br><img src="../../../images/tcp4.png" style="zoom:60%"></p><ul><li>成功进行TCP的三次握手后，就建立起一条TCP连接，即可传送应用层数据 * </li></ul><blockquote><ul><li>因 TCP提供的是全双工通信，故通信双方的应用进程在任何时候都能发送数据</li><li>三次握手期间，任何1次未收到对面的回复，则都会重发</li></ul></blockquote><h3 id="特别说明：为什么TCP建立连接需三次握手？"><a href="#特别说明：为什么TCP建立连接需三次握手？" class="headerlink" title="特别说明：为什么TCP建立连接需三次握手？"></a>特别说明：为什么TCP建立连接需三次握手？</h3><ul><li><p>answer:</p><ul><li>防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源</li></ul></li><li><p>具体描述<br><img src="../../../images/tcp5.png" style="zoom:60%"></p></li></ul><blockquote><p>SYN洪泛攻击：</p><p>从上可看出：服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时<br>这就使得服务器易于受到SYN洪泛攻击，即同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配 </p></blockquote><h2 id="6-释放连接过程"><a href="#6-释放连接过程" class="headerlink" title="6.释放连接过程"></a>6.释放连接过程</h2><p>在通信结束后，需要释放TCP连接，需经历四次挥手过程，才能断开连接</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>第一次挥手，客户端向服务端发送一个 <em> 释放连接 </em> 的报文段，报文段信息：FIN = 1，seq = u，客户端进入 FIN_WAIT_1 状态</li><li>第二次挥手，服务端收到客户端发送的释放连接的请求报文，想客户端发送一个 <em> 连接释放确认 </em> 报文段，报文段信息： ACK = 1，seq = v，ack = u + 1， 服务端进入 CLOSE_WAIT 状态。<br>此时，客户端 -&gt; 服务端的连接已断开，TCP连接处于半关闭状态</li><li>第三次挥手，服务端向客户端再发送一个 <em> 释放连接 </em> 的报文段，报文段信息：FIN= 1， ACK = 1，seq = w，ack = u + 1；服务端进入 LAST_ACK 状态</li><li>第四次挥手，客户端接收到服务端发送的释放连接报文，再向服务端发送一个 <em> 连接释放确认 </em> 报文段，报文段信息： ACK = 1，seq = u + 1，ack = w + 1。<br>此时客户端进入 TIME_WAIT 状态，服务端进入 CLOSED 状态，此时TCP还未断开，需经过时间等待计时器设置的时间2MSL后，客户端才进入 CLOSED 状态，即服务端比客户端先关闭</li></ul><p><img src="../../../images/tcp6.png" style="zoom:60%"><br><img src="../../../images/tcp7.png" style="zoom:60%"></p><h3 id="特别说明：为什么TCP释放连接需四次挥手？"><a href="#特别说明：为什么TCP释放连接需四次挥手？" class="headerlink" title="特别说明：为什么TCP释放连接需四次挥手？"></a>特别说明：为什么TCP释放连接需四次挥手？</h3><ul><li><p>结论</p><ul><li>为了保证通信双方都能通知对方 需释放 &amp; 断开连接<blockquote><p>即释放连接后，都无法接收 / 发送消息给对方</p></blockquote></li></ul></li><li><p>具体描述<br><img src="../../../images/tcp8.png" style="zoom:60%"></p></li></ul><blockquote><p>延伸疑问：为什么客户端关闭连接前要等待2MSL时间？</p><p>即 TIME - WAIT 状态的作用是什么；<br>MSL = 最长报文段寿命（Maximum Segment Lifetime）</p></blockquote><ul><li><p>原因1：为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接<br><img src="../../../images/tcp9.png" style="zoom:60%"></p></li><li><p>原因2：防止 上文提到的早已失效的连接请求报文 出现在本连接中客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失</p></li></ul><blockquote><p>即 在下1个新的连接中就不会出现早已失效的连接请求报文</p></blockquote><h2 id="7-无差错传输"><a href="#7-无差错传输" class="headerlink" title="7.无差错传输"></a>7.无差错传输</h2><ul><li>对比于UDP，TCP的传输是可靠的、无差错的</li><li>那么，为什么TCP的传输为什么是可靠的、无差错的呢？</li><li>下面，我将详细讲解TCP协议的无差错传输</li></ul><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>无差错：即 传输信道不出差错</li><li>发送 &amp; 接收效率匹配：即 无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据</li></ul><h3 id="基础：滑动窗口-协议"><a href="#基础：滑动窗口-协议" class="headerlink" title="基础：滑动窗口 协议"></a>基础：滑动窗口 协议</h3><ul><li>先理解2个基础概念：发送窗口、接收窗口<br><img src="../../../images/tcp10.png" style="zoom:60%"></li></ul><ul><li>工作原理<ul><li>对于发送端：<ul><li>1、每收到一个确认帧，发送窗口就向前滑动一个帧的距离</li><li>2、当发送窗口内无可发送的帧时（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送</li></ul></li></ul></li></ul><p>具体如下图：</p><p><img src="../../../images/tcp11.png" style="zoom:60%"></p><p>只有收到服务端发送的确认帧，才会继续发送数据帧，否则停止发送</p><ul><li>对于接收端：当收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</li></ul><p><img src="../../../images/tcp12.png" style="zoom:60%"></p><p>也就是说，只有确保当前的数据帧是准确位置窗口的，否则丢弃</p><ul><li>总的流程：<ul><li>1、客户端向服务端发送数据帧</li><li>2、服务端接收数据帧，并判断该数据帧是否属于当前接收窗口，如果不是，则丢弃该数据帧。如果是，则放入该接收窗口，并右移，然后向客户端发送确认帧</li><li>3、客户端接收到确认帧，并检查发出的数据帧是否都收到确认帧，如果没有，则等待接收确认帧。如果都收到确认帧，则又从第1步开始。</li></ul></li></ul><h3 id="滑动窗口-协议的重要特性"><a href="#滑动窗口-协议的重要特性" class="headerlink" title="滑动窗口 协议的重要特性"></a>滑动窗口 协议的重要特性</h3><ul><li>只有接收窗口向前滑动、接收方发送了确认帧时，发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动</li><li>停止-等待协议、后退N帧协议 &amp; 选择重传协议只是在发送窗口大小和接收窗口大小上有所差别：</li></ul><blockquote><p>停止等待协议：发送窗口大小=1，接收窗口大小=1；即 单帧滑动窗口 等于 停止-等待协议<br>后退N帧协议：发送窗口大小&gt;1，接收窗口大小=1。<br>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1。</p></blockquote><ul><li>当接收窗口的大小为1时，可保证帧有序接收。</li><li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意要与TCP的滑动窗口协议区别）</li></ul><h3 id="实现无差错传输的解决方案"><a href="#实现无差错传输的解决方案" class="headerlink" title="实现无差错传输的解决方案"></a>实现无差错传输的解决方案</h3><p>核心思想：采用一些可靠传输协议，使得 </p><ul><li>出现差错时，让发送方重传差错数据：即 出错重传</li><li>当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率：即 速度匹配</li></ul><p>针对上述2个问题，分别采用的解决方案是：自动重传协议 和 流量控制 &amp; 拥塞控制协议</p><p><strong> 解决方案1：自动重传请求协议ARQ（针对 出错重传） </strong></p><ul><li><p>定义</p><ul><li>即 Auto Repeat reQuest，具体介绍如下：<br><img src="../../../images/tcp13.png" style="zoom:60%"></li></ul></li><li><p>类型</p></li></ul><p><img src="../../../images/tcp14.png" style="zoom:60%"></p><p>下面，将主要讲解 上述3类协议</p><ul><li>类型1：停等式ARQ（Stop-and-Wait） * </li><li>原理：（单帧滑动窗口）停止 - 等待协议 + 超时重传</li></ul><blockquote><p>即 ：发送窗口大小=1、接收窗口大小=1</p></blockquote><ul><li>停止 - 等待协议的协议原理如下：</li></ul><blockquote><p>发送方每发送一帧，要等到接收方的应答信号后才能发送下一帧<br>接收方每接收一帧，都要反馈一个应答信号，表示可接下一帧<br>若接收方不反馈应答信号，则发送方必须一直等待</p></blockquote><ul><li><p>类型2：后退N帧协议 *<br>也称：连续ARQ协议</p></li><li><p>原理</p><ul><li>多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传</li></ul></li></ul><blockquote><p>即 ：发送窗口大小&gt;1、接收窗口大小=1</p></blockquote><ul><li>具体描述</li></ul><p>a. 发送方：采用多帧滑动窗口的原理，可连续发送多个数据帧 而不需等待对方确认<br>b. 接收方：采用 累计确认 &amp; 后退N帧的原理，只允许按顺序接收帧。具体原理如下：</p><p><img src="../../../images/tcp15.png" style="zoom:60%"></p><ul><li>示例讲解 *</li></ul><p>本示例 = 源站 向 目的站 发送数据帧。具体示例如下：<br><img src="../../../images/tcp16.png" style="zoom:60%"></p><ul><li><p>类型3：选择重传ARQ（Selective Repeat） *</p></li><li><p>原理</p><ul><li>多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传<blockquote><p>即 ：发送窗口大小&gt;1、接收窗口大小&gt;1</p></blockquote></li></ul></li></ul><p>类似于类型2（后退N帧协议），此处仅仅是接收窗口大小的区别，故此处不作过多描述</p><ul><li>特点<ul><li>a. 优：因连续发送数据帧而提高了信道的利用率</li><li>b. 缺：重传时又必须把原来已经传送正确的数据帧进行重传（仅因为这些数据帧前面有一个数据帧出了错），将导致传送效率降低</li></ul></li></ul><blockquote><p>由此可见，若信道传输质量很差，导致误码率较大时，后退N帧协议不一定优于停止-等待协议</p></blockquote><p><strong> 解决方案2：流量控制 &amp; 拥塞控制（针对 速度匹配） </strong></p><ul><li><p>措施1：流量控制 *</p></li><li><p>简介</p></li></ul><p><img src="../../../images/tcp17.png" style="zoom:60%"></p><ul><li><p>示例<br><img src="../../../images/tcp18.png" style="zoom:60%"></p></li><li><p>特别注意：死锁问题<br><img src="../../../images/tcp19.png" style="zoom:60%"></p></li><li><p>措施2：拥塞控制 *</p></li><li><p>定义</p><ul><li>防止过多的数据注入到网络中，使得网络中的路由器 &amp; 链路不致于过载<blockquote><p>拥塞：对网络中的资源需求 &gt; 该资源所能提供的部分</p></blockquote></li></ul></li><li><p>与 “流量控制”的区别</p></li></ul><p><img src="../../../images/tcp20.png" style="zoom:60%"></p><ul><li>具体解决方案<ul><li>共分为2个解决方案：慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复<blockquote><p>其中，涉及4种算法，即 慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复</p></blockquote></li></ul></li></ul><h4 id="解决方案1：慢开始-amp-拥塞避免"><a href="#解决方案1：慢开始-amp-拥塞避免" class="headerlink" title="解决方案1：慢开始 &amp; 拥塞避免"></a>解决方案1：慢开始 &amp; 拥塞避免</h4><h5 id="储备知识：拥塞窗口、慢开始算法、拥塞避免算法"><a href="#储备知识：拥塞窗口、慢开始算法、拥塞避免算法" class="headerlink" title="储备知识：拥塞窗口、慢开始算法、拥塞避免算法"></a>储备知识：拥塞窗口、慢开始算法、拥塞避免算法</h5><h6 id="a-拥塞窗口"><a href="#a-拥塞窗口" class="headerlink" title="a. 拥塞窗口"></a>a. 拥塞窗口</h6><ul><li>发送方维持一个状态变量：拥塞窗口（cwnd， congestion window ），具体介绍如下</li></ul><p><img src="../../../images/tcp21.png" style="zoom:60%"></p><h6 id="b-慢开始算法"><a href="#b-慢开始算法" class="headerlink" title="b. 慢开始算法"></a>b. 慢开始算法</h6><ul><li><p>原理</p><ul><li>当主机开始发送数据时，由小到大逐渐增大 拥塞窗口数值（即 发送窗口数值），从而<em> 由小到大 </em>逐渐增大发送报文段</li></ul></li><li><p>目的</p><ul><li>开始传输时，试探网络的拥塞情况</li></ul></li><li><p>具体措施</p></li></ul><p><img src="../../../images/tcp22.png" style="zoom:60%"></p><ul><li>示意图</li></ul><p><img src="../../../images/tcp23.png" style="zoom:60%"></p><ul><li>特别注意<ul><li>慢开始的“慢”指：一开始发送报文段时拥塞窗口（cwnd）设置得较小（为1），使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况）</li></ul></li></ul><blockquote><p>并不是指拥塞窗口（cwnd）的增长速率慢</p></blockquote><h6 id="c-拥塞避免-算法"><a href="#c-拥塞避免-算法" class="headerlink" title="c. 拥塞避免 算法"></a>c. 拥塞避免 算法</h6><ul><li>原理<ul><li>使得拥塞窗口（cwnd）按线性规律 缓慢增长：每经过一个往返时间RTT，发送方的拥塞窗口（cwnd）加1</li></ul></li></ul><blockquote><p>拥塞避免 并不可避免拥塞，只是将拥塞窗口按现行规律缓慢增长，使得网络比较不容易出现拥塞<br>相比慢开始算法的加倍，拥塞窗口增长速率缓慢得多</p></blockquote><ul><li>示意图</li></ul><p><img src="../../../images/tcp24.png" style="zoom:60%"></p><h5 id="解决方案1描述（慢开始-amp-拥塞避免）"><a href="#解决方案1描述（慢开始-amp-拥塞避免）" class="headerlink" title="解决方案1描述（慢开始 &amp; 拥塞避免）"></a>解决方案1描述（慢开始 &amp; 拥塞避免）</h5><ul><li>为了防止拥塞窗口（cwnd）增长过大而引起网络拥塞，采用慢开始 &amp; 拥塞避免 2种算法，具体规则如下</li></ul><p><img src="../../../images/tcp25.png" style="zoom:60%"></p><ul><li>实例说明</li></ul><p><img src="../../../images/tcp26.png" style="zoom:60%"></p><h4 id="解决方案2：快重传-amp-快恢复"><a href="#解决方案2：快重传-amp-快恢复" class="headerlink" title="解决方案2：快重传 &amp; 快恢复"></a>解决方案2：快重传 &amp; 快恢复</h4><p>快重传 &amp; 快恢复的解决方案 是对慢开始 &amp; 拥塞避免算法的改进</p><ul><li>2.1 储备知识：快重传算法、快恢复算法 *</li></ul><h5 id="a-快重传算法"><a href="#a-快重传算法" class="headerlink" title="a. 快重传算法"></a>a. 快重传算法</h5><ul><li><p>原理</p><ul><li>接收方 每收到一个失序的报文段后 就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认</li><li>发送方只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必 继续等待设置的重传计时器到期</li></ul></li><li><p>作用</p><ul><li>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%</li></ul></li><li><p>示意图<br><img src="../../../images/tcp27.png" style="zoom:60%"></p></li></ul><h5 id="b-快恢复"><a href="#b-快恢复" class="headerlink" title="b. 快恢复"></a>b. 快恢复</h5><p>当发送方连续收到3个重复确认后，就：</p><ul><li>执行 乘法减小 算法：把 慢开始门限（ssthresh）设置为 出现拥塞时发送方窗口值的一半 = 拥塞窗口的1半</li><li>将拥塞窗口（cwnd）值设置为 慢开始门限ssthresh减半后的数值 = 拥塞窗口的1半</li><li>执行 加法增大 算法：执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</li></ul><blockquote><p>注：</p><ul><li>由于跳过了拥塞窗口（cwnd）从1起始的慢开始过程，所以称为：快恢复</li><li>此处网络不会发生网络拥塞，因若拥塞，则不会收到多个重复确认报文</li></ul></blockquote><h5 id="解决方案描述（快重传-amp-快恢复）"><a href="#解决方案描述（快重传-amp-快恢复）" class="headerlink" title="解决方案描述（快重传 &amp; 快恢复）"></a>解决方案描述（快重传 &amp; 快恢复）</h5><ul><li>原理<ul><li>为了优化慢开始 &amp; 拥塞避免的解决方案，在上述方案中加入快重传 &amp; 快恢复 2种算法，具体规则如下</li></ul></li></ul><p><img src="../../../images/tcp28.png" style="zoom:60%"></p><ul><li>示意图</li></ul><p><img src="../../../images/tcp29.png" style="zoom:60%"></p><p>至此，关于TCP无差错传输的知识讲解完毕。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址：&lt;a href=&quot;https://www.jianshu.com/p/65605622234b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/65605622234b&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="hexo/blog/2022/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"/>
    <id>hexo/blog/2022/07/计算机网络.html</id>
    <published>2022-07-06T05:54:20.000Z</published>
    <updated>2022-07-06T06:45:21.652Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址：<a href="https://www.jianshu.com/p/45d27f3e1196" target="_blank" rel="noopener">https://www.jianshu.com/p/45d27f3e1196</a></p><h2 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>定义<br>计算机网络各层 + 其协议的集合</p></li><li><p>作用<br>定义该计算机网络的所能完成的功能</p></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>计算机网络体系结构分为三种：</p><ul><li>OSI体系结构</li><li>TCP/IP体系结构</li><li>五层体系结构</li></ul><blockquote><ul><li>OSI体系结构：概念清楚 &amp; 理念完整，但复杂 &amp; 不实用</li><li>TCP / IP体系结构：含了一系列构成互联网基础的网络协议，是Internet的核心协议 &amp; 被广泛应用于局域网 和 广域网</li><li>五层体系结构：融合了OSI 与 TCP / IP的体系结构，目的是为了学习 &amp; 讲解计算机原理</li></ul></blockquote><p>OSI体系结构(7层)     |       TCP/IP协议体系(4层)            |       五层体系结构(5层)<br>7.应用层            |        4.应用层                       |         5.应用层<br>6.表示层            |<br>5.会话层            |<br>4.传输层            |                                     |        4.运输层<br>3.网络层            |       3. 运输层                       |        3.网络层<br>2.链路层            |       2.网络层                        |        2.链路层<br>1.物理层            |       1.网络接口层                    |         1.物理层</p><p>低三层为通信子网，负责数据传输<br>高三层为资源子网，相当于计算机系统，完成数据处理；<br>传输层承上启下</p><h4 id="TCP-IP体系结构详细介绍"><a href="#TCP-IP体系结构详细介绍" class="headerlink" title="TCP/IP体系结构详细介绍"></a>TCP/IP体系结构详细介绍</h4><p>由于 TCP / IP体系结构较为广泛，故主要讲解</p><p>层级                  ｜                      作用              ｜          传输单位        ｜          功能          ｜              具体协议<br>1、网络接口层          ｜    负责与链路(传输媒介)的数据运输工作       ｜    帧                    ｜  <em> 组帧、差错控制、流量控制和运输管理    ｜      </em> EIA-232C、</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址：&lt;a href=&quot;https://www.jianshu.com/p/45d27f3e1196&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/45d27f3e1196&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>程序设计语言</title>
    <link href="hexo/blog/2022/07/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80.html"/>
    <id>hexo/blog/2022/07/程序设计语言.html</id>
    <published>2022-07-06T03:29:19.000Z</published>
    <updated>2022-07-06T03:32:17.055Z</updated>
    
    <content type="html"><![CDATA[<p>计算机语言分为高级语言、低级语言</p><p>语言越低级，离01代码越近，中间“翻译”的步骤也就越简洁，计算机执行的越快，对计算机很友好；</p><p>语言越高级，封装程度就越高，人类就可以用更少的代码来实现功能。编写高级语言并不需要知道他是怎么转换为计算机识别的语言；</p><p>越高级，就越”龟速”，能做的事情也就越少，但同样代码量也比较少。</p><p>低级与高级，省时间与省力气的关系。人写的代码少了，CPU处理的代码就多，。</p><ul><li>低级：机器码，汇编，Base语言</li><li>次低级：C，C++</li><li>高级：Java，C#</li><li>更高级：Python，PHP，JavaScript</li></ul><p>高级语言一般为解释型语言：<br>  在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。<br>  最典型的代表语言为JavaScript、Python、Ruby和Perl等 </p><p>低级语言一般为编译型语言：<br>  运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。<br>  最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件</p><p>编译型：<br>  运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。<br>  最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件。 </p><p>解释型：<br>  在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。<br>  最典型的代表语言为JavaScript、Python、Ruby和Perl等 </p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机语言分为高级语言、低级语言&lt;/p&gt;
&lt;p&gt;语言越低级，离01代码越近，中间“翻译”的步骤也就越简洁，计算机执行的越快，对计算机很友好；&lt;/p&gt;
&lt;p&gt;语言越高级，封装程度就越高，人类就可以用更少的代码来实现功能。编写高级语言并不需要知道他是怎么转换为计算机识别的语言；
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="hexo/blog/2022/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>hexo/blog/2022/07/面向对象.html</id>
    <published>2022-07-05T06:33:03.000Z</published>
    <updated>2022-07-05T07:47:49.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h2><p>把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形成类。<br>类中的大多数数据，只能用本类的方法进行处理。<br>类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。</p><blockquote><p>面向对象的三大特征</p><ul><li>封装</li><li>继承</li><li>多态</li></ul></blockquote><p>参考地址： <a href="https://blog.csdn.net/sugar_no1/article/details/86366714" target="_blank" rel="noopener">https://blog.csdn.net/sugar_no1/article/details/86366714</a></p><h2 id="面向对象分析与设计"><a href="#面向对象分析与设计" class="headerlink" title="面向对象分析与设计"></a>面向对象分析与设计</h2><p>参考地址：<a href="https://blog.csdn.net/huangshanchun/article/details/121727557" target="_blank" rel="noopener">https://blog.csdn.net/huangshanchun/article/details/121727557</a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>参考地址：<a href="https://blog.csdn.net/gghhb12/article/details/124269575" target="_blank" rel="noopener">https://blog.csdn.net/gghhb12/article/details/124269575</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象基本概念&quot;&gt;&lt;a href=&quot;#面向对象基本概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象基本概念&quot;&gt;&lt;/a&gt;面向对象基本概念&lt;/h2&gt;&lt;p&gt;把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件工程基础知识</title>
    <link href="hexo/blog/2022/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>hexo/blog/2022/07/软件工程基础知识.html</id>
    <published>2022-07-05T03:35:36.000Z</published>
    <updated>2022-07-06T03:00:16.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h2><p>共有9种开发模型，适用范围各不相同</p><ul><li><p>瀑布模型（Waterfall Model）</p><ul><li>瀑布模型适合应用的项目类型：需求明确 或者 二次开发</li><li>瀑布模型是结构化方法中的模型，一般应用于结构化的开发</li></ul></li><li><p>原型模型（Prototype Model）</p><ul><li>适合应用的项目类型：需求不明确</li><li>强调构造一个简易的系统</li></ul></li><li><p>演化模型（Evolutionary Model）</p><ul><li>系统的原型经过多轮调整最终形成了产品</li></ul></li><li><p>螺旋模型（Spiral Model）</p><ul><li>包含原型模式和瀑布模型，演化模型，它由多个模型组成</li><li>螺旋模型具有风险分析这个特征，这是其他模型所不具备的</li></ul></li><li><p>增量模型（Incremental Model）</p><ul><li>由原型模型的思想 + 瀑布模型的思想构成</li><li>风险低，用户会多次接触到项目的核心模块到，能尽早的发现问题并修正。</li></ul></li><li><p>V模型</p><ul><li>强调测试要伴随着整个软件开发的过程</li><li>需求分析阶段进行验收测试&amp;系统测试</li></ul></li><li><p>喷泉模型（Water Fountain Model）</p><ul><li>面向对象的，具有迭代和无间隙的特点；</li></ul></li><li><p>快速(应用)开发（RAD）模型</p><ul><li>RAD模型是由瀑布模型（SDLC）和构建组装模型（CBSD）组成</li><li>使用VB，Delphi，C#等可以通过拖动控件来快速实现界面地构建</li></ul></li><li><p>构建组装模型（CBSD）</p></li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>6大设计原则：</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p>对类来说，⼀个类应该只负责⼀项职责。如果⼀个类负责两个职责，可能存在职责1变化，引起职责2的变化情况。可以基于抽象逻<br>辑，或者业务逻辑对类进⾏细化。</p></blockquote><h3 id="接⼝隔离原则"><a href="#接⼝隔离原则" class="headerlink" title="接⼝隔离原则"></a>接⼝隔离原则</h3><blockquote><p>客户端不应该依赖它不需要的接⼝，⼀个类对另外⼀个类的依赖，应该建⽴在最⼩的接⼝上。</p></blockquote><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><blockquote><p>⾼层模块不应该依赖低层模块，两者应依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；中⼼思想是⾯向接⼝编程。</p></blockquote><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>假设有以下场景：</p><ul><li>存在类型T1，和实例对象O1</li><li>存在类型T2，和实例对象O2</li></ul><blockquote><p>如果将所有类型T1的对象都替换成类型T2的对象O2，程序的行为不会发生变化。那么类型T2是类型T1的子类型。<br>换句话说，有引用基类的地方必须能透明的使用其子类的对象</p></blockquote><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p>开闭原则是编程中最基础、最重要的设计原则，在代码结构的设计时，应该考虑对扩展开发，对修改关闭，抽象思维搭建结构，具体实现扩展细节。</p></blockquote><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><blockquote><p>迪⽶特原则⼜叫最少知道原则，即⼀个类对⾃⼰依赖的类知道的越要越好。也就是说，对于依赖的类不管多么复杂，都尽量将逻辑封<br>装在类的内部。对外除了提供的public⽅法，不对外开放任何信息。类与类关系越密切，耦合度越⼤，耦合的⽅式很多，依赖，关<br>联，组合，聚合等。</p></blockquote><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>参考地址：<a href="https://blog.csdn.net/weixin_43421142/article/details/108038676" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43421142/article/details/108038676</a></p><h2 id="质量特性"><a href="#质量特性" class="headerlink" title="质量特性"></a>质量特性</h2><p>参考地址：<a href="https://blog.csdn.net/shuaihj/article/details/7599528" target="_blank" rel="noopener">https://blog.csdn.net/shuaihj/article/details/7599528</a></p><h2 id="Pert图"><a href="#Pert图" class="headerlink" title="Pert图"></a>Pert图</h2><p>参考地址：<a href="https://blog.csdn.net/Daisy74RJ/article/details/106593226" target="_blank" rel="noopener">https://blog.csdn.net/Daisy74RJ/article/details/106593226</a></p><h2 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h2><p>参考地址：<a href="https://zhuanlan.zhihu.com/p/431021736" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/431021736</a></p><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p>参考地址：<a href="https://blog.csdn.net/baidu_32492845/article/details/89604337" target="_blank" rel="noopener">https://blog.csdn.net/baidu_32492845/article/details/89604337</a></p><h2 id="各种码"><a href="#各种码" class="headerlink" title="各种码"></a>各种码</h2><p>原码、补码、反码参考地址：<a href="https://blog.csdn.net/lluojian/article/details/119579921" target="_blank" rel="noopener">https://blog.csdn.net/lluojian/article/details/119579921</a></p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数<br>[+127]原 = 0111 1111<br>[-127]原 = 1111 1111<br>数值“0”由两种原码表示形式：<br>[+0]原 = 0000 0000<br>[-0]原 = 1000 0000</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>源码的范围：-128 ~ +127，最高位是符号位，0表示正数，1表示负数</p><p>[+127]补 = 0111 1111<br>[-128]补 = 1000 0000<br>因为 [-127]反 = 1000 0000 而 [-127]补 = 反 + 1 = 1 0000001<br>所以 [-128]补 = 1000 0000</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数</p><p>[+127]反 = 0111 1111<br>[-127]反 = 1000 0000<br>数值“0”由两种反码表示形式：<br>[+0]反 = 0000 0000<br>[-0]反 = 1111 1111</p><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>使用二进制来编码的十进制。<br>分为三种：</p><ul><li>8421码</li><li>余3码（8421码+）</li><li>2421码</li></ul><h4 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h4><p>一种有权码，四个二进制的权值分配分别为8、4、2、1。</p><p>就是直接将10进制的每位数都转化为长度为4的二进制数，如：</p><p>0——0000</p><p>1——0001</p><p>2——0010</p><p>3——0011</p><p>4——0100</p><p>5——0101</p><p>6——0110</p><p>7——0111</p><p>8——1000</p><p>9——1001</p><p>123——0001 0010 0011（就是先把1的8421码写下来，再写2的，最后写3的）</p><blockquote><p>使用8421码表示的数字怎么进行加法运算？<br>步骤：1.二进制加法运算<br>2.落到1010—10010非合法范围加6修正，0000—1001合法范围就不用+6修正<br>举例：1+1         0001+ 0001 =0010 （=2）不用修正<br>     4+7         0100+ 0111 =1011   （=11）不合法要修正    1011+0110=10001 补0 =0001 0001<br>     9+9         1001+1001=1  0010    修正，后四位加6   0010+0110=1000<br>     补0，结果为 0001 1000 （=18）</p></blockquote><h4 id="余3码（8421码-）"><a href="#余3码（8421码-）" class="headerlink" title="余3码（8421码+）"></a>余3码（8421码+）</h4><p>0——0000+0011=0011</p><p>1——0001+0011=0100</p><p>2——0010+0011=0101</p><p>3——0011+0011=0110</p><p>4——0100+0011=0111</p><p>5——0101+0011=1000</p><p>6——0110+0011=1001</p><p>7——0111+0011=1010</p><p>8——1000+0011=1011</p><p>9——1001+0011=1100</p><p>四个二进制位的权值不固定，是无权码</p><h4 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h4><p>有权码</p><p>四个二进制权值分别为2、4、2、1</p><p>0——0000</p><p>1——0001</p><p>2——0010</p><p>3——0011</p><p>4——0100</p><p>在这里加个分隔，why？注意：0-4编码第一位是0，5-9编码第一位是1。</p><p>这又是为什么呢？避免歧义的发生！你看，0100和1010都可以表示4，这就麻烦了，所以规定0-4编码第一位是0，5-9编码第一位是1，从而使表示方法唯一！</p><p>5——1011</p><p>6——1100</p><p>7——1101</p><p>8——1110</p><p>9——1111</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="10进制转为其他任意进制"><a href="#10进制转为其他任意进制" class="headerlink" title="10进制转为其他任意进制"></a>10进制转为其他任意进制</h3><p>如十进制数 m 转换为 n 进制的数， 此时用 m 一直除以 n 并留余，除到商为0时，将 余数 从下往上排列，即为最终结果。</p><h3 id="二进制转换为10进制"><a href="#二进制转换为10进制" class="headerlink" title="二进制转换为10进制"></a>二进制转换为10进制</h3><p>如 1001 0101 1010 转换为 10进制</p><p> 1001 0101 1010  从左往右排列： 0101 1010 1001</p><p>从左往右开始累加计算： 0 <em> 2^0 + 1 </em> 2^1 + 0 <em> 2^2 + 1 </em> 2^3 + 1 <em> 2^4 + 0 </em> 2^5 + ….<br>相当于累加 当前位数n对应的值m(0 或 1) * 2^(n-1) 即为最终的结果</p><p>如上述数据 1001 0101 1010 转为 10进制为 4342</p><h3 id="其他任意进制转为10进制"><a href="#其他任意进制转为10进制" class="headerlink" title="其他任意进制转为10进制"></a>其他任意进制转为10进制</h3><p>与 二进制 转为 10进制类似<br>只不过在二进制转10进制中，都是乘以2的幂等，n进制转换就是乘以n的幂等</p><ul><li>如 9进制表示的数140 转换为 10进制</li></ul><p>0 <em> 9^0 + 4 </em> 9^1 + 1 * 9^2 = 0 + 36 + 81 = 117</p><h3 id="二进制转换为8、16进制"><a href="#二进制转换为8、16进制" class="headerlink" title="二进制转换为8、16进制"></a>二进制转换为8、16进制</h3><ul><li><p>转换为8进制时，直接将数据分割为每3位一段，不足3位的在前面补0，再将每段直接转换为10进制数即可</p><ul><li>如1110101，因只有7位，不是3的倍数，在前面补两个0，再分割。 001 110 101，再将三段转为10进制，最终结果：165</li></ul></li><li><p>转换为16进制，直接将数据分割为每4位一段，不足4位的在前面补0，再将每段直接转换为16进制数即可</p><ul><li>如1110101，因只有7位，不是4的倍数，在前面补1个0，再分割。 0111 0101，再将此两端都转为16进制，最终结果：75H</li></ul></li></ul><p>16进制的数可以使用H后缀、或者 0x前缀标识</p><p>75H = 0x75</p><h3 id="二进制转换为其他进制"><a href="#二进制转换为其他进制" class="headerlink" title="二进制转换为其他进制"></a>二进制转换为其他进制</h3><p>先进二进制转为10进制，再将10进制转为其他进制</p><ul><li>1110101 转为9进制<br>1110101 转为10进制为 117，再将117转换为9进制，即为 140</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开发模型&quot;&gt;&lt;a href=&quot;#开发模型&quot; class=&quot;headerlink&quot; title=&quot;开发模型&quot;&gt;&lt;/a&gt;开发模型&lt;/h2&gt;&lt;p&gt;共有9种开发模型，适用范围各不相同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;瀑布模型（Waterfall Model）&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>UML图</title>
    <link href="hexo/blog/2022/07/UML%E5%9B%BE.html"/>
    <id>hexo/blog/2022/07/UML图.html</id>
    <published>2022-07-04T08:09:13.000Z</published>
    <updated>2022-07-05T03:10:04.473Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UML图有可以分类为</p><ul><li>类图</li><li>状态图</li><li>活动图</li><li>交互图-时序图</li><li>交互图-协作图</li><li>用例图</li><li>ER图</li></ul></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>参考地址：<a href="https://blog.csdn.net/zhaxun/article/details/124048871" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124048871</a></p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>参考地址： <a href="https://blog.csdn.net/zhaxun/article/details/124201040" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124201040</a></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>参考地址： <a href="https://blog.csdn.net/qq_41784749/article/details/112242348" target="_blank" rel="noopener">https://blog.csdn.net/qq_41784749/article/details/112242348</a></p><h2 id="交互图-时序图"><a href="#交互图-时序图" class="headerlink" title="交互图-时序图"></a>交互图-时序图</h2><p>参考地址：<a href="https://blog.csdn.net/qq_23024699/article/details/120444441" target="_blank" rel="noopener">https://blog.csdn.net/qq_23024699/article/details/120444441</a></p><h2 id="交互图-协作图"><a href="#交互图-协作图" class="headerlink" title="交互图-协作图"></a>交互图-协作图</h2><p>参考地址：<a href="https://blog.csdn.net/neusoft2016/article/details/116195191" target="_blank" rel="noopener">https://blog.csdn.net/neusoft2016/article/details/116195191</a></p><p>时序图与协作图的区别与联系：</p><ul><li><p>协作图和时序图都表示出了对象间的交互作用，但是它们侧重点不同。</p></li><li><p>时序图清楚地表示了交互作用中的时间顺序(强调时间)，但没有明确表示对象间的关系。</p></li><li><p>协作图清楚地表示了对象间的关系(强调空间)，但时间顺序必须从顺序号获得。</p></li><li><p>协作图不能体现对象的初始化和消亡的时间</p></li><li><p>协作图和时序图可以相互转化。</p></li></ul><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>参考地址：<a href="https://blog.csdn.net/zhaxun/article/details/124047015" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124047015</a></p><h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p>参考地址：<a href="https://blog.csdn.net/caohongxing/article/details/122398825" target="_blank" rel="noopener">https://blog.csdn.net/caohongxing/article/details/122398825</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;UML图有可以分类为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类图&lt;/li&gt;
&lt;li&gt;状态图&lt;/li&gt;
&lt;li&gt;活动图&lt;/li&gt;
&lt;li&gt;交互图-时序图&lt;/li&gt;
&lt;li&gt;交互图-协作图&lt;/li&gt;
&lt;li&gt;用例图&lt;/li&gt;
&lt;li&gt;ER图&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软考-软件设计师</title>
    <link href="hexo/blog/2022/07/%E8%BD%AF%E8%80%83-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88.html"/>
    <id>hexo/blog/2022/07/软考-软件设计师.html</id>
    <published>2022-07-04T06:39:48.000Z</published>
    <updated>2022-07-04T08:07:30.190Z</updated>
    
    <content type="html"><![CDATA[<p>准备报考2022年下半年的软考-软件设计师，</p><ul><li><p>为什么要考？</p><ul><li>减税</li><li>学习</li><li>考证</li></ul></li><li><p>为什么是软件设计师？</p><ul><li>因为之前没有想过去考证书，这是第一次，准备先考个中级的证书试试水</li><li>中级的证书有多个，只有软件设计师稍微有点符合自己的工作岗位，能使用到自己的一些开发经验，也能起到一定的学习作用</li></ul></li><li><p>怎么备考？</p><ul><li>bilibili</li><li>先了解大纲</li><li>逐一学习各个知识点</li><li>写真题</li></ul></li></ul><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><p>软件工程基础知识</p><ul><li>开发模型</li><li>设计原则</li><li>测试方法</li><li>质量特性</li><li>CMM, Pert图</li><li>风险管理</li></ul></li><li><p>面向对象</p><ul><li>面向对象基本概念</li><li>面向对象分析与设计</li><li>UML</li><li>设计模式</li></ul></li><li><p>数据结构与算法</p><ul><li>数组</li><li>栈</li><li>队列</li><li>树与二叉树</li><li>图</li><li>查找与排序</li><li>常见算法</li></ul></li><li><p>程序设计语言</p><ul><li>文法</li><li>有限自动机</li><li>正规式</li><li>语句的作用</li><li>语句的语义</li><li>程序的控制结构</li><li>函数调用的参数传递</li><li>各种程序语言的特点比较</li></ul></li><li><p>计算机硬件基础</p><ul><li>浮点数运算、溢出</li><li>算术、逻辑运算</li><li>计算机体系结构分类</li><li>指令系统基础</li><li>CISC与RISC</li><li>流水线</li><li>Cache存储器可靠性分析</li><li>校验方法</li></ul></li><li><p>操作系统</p><ul><li>进程状态转换图</li><li>信号量与PV操作</li><li>死锁问题</li><li>银行家算法</li><li>段页式存储</li><li>页面置换算法</li><li>磁盘调度</li><li>树形文件系统</li></ul></li><li><p>数据库系统</p><ul><li>E-R模型</li><li>关系代数</li><li>元组演算</li><li>规范化理论(键、范式、模式分解)</li><li>并发控制</li></ul></li><li><p>计算机网络</p><ul><li>OSI模型</li><li>TCP/IP协议族</li><li>子网划分</li><li>常用的网络命令</li></ul></li><li><p>信息安全知识</p><ul><li>加密解密技术</li><li>网络安全</li><li>计算机病毒</li></ul></li><li><p>多媒体基础</p><ul><li>多媒体基本概念</li><li>计算声音</li><li>图像</li><li>视频文件的容量</li><li>JPEG, MPEG</li></ul></li><li><p>知识产权与标准化</p><ul><li>作品保护时间</li><li>侵权判定</li><li>知识产权归属</li><li>标准的分类</li><li>标准代号</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备报考2022年下半年的软考-软件设计师，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么要考？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减税&lt;/li&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;考证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么是软件设计师？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为之
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>减肥计划</title>
    <link href="hexo/blog/2022/06/%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92.html"/>
    <id>hexo/blog/2022/06/减肥计划.html</id>
    <published>2022-06-27T08:26:27.000Z</published>
    <updated>2022-06-27T08:32:55.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="减肥大计"><a href="#减肥大计" class="headerlink" title="减肥大计"></a>减肥大计</h1><p>暂时定为三个阶段，每个阶段目标均为 -5kg</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>通过修改饮食，加上 低运动量减肥操</p><h3 id="早餐"><a href="#早餐" class="headerlink" title="早餐"></a>早餐</h3><p>两个鸡蛋+ 一杯豆浆/一杯牛奶</p><h3 id="中餐"><a href="#中餐" class="headerlink" title="中餐"></a>中餐</h3><p>一碗米饭 + 青菜 + 适量牛肉、虾，保证蛋白质摄入</p><h3 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h3><p>玉米面/荞面 + 适量牛肉、虾</p><p>零食以 牛肉干、黄瓜 为准。</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>通过饮食， 加上适量有氧运动， 跑步<br>目标：75kg</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>通过饮食， 加上中等有氧运动， 跑步</p><p>目标：70kg</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;减肥大计&quot;&gt;&lt;a href=&quot;#减肥大计&quot; class=&quot;headerlink&quot; title=&quot;减肥大计&quot;&gt;&lt;/a&gt;减肥大计&lt;/h1&gt;&lt;p&gt;暂时定为三个阶段，每个阶段目标均为 -5kg&lt;/p&gt;
&lt;h2 id=&quot;第一阶段&quot;&gt;&lt;a href=&quot;#第一阶段&quot; class
      
    
    </summary>
    
    
      <category term="live" scheme="hexo/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>android API 更新</title>
    <link href="hexo/blog/2022/06/android-API-%E6%9B%B4%E6%96%B0.html"/>
    <id>hexo/blog/2022/06/android-API-更新.html</id>
    <published>2022-06-27T08:05:51.000Z</published>
    <updated>2022-06-27T08:08:54.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-API-更新记录"><a href="#android-API-更新记录" class="headerlink" title="android API 更新记录"></a>android API 更新记录</h1><h2 id="android-API-30-（android11）应用文件管理权限"><a href="#android-API-30-（android11）应用文件管理权限" class="headerlink" title="android API 30 （android11）应用文件管理权限"></a>android API 30 （android11）应用文件管理权限</h2><p>在andorid6之后需要动态请求权限，如针对文件写入、读取权限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">    <span class="keyword">var</span> permissionArray = arrayOf(</span><br><span class="line">        Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">    )</span><br><span class="line">    requestPermissions(permissionArray, <span class="number">101</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在android 11之后，这样也会弹出应用权限请求，但写入文件到sdcrd还是会失败，报错：/storage/emulated/0/io/okio.txt: open failed: ENOENT (No such file or directory)</p><p>需要修改请求权限的方式为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Environment.isExternalStorageManager()) &#123;</span><br><span class="line">    <span class="keyword">var</span> intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">    startActivityForResult(intent, <span class="number">102</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-API-更新记录&quot;&gt;&lt;a href=&quot;#android-API-更新记录&quot; class=&quot;headerlink&quot; title=&quot;android API 更新记录&quot;&gt;&lt;/a&gt;android API 更新记录&lt;/h1&gt;&lt;h2 id=&quot;android-A
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="hexo/blog/2022/06/io.html"/>
    <id>hexo/blog/2022/06/io.html</id>
    <published>2022-06-22T08:51:23.000Z</published>
    <updated>2022-06-27T03:18:42.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO是什么"><a href="#IO是什么" class="headerlink" title="IO是什么"></a>IO是什么</h2><blockquote><p>程序内部和外部进行数据交互的过程，就叫输入输出。</p><blockquote><p>程序内部是谁?内存<br>程序外部是谁?</p><blockquote><p>一般来说是两类:本地文件和网络。<br>也有别的情况，比如你和别的程序做交互，和你交互的程序也属于外部，但一般来说，就是文件和网络这么两种。</p></blockquote></blockquote></blockquote><blockquote><p>从文件里或者从网络上读数据到内存里，就叫输入;从内存里写到文件里或者发送到网络上，就叫输出</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><p>使用流，例如 FileInputStream / FileOutputStream</p></li><li><p>可以用 Reader 和 Writer 来对字符进行读写</p></li><li><p>流的外面还可以套别的流，层层嵌套都可以</p></li><li><p>BufferedXXXX 可以给流加上缓冲。对于输入流，是每次多读一些放在内存 里面，下次再去数据就不用再和外部做交互(即不必做 IO 操作);对于输 出流，是把数据先在内存里面攒一下，攒够一波了再往外部去写。</p></li></ul><p>通过缓存的方式减少和和外部的交互，从而可以提高效率</p><ul><li><p>文件的关闭:close()</p></li><li><p>需要用到的写过的数据，flush() 一下可以保证数据真正写到外部去(读数据 没有这样的担忧)</p></li><li><p>这个就是 Java 的 I/O，它的原理就是内存和外界的交互</p></li></ul><p>IO 又可以分为 BIO、NIO、AIO</p><h2 id="BIO、NIO、AIO-区别"><a href="#BIO、NIO、AIO-区别" class="headerlink" title="BIO、NIO、AIO 区别"></a>BIO、NIO、AIO 区别</h2><h3 id="IO模型主要分类："><a href="#IO模型主要分类：" class="headerlink" title="IO模型主要分类："></a>IO模型主要分类：</h3><ul><li><p>同步(synchronous)IO与异步(asynchronous)IO</p></li><li><p>阻塞(blocking)IO与非阻塞(non-blocking)IO</p></li><li><p>同步阻塞IO(blocking-IO)即为 BIO</p></li><li><p>同步非阻塞IO(non-blocking-IO)即为 NIO</p></li><li><p>异步非阻塞IO(synchronous-non-blocking-IO)即为 AIO</p></li></ul><h3 id="BIO（同步阻塞I-O模式）"><a href="#BIO（同步阻塞I-O模式）" class="headerlink" title="BIO（同步阻塞I/O模式）"></a>BIO（同步阻塞I/O模式）</h3><p>数据的读取、写入等操作必须阻塞在一个线程内等待操作完成</p><h3 id="NIO（同步非阻塞I-O模式）"><a href="#NIO（同步非阻塞I-O模式）" class="headerlink" title="NIO（同步非阻塞I/O模式）"></a>NIO（同步非阻塞I/O模式）</h3><p>同时支持阻塞与非阻塞模式，NIO的做法是叫一个线程不断的轮询IO操作的的状态，看看是否有任务的状态发生了改变，从而进行下一步的操作。</p><p>默认是阻塞式的</p><h3 id="AIO-（异步非阻塞I-O模型）"><a href="#AIO-（异步非阻塞I-O模型）" class="headerlink" title="AIO （异步非阻塞I/O模型）"></a>AIO （异步非阻塞I/O模型）</h3><p>异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p><p>对应到IO操作中就是，为每次IO操作上面装了一个开关，IO操作完毕之后，会自动通知任务完成。</p><h3 id="IO-与-NIO-的区别"><a href="#IO-与-NIO-的区别" class="headerlink" title="IO 与 NIO 的区别"></a>IO 与 NIO 的区别</h3><p>IO 面向流</p><p>NIO 面向缓冲区，具备 选择器(Selectors)</p><h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><ul><li><p>同步</p><ul><li>发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生。</li></ul></li><li><p>异步</p><ul><li>发送一个请求，不等待返回，随时可以再发送下一个请求，可以提高效率，保证并发。</li></ul></li></ul><h3 id="阻塞与非阻塞的区别"><a href="#阻塞与非阻塞的区别" class="headerlink" title="阻塞与非阻塞的区别"></a>阻塞与非阻塞的区别</h3><ul><li>阻塞</li></ul><blockquote><p>传统的IO流都是阻塞式的。也就是说，当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务。在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降。  </p></blockquote><ul><li>非阻塞</li></ul><blockquote><p>JavaNIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。  </p></blockquote><h2 id="NIO-3个核心概念"><a href="#NIO-3个核心概念" class="headerlink" title="NIO 3个核心概念"></a>NIO 3个核心概念</h2><p><img src="../../../images/nio.png" style="zoom:70%"></p><p>NIO重点是把Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系弄清楚。</p><h3 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。  </p><p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。  </p><p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。  </p><p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：  </p><ul><li><p>ByteBuffer：字节缓冲区  </p></li><li><p>CharBuffer:字符缓冲区  </p></li><li><p>ShortBuffer：短整型缓冲区  </p></li><li><p>IntBuffer：整型缓冲区  </p></li><li><p>LongBuffer:长整型缓冲区  </p></li><li><p>FloatBuffer：浮点型缓冲区  </p></li><li><p>DoubleBuffer：双精度浮点型缓冲区  </p></li></ul><h3 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p><p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p><p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p><p>Channel有四种实现：</p><ul><li><p>FileChannel:是从文件中读取数据。</p></li><li><p>DatagramChannel:从UDP网络中读取或者写入数据。</p></li><li><p>SocketChannel:从TCP网络中读取或者写入数据。</p></li><li><p>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</p></li></ul><h3 id="多路复用器Selector"><a href="#多路复用器Selector" class="headerlink" title="多路复用器Selector"></a>多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p><h4 id="关键对象"><a href="#关键对象" class="headerlink" title="关键对象"></a>关键对象</h4><ul><li><p>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</p></li><li><p>SelectorKey：通道监听关键字，通过它来监听通道状态。</p></li></ul><h4 id="监听注册"><a href="#监听注册" class="headerlink" title="监听注册"></a>监听注册</h4><p>监听注册在Selector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><h4 id="监听的事件有"><a href="#监听的事件有" class="headerlink" title="监听的事件有"></a>监听的事件有</h4><ul><li><p>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</p></li><li><p>OP_READ: 读取就绪，socketChannel使用</p></li><li><p>OP_WRITE: 写入就绪，socketChannel使用</p></li><li><p>OP_CONNECT: 连接就绪，socketChannel使用</p></li></ul><h2 id="OKIO"><a href="#OKIO" class="headerlink" title="OKIO"></a>OKIO</h2><p>okhttp框架中，使用的io</p><p>OKio本质上是对Java的NIO的一次扩展，并且做了缓存的优化，</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>它也是基于插管的，而且是单向的，输入源叫 Source，输出目标叫 Sink</li><li>支持 Buffer<ul><li>像 NIO 一样，可以对 Buffer 进行操作</li><li>但不强制使用 Buffer</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;h2 id=&quot;IO是什么&quot;&gt;&lt;a href=&quot;#IO是什么&quot; class=&quot;headerlink&quot; title=&quot;IO是什么&quot;&gt;&lt;/a&gt;IO是什
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jetpack hilt</title>
    <link href="hexo/blog/2022/06/jetpack-hilt.html"/>
    <id>hexo/blog/2022/06/jetpack-hilt.html</id>
    <published>2022-06-16T06:09:19.000Z</published>
    <updated>2022-06-22T08:50:59.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a>Hilt</h1><p>先讲使用，再讲原理</p><p>google文档地址：<a href="https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn</a></p><p><a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/hilt" target="_blank" rel="noopener">示例源码地址</a></p><h2 id="使用示例：-Hilt-ViewModel-Repository"><a href="#使用示例：-Hilt-ViewModel-Repository" class="headerlink" title="使用示例： Hilt + ViewModel + Repository"></a>使用示例： Hilt + ViewModel + Repository</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ul><li>注意事项不要参考google文档中的地址设置版本号，因为文档中使用的是 aplha 版本，API会随时变动，很可能使用此版本但运行结果与文档不同，本人就碰到了，（@HiltViewModel 不可用） *</li></ul><p>在项目根目录的 build.gradle 中添加：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.hilt_version = <span class="string">"2.36"</span></span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">// hilt</span></span><br><span class="line">        classpath <span class="string">"com.google.dagger:hilt-android-gradle-plugin:$hilt_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在需要使用 hilt 的 module 的 build.gradle 文件中添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hilt</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:hilt-android:$hilt_version"</span></span><br><span class="line">kapt <span class="string">"com.google.dagger:hilt-android-compiler:$hilt_version"</span></span><br></pre></td></tr></table></figure><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltAndroidApp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">var</span> repository: HiltRepository,</span><br><span class="line">): ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repository.login()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor"><a href="#注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor" class="headerlink" title="注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()"></a>注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityHiltBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: HiltViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityHiltBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，此时生成 viewModel实例时，无需再次传入参数，也不需要另外使用ViewModelFactory来生成。<br>原因就是在 Repository 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过注解已经提供了生成 HiltRepository 实例的方式。</p><p>以上就是一次简单的使用。</p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hilt&quot;&gt;&lt;a href=&quot;#Hilt&quot; class=&quot;headerlink&quot; title=&quot;Hilt&quot;&gt;&lt;/a&gt;Hilt&lt;/h1&gt;&lt;p&gt;先讲使用，再讲原理&lt;/p&gt;
&lt;p&gt;google文档地址：&lt;a href=&quot;https://developer.android
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CameraX</title>
    <link href="hexo/blog/2022/03/CameraX.html"/>
    <id>hexo/blog/2022/03/CameraX.html</id>
    <published>2022-03-28T07:51:31.000Z</published>
    <updated>2022-03-28T09:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。</p><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> camerax_version = <span class="string">"1.0.2"</span></span><br><span class="line">  <span class="comment">// The following line is optional, as the core library is included indirectly by camera-camera2</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-core:$&#123;camerax_version&#125;"</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-camera2:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Lifecycle library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX VideoCapture library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-video:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX View class</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-view:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Extensions library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-extensions:1.1.0-beta02"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-CameraX-开启预览"><a href="#使用-CameraX-开启预览" class="headerlink" title="使用 CameraX 开启预览"></a>使用 CameraX 开启预览</h2><p>在向应用添加预览时，请使用 PreviewView，这是一种可以剪裁、缩放和旋转以确保正确显示的 View。</p><p>当相机处于活动状态时，图片预览会流式传输到 PreviewView 中的 Surface。</p><h3 id="将-PreviewView-添加到布局"><a href="#将-PreviewView-添加到布局" class="headerlink" title="将 PreviewView 添加到布局"></a>将 PreviewView 添加到布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".camera.CameraActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.camera.view.PreviewView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/previewView"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="请求-CameraProvider"><a href="#请求-CameraProvider" class="headerlink" title="请求 CameraProvider"></a>请求 CameraProvider</h3><p>以下代码展示了如何请求 CameraProvider：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> cameraProviderFuture: ListenableFuture&lt;ProcessCameraProvider&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> dataBinding: ActivityCameraBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        dataBinding = ActivityCameraBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(dataBinding.root)</span><br><span class="line">        cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查-CameraProvider-可用性"><a href="#检查-CameraProvider-可用性" class="headerlink" title="检查 CameraProvider 可用性"></a>检查 CameraProvider 可用性</h3><p>请求 CameraProvider 后，请验证它能否在视图创建后成功初始化。以下代码展示了如何执行此操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">  <span class="keyword">val</span> cameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line">  bindPreview(cameraProvider)</span><br><span class="line"></span><br><span class="line">&#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure><h3 id="选择相机并绑定生命周期和用例"><a href="#选择相机并绑定生命周期和用例" class="headerlink" title="选择相机并绑定生命周期和用例"></a>选择相机并绑定生命周期和用例</h3><p>创建并确认 CameraProvider 后，请执行以下操作:</p><ul><li><p>1、创建 Preview。</p></li><li><p>2、指定所需的相机 LensFacing 选项。</p></li><li><p>3、将所选相机和任意用例绑定到生命周期。</p></li><li><p>4、将 Preview 连接到 PreviewView。</p></li></ul><p>以下代码展示了一个示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindPreview</span><span class="params">(cameraProvider: <span class="type">ProcessCameraProvider</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> preview: Preview = Preview.Builder()</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cameraSelector: CameraSelector = CameraSelector.Builder()</span><br><span class="line">        .requireLensFacing(CameraSelector.LENS_FACING_BACK)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    preview.setSurfaceProvider(dataBinding.previewView.getSurfaceProvider())</span><br><span class="line">    <span class="keyword">var</span> camera = cameraProvider?.bindToLifecycle(<span class="keyword">this</span> <span class="keyword">as</span> LifecycleOwner, cameraSelector, preview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，bindToLifecycle() 会返回一个 Camera 对象。如需详细了解如何控制相机输出（如变焦和曝光），请参阅此指南。</p><p>现在，您已完成实现相机预览的操作。请构建您的应用，然后确认预览是否出现在您的应用中并能按预期工作。</p><p>PS: 记得需要相机权限</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。&lt;/p&gt;
&lt;h2 id=&quot;添加依赖项&quot;&gt;&lt;a href=&quot;#添加依赖项&quot; class=&quot;headerlink&quot; title=&quot;添加依赖项&quot;&gt;&lt;/a&gt;添加依赖项&lt;/h2&gt;&lt;fig
      
    
    </summary>
    
    
      <category term="android-Jetpack" scheme="hexo/tags/android-Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法</title>
    <link href="hexo/blog/2022/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2022/02/常用的排序方法.html</id>
    <published>2022-02-18T03:08:05.000Z</published>
    <updated>2022-07-04T06:39:26.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，当前元素与下一个元素对比，将较大值放于右侧，<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//选择排序算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length-<span class="number">1</span> ;i++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;args.length ;j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[min]&gt;args[j])&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=args[i];</span><br><span class="line">            args[i]=args[min];</span><br><span class="line">            args[min]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，取出最小值或者最大值，交互数组位置，使最值位于数组两侧，最后得出一个升序/降序数组<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//插入排序算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[j]&lt;args[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=args[j-<span class="number">1</span>];</span><br><span class="line">                args[j-<span class="number">1</span>]=args[j];</span><br><span class="line">                args[j]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>使用系统自带的排序方法 sorts<br>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的遍历一般根据节点可分为三种：前序、中序、后序遍历<br>根据树的层级又有层级遍历</p><p>下面的代码就是一个树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Node left;</span><br><span class="line"><span class="keyword">private</span> Node right;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node[ no = "</span> + no + <span class="string">", name ="</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>先取父节点，再取左节点，再取右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>先取左节点，再取父节点，再取右节点<br>中序遍历可以得出一个升序结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LDR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>先取左节点，再取右节点，再取父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LRD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-ViewModel</title>
    <link href="hexo/blog/2022/02/jetpack-ViewModel.html"/>
    <id>hexo/blog/2022/02/jetpack-ViewModel.html</id>
    <published>2022-02-08T07:08:05.000Z</published>
    <updated>2022-02-18T02:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考 android developer 中的文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>当 ViewModel 构造函数为有参构造函数时，使用 private val model : OverTimeViewModel by activityViewModels() 会报错<br>此时处理方案为新建一个Factory类<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> dataSource: OverTimeDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span>(modelClass.isAssignableFrom(OverTimeViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OverTimeViewModel(dataSource) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在写一个静态类，作为Factory作为Provider</span></span><br><span class="line"><span class="keyword">object</span> Injection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideUserDataSource</span><span class="params">(context: <span class="type">Context</span>)</span></span>: OverTimeDao &#123;</span><br><span class="line">        <span class="keyword">val</span> database = AppDatabase.getInstance(context)</span><br><span class="line">        <span class="keyword">return</span> database.overTimeDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideViewModelFactory</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ViewModelFactory &#123;</span><br><span class="line">        <span class="keyword">val</span> dataSource = provideUserDataSource(context)</span><br><span class="line">        <span class="keyword">return</span> ViewModelFactory(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModelFactory: ViewModelFactory</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> model : OverTimeViewModel <span class="keyword">by</span> activityViewModels&#123; viewModelFactory &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定的生命函数中实例化ViewModelFactory</span></span><br><span class="line">viewModelFactory = Injection.provideViewModelFactory(activity!!)</span><br></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 android developer 中的文档：&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager2</title>
    <link href="hexo/blog/2022/02/ViewPager2.html"/>
    <id>hexo/blog/2022/02/ViewPager2.html</id>
    <published>2022-02-07T07:59:48.000Z</published>
    <updated>2022-02-07T09:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2</a></p><p>需要对比 ViewPager2 与 ViewPager 的差异、优劣</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deve
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-Navigation</title>
    <link href="hexo/blog/2022/02/jetpack-Navigation.html"/>
    <id>hexo/blog/2022/02/jetpack-Navigation.html</id>
    <published>2022-02-07T07:56:06.000Z</published>
    <updated>2022-02-07T07:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>具体参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-getting-started</a></p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>Navigation 其实是对 Fragment 跳转的管理，而不是 Activity，需要配置到某个 Activity 中。<br>其实是单 Activity 模式</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-getting-started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack Room</title>
    <link href="hexo/blog/2021/12/jetpack-Room.html"/>
    <id>hexo/blog/2021/12/jetpack-Room.html</id>
    <published>2021-12-22T10:44:10.000Z</published>
    <updated>2022-06-28T08:27:30.560Z</updated>
    
    <content type="html"><![CDATA[<p>处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的使用场景是缓存相关的数据，这样一来，当设备无法访问网络时，用户仍然可以在离线状态下浏览该内容。</p><p>Room 持久性库在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。<br>具体来说，Room 具有以下优势：</p><ul><li>针对 SQL 查询的编译时验证</li><li>可最大限度减少重复和容易出错的样板代码的方便注解。</li><li>简化了数据库迁移路径。</li></ul><p>出于这些方面的考虑，我们强烈建议您使用 Room，而不是直接使用 SQLite API。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在build.gradle中添加 kapt plugin<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.android.application'</span></span><br><span class="line">    id <span class="string">'kotlin-android'</span></span><br><span class="line">    id <span class="string">'kotlin-kapt'</span> <span class="comment">// 新增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加room依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Room</span></span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.4.1"</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    kapt <span class="string">"androidx.room:room-compiler:$room_version"</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p>Room 包含三个主要组件：</p><ul><li>数据库类，用于保存数据库并作为应用持久性数据底层连接的主要访问点。</li><li>数据实体，用于表示应用的数据库中的表。</li><li>数据访问对象 (DAO)，提供您的应用可用于查询、更新、插入和删除数据库中的数据的方法。</li></ul><p>数据库类为应用提供与该数据库关联的 DAO 的实例。反过来，应用可以使用 DAO 从数据库中检索数据，作为关联的数据实体对象的实例。<br>此外，应用还可以使用定义的数据实体更新相应表中的行，或者创建新行供插入。</p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><p>本部分介绍了具有单个数据实体和单个 DAO 的 Room 数据库实现示例。</p><h3 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h3><p>使用 Room 时，每个表都由一个类表示。在 Room 等 ORM（对象关系映射）库中，这些类通常称为模型类或实体。</p><ul><li>1、创建一个名为 Schedule.kt 的新文件，并定义一个名为 Schedule 的数据类。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedule</span> </span>()</span><br></pre></td></tr></table></figure></li></ul><p>注意要使用注解@Dao,标注这是数据库实体类</p><ul><li>2、添加主键</li></ul><p>据表应该有一个用于唯一标识每行的主键。您要添加到 Schedule 类中的第一个属性是用于表示唯一 ID 的一个整数。<br>添加一个新属性，并使用 @PrimaryKey 注解对其进行标记。<br>此注解会告知 Room 在插入新行时将此属性视为主键。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedule</span> </span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line"></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><ul><li>3、添加其他信息列</li></ul><p>对于新列，您需要添加 @ColumnInfo 注解，用于为该列指定名称。<br>通常，SQL 列名称使用以下划线分隔的单词，而 Kotlin 属性采用小驼峰命名法。<br>对于此列，我们还希望其值为非 null 值，因此您应该使用 @NonNull 注解对其进行标记。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedule</span> </span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="meta-string">"stop_name"</span>)</span> <span class="keyword">val</span> stopName: String,</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="meta-string">"arrival_time"</span>)</span> <span class="keyword">val</span> arrivalTime: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="定义DAO"><a href="#定义DAO" class="headerlink" title="定义DAO"></a>定义DAO</h3><p>为了集成 Room 而需要添加的下一个类是 DAO。DAO 代表数据访问对象，是一个提供数据访问的 Kotlin 类。<br>具体而言，您会在 DAO 中包含用于读取和操作数据的函数。对 DAO 调用函数相当于对数据库执行 SQL 命令。<br>实际上，像您要在此应用中定义的函数这样的 DAO 函数通常会指定一个 SQL 命令，以便您可以精确地指定您希望该函数执行什么操作。<br>在定义 DAO 时，您从上一个 Codelab 中学到的 SQL 知识将派上用场。</p><ul><li>为 Schedule 实体添加一个 DAO 类。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ScheduleDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加一条查询语句</li></ul><p>根据到达时间升序查询所有车次</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="meta-string">"SELECT * FROM schedule ORDER BY arrival_time ASC"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: List&lt;Schedule&gt;</span><br></pre></td></tr></table></figure><p>在增加一条条件查询语句<br>指定stop_name的查询</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="meta-string">"SELECT * FROM schedule WHERE stop_name = :stopName ORDER BY arrival_time ASC"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getByStopName</span><span class="params">(stopName: <span class="type">String</span>)</span></span>: List&lt;Schedule&gt;</span><br></pre></td></tr></table></figure><h2 id="异常情况记录"><a href="#异常情况记录" class="headerlink" title="异常情况记录"></a>异常情况记录</h2><ul><li>Room AppDatabase_Impl does not exist</li></ul><p>使用了 kotlin 构建了项目,并且使用 kotlin 编写 room 创建数据库,在 build.gradle 文件里做如下修改</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.android.library'</span></span><br><span class="line">    id <span class="string">'kotlin-android'</span></span><br><span class="line">    id <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">    id <span class="string">'kotlin-kapt'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略...</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api<span class="string">"android.arch.persistence.room:runtime:$rootProject.room_version"</span></span><br><span class="line">    kapt<span class="string">"android.arch.persistence.room:compiler:$rootProject.room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 annotationProcessor 替换成 kapt,请注意需要导入 id ‘kotlin-kapt’ 才能使用 kapt</p><p>参考地址：<a href="https://www.cnblogs.com/guanxinjing/p/14990401.html" target="_blank" rel="noopener">https://www.cnblogs.com/guanxinjing/p/14990401.html</a></p><p><a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/Room" target="_blank" rel="noopener">样例代码地址</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的使用场景是缓存相关的数据，这样一来，当设备无法访问网络时，用户仍然可以在离线状态下浏览该内容。&lt;/p&gt;
&lt;p&gt;Room 持久性库在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack DataSource</title>
    <link href="hexo/blog/2021/12/jetpack-DataSource.html"/>
    <id>hexo/blog/2021/12/jetpack-DataSource.html</id>
    <published>2021-12-22T10:29:42.000Z</published>
    <updated>2021-12-22T10:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。</p><p>DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。</p><ul><li>Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。</li><li>Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。&lt;/p&gt;
&lt;p&gt;DataStore 提供两种不同的实现：Preferences 
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack lifecycle</title>
    <link href="hexo/blog/2021/12/jetpack-lifecycle.html"/>
    <id>hexo/blog/2021/12/jetpack-lifecycle.html</id>
    <published>2021-12-22T03:08:25.000Z</published>
    <updated>2021-12-22T03:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 库中用来感知生命周期的组件</p><h2 id="使用生命周期感知型组件处理生命周期"><a href="#使用生命周期感知型组件处理生命周期" class="headerlink" title="使用生命周期感知型组件处理生命周期"></a>使用生命周期感知型组件处理生命周期</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。</p><p>一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。</p><p>androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p><p>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p><p><strong>事件</strong><br>从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。<br><strong>状态</strong><br>由 Lifecycle 对象跟踪的组件的当前状态</p><p><img src="../../../images/lifecycle.svg" style="zoom:60%"></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MainLifecycleObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainLifecycleObserver</span></span>() : LifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> TAG: String  = <span class="string">"MainLifecycleObserver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityCreated: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityResume: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityStopped: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，就可以實現在 Activity 之外獲取到生命週期的變化，避免在 Activity/Fragment 中的生命週期中寫大量業務代碼</p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>LifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。</p><p>此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。</p><p>实现 DefaultLifecycleObserver 的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p><h3 id="自定義-LifecycleOwner"><a href="#自定義-LifecycleOwner" class="headerlink" title="自定義 LifecycleOwner"></a>自定義 LifecycleOwner</h3><p>我們不只是可以綁定視圖的生命週期，可以通過 LifecycleOwner 自定義對應色生命週期<br>如當處於 Activity 的 onCreate、onStart 中都需執行 onStart</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), LifecycleOwner &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LifeCycle 组件实际上并没有带来什么新的功能，他通过观察者模式+注解来让我们更方便的监听 Activity 和 Fragment 的生命周期变化。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle 是 Jetpack 库中用来感知生命周期的组件&lt;/p&gt;
&lt;h2 id=&quot;使用生命周期感知型组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知型组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知型组件处理生命周期
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>kotlin学习指南一</title>
    <link href="hexo/blog/2021/12/kotlin%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80.html"/>
    <id>hexo/blog/2021/12/kotlin学习指南一.html</id>
    <published>2021-12-20T06:22:11.000Z</published>
    <updated>2021-12-22T00:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin 是 google 推出的一門新語言，也是基於 JVM 的。</p><h2 id="kotlin-基础"><a href="#kotlin-基础" class="headerlink" title="kotlin 基础"></a>kotlin 基础</h2><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>新建一个 kt 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主入口 main 方法， 无需新建类即可运行，函数声明用 fun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int, b:Int):Int&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值写在参数之后</p><p>表达式可以作为函数体，返回值类型自动推断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sun(a:Int, b:Int) = a+b;</span><br></pre></td></tr></table></figure><p>返回无意义的值用 Unit 表示</p><p>fun test():Unit {<br>println(“test”);<br>}</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>变量赋值声明关键字：var、val<br>var：声明变量<br>val：声明常量</p><p>var i:Int = 1;<br>val PI:Double = 3.14;</p><p>当声明并赋值时，数据类型可以省略, 会自动推断数据类型<br>var i = 1;<br>val PI = 3.14</p><p>当声明但不赋值时，不能省略数据类型<br>var i:Int;<br>val PI:Double;</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;aaaaa&quot;;</span><br><span class="line">var b = &quot;str = $s&quot;;</span><br><span class="line">var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testIf(a:Int, b:Int):Int &#123;</span><br><span class="line">    if(a &gt; b) return a;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kotlin 中，if 还可以用作表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun max(a:Int, b:Int) = if(a &gt; b) a else b</span><br></pre></td></tr></table></figure><h2 id="空值与-null-检测"><a href="#空值与-null-检测" class="headerlink" title="空值与 null 检测"></a>空值与 null 检测</h2><p>当某个值可以为空时，需要在类型后添加?表示可以为空<br>此时，声明时不能省略类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj:Objects ? = null;</span><br><span class="line">// 表示返回值可以为null</span><br><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型检测与自动类型转换"><a href="#类型检测与自动类型转换" class="headerlink" title="类型检测与自动类型转换"></a>类型检测与自动类型转换</h2><p>is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 </strong></p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);</span><br><span class="line">// 根据元素遍历</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据下标便利</span><br><span class="line">for (item in items.indices) &#123;</span><br><span class="line">    println(items[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = 0;</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(items[index]);</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when-表达式"><a href="#when-表达式" class="headerlink" title="when 表达式"></a>when 表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private fun testWhen(s: Any?) &#123;</span><br><span class="line">        when(s) &#123;</span><br><span class="line">            &quot;a&quot; -&gt; 1;</span><br><span class="line">            &quot;b&quot; -&gt; 2;</span><br><span class="line">            is String -&gt; 3;</span><br><span class="line">            1 -&gt; &quot;n&quot;;</span><br><span class="line">            2 -&gt; &#123;</span><br><span class="line">              println(&quot;222&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            else -&gt; &quot;else&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有点类似 java 中的 switch</p><h2 id="区间-range"><a href="#区间-range" class="headerlink" title="区间 range"></a>区间 range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = 9;</span><br><span class="line">if(x in 0..y) &#123;</span><br><span class="line">    println(&quot;x in 0 - y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间只用于数字</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的迭代可以用的上面的 for in 循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">for(item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断集合中是否包含某元素 用 while in || when</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (&quot;a&quot; in items) &#123;</span><br><span class="line">    println(&quot;items include a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when &#123;</span><br><span class="line">    &quot;a&quot; in items -&gt; println(&quot;aaa&quot;);</span><br><span class="line">    &quot;d&quot; in items -&gt; println(&quot;ddd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 lambda 来过滤和映射集合 ，与 java8 lambda stream 大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125;</span><br><span class="line">    .sortBy&#123; it &#125;</span><br><span class="line">    .map&#123; it.toUpperCase() &#125;</span><br><span class="line">    .forEach&#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>什么是协程？<br>官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。<br>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</p><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。<br>CPU 调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。<br>而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p><p>协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。</p><p>build.gralde 中引入依赖<br>implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1”</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity4 : AppCompatActivity() &#123;</span><br><span class="line">    val TAG = &quot;MainActivity4&quot;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main2)</span><br><span class="line">        test()</span><br><span class="line">        Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun test() = runBlocking &#123;</span><br><span class="line">        repeat(8) &#123;</span><br><span class="line">            Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>协程执行 0 线程 id：1<br>协程执行 1 线程 id：1<br>协程执行 2 线程 id：1<br>协程执行 3 线程 id：1<br>协程执行 4 线程 id：1<br>协程执行 5 线程 id：1<br>协程执行 6 线程 id：1<br>协程执行 7 线程 id：1<br>线程 main ：1</p><p>我们可以得出结论：<br>runBlocking 会阻塞线程，但允许还是在当前线程</p><h3 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch:Job"></a>launch:Job</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testJob() &#123;</span><br><span class="line">        val job = GlobalScope.launch &#123;</span><br><span class="line">            repeat(8) &#123;</span><br><span class="line">                delay(2000)</span><br><span class="line">                Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>testJob: 线程 main：2<br>testJob: 线程 id:6809<br>testJob: 线程 id:6807<br>testJob: 线程 id:6807<br>testJob: 线程 id:6815<br>testJob: 线程 id:6807<br>testJob: 线程 id:6808<br>testJob: 线程 id:6818<br>testJob: 线程 id:6809</p><p>说明使用 GlobalScope.launch</p><ul><li>并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务</li><li>是非阻塞、异步执行，相当于开启了子线程</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun testAsync()&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        var result1 = GlobalScope.async &#123;</span><br><span class="line">            getResult1()</span><br><span class="line">        &#125;</span><br><span class="line">        var result2 = GlobalScope.async &#123;</span><br><span class="line">            getResult2()</span><br><span class="line">        &#125;</span><br><span class="line">        val result = result1.await() + result2.await()</span><br><span class="line">        Log.e(TAG, &quot;testAsync: ThreadId =  $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult1():Int &#123;</span><br><span class="line">    delay(3000)</span><br><span class="line">    Log.e(TAG, &quot;getResult1: ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult2():Int &#123;</span><br><span class="line">    delay(5000)</span><br><span class="line">    Log.e(TAG, &quot;getResult2:  ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>E/MainActivity4: 线程 main ：2<br>E/MainActivity4: getResult1: ThreadId = 7870<br>E/MainActivity4: getResult2: ThreadId = 7870<br>E/MainActivity4: testAsync: ThreadId = 7870 result = 9</p><p>其中当打印 getResult2 后就打印了 testAsync: result = 9<br>阻塞时间为 5 秒，而不是 8 秒，说明 getResult1、getResult2 是并行的。</p><p>而且发现 threadId 都一样，说明处于同一个线程。<br>但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。</p><ul><li>协程并不等于线程，协程内部会根据任务情况自动调度线程。</li></ul><p>launch()有三个入参： 1.协程下上文；2.协程启动模式；3.协程体：block 是一个带接收者的函数字面量，接收者是 CoroutineScope</p><p>我们在线程中执行的代码就是第三个参数</p><h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>上下文可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，Kotlin 协程使用调度器来确定哪些线程用于协程执行，Kotlin 提供了调度器给我们使用：</p><p>Dispatchers.Main：使用这个调度器在 Android 主线程上运行一个协程。可以用来更新 UI 。在 UI 线程中执行</p><p>Dispatchers.IO：这个调度器被优化在主线程之外执行磁盘或网络 I/O。在线程池中执行</p><p>Dispatchers.Default：这个调度器经过优化，可以在主线程之外执行 cpu 密集型的工作。例如对列表进行排序和解析 JSON。在线程池中执行。</p><p>Dispatchers.Unconfined：在调用的线程直接执行。</p><p>调度器实现了 CoroutineContext 接口。</p><p>我们还可以自己自定义调度器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dis = Executors.newCachedThreadPool().asCoroutineDispatcher()</span><br><span class="line">runBlocking &#123;</span><br><span class="line">    launch(dis) &#123;</span><br><span class="line">        println(&quot;dis 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>在 Kotlin 协程当中，启动模式定义在一个枚举类中：</p><p>public enum class CoroutineStart {<br>DEFAULT,<br>LAZY,<br>@ExperimentalCoroutinesApi<br>ATOMIC,<br>@ExperimentalCoroutinesApi<br>UNDISPATCHED;<br>}<br>一共定义了 4 种启动模式，<br>DEFAULT: 默认的模式，立即执行协程体<br>LAZY: 只有在需要的情况下运行<br>ATOMIC: 立即执行协程体，但在开始运行之前无法取消<br>UNDISPATCHED :立即在当前线程执行协程体，直到第一个 suspend 调用</p><h3 id="协程体"><a href="#协程体" class="headerlink" title="协程体"></a>协程体</h3><p>协程体是一个用 suspend 关键字修饰的一个无参，无返回值的函数类型。被 suspend 修饰的函数称为挂起函数,与之对应的是关键字 resume（恢复）<br>注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>Kotlin 的硬关键宇包括:</p><p>as 一一 用于做类型转换或为 import 语句指定别名<br>as?一一类型安全 的类型转换运算符。<br>break 一一中断循环<br>class 一一声明类。<br>continue 一忽略本次循环剩下的语句，重新开始下一次循环。<br>do 一一用于 do while 循环<br>else 一一在 if 分支中使用<br>false 一一在 Boolean 类型中表示假 的直接量。<br>for 一一用于 for 循环<br>fun 一一声 明函数<br>if－在 if 分支中使用<br>in 一一在 for 循环中使用； in 还可作为双目运算符，检查 一个值是否处于区间或集合 内；<br>in 也可 在 when 表达式中使用； in 还可用于修饰泛型参数，表明该泛型参数支持逆变<br>!in 一一可作为双目运算符 的反义词：！in 也可在 when 表达式中使用<br>is 一一用于做类型检查（类 Java instanceof) 或在 when 表达式中使用<br>!is 一一 用于做类型检查（ is 的反义词〉或在 when 表达式中使用<br>null 一一 代表空的直接量。<br>object ——用于声明对象表达式或定义命名对象<br>package 一一用于为当 前文件指定包<br>return 一一声明函数的返回<br>super 一－用于引用父类实现的方法或属性，或者在子类构造器中调用父类构造器<br>this 一一 代表当前类的对象或在构造器中调用当前类的其他构造器<br>throw 一一用于抛出异常<br>true 一一在 Boolean 类型中表示真的直接量。<br>try 一一开始异常处理<br>typealias 一一用于定义类型别名。<br>val 一声明只读属性或变量。<br>var 一一声明可变属性或变量。<br>when 一一用于 when 表达式。while 一一－用于 while 循环或 do while 循环</p><p>Kotlin 的软关键宇包括：</p><p>by 一一用于将接口或祖先类的实现代理给其他对象。<br>catch 一一在异常处理中用于捕捉异常<br>constructor 一一用于声明构造器。<br>delegate 一用于指定该注解修饰委托属性存储其委托实例的字段<br>dynamic 一一主要用于在 Kotlin/JavaScript 中引用 一个动态类型<br>field 一一用于指定该注解修饰属性的幕后字段。<br>file 一一用于指定该注解修饰该源文件本身<br>finally 一一异常处理中的 finally<br>get 一一用于声明属性的 getter 方法，或者用于指定该注解修饰属性的 getter 方法<br>import 一一用于导包。<br>init 一一用于声明初始化块<br>param 一一用于指定该注解修饰构造器参数<br>property 一一用于指定该注解修饰整个属性（这种目标的注解对 Java 不可见，因为 Java<br>并没有真正的属性）。<br>receiveris 一一用于指定该注解修饰扩展方法或扩展属性的接收者<br>set 一一用于声明属性的 setter 方法，或者用于指定该注解修饰属性的 setter 方法<br>setparam 一一用于指定该注解修饰 setter 方法的参数<br>where 一一用于为泛型参数增加限制。</p><p>Kotlin 的修饰符关键宇包括：</p><p>abstract 一一用于修饰抽象类或抽象成员<br>annotation 一一用于修饰一个注解类。<br>companion 一一用于声明一个伴生对象<br>const 一一用于声明编译时常量<br>crossinline 一一用于禁止在传给内联函数的 Lambd 表达式中执行非局部返回<br>data 一一用于声明数据类。<br>enum 一一用于声明枚举<br>external 一一用于声明某个方法不由 Kotlin 实现（与 Java 的 native 相似〉。<br>final 一一用于禁止被重写<br>infix 一一声明该函数能以双目运算符的格式执行<br>inline 一一用于声明内联函数， Lambda 表达式可在内联函数中执行局部返回。<br>inner 一一用于声明内部类，内部类可以访问外部类的实例<br>internal 一一用于表示被修饰的声明只能在当前模块内可见<br>lateinit——-用于修饰 non-null 属性，用于指定该属性可在构造器以外的地方<br>初始化<br>noinline 一一用于禁止内联函数中个别 Lambda 表达式被内联化<br>open 一一用于修饰类，表示该类可派生子类；或者用于修饰成员，表示该成员可以被<br>重写。<br>out 一一用于修饰泛型参数，表明该泛型参数支持协变。<br>override 一一用于声明重写父类的成员<br>private ——private 访问权限<br>protected ——–protected 访问权限<br>public——-public 访问权限。<br>reified 一一用于修饰内联函数中的泛型形参，接下来在该函数中就可像使用普通类型<br>一样使用该类型参数。<br>sealed 一一用于声明一个密封类。<br>suspend 一一用于标识一个函数后 Lambda 表达式可作为暂停。<br>tailrec 一一用于修饰一个函数可作为尾随递归函数使用。<br>vararg 一一用于修饰形参，表明该参数是个数可变的形参。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;kotlin 是 google 推出的一門新語言，也是基於 JVM 的。&lt;/p&gt;
&lt;h2 id=&quot;kotlin-基础&quot;&gt;&lt;a href=&quot;#kotlin-基础&quot; class=&quot;headerlink&quot; title=&quot;kotlin 基础&quot;&gt;&lt;/a&gt;kotlin 基础&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="kotlin" scheme="hexo/tags/kotlin/"/>
    
  </entry>
  
</feed>
