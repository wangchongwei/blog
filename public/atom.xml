<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Happy To Try</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2020-05-13T07:41:22.551Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm 线程私有区</title>
    <link href="hexo/blog/2020/05/jvm-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA.html"/>
    <id>hexo/blog/2020/05/jvm-线程私有区.html</id>
    <published>2020-05-13T06:33:03.000Z</published>
    <updated>2020-05-13T07:41:22.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm-线程私有区"><a href="#jvm-线程私有区" class="headerlink" title="jvm 线程私有区"></a>jvm 线程私有区</h1><p>jvm从多线程角度看，分为线程共享区、线程私有区</p><p>而在线程私有区中有：程序计数器、方法栈区（包括虚拟机栈、本地方法栈）</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响</p><p>jvm的多线程是通过cpu时间片轮转算法实现的，某个线程在执行过程中会因为时间片耗尽而被挂起，其他线程获得时间片开始执行。当被挂起的线程重新获取到<br>时间片，它要想从之前被挂起的地方开始执行，就需要知道之前执行到了哪里，在jvm中，通过程序计数器来记录字节码执行的位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。</p><h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><p>1、线程隔离：每个线程都有自己的程序计数器<br>2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址<br>3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。<br>4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。<br>5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。</p><h2 id="方法栈区"><a href="#方法栈区" class="headerlink" title="方法栈区"></a>方法栈区</h2><p>线程在运行时，在执行每一个方法的时候都会打包成一个栈帧，然后将栈帧入栈，当方法执行完时，就会将该栈帧出栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。</p><p>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p><h2 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h2><p>栈帧中含有：局部变量表、操作数据栈、动态链接、返回地址</p><p>局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。<br>操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作<br>动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）<br>返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jvm-线程私有区&quot;&gt;&lt;a href=&quot;#jvm-线程私有区&quot; class=&quot;headerlink&quot; title=&quot;jvm 线程私有区&quot;&gt;&lt;/a&gt;jvm 线程私有区&lt;/h1&gt;&lt;p&gt;jvm从多线程角度看，分为线程共享区、线程私有区&lt;/p&gt;
&lt;p&gt;而在线程私有区中有：
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 锁</title>
    <link href="hexo/blog/2020/05/java-%E9%94%81.html"/>
    <id>hexo/blog/2020/05/java-锁.html</id>
    <published>2020-05-07T02:42:32.000Z</published>
    <updated>2020-05-07T09:38:54.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中使用锁，主要是用于解决多线程并发问题"><a href="#java中使用锁，主要是用于解决多线程并发问题" class="headerlink" title="java中使用锁，主要是用于解决多线程并发问题"></a>java中使用锁，主要是用于解决多线程并发问题</h1><p>多个线程对某个对象进行操作，就存在并发问题。</p><p>java内存规定了，所有变量都储存在主内存中，每个线程又有自己的工作内存</p><p>线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存</p><p>线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。</p><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><h2 id="并发三要素"><a href="#并发三要素" class="headerlink" title="并发三要素"></a>并发三要素</h2><p>原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。</p><p>可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行。</p><h2 id="解决并发问题"><a href="#解决并发问题" class="headerlink" title="解决并发问题"></a>解决并发问题</h2><h3 id="volatile：保证可见性，不保证原子性"><a href="#volatile：保证可见性，不保证原子性" class="headerlink" title="volatile：保证可见性，不保证原子性"></a>volatile：保证可见性，不保证原子性</h3><p>当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中</p><p>这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见</p><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则</p><p>不会对存在依赖关系的指令重排序，例如 a = 1;b = a; a 和b存在依赖关系，不会被重排序</p><p>不能影响单线程下的执行结果。比如：a=1;b=2;c=a+b这三个操作,前两个操作可以重排序，但是c=a+b不会被重排序，因为要保证结果是3</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对于一个变量，单个线程写，其他线程读，这个时候就可以使用volatile来修饰这个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Utils &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Utils instance;</span><br><span class="line"></span><br><span class="line">    public static Utils getInstance() &#123;         // 1</span><br><span class="line">        if(instance == null) &#123;                  // 2</span><br><span class="line">            synchronized(Utils.class) &#123;         // 3</span><br><span class="line">                if(instance == null) &#123;          // 4</span><br><span class="line">                    instance = new Utils();     // 5</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个对象有如下步骤：<br>分配内存，<br>初始化对象，<br>指向内存</p><p>如上代码，如果不使用volatile修饰，这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，<br>并且执行到注释2，这时候判断instance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。</p><h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><p>在jvm底层，volatile是通过内存屏障来实现的，内存屏障会提供三个功能：</p><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>它会强制将缓存的修改操作立即写到主内存</p><p>写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。</p><h3 id="valatile局限性"><a href="#valatile局限性" class="headerlink" title="valatile局限性"></a>valatile局限性</h3><p>volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>多个线程同时写一个变量<br>这个时候使用Synchronized，可以保证同一时刻，只有一个线程可执行某个方法或某个代码块</p><h3 id="Synchronized锁升级"><a href="#Synchronized锁升级" class="headerlink" title="Synchronized锁升级"></a>Synchronized锁升级</h3><p>Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。</p><p><strong><em> 偏向锁 </em></strong>：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><pre><code>当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。</code></pre><p><strong><em> 轻量级锁 </em></strong>：在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。</p><p><strong><em> 重量级锁 </em></strong>：如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。</p><h3 id="Synchromized缺陷"><a href="#Synchromized缺陷" class="headerlink" title="Synchromized缺陷"></a>Synchromized缺陷</h3><p>不能设置锁超时时间<br>不能通过代码释放锁<br>容易造成死锁</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>上面说到Synchronized的缺点，不能设置锁超时时间和不能通过代码释放锁，ReentranLock就可以解决这个问题</p><p><strong><em> 在多个条件变量和高度竞争锁的地方 </em></strong> ， 用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性</p><p>原文地址(<a href="https://www.jianshu.com/p/4eec21c3338e" target="_blank" rel="noopener">https://www.jianshu.com/p/4eec21c3338e</a>)</p><p>JVM内存模型、指令重排、内存屏障概念解析(<a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangyao/p/5269622.html</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中使用锁，主要是用于解决多线程并发问题&quot;&gt;&lt;a href=&quot;#java中使用锁，主要是用于解决多线程并发问题&quot; class=&quot;headerlink&quot; title=&quot;java中使用锁，主要是用于解决多线程并发问题&quot;&gt;&lt;/a&gt;java中使用锁，主要是用于解决多
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 内存结构</title>
    <link href="hexo/blog/2020/01/java-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
    <id>hexo/blog/2020/01/java-内存结构.html</id>
    <published>2020-01-13T08:15:01.000Z</published>
    <updated>2020-01-13T10:34:24.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-内存结构"><a href="#java-内存结构" class="headerlink" title="java 内存结构"></a>java 内存结构</h1><p>首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。<br><img src="../../../images/java.jpg" style="zoom:20%"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器： 主要功能是记录当前线程执行程序的位置，通过改变计数值来确定执行下一条指令。每个线程的创建，都会创建一个程序计数器，并且对于每个线程而言是互相独立的。比如我们在debuger模式下运行，for循环的停止，异常的抛出，都是通过改变该线程对应的计数值来确定下一个执行指令。</p><h2 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h2><p>java虚拟机栈：主要功能是临时存储线程执行到的每个方法需要的参数，其内存空间在编译时就已确定。与程序计数器一样，每创建一个线程，则创建一个虚拟机栈，线程每执行到一个方法，对应的栈里就会创建一个栈帧，栈帧会存储局部变量表、动态链接、操作数和方法出口等信息，执行方法，栈帧入栈，方法执行完，栈帧出栈。</p><p><img src="../../../images/gc_class.jpg" style="zoom:20%"></p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与java虚拟机栈一样，只是记录native方法执行。jni native调用的c、c++函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-内存结构&quot;&gt;&lt;a href=&quot;#java-内存结构&quot; class=&quot;headerlink&quot; title=&quot;java 内存结构&quot;&gt;&lt;/a&gt;java 内存结构&lt;/h1&gt;&lt;p&gt;首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>算法（1）简单算法</title>
    <link href="hexo/blog/2020/01/%E7%AE%97%E6%B3%95.html"/>
    <id>hexo/blog/2020/01/算法.html</id>
    <published>2020-01-06T07:49:28.000Z</published>
    <updated>2020-01-13T10:07:11.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法（1）简单算法"><a href="#算法（1）简单算法" class="headerlink" title="算法（1）简单算法"></a>算法（1）简单算法</h1><p>简单常见算法</p><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>针对有序的数据集，每次查找时都取中间值，逐步缩小查找范围，最后获取到目标值</p><p>复杂度：$O(log_n)$</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是针对数组的一种排序算法。<br>过程：遍历数组，计算出最值，新建一个数组，将最值放入新数组,</p><p>复杂度：$O(n^2)$</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归指函数在内部调用本身，<br>使用递归注意两个条件：基线条件、递归条件。<br>基线条件：跳出递归的条件<br>递归条件：对递归元素逐步减少的条件，<br>要合理利用这两点，不然容易无限循环。</p><p>在数组中取最大值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function findMax(arr) &#123;</span><br><span class="line">    let max = 0;</span><br><span class="line">    if(arr.length === 0) &#123;</span><br><span class="line">        return max;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        max = arr[0] &gt; max ? arr[0] : max;</span><br><span class="line">        arr.splice(0, 1);</span><br><span class="line">        return findMax(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">findMax(arr);</span><br></pre></td></tr></table></figure></p><p>递归算法与数据结构中的 栈 是及其相似的。<br>已上面的算法为例，<br>调用findMax([1,2,3,4,5])时，将findMax([1,2,3,4,5])压入栈顶，<br>而findMax会调用findMax([2,3,4,5]),然后将findMax([2,3,4,5])压入栈,<br>如下图所示：<br><img src="../../../images/recursion.jpg" style="zoom:20%"></p><p>然后从栈顶依次得出计算结果出栈。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法（1）简单算法&quot;&gt;&lt;a href=&quot;#算法（1）简单算法&quot; class=&quot;headerlink&quot; title=&quot;算法（1）简单算法&quot;&gt;&lt;/a&gt;算法（1）简单算法&lt;/h1&gt;&lt;p&gt;简单常见算法&lt;/p&gt;
&lt;h2 id=&quot;二分查找法&quot;&gt;&lt;a href=&quot;#二分查找法&quot;
      
    
    </summary>
    
    
      <category term="算法" scheme="hexo/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 (1)</title>
    <link href="hexo/blog/2020/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.html"/>
    <id>hexo/blog/2020/01/数据结构-1.html</id>
    <published>2020-01-03T09:27:20.000Z</published>
    <updated>2020-01-08T09:44:33.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-1-简单数据"><a href="#数据结构-1-简单数据" class="headerlink" title="数据结构 (1) - 简单数据"></a>数据结构 (1) - 简单数据</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组：有序、内存连续的数据集，</p><p>数组是有序的，顺序就是插入的顺序，先插入的值排在前面，<br>内存连续：在内存分配时，数组中的值的内存空间是分配在一起的<br>所以在我们使用数组时，推荐在申明时申明数组的长度，不然在后续插入值时可能会导致之前的数据内存空间不够，需要重新分配整个数据内存空间</p><p>数组的索引就是数组中值的下标：从0开始计数。<br>数组的查找通过索引，所以快。<br>而增删、修改时，当插入一个值，则需要将后面的数据都后移，删除也是类似。</p><p>数组查询快，增删慢<br>查询：O(1)<br>增删：O(n)<br>修改：O(n)</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表：无序、内存非连续、每个节点都具有下一个节点的地址</p><p>链表是无序的，内存非连续，因为每一个节点都含有下一个节点的地址，<br>相比于数组，内存非连续，则当数据增多，也不会存在内存空间的问题，因为只需随便分配下一个节点的内存，然后将上一个节点的中含有的下一个节点地址指向最新分配的地址即可。</p><p>链表数据第一个、最后一个节点的值是明确的。<br>因为链表是无序的。所以查询慢，因为想要获取一个节点的值，需要先获取上一个节点，通过上一个节点获取到下一个节点的地址。</p><p>查询：O(n)<br>增删：O(1)<br>修改：O(1)</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种只允许在一端进行插入或删除的线性表</p><p>栈的操作只有两种：出栈、进栈<br>特点：先进后出(FILO:first in last out)</p><p>只允许对栈顶的元素操作。<br>最先进入的元素将会被压入栈底</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-1-简单数据&quot;&gt;&lt;a href=&quot;#数据结构-1-简单数据&quot; class=&quot;headerlink&quot; title=&quot;数据结构 (1) - 简单数据&quot;&gt;&lt;/a&gt;数据结构 (1) - 简单数据&lt;/h1&gt;&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构" scheme="hexo/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>android 贝塞尔曲线</title>
    <link href="hexo/blog/2020/01/android-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF.html"/>
    <id>hexo/blog/2020/01/android-贝塞尔曲线.html</id>
    <published>2020-01-03T08:46:06.000Z</published>
    <updated>2020-01-03T08:46:26.266Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android-自定义View-继承EditText</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFEditText.html"/>
    <id>hexo/blog/2019/12/android-自定义View-继承EditText.html</id>
    <published>2019-12-19T09:59:28.000Z</published>
    <updated>2019-12-30T10:08:03.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-自定义View-继承EditText"><a href="#android-自定义View-继承EditText" class="headerlink" title="android-自定义View-继承EditText"></a>android-自定义View-继承EditText</h1><p>一直觉得flutter中的输入框效果不错。<br>动画，提示标题都有。<br>这次要通过自定义View, 继承重写EditText来实现同样的输入框效果</p><p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>首先确定大致思路<br>两个元素：TextView、EditText，TextView为标题，EditText为输入框展示<br>当未获取焦点时：<br>1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部<br>2、输入框如果没有输入的内容，则输入框展示的提示文本<br>当获取焦点时：<br>不管有无输入内容，提示文本缩小在输入框上部</p><p>TextView并非实质组件，只是绘制Text，当作TextView。</p><h3 id="1、先写一个类继承AppCompatEditText，并实现构造函数"><a href="#1、先写一个类继承AppCompatEditText，并实现构造函数" class="headerlink" title="1、先写一个类继承AppCompatEditText，并实现构造函数"></a>1、先写一个类继承AppCompatEditText，并实现构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AnimatedInput extends AppCompatEditText &#123;</span><br><span class="line"></span><br><span class="line"> public AnimatedInput(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnimatedInput(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initView(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initView(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、重写onFocusChanged函数"><a href="#2、重写onFocusChanged函数" class="headerlink" title="2、重写onFocusChanged函数"></a>2、重写onFocusChanged函数</h3><p>这样获取到 是否获取焦点的标识位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123;</span><br><span class="line">        super.onFocusChanged(focused, direction, previouslyFocusedRect);</span><br><span class="line">        isFocus = focused;</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、重写onTextChanged函数"><a href="#3、重写onTextChanged函数" class="headerlink" title="3、重写onTextChanged函数"></a>3、重写onTextChanged函数</h3><p>这样获取到输入框的内容value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123;</span><br><span class="line">        super.onTextChanged(text, start, lengthBefore, lengthAfter);</span><br><span class="line">        value = text.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="4、绘制提示文本"><a href="#4、绘制提示文本" class="headerlink" title="4、绘制提示文本"></a>4、绘制提示文本</h3><p>这时候要分情况，即是否获取焦点、输入框是否有内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸</span><br><span class="line">    int width = getMeasuredWidth();</span><br><span class="line">    int height = getMeasuredHeight();</span><br><span class="line">    top = getPaddingTop();</span><br><span class="line">    left = getPaddingLeft();</span><br><span class="line">    right = width - left - getPaddingRight();</span><br><span class="line">    bottom = height - top;</span><br><span class="line">    drawTitle(canvas);</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 绘制标题</span><br><span class="line"> * @param canvas</span><br><span class="line"> */</span><br><span class="line">private void drawTitle(Canvas canvas) &#123;</span><br><span class="line">    if(TextUtils.isEmpty(value)) &#123;</span><br><span class="line">        if(isFocus) &#123;</span><br><span class="line">            canvas.drawText(title, left, top + 20, focusTitlePaint);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        canvas.drawText(title, left, top + 20, focusTitlePaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如此就基本实现了我们的预期目标。<br>这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-自定义View-继承EditText&quot;&gt;&lt;a href=&quot;#android-自定义View-继承EditText&quot; class=&quot;headerlink&quot; title=&quot;android-自定义View-继承EditText&quot;&gt;&lt;/a&gt;android-
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android-自定义View 继承ViewGroup</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFViewGroup.html"/>
    <id>hexo/blog/2019/12/android-自定义View-继承ViewGroup.html</id>
    <published>2019-12-12T07:13:45.000Z</published>
    <updated>2019-12-19T10:02:04.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-自定义View-继承ViewGroup"><a href="#android-自定义View-继承ViewGroup" class="headerlink" title="android 自定义View 继承ViewGroup"></a>android 自定义View 继承ViewGroup</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-自定义View-继承ViewGroup&quot;&gt;&lt;a href=&quot;#android-自定义View-继承ViewGroup&quot; class=&quot;headerlink&quot; title=&quot;android 自定义View 继承ViewGroup&quot;&gt;&lt;/a&gt;andro
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 自定义View 继承View</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFView.html"/>
    <id>hexo/blog/2019/12/android-自定义View-继承View.html</id>
    <published>2019-12-11T01:47:36.000Z</published>
    <updated>2019-12-19T09:44:13.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-自定义View-继承View"><a href="#android-自定义View-继承View" class="headerlink" title="android 自定义View 继承View"></a>android 自定义View 继承View</h1><p><a href="android-自定义View.html">上篇关于自定义View的介绍</a><br>接下来将会针对自定义View三种情况一一实现。</p><p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>最后实现效果如下图：</p><p><img src="../../../images/custom_view_final.jpg" style="zoom:20%"></p><h2 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h2><p>创建一个class MyView 继承View</p><p>目标是写一个折线图</p><p>现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;declare-styleable name=&quot;LineView&quot;&gt;</span><br><span class="line">        &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">        &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="先新建一个clas-继承View，-并初始化几个构造函数"><a href="#先新建一个clas-继承View，-并初始化几个构造函数" class="headerlink" title="先新建一个clas 继承View， 并初始化几个构造函数"></a>先新建一个clas 继承View， 并初始化几个构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyView extends View &#123;</span><br><span class="line">    // 代码生成时，才会调用该构造函数</span><br><span class="line">     public MyView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    // xml配置时，会调用这个生命周期</span><br><span class="line">    public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initData(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。</span><br><span class="line">    private void initData(AttributeSet attrs) &#123;</span><br><span class="line">         Log.d(TAG, &quot;initData: &quot;);</span><br><span class="line">        // 获取xml中配置的数据</span><br><span class="line">        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView);</span><br><span class="line">        paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black));</span><br><span class="line"></span><br><span class="line">        // 画笔初始化</span><br><span class="line">        paint = new Paint();</span><br><span class="line">        paint.setColor(context.getResources().getColor(R.color.black));</span><br><span class="line">        paint.setTextSize(40);</span><br><span class="line">        paint.setStrokeWidth(10); // 线条粗细</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在onMeasure函数中对尺寸做约束"><a href="#在onMeasure函数中对尺寸做约束" class="headerlink" title="在onMeasure函数中对尺寸做约束"></a>在onMeasure函数中对尺寸做约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    Log.d(TAG, &quot;onMeasure: &quot;);</span><br><span class="line">    int height = measuretDimension(defaultHeight, heightMeasureSpec);</span><br><span class="line">    int width = measuretDimension(0, widthMeasureSpec);</span><br><span class="line">    top = 0;</span><br><span class="line">    left = 0;</span><br><span class="line">    bottom = top + height;</span><br><span class="line">    right = left + width;</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测量实际尺寸</span><br><span class="line"> * @param defaultSize: 默认尺寸</span><br><span class="line"> * @param measureSpec: 测量规格</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int measureDimension(int defaultSize, int measureSpec) &#123;</span><br><span class="line">    int resultSize = defaultSize;</span><br><span class="line">    int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        // 没有做限制，取默认值</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            resultSize = defaultSize;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // WRAP</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            // 要取默认值和测量值中较小值</span><br><span class="line">            // 当默认值为0时，取最大值, 即宽充满屏幕</span><br><span class="line">            resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // 具体值 或 MATCH</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            resultSize = specSize;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先绘制两个轴线"><a href="#先绘制两个轴线" class="headerlink" title="先绘制两个轴线"></a>先绘制两个轴线</h3><p>注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。<br>这两个里的坐标不要弄混。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制两条轴线 */</span><br><span class="line">private void drawXY(Canvas canvas) &#123;</span><br><span class="line">    Log.d(TAG, &quot;drawXY: &quot;);</span><br><span class="line">    // 绘制x轴</span><br><span class="line">    canvas.drawLine(left + 20, bottom, right, bottom, paint);</span><br><span class="line">    // 绘制y轴</span><br><span class="line">    canvas.drawLine(left + 20, top, left + 20, bottom, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity中配置该视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.justin.customview.MyView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot;</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        app:axieColor=&quot;@color/black&quot;</span><br><span class="line">        android:id=&quot;@+id/myView&quot;</span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p><p>我们直接运行,效果如下：<br><img src="../../../images/view.jpg" style="zoom:20%"></p><p>x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。<br>新增一个方法初始化这些尺寸数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尺寸数据初始化</span><br><span class="line"> */</span><br><span class="line">private void initSize () &#123;</span><br><span class="line">    // 获取padding尺寸</span><br><span class="line">    paddingLeft = getPaddingLeft();</span><br><span class="line">    paddingTop = getPaddingTop();</span><br><span class="line">    paddingRight = getPaddingRight();</span><br><span class="line">    paddingBottom = getPaddingBottom();</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&quot;paddingLeft =&quot;).append(paddingLeft)</span><br><span class="line">            .append(&quot;paddingTop =&quot;).append(paddingTop)</span><br><span class="line">            .append(&quot;paddingRight =&quot;).append(paddingRight)</span><br><span class="line">            .append(&quot;paddingBottom =&quot;).append(paddingBottom);</span><br><span class="line">    Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString()));</span><br><span class="line">    top = paddingTop;</span><br><span class="line">    left = paddingLeft;</span><br><span class="line">    bottom = height - top - paddingBottom;</span><br><span class="line">    right = width - left;</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就对padding做了处理，接下来接着绘制我们需要的图形。<br>我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void drawArrow(Canvas canvas) &#123;</span><br><span class="line">    Path path = new Path();</span><br><span class="line">    // 先绘制x轴三角</span><br><span class="line">    //先移动到三角形一个点</span><br><span class="line">    path.moveTo(right-20, bottom + 20);</span><br><span class="line">    path.lineTo(right-20, bottom - 20); // 画线</span><br><span class="line">    path.lineTo(right, bottom); // 画线</span><br><span class="line">    path.close(); // 图形闭合</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">    // 绘制y轴三角</span><br><span class="line">    path.moveTo(left - 20, top + 20);</span><br><span class="line">    path.lineTo(left + 20, top + 20);</span><br><span class="line">    path.lineTo(left, top);</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。</p><h3 id="设置数据并绘制点"><a href="#设置数据并绘制点" class="headerlink" title="设置数据并绘制点"></a>设置数据并绘制点</h3><p>我们已经完成了绘制两条轴线，现在要开始绘制数据了。<br>首先我们要确认标准线，x轴的标准线肯定就是xValue的值，<br>但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。<br>我们先假设我们的值在0-100以内，取5条标准线，每条间距20.</p><p>先设置两个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数据</span><br><span class="line">   private float[] yValue;</span><br><span class="line">   private String[] xValue;</span><br><span class="line">   private int lineNum = 5;</span><br><span class="line"></span><br><span class="line">   /** 设置数据并刷新 */</span><br><span class="line">   public void setData(float[]yValue, String[]xValue) &#123;</span><br><span class="line">       this.yValue = yValue;</span><br><span class="line">       this.xValue = xValue;</span><br><span class="line">       postInvalidate();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** 设置标准线数目 */</span><br><span class="line">   public void setData(int lineNum) &#123;</span><br><span class="line">       this.lineNum = lineNum;</span><br><span class="line">       postInvalidate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>然后我们开始绘制标准线、各个点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制各个点 */</span><br><span class="line">private void drawPoint(Canvas canvas) &#123;</span><br><span class="line">    if(xValue == null || yValue == null) return;</span><br><span class="line">    // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。</span><br><span class="line">    float maxHeight = (float)((bottom - top) * 0.9);</span><br><span class="line">    float itemHeight = maxHeight / 5;</span><br><span class="line">    for(int i = 1; i &lt;=5; i ++) &#123;</span><br><span class="line">        canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint);</span><br><span class="line">    &#125;</span><br><span class="line">    // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值</span><br><span class="line">    float maxWidth = (float)((right - left) * 0.9);</span><br><span class="line">    float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length;</span><br><span class="line">    for (int i = 1; i &lt;= xValue.length; i ++) &#123;</span><br><span class="line">        float x = left + itemWidth * i;</span><br><span class="line">                // 绘制轴线</span><br><span class="line">        canvas.drawLine(x, bottom, x, bottom - 15, paint);</span><br><span class="line">        // 绘制点</span><br><span class="line">        float y = bottom - maxHeight * yValue[i-1] / yMax;</span><br><span class="line">        canvas.drawCircle(x, y, 5, paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在MainActivity.kt中，我们可以这样使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// kotlin语法</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;)</span><br><span class="line">        var yValue = floatArrayOf(70f, 80f, 90f);</span><br><span class="line">        myView.setData(yValue, xValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的实现效果：</p><p><img src="../../../images/chat.jpg" style="zoom:20%"></p><p>现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些</p><h3 id="绘制x、y轴标准线值，将各个点连接起来。"><a href="#绘制x、y轴标准线值，将各个点连接起来。" class="headerlink" title="绘制x、y轴标准线值，将各个点连接起来。"></a>绘制x、y轴标准线值，将各个点连接起来。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制各个点 */</span><br><span class="line">    private void drawPoint(Canvas canvas) &#123;</span><br><span class="line">        if(xValue == null || yValue == null) return;</span><br><span class="line">        // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。</span><br><span class="line">        float maxHeight = (float)((bottom - top) * 0.9);</span><br><span class="line">        float itemHeight = maxHeight / 5;</span><br><span class="line">        int itemValue = yMax / 5;</span><br><span class="line">        for(int i = 1; i &lt;=5; i ++) &#123;</span><br><span class="line">            canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint);</span><br><span class="line">            // 绘制y轴标准值</span><br><span class="line">            canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值</span><br><span class="line">        float maxWidth = (float)((right - left) * 0.9);</span><br><span class="line">        float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length;</span><br><span class="line">        for (int i = 1; i &lt;= xValue.length; i ++) &#123;</span><br><span class="line">            float x = left + itemWidth * i;</span><br><span class="line">                    // 绘制轴线</span><br><span class="line">            canvas.drawLine(x, bottom, x, bottom - 15, paint);</span><br><span class="line">            // 绘制点</span><br><span class="line">            float y = bottom - maxHeight * yValue[i-1] / yMax;</span><br><span class="line">            canvas.drawCircle(x, y, 10, paint);</span><br><span class="line"></span><br><span class="line">            // 绘制点与点之间的连线</span><br><span class="line">            if(lastX &gt; 0f) &#123;</span><br><span class="line">                canvas.drawLine(lastX, lastY, x, y, paint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 绘制x轴标准值</span><br><span class="line">            canvas.drawText(xValue[i-1], x, bottom + 50, paint);</span><br><span class="line"></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后实现效果如下图：</p><p><img src="../../../images/custom_view_final.jpg" style="zoom:20%"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-自定义View-继承View&quot;&gt;&lt;a href=&quot;#android-自定义View-继承View&quot; class=&quot;headerlink&quot; title=&quot;android 自定义View 继承View&quot;&gt;&lt;/a&gt;android 自定义View 继承Vi
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 自定义View</title>
    <link href="hexo/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View.html"/>
    <id>hexo/blog/2019/12/android-自定义View.html</id>
    <published>2019-12-10T07:42:49.000Z</published>
    <updated>2019-12-10T10:07:35.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-自定义View"><a href="#Android-自定义View" class="headerlink" title="Android 自定义View"></a>Android 自定义View</h1><p>自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。</p><p>首页android自定义View有三种类型，<br>1、继承View，多用于实现一些不规则的图形。</p><p>2、继承特定的组件，如TextView，</p><p>3、继承ViewGroup，用于视图组</p><p>在自定义View中有三个关键的方法：<br>onMeasure、onLayout、onDraw</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>测量，<br>ViewGroup 会遍历测量子视图的onMeasure方法。<br>一般view 则是在测量自身。</p><p>在这个方法中，一般是对视图的尺寸做一些要求。<br>如：处理padding、处理wrap_parent</p><p>margin是无需处理的，margin其实是在父容器的onMeasure时处理的。</p><p>在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent</p><p>onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。<br>这两个参数都是父容器传递过来。</p><p>视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec</p><h3 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h3><p>我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：<br>android:layout_width = “wrap_parent | 50dp | match_parent”<br>存在三种情况，<br>wrap_parent： 自适应大小，<br>50dp: 具体尺寸<br>match_parent: 充满父容器-父容器大小</p><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>测量规格，MeasureSpec由size和mode组成</p><p>1.static int getMode(int measureSpec): // 获取mode<br>2.static int getSize(int measureSpec):// 获取size<br>3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec</p><p>specMode存在三种情况:<br>EXACTLY:<br>具体尺寸、具体值<br>AT_MOST：<br>表示子视图最多只能是specSize中指定的大小<br>UNSPECIFIED：<br>可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。</p><p>size：<br>就是LayputParams中指定的大小</p><p>而子视图的大小也就是通过size和specMode获取的，具体关系如下图：</p><table><thead><tr><th></th><th>EXACTLY</th><th>AT_MOST</th><th>UNSPECIFIED</th><th>&lt;-MeasureSpec</th></tr></thead><tbody><tr><td>wrap_parnet</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>match_parent</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>50dp</td><td>50dp</td><td>50dp</td><td>50dp</td><td></td></tr><tr><td>^LayoutParams</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸</p><p>下面会讲具体使用</p><h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><p>布局方法</p><p>在调用onLayout时，onMeasure已经完成，<br>子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。<br>在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>绘制的方法<br>onDraw是在容器的draw方法时调用的。<br>而绘制的顺序为：<br>1.绘制背景<br>2.如果有必要，保存画布的图层，以准备失效<br>3.绘制视图的内容<br>4.绘制子控件<br>5.如果必要，绘制衰落边缘和恢复层<br>6.绘制装饰（比如滚动条）</p><p>onDraw 有一个参数(Canvas cancas),<br>canvas 就是画布，画布的范围就是onLayout布局后确定的区域</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-自定义View&quot;&gt;&lt;a href=&quot;#Android-自定义View&quot; class=&quot;headerlink&quot; title=&quot;Android 自定义View&quot;&gt;&lt;/a&gt;Android 自定义View&lt;/h1&gt;&lt;p&gt;自定义View主要用于：需要一些不规
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>react redux</title>
    <link href="hexo/blog/2019/12/react-redux.html"/>
    <id>hexo/blog/2019/12/react-redux.html</id>
    <published>2019-12-03T01:54:38.000Z</published>
    <updated>2019-12-03T05:34:32.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在react-native中集成redux"><a href="#在react-native中集成redux" class="headerlink" title="在react-native中集成redux"></a>在react-native中集成redux</h1><p>对react框架而言，状态树、dom树是它的一大优势。<br>而redux就是对数据、状态进行管理。</p><h2 id="集成redux"><a href="#集成redux" class="headerlink" title="集成redux"></a>集成redux</h2><p>1、执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install redux --save</span><br><span class="line">npm install react-redux --save</span><br><span class="line">npm install redux-thunk --save</span><br><span class="line">npm i redux-logger --save</span><br></pre></td></tr></table></figure></p><p>以上命令下载关于redux的组件。</p><p>2、store的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// configStore.js</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">import rootReducer from &apos;./reducer&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default configStore =(initState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const store = createStoreWithMiddleware(rootReducer, initState);</span><br><span class="line"></span><br><span class="line">    return store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// rootReducer</span><br><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; reducer as test &#125; from &apos;../Home/store&apos;;</span><br><span class="line"></span><br><span class="line">const appReducer = combineReducers(&#123;</span><br><span class="line">    test,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const rootReducer =(state, action) =&gt; &#123;</span><br><span class="line">    return appReducer(state, action);</span><br><span class="line">&#125;</span><br><span class="line">export default rootReducer;</span><br></pre></td></tr></table></figure><p>test是一个测试的reducer。</p><p>在入口处，绑定store，在入口文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(&apos;projectName&apos;, () =&gt; Root);</span><br><span class="line">// 指向了root.js，在root.js中：</span><br><span class="line"></span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import configStore from &apos;./store/configStore&apos;;</span><br><span class="line"></span><br><span class="line">const store = configStore();</span><br><span class="line"></span><br><span class="line">export default class Root extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt;</span><br><span class="line">                    &#123;...&#125;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// actionType.js</span><br><span class="line">export const TEST_REDUCE = &quot;TEST_REDUCE&quot;;</span><br><span class="line"></span><br><span class="line">// test action.js</span><br><span class="line">import &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const test =() =&gt; (&#123;</span><br><span class="line">    type: TEST_REDUCE,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    test,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test reducer.js</span><br><span class="line">import &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;</span><br><span class="line"></span><br><span class="line">const initState = &#123;</span><br><span class="line">    num: 0,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default reducer = (state = initState, action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line"></span><br><span class="line">        case TEST_REDUCE:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                num: state.num + 1,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...initState,</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件component中使用<br>Test.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; bindActionCreators &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; action &#125; from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test extends Component &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testFunction =() =&gt; &#123;</span><br><span class="line">        this.props.action.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; num &#125; = this.props;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt;</span><br><span class="line">                &lt;TouchableOpacity</span><br><span class="line">                    onPress=&#123;this.testFunction&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;Text&gt;</span><br><span class="line">                        触发按钮</span><br><span class="line">                    &lt;/Text&gt;</span><br><span class="line">                    &lt;Text&gt;&#123;num&#125;&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = (state) =&gt; (&#123;</span><br><span class="line">    num: state.test.num,</span><br><span class="line">&#125;)</span><br><span class="line">const mapActionToProps = dispatch =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        action: bindActionCreators(action, dispatch),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps, mapActionToProps)(Test);</span><br></pre></td></tr></table></figure><p><strong><em> 具体的使用方法已在上面，下面再去讲解redux原理 </em></strong></p><h2 id="redux原理说明"><a href="#redux原理说明" class="headerlink" title="redux原理说明"></a>redux原理说明</h2><p>redux状态管理大致流程：</p><p>component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render</p><p>reducer中数据改变即store中数据改变为何会导致 component props改变呢？<br>其实就是connect函数。</p><p>我们在组件中，<br>export default connect(mapStateToProps, mapActionToProps)(Test);<br>connet是一个柯里化函数。<br>第一组入参两个：<br>第一个mapStateToProps，其实就是将store中的数据绑定到props，<br>第二个mapActionToProps，是将action函数绑定到props，<br>所以我们在使用是，如取store中的值，<br>const { num } = this.props;<br>dispatch action：this.props.action.test();</p><p>第二组入参：当前的Test对象。</p><p>再往深考虑connect 函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在react-native中集成redux&quot;&gt;&lt;a href=&quot;#在react-native中集成redux&quot; class=&quot;headerlink&quot; title=&quot;在react-native中集成redux&quot;&gt;&lt;/a&gt;在react-native中集成redux&lt;/
      
    
    </summary>
    
    
      <category term="react" scheme="hexo/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>android sqlite的使用</title>
    <link href="hexo/blog/2019/11/android-sqlite%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>hexo/blog/2019/11/android-sqlite的使用.html</id>
    <published>2019-11-19T06:01:11.000Z</published>
    <updated>2019-11-21T03:43:42.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-sqlite的使用"><a href="#android-sqlite的使用" class="headerlink" title="android sqlite的使用"></a>android sqlite的使用</h1><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><p>a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法</p><h4 id="onCreate（SQLiteDatabase）"><a href="#onCreate（SQLiteDatabase）" class="headerlink" title="onCreate（SQLiteDatabase）"></a>onCreate（SQLiteDatabase）</h4><p>在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。</p><h4 id="onUpgrade（SQLiteDatabase，int，int）"><a href="#onUpgrade（SQLiteDatabase，int，int）" class="headerlink" title="onUpgrade（SQLiteDatabase，int，int）"></a>onUpgrade（SQLiteDatabase，int，int）</h4><p>当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。</p><h4 id="onOpen（SQLiteDatabase）"><a href="#onOpen（SQLiteDatabase）" class="headerlink" title="onOpen（SQLiteDatabase）"></a>onOpen（SQLiteDatabase）</h4><p>这是当打开数据库时的回调函数，一般在程序中不是很常使用。</p><p>在构造函数中创建数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 数据表名</span><br><span class="line">   private static final String TABLE_NAME = &quot;userlog.db&quot;;</span><br><span class="line"></span><br><span class="line">   public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123;</span><br><span class="line">       super(context, name, factory, version);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public MyDatabase(Context context, int version) &#123;</span><br><span class="line">       this(context, TABLE_NAME, null, version);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在onCreate方法中创建数据表<br>数据库数据类型：<br>NULL：null值<br>INTEGER：整数，1、2、3、4、6、8字节<br>REAL：浮点值，8字节<br>TEXT：字符串<br>BLOB：blob数据<br>DATE：日期 年月日<br>TIME：时刻 时分秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">       Log.d(TAG, &quot;onCreate: onCreate&quot;);</span><br><span class="line">       String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;;</span><br><span class="line">       db.execSQL(sql);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong><em> 然后在需要建表的实话，初始化一个该java类实例即可 </em></strong></p><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="增加-insert-一条数据"><a href="#增加-insert-一条数据" class="headerlink" title="增加 insert 一条数据"></a>增加 insert 一条数据</h4><p>1、使用sql语句插入一条数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;</span><br><span class="line">db.execSQL(sql);</span><br></pre></td></tr></table></figure></p><p>但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’</p><p>此时应该使用 ? 替代符，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123;</span><br><span class="line">    SQLiteDatabase db = getWritableDatabase();</span><br><span class="line">    StringBuilder sql = new StringBuilder();</span><br><span class="line">    sql.append(&quot;insert into &quot;)</span><br><span class="line">            .append(table_name)</span><br><span class="line">            .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;);</span><br><span class="line">    Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;;</span><br><span class="line">    Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString())));</span><br><span class="line">    db.execSQL(sql.toString(), values);</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-sqlite的使用&quot;&gt;&lt;a href=&quot;#android-sqlite的使用&quot; class=&quot;headerlink&quot; title=&quot;android sqlite的使用&quot;&gt;&lt;/a&gt;android sqlite的使用&lt;/h1&gt;&lt;h3 id=&quot;1、创建表
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ValueAnimator</title>
    <link href="hexo/blog/2019/10/ValueAnimator.html"/>
    <id>hexo/blog/2019/10/ValueAnimator.html</id>
    <published>2019-10-22T08:48:04.000Z</published>
    <updated>2019-10-22T08:48:33.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性动画-ValueAnimator"><a href="#属性动画-ValueAnimator" class="headerlink" title="属性动画 ValueAnimator"></a>属性动画 ValueAnimator</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;属性动画-ValueAnimator&quot;&gt;&lt;a href=&quot;#属性动画-ValueAnimator&quot; class=&quot;headerlink&quot; title=&quot;属性动画 ValueAnimator&quot;&gt;&lt;/a&gt;属性动画 ValueAnimator&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>canvas 中的方法</title>
    <link href="hexo/blog/2019/10/canvas-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2019/10/canvas-中的方法.html</id>
    <published>2019-10-22T08:09:46.000Z</published>
    <updated>2019-10-22T08:34:19.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="canvas-中的一些方法"><a href="#canvas-中的一些方法" class="headerlink" title="canvas 中的一些方法"></a>canvas 中的一些方法</h1><p>在canvas中一般使用的方法为<br>drawXXX(): 绘制的方法<br>clipXXX(): 裁剪的方法</p><h3 id="clipRect"><a href="#clipRect" class="headerlink" title="clipRect"></a>clipRect</h3><p>裁剪画布，clipRect(int left, top, right, bottom);<br>clipRectF(float left, top, right, bottom)</p><p>当执行了该方法，如clipRect(0,0,500,500);<br>则后面都只能在(0,0,500,500)区域绘制</p><h3 id="用Rect实现多区域裁剪"><a href="#用Rect实现多区域裁剪" class="headerlink" title="用Rect实现多区域裁剪"></a>用Rect实现多区域裁剪</h3><h4 id="intersect-交集】"><a href="#intersect-交集】" class="headerlink" title="intersect 交集】"></a>intersect 交集】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Rect rect = new Rect(0, 0, 500, 500);  </span><br><span class="line">          </span><br><span class="line">rect.intersect(250, 250, 750, 750); </span><br><span class="line">        </span><br><span class="line">canvas.clipRect(rect);</span><br><span class="line"></span><br><span class="line">// 取到区域(250, 250, 500, 500)</span><br></pre></td></tr></table></figure><p>绘制多个区域相交的区域</p><h4 id="union-合集"><a href="#union-合集" class="headerlink" title="union 合集"></a>union 合集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Rect rect = new Rect(0, 0, 500, 500);  </span><br><span class="line">      </span><br><span class="line">rect.union(250, 250, 750, 750);  </span><br><span class="line">    </span><br><span class="line">canvas.clipRect(rect);</span><br><span class="line"></span><br><span class="line">// 取到的区域为(0, 0, 750, 750)</span><br></pre></td></tr></table></figure><p>绘制多个区域之和</p><h3 id="clipPath-取出某个区域"><a href="#clipPath-取出某个区域" class="headerlink" title="clipPath 取出某个区域"></a>clipPath 取出某个区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 实例化路径</span><br><span class="line">mPath = new Path();</span><br><span class="line">// 移动起点至[50,50]</span><br><span class="line">mPath.moveTo(50, 50);  </span><br><span class="line">mPath.lineTo(75, 23);  </span><br><span class="line">mPath.lineTo(150, 100);  </span><br><span class="line">mPath.lineTo(80, 110);  </span><br><span class="line">// 闭合路径</span><br><span class="line">mPath.close();</span><br><span class="line"></span><br><span class="line">// 按照路径进行裁剪</span><br><span class="line">canvas.clipPath(mPath);</span><br></pre></td></tr></table></figure><p>即是将path区域裁剪出来<br>同样后面在能在该path区域绘制图形</p><h3 id="Region-Op"><a href="#Region-Op" class="headerlink" title="Region.Op"></a>Region.Op</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;canvas-中的一些方法&quot;&gt;&lt;a href=&quot;#canvas-中的一些方法&quot; class=&quot;headerlink&quot; title=&quot;canvas 中的一些方法&quot;&gt;&lt;/a&gt;canvas 中的一些方法&lt;/h1&gt;&lt;p&gt;在canvas中一般使用的方法为&lt;br&gt;drawXX
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>hashMap解析</title>
    <link href="hexo/blog/2019/09/hashMap%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2019/09/hashMap解析.html</id>
    <published>2019-09-03T06:01:51.000Z</published>
    <updated>2019-09-03T07:31:47.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><h3 id="Hash内部类Node："><a href="#Hash内部类Node：" class="headerlink" title="Hash内部类Node："></a>Hash内部类Node：</h3><p>Node(节点)，链表中的节点，当HashMap数据少于6条时，为链表结构，Node为其中的节点。<br>链表数据结构，每一个节点都记录下一个节点的地址。<br>在Node的构造函数中，直接包含了下一个节点，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        // 将下一个节点作为入参放入构造函数中</span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p><p>获取某个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        Node&lt;K,V&gt; first, e;</span><br><span class="line">        int n;</span><br><span class="line">        K k;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                // 当为树结构的时候</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                // 获取树形结构中某个节点</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                // 遍历链表结构    </span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap源码分析&quot;&gt;&lt;a href=&quot;#HashMap源码分析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码分析&quot;&gt;&lt;/a&gt;HashMap源码分析&lt;/h1&gt;&lt;h3 id=&quot;Hash内部类Node：&quot;&gt;&lt;a href=&quot;#Hash内
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>升级rn版本适配android64</title>
    <link href="hexo/blog/2019/08/%E5%8D%87%E7%BA%A7rn%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8Dandroid64.html"/>
    <id>hexo/blog/2019/08/升级rn版本适配android64.html</id>
    <published>2019-08-21T01:31:14.000Z</published>
    <updated>2019-08-21T01:38:46.589Z</updated>
    
    <content type="html"><![CDATA[<p>google play在2019/08/01起实施强制支持64位手机的措施。</p><p>因为之前的version为0.55.4,到0.59.1版本更新太多，<br>采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;google play在2019/08/01起实施强制支持64位手机的措施。&lt;/p&gt;
&lt;p&gt;因为之前的version为0.55.4,到0.59.1版本更新太多，&lt;br&gt;采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="react-native" scheme="hexo/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava + Retrofit 实现BaseResult</title>
    <link href="hexo/blog/2019/07/Rxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html"/>
    <id>hexo/blog/2019/07/Rxjava-Retrofit-实现BaseResult.html</id>
    <published>2019-07-25T03:24:56.000Z</published>
    <updated>2019-07-25T03:25:23.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rxjava-Retrofit-实现BaseResult"><a href="#Rxjava-Retrofit-实现BaseResult" class="headerlink" title="Rxjava + Retrofit 实现BaseResult"></a>Rxjava + Retrofit 实现BaseResult</h1><p>最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。<br>答案肯定是可以的。本文只讲使用。</p><h4 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;</span><br><span class="line">implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;</span><br><span class="line">implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;</span><br><span class="line">implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;</span><br><span class="line">implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;</span><br></pre></td></tr></table></figure><h4 id="普通使用案例"><a href="#普通使用案例" class="headerlink" title="普通使用案例"></a>普通使用案例</h4><p>首先创建实体数据类Test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;=====TEST&quot;;</span><br><span class="line"></span><br><span class="line">    String key = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String test = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public void log() &#123;</span><br><span class="line">        Log.d(TAG,&quot;key=&quot;  + key);</span><br><span class="line">        Log.d(TAG, &quot;test=&quot; + test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写一个接口TestServer，申明请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface TestService &#123;</span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Test&gt;getObJson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void testService() &#123;</span><br><span class="line">      // 实例化一个Retrofit 对象</span><br><span class="line">        Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">                .baseUrl(&quot;http://192.168.1.42:8080/&quot;)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        TestServer service = retrofit.create(TestService.class);</span><br><span class="line">         service.getObJson()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(new Observer&lt;Test&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onNext(Test test) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="开发考虑"><a href="#开发考虑" class="headerlink" title="开发考虑"></a>开发考虑</h3><p>我们不可能每个请求都重新创建一个Retrofit对象，<br>而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。<br>所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。</p><h5 id="1、写一个result实体类"><a href="#1、写一个result实体类" class="headerlink" title="1、写一个result实体类"></a>1、写一个result实体类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 因为每一个接口返回的数据结构都不同，肯定要用泛型。</span><br><span class="line">public class Result&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final String TAG = &quot;Result ====&quot;;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    private String code = &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public void logCode() &#123;</span><br><span class="line">        Log.d(TAG, code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getLongCode() &#123;</span><br><span class="line">        long resultCode = 0;</span><br><span class="line">        if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123;</span><br><span class="line">            resultCode = Long.parseLong(code);</span><br><span class="line">        &#125;</span><br><span class="line">        return resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log() &#123;</span><br><span class="line">        Log.d(TAG, &quot;msg:&quot; +msg + &quot;\n code:&quot; + code + &quot;\n data:&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getResultData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论</strong></p><p>然后需要写一个BaseObserver观察者基类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 这里还是因为接口返回数据格式问题，使用泛型。</span><br><span class="line">public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final String TAG = &quot;====BaseObserver===&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求成功</span><br><span class="line">     * @param t</span><br><span class="line">     */</span><br><span class="line">    public abstract void onSuccess(T t);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当返回的code值错误时的默认方法</span><br><span class="line">     * @param code</span><br><span class="line">     */</span><br><span class="line">    public void onResultCodeErr(long code) &#123;</span><br><span class="line">        Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Result result) &#123;</span><br><span class="line">        if(result.getLongCode() != 200) &#123;</span><br><span class="line">            onResultCodeErr(result.getLongCode());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            onSuccess((T)result.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        result.log();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError&quot;);</span><br><span class="line">        Log.d(TAG, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的Server类就变成了如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TestService &#123;</span><br><span class="line"></span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson();</span><br><span class="line"></span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Test&gt;getObJson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(Test test) &#123;</span><br><span class="line">            Log.d(&quot;======&quot;, &quot;onSuccess&quot;);</span><br><span class="line">            test.log();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /** Retrofit + Rxjav */</span><br><span class="line">    private void testRxjavaService() &#123;</span><br><span class="line">        Retrofit retrofit = RetrofitUtil.getRetrofit();</span><br><span class="line">        TestService ts = retrofit.create(TestService.class);</span><br><span class="line">        ts.getTestRxjavaJson()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(observer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rxjava-Retrofit-实现BaseResult&quot;&gt;&lt;a href=&quot;#Rxjava-Retrofit-实现BaseResult&quot; class=&quot;headerlink&quot; title=&quot;Rxjava + Retrofit 实现BaseResult&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门（三）布局组件</title>
    <link href="hexo/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html"/>
    <id>hexo/blog/2019/07/Flutter入门（三）布局组件.html</id>
    <published>2019-07-25T03:00:09.000Z</published>
    <updated>2019-07-25T03:10:55.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter入门（三）布局组件"><a href="#Flutter入门（三）布局组件" class="headerlink" title="Flutter入门（三）布局组件"></a>Flutter入门（三）布局组件</h1><p>之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！</p><p><img src="../images/flutter1.png" alt="fluttercn.png"></p><p>查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍</p><h3 id="ui组件"><a href="#ui组件" class="headerlink" title="ui组件"></a>ui组件</h3><p>学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。</p><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    &apos;要显示的文本&apos;, </span><br><span class="line">    &#123;</span><br><span class="line">        textAlign: TextAlign.center, // 文本横向对齐方式 居中</span><br><span class="line">        overflow: TextOverflow.ellipsis, // 文本溢出处理方式</span><br><span class="line">        textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left)</span><br><span class="line">        softWrap: true, // 是否自动换行</span><br><span class="line">        textScaleFactor: 2.0, // 字体显示倍率</span><br><span class="line">        maxLines: 1, // 文本最大行数</span><br><span class="line">        style: new TextStyle(</span><br><span class="line">            color: Colors.purple,</span><br><span class="line">            fontSize: 20.0,</span><br><span class="line">        ), // 文本样式</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter入门（三）布局组件&quot;&gt;&lt;a href=&quot;#Flutter入门（三）布局组件&quot; class=&quot;headerlink&quot; title=&quot;Flutter入门（三）布局组件&quot;&gt;&lt;/a&gt;Flutter入门（三）布局组件&lt;/h1&gt;&lt;p&gt;之前吐槽过flutter中文
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter入门  vscode调试及查看日志</title>
    <link href="hexo/blog/2019/07/flutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html"/>
    <id>hexo/blog/2019/07/flutter入门-vscode调试及查看日志.html</id>
    <published>2019-07-25T02:55:36.000Z</published>
    <updated>2019-07-25T03:12:04.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flutter入门-vscode调试及查看日志"><a href="#flutter入门-vscode调试及查看日志" class="headerlink" title="flutter入门  vscode调试及查看日志"></a>flutter入门  vscode调试及查看日志</h1><p>开发肯定需要调试应用，以及查看日志。</p><p>在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。</p><p>还有一个print()函数，最终发现这个是可以的。</p><h4 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h4><p>a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。</p><p>b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出</p><p>c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出</p><h4 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h4><p>print()日志输出函数<br>通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出</p><p>ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。</p><h4 id="用vscode调试flutetr"><a href="#用vscode调试flutetr" class="headerlink" title="用vscode调试flutetr"></a>用vscode调试flutetr</h4><p><img src="../images/log1.png" alt="fluttervscode.png"><br>一个正常的flutter项目用vscode应该是这样的。<br>之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。</p><p>点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目<br><img src="../images/log2.png" alt="run.png"></p><p>我打了一个断点，当项目运行起来，如下图。<br><img src="../images/log3.png" alt="debugger.png"></p><p>当我点击按钮，进入断点。如下图<br>可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。<br><img src="../images/log4.png" alt="indebugger.png"></p><p>添加断点点击代码左侧的红框区域即可（下图）。<br><img src="../images/log5.png" alt="adddebugger.png"></p><p>在左上角的调试/新建断点 也可以。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;flutter入门-vscode调试及查看日志&quot;&gt;&lt;a href=&quot;#flutter入门-vscode调试及查看日志&quot; class=&quot;headerlink&quot; title=&quot;flutter入门  vscode调试及查看日志&quot;&gt;&lt;/a&gt;flutter入门  vscod
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门（二） 使用vscode编写第一个Flutter应用</title>
    <link href="hexo/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html"/>
    <id>hexo/blog/2019/07/Flutter入门（二）-使用vscode编写第一个Flutter应用.html</id>
    <published>2019-07-25T02:51:37.000Z</published>
    <updated>2019-07-25T03:12:34.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter入门（二）-使用vscode编写第一个Flutter应用"><a href="#Flutter入门（二）-使用vscode编写第一个Flutter应用" class="headerlink" title="Flutter入门（二） 使用vscode编写第一个Flutter应用"></a>Flutter入门（二） 使用vscode编写第一个Flutter应用</h1><p>在上一篇中我们利用android studio运行了一个hello word项目。<br>作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。</p><p>###1、配置插件<br>需要在vscode中下载插件<br><img src="../images/dart1.png" alt="dartPlugin.png"><br><img src="../images/dart2.png" alt="flutterPlugin.png"><br>找到这两个插件下载好并重新加载vscode就可以了。</p><p>###2、运行<br>flutter项目的运行命令是 flutter run<br>但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。<br>你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。</p><p>在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。<br>还有有一些提示信息<br><img src="../images/dart3.png" alt="tips.png"></p><p>当你需要热加载的时候按 r，需要重启应用按R。<br>所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。</p><p>###3、写第一个flutter应用。<br>按照flutter中文网（<a href="https://flutterchina.club/get-started/codelab/）" target="_blank" rel="noopener">https://flutterchina.club/get-started/codelab/）</a><br>写我们第一个flutter应用。<br>其中我个人碰到一个问题。<br>就是在第2步、使用外部package中，<br><img src="../images/dart4.png" alt="package.png"></p><p>在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。<br>然后重新打开vscode才好，应该是vscode对这个以来的读取问题。</p><p>然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。</p><p>###个人体会</p><p><strong>flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼</strong></p><p>fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。<br>没有对state这个做解释、没有state的使用说明，然后那个路由也是。</p><p>##待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter入门（二）-使用vscode编写第一个Flutter应用&quot;&gt;&lt;a href=&quot;#Flutter入门（二）-使用vscode编写第一个Flutter应用&quot; class=&quot;headerlink&quot; title=&quot;Flutter入门（二） 使用vscode编
      
    
    </summary>
    
    
      <category term="flutter" scheme="hexo/tags/flutter/"/>
    
  </entry>
  
</feed>
