<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Happy To Try</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2020-08-27T09:41:13.124Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java volatile关键字</title>
    <link href="hexo/blog/2020/08/java-volatile%E5%85%B3%E9%94%AE%E5%AD%97.html"/>
    <id>hexo/blog/2020/08/java-volatile关键字.html</id>
    <published>2020-08-27T09:27:26.000Z</published>
    <updated>2020-08-27T09:41:13.124Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java wait方法</title>
    <link href="hexo/blog/2020/08/java-wait%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2020/08/java-wait方法.html</id>
    <published>2020-08-27T09:26:45.000Z</published>
    <updated>2020-08-27T09:41:17.350Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java join方法</title>
    <link href="hexo/blog/2020/08/java-join%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2020/08/java-join方法.html</id>
    <published>2020-08-27T08:18:59.000Z</published>
    <updated>2020-08-27T09:24:35.404Z</updated>
    
    <content type="html"><![CDATA[<p>t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续<br>如在main线程调用t.join(),则会阻塞main线程直到t线程执行完。</p><p>而join()函数参数，当调用为t.join(2000),代表阻塞2000毫秒, 当2000毫秒完后，main线程会向下执行，<br>但也有例外，join(millis)<br>如在t线程使用 synchronized时，则必须等到synchronized包裹的代码块执行完并传递的millis毫秒后，t.join()的调用线程才会向下执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">//                synchronized (currentThread()) &#123;</span><br><span class="line">                    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            sleep(1000);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(&quot;休眠&quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;线程结束&quot;);</span><br><span class="line">//                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            thread.join(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;main线程结束&quot;);</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>main线程结束<br>1005<br>休眠0<br>休眠1<br>休眠2<br>休眠3<br>休眠4<br>线程结束</p><p>将thread.join(1000) 改为2000 时，输出结果如下：<br>休眠0<br>main线程结束<br>2005<br>休眠1<br>休眠2<br>休眠3<br>休眠4<br>线程结束</p><p>将上面代码synchronized 注释放开后再运行，输出结果如下：<br>休眠0<br>休眠1<br>休眠2<br>休眠3<br>休眠4<br>线程结束<br>main线程结束<br>5011</p><p>查看join方法源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to  </span><br><span class="line"> * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever.    当为0时，会一直阻塞调用join函数的线程，直到调用join函数的对象线程执行完毕</span><br><span class="line"> */</span><br><span class="line">public final synchronized void join(long millis)    throws InterruptedException &#123;</span><br><span class="line">    // 获取当时系统时间</span><br><span class="line">    long base = System.currentTimeMillis();</span><br><span class="line">    long now = 0;</span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        // 当传过来的入参时间小于0，抛出异常</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (millis == 0) &#123;</span><br><span class="line">        // 当等于0时，只要线程未执行完毕，则一直阻塞</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            // 当前线程未执行完一直阻塞</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 当时间大于0</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            // 当前线程还未执行完，则一直循环获取时间，阻塞调用线程到时间结束</span><br><span class="line">            long delay = millis - now;</span><br><span class="line">            if (delay &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br>wait()是运行在调用线程的，<br>如在main线程中调用t.join();<br>则join()函数的调用线程是main线程，wait()也是运行在main线程的，所以阻塞main线程，<br>而t才是join()的调用对象线程，isAlive也是判断的t线程是否执行完毕，只有在t线程执行完毕，isAlive才为false</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续&lt;br&gt;如在main线程调用t.join(),则会阻塞main线程直到t线程执行完。&lt;/p&gt;
&lt;p&gt;而join()函数参数，当调用为t
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android 指纹验证</title>
    <link href="hexo/blog/2020/08/android-%E6%8C%87%E7%BA%B9%E9%AA%8C%E8%AF%81.html"/>
    <id>hexo/blog/2020/08/android-指纹验证.html</id>
    <published>2020-08-12T01:42:55.000Z</published>
    <updated>2020-08-13T03:17:41.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-指纹识别"><a href="#android-指纹识别" class="headerlink" title="android 指纹识别"></a>android 指纹识别</h1><p>android API 23时新增的功能，指纹识别</p><p>主要类：FingerpringManager</p><p>在API28后，FingerpringManager被遗弃，使用BiometricPrompt，此时授权识别的弹窗不能自定义，<br>只能使用官方统一弹窗，只能设置各个授权文案。各个开发商内部实现可能不一致。</p><p>通过只是使用指纹识别，直接使用官方api即可，但出于安全或业务场景需求，很多都需要去检测生物库信息是否变更，<br>如指纹库在重新指纹识别前是否发生变更，这个官方api就没有提供方法，需要我们自己实现。</p><h2 id="检测指纹库是否发生变更"><a href="#检测指纹库是否发生变更" class="headerlink" title="检测指纹库是否发生变更"></a>检测指纹库是否发生变更</h2><p>参考：<br>通过检测密钥查看是否变更(<a href="https://www.jianshu.com/p/dbb1a43cfb21" target="_blank" rel="noopener">https://www.jianshu.com/p/dbb1a43cfb21</a>)</p><p>在API28以前，指纹库信息时可以通过反射获取，获取的信息有指纹id、groupId、指纹名称、指纹个数、设备id等等，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    Log.d(TAG, &quot;getFingerPrintInfo: &quot;);</span><br><span class="line">    FingerprintManager fingerprintManager = (FingerprintManager) getCurrentActivity().getSystemService(Context.FINGERPRINT_SERVICE);</span><br><span class="line">    try&#123;</span><br><span class="line">        Class clz = Class.forName(&quot;android.hardware.fingerprint.FingerprintManager&quot;);</span><br><span class="line">        Method method = clz.getDeclaredMethod(&quot;getEnrolledFingerprints&quot;, new Class[]&#123;&#125;);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        Object obj = method.invoke(fingerprintManager, null);</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;objStr:&quot; + JsonUtils.toJson(obj));</span><br><span class="line">            List&lt;FingerprintBean&gt; list = (List&lt;FingerprintBean&gt;) JsonUtils.fromJson(objStr, new TypeToken&lt;List&lt;FingerprintBean&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而FingerprintBean是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class FingerprintBean implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private long mDeviceId;</span><br><span class="line">    private long mFingerId;</span><br><span class="line">    private long mGroupId;</span><br><span class="line">    private String mName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最理想的方式是我们反射获取到这些指纹库信息，然后将这些信息保存到本地，每次调用指纹识别时，获取当前指纹库信息与之前的指纹库信息比较，<br>只有不同即可判定指纹库信息变更，<br>但在实际操作中，发现在手机上获取到的指纹id只是简单的1、2、3即指纹库里的排列顺序，而指纹名称是可以随意更改，groupId、deviceId都为0，<br>如果使用这些信息去校验，错误率太高。</p><p>还有一种方式即是上面参考链接中的，<br>检测指纹库密钥信息是否变更</p><p>但在上面链接那种方法中，有几个问题：<br>1、增加、删除指纹无法检测<br>2、使用修改指纹的手指识别后才能检测出修改</p><p>于是将反射、密钥检测两者结合，<br>先反射获取指纹库信息，只是比较指纹库指纹个数，先判断指纹个数是否发生变更，就可知道指纹库信息变更了<br>如果指纹个数没有变更，再来校验密钥是否发生变化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-指纹识别&quot;&gt;&lt;a href=&quot;#android-指纹识别&quot; class=&quot;headerlink&quot; title=&quot;android 指纹识别&quot;&gt;&lt;/a&gt;android 指纹识别&lt;/h1&gt;&lt;p&gt;android API 23时新增的功能，指纹识别&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>kotlin (二)</title>
    <link href="hexo/blog/2020/07/kotlin-%E4%BA%8C.html"/>
    <id>hexo/blog/2020/07/kotlin-二.html</id>
    <published>2020-07-29T13:58:32.000Z</published>
    <updated>2020-07-29T13:58:32.468Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2020/07/android-%E5%8A%A8%E7%94%BB.html"/>
    <id>hexo/blog/2020/07/android-动画.html</id>
    <published>2020-07-27T03:26:53.233Z</published>
    <updated>2020-07-27T03:26:53.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android动画"><a href="#android动画" class="headerlink" title="android动画"></a>android动画</h1><p>动画分为两类，传统动画、属性动画</p><h2 id="传统动画"><a href="#传统动画" class="headerlink" title="传统动画"></a>传统动画</h2><p>传统动画又分为帧动画、补间动画</p><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。<br>有点类似与gif</p><p>将图片资源放入到drawable文件夹<br>在drawable下新建资源文件 drawable1.xml  类型：animation-list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image1&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image2&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image3&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image4&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><p>android:drawable 指的是要显示的图片资源<br>android:duration: 图片显示时长</p><p>还有一些其它参数</p><p>在Activity中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imageView = findViewById(R.id.imageView);</span><br><span class="line">imageView.setImageResource(R.drawable.image);</span><br><span class="line">AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">drawable.start();</span><br></pre></td></tr></table></figure></p><p>这样就可以让四张图片动起来了。</p><p>这样就是一个帧动画的简单样例</p><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）<br>其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。</p><p>补间动画可以通过xml、或者代码形式实现。</p><h3 id="xml实现补间动画"><a href="#xml实现补间动画" class="headerlink" title="xml实现补间动画"></a>xml实现补间动画</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android动画&quot;&gt;&lt;a href=&quot;#android动画&quot; class=&quot;headerlink&quot; title=&quot;android动画&quot;&gt;&lt;/a&gt;android动画&lt;/h1&gt;&lt;p&gt;动画分为两类，传统动画、属性动画&lt;/p&gt;
&lt;h2 id=&quot;传统动画&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android 动画</title>
    <link href="hexo/blog/2020/07/android-%E5%8A%A8%E7%94%BB.html"/>
    <id>hexo/blog/2020/07/android-动画.html</id>
    <published>2020-07-21T01:32:47.000Z</published>
    <updated>2020-07-27T03:26:53.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android动画"><a href="#android动画" class="headerlink" title="android动画"></a>android动画</h1><p>动画分为两类，传统动画、属性动画</p><h2 id="传统动画"><a href="#传统动画" class="headerlink" title="传统动画"></a>传统动画</h2><p>传统动画又分为帧动画、补间动画</p><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。<br>有点类似与gif</p><p>将图片资源放入到drawable文件夹<br>在drawable下新建资源文件 drawable1.xml  类型：animation-list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image1&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image2&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image3&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image4&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><p>android:drawable 指的是要显示的图片资源<br>android:duration: 图片显示时长</p><p>还有一些其它参数</p><p>在Activity中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imageView = findViewById(R.id.imageView);</span><br><span class="line">imageView.setImageResource(R.drawable.image);</span><br><span class="line">AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">drawable.start();</span><br></pre></td></tr></table></figure></p><p>这样就可以让四张图片动起来了。</p><p>这样就是一个帧动画的简单样例</p><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）<br>其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。</p><p>补间动画可以通过xml、或者代码形式实现。</p><h3 id="xml实现补间动画"><a href="#xml实现补间动画" class="headerlink" title="xml实现补间动画"></a>xml实现补间动画</h3><h4 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h4><p>在res/anim下新建文件alpha_anime.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:fromAlpha=&quot;0.0&quot;</span><br><span class="line">    android:toAlpha=&quot;1.0&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span><br><span class="line">    android:repeatMode=&quot;restart&quot;</span><br><span class="line">    android:repeatCount=&quot;infinite&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></p><p>在Activity中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animation animation = AnimationUtils.loadAnimation(this.getApplicationContext(), R.anim.alpha_anime);</span><br><span class="line">ImageView alphaImage = findViewById(R.id.alphaImageView);</span><br><span class="line">alphaImage.startAnimation(animation);</span><br></pre></td></tr></table></figure></p><p>这样就能实现图片渐隐的无限循环效果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android动画&quot;&gt;&lt;a href=&quot;#android动画&quot; class=&quot;headerlink&quot; title=&quot;android动画&quot;&gt;&lt;/a&gt;android动画&lt;/h1&gt;&lt;p&gt;动画分为两类，传统动画、属性动画&lt;/p&gt;
&lt;h2 id=&quot;传统动画&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android MVP</title>
    <link href="hexo/blog/2020/05/android-MVP.html"/>
    <id>hexo/blog/2020/05/android-MVP.html</id>
    <published>2020-05-30T08:28:01.000Z</published>
    <updated>2020-05-30T08:39:07.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>android MVP是一种开发架构，由MVC演化而来，<br>因为在MVC中，Activity层，糅合逻辑、ui操作，显得臃肿、混乱。</p><p>在MVP中，</p><ul><li>M：model，数据层</li><li>V：View，页面操作</li><li>P：Present，M、V的桥接，逻辑操作</li></ul><h2 id="MVP的优势"><a href="#MVP的优势" class="headerlink" title="MVP的优势"></a>MVP的优势</h2><ul><li>1、代码简洁，逻辑清晰</li><li>2、解耦，便于维护</li></ul><p>因为MVP将逻辑与视图分离，降低了业务耦合，使得整个代码层次分明，所以也就更好维护</p><p>下面以登陆做一个示例</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MVP&quot;&gt;&lt;a href=&quot;#MVP&quot; class=&quot;headerlink&quot; title=&quot;MVP&quot;&gt;&lt;/a&gt;MVP&lt;/h1&gt;&lt;p&gt;android MVP是一种开发架构，由MVC演化而来，&lt;br&gt;因为在MVC中，Activity层，糅合逻辑、ui操作，显得臃肿、混
      
    
    </summary>
    
    
      <category term="andorid" scheme="hexo/tags/andorid/"/>
    
  </entry>
  
  <entry>
    <title>android MVVM</title>
    <link href="hexo/blog/2020/05/android-MVVM.html"/>
    <id>hexo/blog/2020/05/android-MVVM.html</id>
    <published>2020-05-30T08:27:55.000Z</published>
    <updated>2020-05-30T08:27:55.412Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android 高级ui</title>
    <link href="hexo/blog/2020/05/android-%E9%AB%98%E7%BA%A7ui.html"/>
    <id>hexo/blog/2020/05/android-高级ui.html</id>
    <published>2020-05-30T08:27:36.000Z</published>
    <updated>2020-05-30T08:27:36.317Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android 图片加载</title>
    <link href="hexo/blog/2020/05/android-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD.html"/>
    <id>hexo/blog/2020/05/android-图片加载.html</id>
    <published>2020-05-30T08:20:33.000Z</published>
    <updated>2020-05-30T08:20:48.207Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 网络请求框架</title>
    <link href="hexo/blog/2020/05/android-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6.html"/>
    <id>hexo/blog/2020/05/android-网络请求框架.html</id>
    <published>2020-05-30T08:20:15.000Z</published>
    <updated>2020-05-30T08:20:51.794Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 序列化</title>
    <link href="hexo/blog/2020/05/android-%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <id>hexo/blog/2020/05/android-序列化.html</id>
    <published>2020-05-27T12:48:49.000Z</published>
    <updated>2020-06-01T02:22:37.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android序列化"><a href="#android序列化" class="headerlink" title="android序列化"></a>android序列化</h1><h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>将java对象转化为二进制过程，就是序列化，<br>将二进制转化为java对象的过程，就是反序列化</p><h2 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h2><p>在下面几种场景下我们需要序列化</p><ul><li>永久性保存对象，保存对象的字节序列到本地文件中；</li><li>对象在网络中传递；</li><li>对象在IPC间传递（进程通信）</li></ul><h2 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h2><p>序列化有两种方法，java中自带的实现Serializable，android中特有的Parcelable</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>新建类实现Serializable，Serializable为空接口，没有要实现的方法， 需要 定义一个静态常量serialVersionUID </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SerBean implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 263894729013938L;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public SerBean(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这个类的序列化就完成了。</p><h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class ParBean implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    // 系统自动添加，给createFromParcel里面用</span><br><span class="line">    protected ParBean(Parcel in) &#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;ParBean&gt; CREATOR = new Creator&lt;ParBean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         *</span><br><span class="line">         * @param in</span><br><span class="line">         * @return</span><br><span class="line">         *createFromParcel()方法中我们要去读取刚才写出的name和age字段，</span><br><span class="line">         * 并创建一个Person对象进行返回，其中color和size都是调用Parcel的readXxx()方法读取到的，</span><br><span class="line">         * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。</span><br><span class="line">         * 读取的工作我们利用一个构造函数帮我们完成了</span><br><span class="line">         *</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public ParBean createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new ParBean(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //供反序列化本类数组时调用的</span><br><span class="line">        @Override</span><br><span class="line">        public ParBean[] newArray(int size) &#123;</span><br><span class="line">            return new ParBean[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 内容接口描述，默认返回0即可。</span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(name); // 写出name</span><br><span class="line">        dest.writeInt(age); // 写出age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // --------下面为自己写的构造函数和get set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ParBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ParBean(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化方案区别"><a href="#序列化方案区别" class="headerlink" title="序列化方案区别"></a>序列化方案区别</h2><p>上面讲了两个序列化方案，<br>Serializable：是java就有的，代码量少，但在序列化时，会产生大量的临时对象，容易造成频繁的minor GC</p><p>Parcelable：android特有的，代码量比Serializable要多，但使用效率高，且没那么占内存</p><p>因为在选择序列化时，优先使用Parcelable，但有一种情况特殊，当数据保存在磁盘上时，Parcelable在外界有变化的情况下，<br>不能很好的保证数据的连续性，因此在此种场景下推荐使用Serializable；</p><h2 id="序列化某种程度来说并不安全"><a href="#序列化某种程度来说并不安全" class="headerlink" title="序列化某种程度来说并不安全"></a>序列化某种程度来说并不安全</h2><ul><li><p>因为序列化的对象数据转换为二进制，并且完全可逆。但是在RMI调用时<br>所有private字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的</p></li><li><p>解决方案<br>1、 序列化Hook化（移位和复位）<br>2、 序列数据加密和签名<br>3、 利用transient的特性解决<br>4、 打包和解包代理</p></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>static和transient字段不能被序列化（感兴趣的同学可以深入研究下）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android序列化&quot;&gt;&lt;a href=&quot;#android序列化&quot; class=&quot;headerlink&quot; title=&quot;android序列化&quot;&gt;&lt;/a&gt;android序列化&lt;/h1&gt;&lt;h2 id=&quot;什么是序列化&quot;&gt;&lt;a href=&quot;#什么是序列化&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>kotlin</title>
    <link href="hexo/blog/2020/05/kotlin.html"/>
    <id>hexo/blog/2020/05/kotlin.html</id>
    <published>2020-05-26T13:28:38.000Z</published>
    <updated>2020-07-27T03:26:53.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin学习"><a href="#kotlin学习" class="headerlink" title="kotlin学习"></a>kotlin学习</h1><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>新建一个kt文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主入口main方法， 无需新建类即可运行，函数声明用fun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int, b:Int):Int&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值写在参数之后 </p><p>表达式可以作为函数体，返回值类型自动推断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sun(a:Int, b:Int) = a+b;</span><br></pre></td></tr></table></figure></p><p>返回无意义的值用Unit表示</p><p>fun test():Unit {<br>    println(“test”);<br>}</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>变量赋值声明关键字：var、val<br>var：声明变量<br>val：声明常量</p><p>var i:Int = 1;<br>val PI:Double = 3.14;</p><p>当声明并赋值时，数据类型可以省略, 会自动推断数据类型<br>var i = 1;<br>val PI = 3.14</p><p>当声明但不赋值时，不能省略数据类型<br>var i:Int;<br>val PI:Double;</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;aaaaa&quot;;</span><br><span class="line">var b = &quot;str = $s&quot;;</span><br><span class="line">var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testIf(a:Int, b:Int):Int &#123;</span><br><span class="line">    if(a &gt; b) return a;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中，if还可以用作表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun max(a:Int, b:Int) = if(a &gt; b) a else b</span><br></pre></td></tr></table></figure><h2 id="空值与null检测"><a href="#空值与null检测" class="headerlink" title="空值与null检测"></a>空值与null检测</h2><p>当某个值可以为空时，需要在类型后添加?表示可以为空<br>此时，声明时不能省略类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj:Objects ? = null;</span><br><span class="line">// 表示返回值可以为null</span><br><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型检测与自动类型转换"><a href="#类型检测与自动类型转换" class="headerlink" title="类型检测与自动类型转换"></a>类型检测与自动类型转换</h2><p>is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 </strong></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);</span><br><span class="line">// 根据元素遍历</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据下标便利</span><br><span class="line">for (item in items.indices) &#123;</span><br><span class="line">    println(items[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = 0;</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(items[index]);</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private fun testWhen(s: Any?) &#123;</span><br><span class="line">        when(s) &#123;</span><br><span class="line">            &quot;a&quot; -&gt; 1;</span><br><span class="line">            &quot;b&quot; -&gt; 2;</span><br><span class="line">            is String -&gt; 3;</span><br><span class="line">            1 -&gt; &quot;n&quot;;</span><br><span class="line">            2 -&gt; &#123;</span><br><span class="line">              println(&quot;222&quot;);  </span><br><span class="line">            &#125;;</span><br><span class="line">            else -&gt; &quot;else&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有点类似java中的 switch</p><h2 id="区间-range"><a href="#区间-range" class="headerlink" title="区间 range"></a>区间 range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = 9;</span><br><span class="line">if(x in 0..y) &#123;</span><br><span class="line">    println(&quot;x in 0 - y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间只用于数字</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的迭代可以用的上面的 for in 循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">for(item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断集合中是否包含某元素 用while in || when<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (&quot;a&quot; in items) &#123;</span><br><span class="line">    println(&quot;items include a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when &#123;</span><br><span class="line">    &quot;a&quot; in items -&gt; println(&quot;aaa&quot;);</span><br><span class="line">    &quot;d&quot; in items -&gt; println(&quot;ddd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用lambda来过滤和映射集合 ，与java8 lambda stream大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125;</span><br><span class="line">    .sortBy&#123; it &#125;</span><br><span class="line">    .map&#123; it.toUpperCase() &#125;</span><br><span class="line">    .forEach&#123; println(it) &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kotlin学习&quot;&gt;&lt;a href=&quot;#kotlin学习&quot; class=&quot;headerlink&quot; title=&quot;kotlin学习&quot;&gt;&lt;/a&gt;kotlin学习&lt;/h1&gt;&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class
      
    
    </summary>
    
    
      <category term="kotlin" scheme="hexo/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>react 掉起摄像头</title>
    <link href="hexo/blog/2020/05/react-%E6%8E%89%E8%B5%B7%E6%91%84%E5%83%8F%E5%A4%B4.html"/>
    <id>hexo/blog/2020/05/react-掉起摄像头.html</id>
    <published>2020-05-22T09:21:42.000Z</published>
    <updated>2020-05-22T09:29:17.381Z</updated>
    
    <content type="html"><![CDATA[<p>在h5中掉起摄像头，<br>碰到一些问题，<br>无法切换到后置摄像头 —-&gt; 将本地http 改为https就可以了<br>chrome浏览器报错：不支持访问用户媒体 —》  将本地http 改为https就可以了</p><p>npm start默认采用的是http协议<br>而npm start其实执行的脚本是react-script/start.js文件<br>查看 79行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const protocol = process.env.HTTPS === &apos;true&apos; ? &apos;https&apos; : &apos;http&apos;;</span><br></pre></td></tr></table></figure></p><p>我们只要在环境变量中将HTTPS设置为true即可<br>在macos 执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">code .bash_profile</span><br><span class="line">添加一行 HTTPS=true</span><br><span class="line">source .bash_profile</span><br><span class="line"></span><br><span class="line">// 也可以在终端执行</span><br><span class="line">export PORT=8081</span><br></pre></td></tr></table></figure></p><p>在 window 新增环境变量 HTTPS true<br>或者在终端执行 set HTTPS=true</p><p>本地掉起的摄像头呈现镜像 —-》css 镜像翻转 transform: ‘rotateY(180deg)’ // 水平镜像翻转180</p><p>完整代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123;StyleSheet,css&#125; from &apos;aphrodite/no-important&apos;</span><br><span class="line">import &#123; dpw, dph &#125; from &apos;../../common/tool/ScreenFit&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class AliveCheck extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">        this.video = document.getElementById(&apos;video&apos;);</span><br><span class="line">        this.canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">        this.context = this.canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">        const constraints = &#123;</span><br><span class="line">            audio: false,</span><br><span class="line">            video : &#123;</span><br><span class="line">                width: 480,</span><br><span class="line">                height: 320,</span><br><span class="line">                sourceId: &apos;default&apos;,</span><br><span class="line">                facingMode: &#123; exact: &quot;environment&quot; &#125;,</span><br><span class="line">                // facingMode:  &#123; exact: &quot;user&quot; &#125;,</span><br><span class="line">                permissions: &#123;</span><br><span class="line">                    &quot;audio-capture&quot;: &#123;</span><br><span class="line">                        &quot;description&quot;: &quot;Required to capture audio using getUserMedia()&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;video-capture&quot;: &#123;</span><br><span class="line">                        &quot;description&quot;: &quot;Required to capture video using getUserMedia()&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象</span><br><span class="line">        if (navigator.mediaDevices === undefined) &#123;</span><br><span class="line">            navigator.mediaDevices = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123;</span><br><span class="line">            //调用用户媒体设备, 访问摄像头</span><br><span class="line">            this.getUserMedia(constraints, this.success, this.error);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            alert(&apos;不支持访问用户媒体&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //访问用户媒体设备的兼容方法</span><br><span class="line">    getUserMedia =(constraints, success, error) =&gt; &#123;</span><br><span class="line">        if (navigator.mediaDevices.getUserMedia) &#123;</span><br><span class="line">          //最新的标准API</span><br><span class="line">          navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error);</span><br><span class="line">        &#125; else if (navigator.webkitGetUserMedia) &#123;</span><br><span class="line">          //webkit核心浏览器</span><br><span class="line">          navigator.webkitGetUserMedia(constraints,success, error)</span><br><span class="line">        &#125; else if (navigator.mozGetUserMedia) &#123;</span><br><span class="line">          //firfox浏览器</span><br><span class="line">          navigator.mozGetUserMedia(constraints, success, error);</span><br><span class="line">        &#125; else if (navigator.getUserMedia) &#123;</span><br><span class="line">          //旧版API</span><br><span class="line">          navigator.getUserMedia(constraints, success, error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    success =(stream) =&gt; &#123;</span><br><span class="line">        //兼容webkit核心浏览器</span><br><span class="line">        let CompatibleURL = window.URL || window.webkitURL;</span><br><span class="line">        //将视频流设置为video元素的源</span><br><span class="line">        console.log(stream);</span><br><span class="line">  </span><br><span class="line">        //video.src = CompatibleURL.createObjectURL(stream);</span><br><span class="line">        this.video.srcObject = stream;</span><br><span class="line">        this.video.play();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    error =(error)=&gt; &#123;</span><br><span class="line">        console.log(`访问用户媒体设备失败$&#123;error.name&#125;, $&#123;error.message&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    takePhoto =() =&gt; &#123;</span><br><span class="line">        alert(&apos;takePhoto&apos;)</span><br><span class="line">        this.context.drawImage(this.video, 0, 0, 480, 320); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopCamera =() =&gt; &#123;</span><br><span class="line">        if (!this.video.srcObject) return</span><br><span class="line">        let stream = this.video.srcObject</span><br><span class="line">        let tracks = stream.getTracks();</span><br><span class="line">        tracks.forEach(track =&gt; &#123;</span><br><span class="line">            track.stop()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div className=&#123;css(styles.box)&#125;&gt;</span><br><span class="line">                &lt;video className=&#123;css(styles.video)&#125; id=&quot;video&quot; width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;/video&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;button id=&quot;capture&quot; onClick=&#123;this.takePhoto&#125;&gt;拍照&lt;/button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;canvas id=&quot;canvas&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">    box: &#123;</span><br><span class="line">        display: &apos;flex&apos;,</span><br><span class="line">        width: &apos;100%&apos;,</span><br><span class="line">        height: &apos;100%&apos;,</span><br><span class="line">        flexDirection: &apos;column&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    video: &#123;</span><br><span class="line">        // 水平镜像翻转180</span><br><span class="line">        transform: &apos;rotateY(180deg)&apos;, </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在h5中掉起摄像头，&lt;br&gt;碰到一些问题，&lt;br&gt;无法切换到后置摄像头 —-&amp;gt; 将本地http 改为https就可以了&lt;br&gt;chrome浏览器报错：不支持访问用户媒体 —》  将本地http 改为https就可以了&lt;/p&gt;
&lt;p&gt;npm start默认采用的是htt
      
    
    </summary>
    
    
      <category term="react" scheme="hexo/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>日常记录</title>
    <link href="hexo/blog/2020/05/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95.html"/>
    <id>hexo/blog/2020/05/日常记录.html</id>
    <published>2020-05-21T13:48:21.000Z</published>
    <updated>2020-06-01T02:22:37.501Z</updated>
    
    <content type="html"><![CDATA[<p>i++<br>++ 在后，先运算完当前结果，再给i赋值</p><p>ex：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object [] obj = new Object [16]</span><br><span class="line">i = 0；</span><br><span class="line">obj[i ++] = &quot;obj&quot;</span><br><span class="line">// 会先执行</span><br><span class="line">obj[0]=&quot;obj&quot;;</span><br><span class="line">// 再执行</span><br><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure></p><p>–i;<br>– 在前，则先给i赋值，再执行当前运算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;i++&lt;br&gt;++ 在后，先运算完当前结果，再给i赋值&lt;/p&gt;
&lt;p&gt;ex：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>位操作符</title>
    <link href="hexo/blog/2020/05/%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.html"/>
    <id>hexo/blog/2020/05/位操作符.html</id>
    <published>2020-05-21T13:39:31.000Z</published>
    <updated>2020-06-01T02:22:37.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>逻辑 与<br>A &amp; B<br>将A、B都转化为二进制，同为均为1则为1，否则为0</p><p>ex：5 &amp; 8<br>0000 0101<br>&amp;<br>0000 1000</p><p>result ： 0000 0000 结果就是0</p><p>逻辑或<br>A | B<br>将A、B都转化为二进制，同为有一位为1则为1，否则为0<br>ex ： 5 &amp; 8<br>0000 0101<br>&amp;<br>0000 1000</p><p>result ： 0000 1101 结果就是13</p><p>逻辑非</p><p>逻辑异或</p><blockquote><blockquote></blockquote><p>5&gt;&gt;2</p></blockquote><p>0000 0101 &gt;&gt; 2  — 0000 0001  === 1</p><p>像右移2<br>左移运算符，&gt;&gt;&gt; </p><p>&lt;&lt; </p><p>5 &lt;&lt; 2<br>像左移2<br>0000 0101 &lt;&lt; 2 – 0001 0100 === 20<br>左移运算符，</p><blockquote><blockquote><blockquote><p>无符号移动 无符号右移，忽略符号位，空位都以0补齐</p></blockquote></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;amp&quot;&gt;&lt;a href=&quot;#amp&quot; class=&quot;headerlink&quot; title=&quot;&amp;amp;&quot;&gt;&lt;/a&gt;&amp;amp;&lt;/h2&gt;&lt;p&gt;逻辑 与&lt;br&gt;A &amp;amp; B&lt;br&gt;将A、B都转化为二进制，同为均为1则为1，否则为0&lt;/p&gt;
&lt;p&gt;ex：5 &amp;am
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 枚举</title>
    <link href="hexo/blog/2020/05/java-%E6%9E%9A%E4%B8%BE.html"/>
    <id>hexo/blog/2020/05/java-枚举.html</id>
    <published>2020-05-21T13:26:46.000Z</published>
    <updated>2020-06-01T02:22:37.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>enum 的全程事 Enumeration 是jdk1.5引进的</p><p>被enum 修饰的数据类型就是枚举类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Test &#123; TEST0, TEST1, TEST2 &#125;</span><br></pre></td></tr></table></figure></p><p>如果枚举不添加任何方法，枚举值默认为从0开始的递增数值，ru上面的： TEST0：0， TEST1：1，TEST2：2</p><p>枚举的好处：可以将常量组织起来，便于管理<br>应用场景：状态码：错误码</p><h2 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h2><p>枚举的本质是一个类，受限制的类</p><p>创建enum是，编译器会自动为你生成一个相关的类，这个类继承 <strong> java.lang.Enum </strong></p><p>b编译过后其实是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;</span><br><span class="line">        implements Comparable&lt;E&gt;, Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>是一个抽象类，并且继承了Comparable以及Serializable，也就是标记了序列化</p><p>而且枚举可以添加自己的方法、变量，但是不能为枚举常量用 “=”赋值，但不能继承其他类，因为已经继承了Enum类，也不能被继承。</p><p>枚举可以实现接口，像上面就是内部实现了两个接口，我们也可以自己实现其他接口</p><h2 id="枚举添加方法"><a href="#枚举添加方法" class="headerlink" title="枚举添加方法"></a>枚举添加方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public enum  TestEnum &#123;</span><br><span class="line"></span><br><span class="line">    //此处调用额其实就是下面写的构造函数</span><br><span class="line">     TEST(22),</span><br><span class="line">    TEST1(33),</span><br><span class="line">    TEST2(44),</span><br><span class="line">    TEST3(55);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private TestEnum(int num) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h1&gt;&lt;p&gt;enum 的全程事 Enumeration 是jdk1.5引进的&lt;/p&gt;
&lt;p&gt;被enum 修饰的数据类型就是枚举类型：&lt;br&gt;&lt;figur
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 泛型</title>
    <link href="hexo/blog/2020/05/java-%E6%B3%9B%E5%9E%8B.html"/>
    <id>hexo/blog/2020/05/java-泛型.html</id>
    <published>2020-05-19T15:05:30.000Z</published>
    <updated>2020-06-01T02:22:37.499Z</updated>
    
    <content type="html"><![CDATA[<p>声明中有一个或者多个类型化参数的类或者接口，叫做泛型类或者接口。泛型类和接口统称为泛型。</p><p>泛型是一种安全规范，帮助我们在编译前就发现类型安全问题，而不需要等到编译报错。泛型在编译时会被擦除。</p><p>关于使用泛型的几个规则：</p><ul><li>请不要使用原生态类型<br>  如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势</li><li><p>消除非受检的警告</p></li><li><p>优先考虑泛型</p></li><li><p>优先考虑泛型方法</p></li></ul><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>无限通配符 ？<br>上限通配符 ？ extends T<br>下限通配符 ? super T</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;声明中有一个或者多个类型化参数的类或者接口，叫做泛型类或者接口。泛型类和接口统称为泛型。&lt;/p&gt;
&lt;p&gt;泛型是一种安全规范，帮助我们在编译前就发现类型安全问题，而不需要等到编译报错。泛型在编译时会被擦除。&lt;/p&gt;
&lt;p&gt;关于使用泛型的几个规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 集合</title>
    <link href="hexo/blog/2020/05/java-%E9%9B%86%E5%90%88.html"/>
    <id>hexo/blog/2020/05/java-集合.html</id>
    <published>2020-05-18T15:08:59.000Z</published>
    <updated>2020-06-01T02:22:37.498Z</updated>
    
    <content type="html"><![CDATA[<p>java中的集合包括map、set、list</p><p>collection</p><p>所有的linked 都是链表实现<br>所有的hash 都是hash表，存储的对象都需要重写hashcode、equas函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java中的集合包括map、set、list&lt;/p&gt;
&lt;p&gt;collection&lt;/p&gt;
&lt;p&gt;所有的linked 都是链表实现&lt;br&gt;所有的hash 都是hash表，存储的对象都需要重写hashcode、equas函数&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
</feed>
