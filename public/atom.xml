<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2022-07-11T06:11:06.695Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Socket详解</title>
    <link href="hexo/blog/2022/07/Socket%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2022/07/Socket详解.html</id>
    <published>2022-07-11T06:06:33.000Z</published>
    <updated>2022-07-11T06:11:06.695Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Socket在网络通信中扮演及其重要的角色</li></ul><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><ul><li>即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）</li></ul><p><img src="../../../images/socket1.png" style="zoom:60%"></p><blockquote><p>Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）<br>即：通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发<br>对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信</p></blockquote><ul><li>成对出现，一对套接字：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket =&#123;(IP地址<span class="number">1</span>:PORT端口号)，(IP地址<span class="number">2</span>:PORT端口号)\&#125;</span><br></pre></td></tr></table></figure><ul><li>一个 Socket 实例 唯一代表一个主机上的一个应用程序的通信链路</li></ul><h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p>Socket的使用类型主要有两种：</p><ul><li>流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务</li><li>数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务</li></ul><p>具体原理图如下：</p><p><img src="../../../images/socket3.png" style="zoom:60%"></p><h2 id="3、Socket建立连接过程"><a href="#3、Socket建立连接过程" class="headerlink" title="3、Socket建立连接过程"></a>3、Socket建立连接过程</h2><p><img src="../../../images/socket2.png" style="zoom:60%"></p><h2 id="4、Socket-与-Http-对比"><a href="#4、Socket-与-Http-对比" class="headerlink" title="4、Socket 与 Http 对比"></a>4、Socket 与 Http 对比</h2><ul><li>Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题</li><li>HTTP协议 属于 应用层，解决的是如何包装数据</li></ul><p>由于二者不属于同一层面，所以本来是没有可比性的。但随着发展，默认的Http里封装了下面几层的使用，<br>所以才会出现Socket &amp; HTTP协议的对比：（主要是工作方式的不同）：</p><ul><li>Http：采用 请求—响应 方式。</li></ul><blockquote><ul><li>即建立网络连接后，当 客户端 向 服务器 发送请求后，服务器端才能向客户端返回数据。</li><li>可理解为：是客户端有需要才进行通信</li></ul></blockquote><ul><li>Socket：采用 服务器主动发送数据 的方式</li></ul><blockquote><ul><li>即建立网络连接后，服务器可主动发送消息给客户端，而不需要由客户端向服务器发送请求</li><li>可理解为：是服务器端有需要才进行通信</li></ul></blockquote><p>5.使用</p><ul><li>Socket可基于TCP或者UDP协议，但TCP更加常用</li><li>所以下面的使用步骤 &amp; 实例的Socket将基于TCP协议</li></ul><p>在客户端使用示例：<a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/socket" target="_blank" rel="noopener">https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/socket</a></p><h2 id="Socket源码解读"><a href="#Socket源码解读" class="headerlink" title="Socket源码解读"></a>Socket源码解读</h2><h3 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h3><p>当Socket实例创建完毕时，TCP三次握手就已完成，代表实例已创建。</p><p>客户端创建实例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = Socket(<span class="string">"192.168.101.130"</span>, <span class="number">3333</span>)</span><br></pre></td></tr></table></figure></p><ul><li>看一下Socket构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnknownHostException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Android-changed: App compat. Socket ctor should try all addresses. http://b/30007735</span></span><br><span class="line">        <span class="keyword">this</span>(InetAddress.getAllByName(host), port, (SocketAddress) <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里会把传入的主机域名解析成 ip地址集合，然后调用另一个构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Socket</span><span class="params">(InetAddress[] addresses, <span class="keyword">int</span> port, SocketAddress localAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addresses == <span class="keyword">null</span> || addresses.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 当ip解析为空时，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Impossible: empty address list"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addresses.length; i++) &#123;</span><br><span class="line">            setImpl();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(addresses[i], port);</span><br><span class="line">                createImpl(stream);</span><br><span class="line">                <span class="keyword">if</span> (localAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bind(localAddr);</span><br><span class="line">                &#125;</span><br><span class="line">                connect(address);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | IllegalArgumentException | SecurityException e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Android-changed: Let ctor call impl.close() instead of overridable close().</span></span><br><span class="line">                    <span class="comment">// Subclasses may not expect a call to close() coming from this constructor.</span></span><br><span class="line">                    impl.close();</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ce) &#123;</span><br><span class="line">                    e.addSuppressed(ce);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Only stop on the last address.</span></span><br><span class="line">                <span class="keyword">if</span> (i == addresses.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Discard the connection state and try again.</span></span><br><span class="line">            impl = <span class="keyword">null</span>;</span><br><span class="line">            created = <span class="keyword">false</span>;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">            closed = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，在此处的逻辑中，最主要只有如下四个函数</p><ul><li>setImpl()</li><li>createImpl(stream)</li><li>bind(localAddr)</li><li>connect(address)</li></ul><p>再对以上四个函数进行逐一分析</p><p>先看一下 SocketImpl 及其子类的UML类图<br><img src="../../../images/socketImpl.png" style="zoom:60%"></p><h4 id="setImpl"><a href="#setImpl" class="headerlink" title="setImpl"></a>setImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        impl = factory.createSocketImpl();</span><br><span class="line">        checkOldImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No need to do a checkOldImpl() here, we know it's an up to date</span></span><br><span class="line">        <span class="comment">// SocketImpl!</span></span><br><span class="line">        impl = <span class="keyword">new</span> SocksSocketImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (impl != <span class="keyword">null</span>)</span><br><span class="line">        impl.setSocket(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>factory 默认为空，除非 通过调用 setSocketImplFactory 手动实现自己的 SocketImplFactory</p><p>所以此处的 impl = new SocksSocketImpl();</p><h4 id="createImpl-stream"><a href="#createImpl-stream" class="headerlink" title="createImpl(stream)"></a>createImpl(stream)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createImpl</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (impl == <span class="keyword">null</span>)</span><br><span class="line">        setImpl();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        impl.create(stream);</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说了  impl = new SocksSocketImpl();<br>但 SocksSocketImpl 中并没有实现 create 函数， SocksSocketImpl 是继承自 PlainSocketImpl，而 PlainSocketImpl，而 中也没有实现 create 函数,<br>而 PlainSocketImpl 又是继承自 AbstractPlainSocketImpl</p><p>也就是说最终是调用的 AbstractPlainSocketImpl 中的 create</p><ul><li>AbstractPlainSocketImpl create<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// stream = true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">boolean</span> stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">        <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">            ResourceManager.beforeUdpCreate();</span><br><span class="line">            <span class="comment">// Android-removed: socketCreate should set fd if it succeeds.</span></span><br><span class="line">            <span class="comment">// fd = new FileDescriptor();</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socketCreate(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ResourceManager.afterUdpClose();</span><br><span class="line">                <span class="comment">// Android-changed: Closed sockets use an invalid fd, not null. b/26470377</span></span><br><span class="line">                <span class="comment">// fd = null;</span></span><br><span class="line">                <span class="keyword">throw</span> ioe;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Android-removed: socketCreate should set fd if it succeeds.</span></span><br><span class="line">            <span class="comment">// fd = new FileDescriptor();</span></span><br><span class="line">            socketCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">            socket.setCreated();</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">            serverSocket.setCreated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Android-added: CloseGuard.</span></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span> &amp;&amp; fd.valid()) &#123;</span><br><span class="line">            guard.open(<span class="string">"close"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>此处会调用 socketCreate 但 该函数是一个抽象函数，查看子类是否有实现，</p><ul><li>在   类中，实现了该函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketCreate</span><span class="params">(<span class="keyword">boolean</span> isStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// The fd object must not change after calling bind, because we rely on this undocumented</span></span><br><span class="line">        <span class="comment">// behaviour. See libcore.java.net.SocketTest#testFileDescriptorStaysSame.</span></span><br><span class="line">        fd.setInt$(IoBridge.socket(AF_INET6, isStream ? SOCK_STREAM : SOCK_DGRAM, <span class="number">0</span>).getInt$());</span><br><span class="line">        IoUtils.setFdOwner(fd, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            IoUtils.setBlocking(fd, <span class="keyword">false</span>);</span><br><span class="line">            IoBridge.setSocketOption(fd, SO_REUSEADDR, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>上次的调用还只是 生成一个 SocketImpl 的实例对象</li><li>接下来查看 bind 函数</li></ul><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress bindpoint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isBound())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Already bound"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bindpoint != <span class="keyword">null</span> &amp;&amp; (!(bindpoint <span class="keyword">instanceof</span> InetSocketAddress)))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) bindpoint;</span><br><span class="line">        <span class="keyword">if</span> (epoint != <span class="keyword">null</span> &amp;&amp; epoint.isUnresolved())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Unresolved address"</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoint == <span class="keyword">null</span>) &#123;</span><br><span class="line">            epoint = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        InetAddress addr = epoint.getAddress();</span><br><span class="line">        <span class="keyword">int</span> port = epoint.getPort();</span><br><span class="line">        checkAddress (addr, <span class="string">"bind"</span>);</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkListen(port);</span><br><span class="line">        &#125;</span><br><span class="line">        getImpl().bind (addr, port);</span><br><span class="line">        bound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getImpl().bind (addr, port);<br>也就是说最终会调用到 AbstractPlainSocketImpl 中的 bind 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(InetAddress address, <span class="keyword">int</span> lport)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!closePending &amp;&amp; (socket == <span class="keyword">null</span> || !socket.isBound())) &#123;</span><br><span class="line">                NetHooks.beforeTcpBind(fd, address, lport);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        socketBind(address, lport);</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">            socket.setBound();</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">            serverSocket.setBound();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与 create 函数类似，此处也会调用一个抽象函数， socketBind(address, lport); 该函数的实现在 PlainSocketImpl 类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PlainSocketImpl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketBind</span><span class="params">(InetAddress address, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="keyword">null</span> || !fd.valid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IoBridge.bind(fd, address, port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Now that we're a connected socket, let's extract the port number that the system</span></span><br><span class="line">            <span class="comment">// chose for us and store it in the Socket object.</span></span><br><span class="line">            localport = IoBridge.getLocalInetSocketAddress(fd).getPort();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            localport = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>bind 函数的主要作用应该是 绑定 地址、端口、fd(FileDescriptor)</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>connect 过程代表的是 TCP 建立连接过程中的 <strong>第一次握手</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress endpoint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        connect(endpoint, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (endpoint == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: The address can't be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connect: timeout can't be negative"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isClosed())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!oldImpl &amp;&amp; isConnected())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"already connected"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(endpoint <span class="keyword">instanceof</span> InetSocketAddress))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported address type"</span>);</span><br><span class="line"></span><br><span class="line">        InetSocketAddress epoint = (InetSocketAddress) endpoint;</span><br><span class="line">        InetAddress addr = epoint.getAddress ();</span><br><span class="line">        <span class="keyword">int</span> port = epoint.getPort();</span><br><span class="line">        checkAddress(addr, <span class="string">"connect"</span>);</span><br><span class="line"></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">                security.checkConnect(epoint.getHostName(), port);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                security.checkConnect(addr.getHostAddress(), port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!created)</span><br><span class="line">            createImpl(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oldImpl)</span><br><span class="line">            impl.connect(epoint, timeout);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epoint.isUnresolved())</span><br><span class="line">                impl.connect(addr.getHostName(), port);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                impl.connect(addr, port);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"SocketImpl.connect(addr, timeout)"</span>);</span><br><span class="line">        connected = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the socket was not bound before the connect, it is now because</span></span><br><span class="line"><span class="comment">         * the kernel will have picked an ephemeral port &amp; a local address</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bound = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处会调用  impl.connect(addr, port); 最终实现在 AbstractPlainSocketImpl 类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnknownHostException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> connected = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress address = InetAddress.getByName(host);</span><br><span class="line">            <span class="keyword">this</span>.port = port;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line"></span><br><span class="line">            connectToAddress(address, port, timeout);</span><br><span class="line">            connected = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    <span class="comment">/* Do nothing. If connect threw an exception then</span></span><br><span class="line"><span class="comment">                       it will be passed up the call stack */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectToAddress</span><span class="params">(InetAddress address, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (address.isAnyLocalAddress()) &#123;</span><br><span class="line">            doConnect(InetAddress.getLocalHost(), port, timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doConnect(address, port, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">(InetAddress address, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!closePending &amp;&amp; (socket == <span class="keyword">null</span> || !socket.isBound())) &#123;</span><br><span class="line">                NetHooks.beforeTcpConnect(fd, address, port);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acquireFD();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Android-added: BlockGuard.</span></span><br><span class="line">                BlockGuard.getThreadPolicy().onNetwork();</span><br><span class="line">                socketConnect(address, port, timeout);</span><br><span class="line">                <span class="comment">/* socket may have been closed during poll/select */</span></span><br><span class="line">                <span class="keyword">synchronized</span> (fdLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (closePending) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException (<span class="string">"Socket closed"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If we have a ref. to the Socket, then sets the flags</span></span><br><span class="line">                <span class="comment">// created, bound &amp; connected to true.</span></span><br><span class="line">                <span class="comment">// This is normally done in Socket.connect() but some</span></span><br><span class="line">                <span class="comment">// subclasses of Socket may call impl.connect() directly!</span></span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    socket.setBound();</span><br><span class="line">                    socket.setConnected();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                releaseFD();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会调用到 socketConnect 函数， 该函数又是抽象函数， 会调用到 PlainSocketImpl 中的 socketConnect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">socketConnect</span><span class="params">(InetAddress address, <span class="keyword">int</span> port, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="keyword">null</span> || !fd.valid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket closed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IoBridge.connect(fd, address, port, timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localport == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If socket is pending close, fd becomes an AF_UNIX socket and calling</span></span><br><span class="line">            <span class="comment">// getLocalInetSocketAddress will fail.</span></span><br><span class="line">            <span class="comment">// http://b/34645743</span></span><br><span class="line">            <span class="keyword">if</span> (!isClosedOrPending()) &#123;</span><br><span class="line">                localport = IoBridge.getLocalInetSocketAddress(fd).getPort();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时，TCP连接中第一次握手完成，会发送一个  <strong>连接请求</strong> 报文段到服务端，报文段中首部信息：SYN = 1， 并随机一个起始序号 x， seq = x；不携带数据， 客户端进入 SYN_SENT  状态</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Socket在网络通信中扮演及其重要的角色&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、定义&quot;&gt;&lt;a href=&quot;#1、定义&quot; class=&quot;headerlink&quot; title=&quot;1、定义&quot;&gt;&lt;/a&gt;1、定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;即套接字，是应用层 与 TC
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议详解</title>
    <link href="hexo/blog/2022/07/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2022/07/TCP协议详解.html</id>
    <published>2022-07-07T02:51:44.000Z</published>
    <updated>2022-07-11T06:06:14.662Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址：<a href="https://www.jianshu.com/p/65605622234b" target="_blank" rel="noopener">https://www.jianshu.com/p/65605622234b</a></p><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>Transmission Control Protocol，即 传输控制协议</p><blockquote><ul><li>属于 传输层通信协议</li><li>基于TCP的应用层协议有HTTP、SMTP、FTP、Telnet 和 POP3</li></ul></blockquote><p>位于TCP/IP协议体系结构中的第三层 传输层</p><h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><ul><li>面向连接<ul><li>使用TCP协议传输数据前，必须先建立TCP连接</li></ul></li><li>全双工通信<ul><li>通信双方都可以发送数据</li></ul></li><li>可靠<ul><li>不丢失、无差错、不重复、按序到达</li></ul></li><li>面向字节流<ul><li>一次传输的报文段有长度限制，可分块、分次传输</li></ul></li></ul><h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h2><ul><li>优点： 可靠，不丢失</li><li>缺点： 效率低，因为每次使用都要建立连接</li></ul><h2 id="4-报文段格式"><a href="#4-报文段格式" class="headerlink" title="4.报文段格式"></a>4.报文段格式</h2><ul><li>TCP虽面向字节流，但传送的数据单元 = 报文段</li><li>报文段 = 首部 + 数据 2部分</li><li>TCP的全部功能体现在它首部中各字段的作用，故下面主要讲解TCP报文段的首部</li></ul><blockquote><p>首部前20个字符固定、后面有4n个字节是根据需而增加的选项<br>故 TCP首部最小长度 = 20字节</p></blockquote><p><img src="../../../images/tcp1.png" style="zoom:60%"><br><img src="../../../images/tcp2.png" style="zoom:60%"></p><h2 id="5-TCP连接建立过程"><a href="#5-TCP连接建立过程" class="headerlink" title="5.TCP连接建立过程"></a>5.TCP连接建立过程</h2><ul><li>TCP协议建立需要经过 三次握手<ul><li>第一次握手：客户端发送一个 <strong>连接请求</strong> 报文段到服务端，报文段中首部信息：SYN = 1， 并随机一个起始序号 x， seq = x；不携带数据， 客户端进入 SYN_SENT  状态</li><li>第二次握手：服务端接收到连接请求报文段，，也向客户端发送一个 <strong>连接确认</strong> 的报文段，报文段中首部信息：SYN = 1，ACK = 1，并随机一个起始序号 y， seq = y，确认号字段，ack = x + 1；不携带数据，服务端进入 SYN_RCVD 状态</li><li>第三次握手：客户端收到服务端发送的连接确认报文段，再向服务端发送一个 <strong>连接确认</strong> 的报文段，报文段首部信息：ACK = 1，seq = x + 1， ack = y + 1，因无SYN = 1，此报文段可携带数据.此时，客户端与服务端都进入ESTABLISHED状态</li></ul></li></ul><p><img src="../../../images/tcp3.png" style="zoom:60%"><br><img src="../../../images/tcp4.png" style="zoom:60%"></p><p><strong>成功进行TCP的三次握手后，就建立起一条TCP连接，即可传送应用层数据</strong></p><blockquote><ul><li>因 TCP提供的是全双工通信，故通信双方的应用进程在任何时候都能发送数据</li><li>三次握手期间，任何1次未收到对面的回复，则都会重发</li></ul></blockquote><h3 id="特别说明：为什么TCP建立连接需三次握手？"><a href="#特别说明：为什么TCP建立连接需三次握手？" class="headerlink" title="特别说明：为什么TCP建立连接需三次握手？"></a>特别说明：为什么TCP建立连接需三次握手？</h3><ul><li><p>answer:</p><ul><li>防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源</li></ul></li><li><p>具体描述<br><img src="../../../images/tcp5.png" style="zoom:60%"></p></li></ul><blockquote><p>SYN洪泛攻击：</p><p>从上可看出：服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时<br>这就使得服务器易于受到SYN洪泛攻击，即同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配 </p></blockquote><h2 id="6-释放连接过程"><a href="#6-释放连接过程" class="headerlink" title="6.释放连接过程"></a>6.释放连接过程</h2><p>在通信结束后，需要释放TCP连接，需经历四次挥手过程，才能断开连接</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>第一次挥手，客户端向服务端发送一个 <strong>释放连接</strong> 的报文段，报文段信息：FIN = 1，seq = u，客户端进入 FIN_WAIT_1 状态</li><li>第二次挥手，服务端收到客户端发送的释放连接的请求报文，想客户端发送一个 <strong>连接释放确认</strong> 报文段，报文段信息： ACK = 1，seq = v，ack = u + 1， 服务端进入 CLOSE_WAIT 状态。<br>此时，客户端 -&gt; 服务端的连接已断开，TCP连接处于半关闭状态</li><li>第三次挥手，服务端向客户端再发送一个 <strong>释放连接</strong> 的报文段，报文段信息：FIN= 1， ACK = 1，seq = w，ack = u + 1；服务端进入 LAST_ACK 状态</li><li>第四次挥手，客户端接收到服务端发送的释放连接报文，再向服务端发送一个 <strong>连接释放确认</strong> 报文段，报文段信息： ACK = 1，seq = u + 1，ack = w + 1。<br>此时客户端进入 TIME_WAIT 状态，服务端进入 CLOSED 状态，此时TCP还未断开，需经过时间等待计时器设置的时间2MSL后，客户端才进入 CLOSED 状态，即服务端比客户端先关闭</li></ul><p><img src="../../../images/tcp6.png" style="zoom:60%"><br><img src="../../../images/tcp7.png" style="zoom:60%"></p><h3 id="特别说明：为什么TCP释放连接需四次挥手？"><a href="#特别说明：为什么TCP释放连接需四次挥手？" class="headerlink" title="特别说明：为什么TCP释放连接需四次挥手？"></a>特别说明：为什么TCP释放连接需四次挥手？</h3><ul><li><p>结论</p><ul><li>为了保证通信双方都能通知对方 需释放 &amp; 断开连接<blockquote><p>即释放连接后，都无法接收 / 发送消息给对方</p></blockquote></li></ul></li><li><p>具体描述<br><img src="../../../images/tcp8.png" style="zoom:60%"></p></li></ul><blockquote><p>延伸疑问：为什么客户端关闭连接前要等待2MSL时间？</p><p>即 TIME - WAIT 状态的作用是什么；<br>MSL = 最长报文段寿命（Maximum Segment Lifetime）</p></blockquote><ul><li><p>原因1：为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接<br><img src="../../../images/tcp9.png" style="zoom:60%"></p></li><li><p>原因2：防止 上文提到的早已失效的连接请求报文 出现在本连接中客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失</p></li></ul><blockquote><p>即 在下1个新的连接中就不会出现早已失效的连接请求报文</p></blockquote><h2 id="7-无差错传输"><a href="#7-无差错传输" class="headerlink" title="7.无差错传输"></a>7.无差错传输</h2><ul><li>对比于UDP，TCP的传输是可靠的、无差错的</li><li>那么，为什么TCP的传输为什么是可靠的、无差错的呢？</li><li>下面，我将详细讲解TCP协议的无差错传输</li></ul><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>无差错：即 传输信道不出差错</li><li>发送 &amp; 接收效率匹配：即 无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据</li></ul><h3 id="基础：滑动窗口-协议"><a href="#基础：滑动窗口-协议" class="headerlink" title="基础：滑动窗口 协议"></a>基础：滑动窗口 协议</h3><ul><li>先理解2个基础概念：发送窗口、接收窗口<br><img src="../../../images/tcp10.png" style="zoom:60%"></li></ul><ul><li>工作原理<ul><li>对于发送端：<ul><li>1、每收到一个确认帧，发送窗口就向前滑动一个帧的距离</li><li>2、当发送窗口内无可发送的帧时（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送</li></ul></li></ul></li></ul><p>具体如下图：</p><p><img src="../../../images/tcp11.png" style="zoom:60%"></p><p>只有收到服务端发送的确认帧，才会继续发送数据帧，否则停止发送</p><ul><li>对于接收端：当收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</li></ul><p><img src="../../../images/tcp12.png" style="zoom:60%"></p><p>也就是说，只有确保当前的数据帧是准确位置窗口的，否则丢弃</p><ul><li>总的流程：<ul><li>1、客户端向服务端发送数据帧</li><li>2、服务端接收数据帧，并判断该数据帧是否属于当前接收窗口，如果不是，则丢弃该数据帧。如果是，则放入该接收窗口，并右移，然后向客户端发送确认帧</li><li>3、客户端接收到确认帧，并检查发出的数据帧是否都收到确认帧，如果没有，则等待接收确认帧。如果都收到确认帧，则又从第1步开始。</li></ul></li></ul><h3 id="滑动窗口-协议的重要特性"><a href="#滑动窗口-协议的重要特性" class="headerlink" title="滑动窗口 协议的重要特性"></a>滑动窗口 协议的重要特性</h3><ul><li>只有接收窗口向前滑动、接收方发送了确认帧时，发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动</li><li>停止-等待协议、后退N帧协议 &amp; 选择重传协议只是在发送窗口大小和接收窗口大小上有所差别：</li></ul><blockquote><p>停止等待协议：发送窗口大小=1，接收窗口大小=1；即 单帧滑动窗口 等于 停止-等待协议<br>后退N帧协议：发送窗口大小&gt;1，接收窗口大小=1。<br>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1。</p></blockquote><ul><li>当接收窗口的大小为1时，可保证帧有序接收。</li><li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意要与TCP的滑动窗口协议区别）</li></ul><h3 id="实现无差错传输的解决方案"><a href="#实现无差错传输的解决方案" class="headerlink" title="实现无差错传输的解决方案"></a>实现无差错传输的解决方案</h3><p>核心思想：采用一些可靠传输协议，使得 </p><ul><li>出现差错时，让发送方重传差错数据：即 出错重传</li><li>当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率：即 速度匹配</li></ul><p>针对上述2个问题，分别采用的解决方案是：自动重传协议 和 流量控制 &amp; 拥塞控制协议</p><p><strong>解决方案1：自动重传请求协议ARQ（针对 出错重传）</strong></p><ul><li><p>定义</p><ul><li>即 Auto Repeat reQuest，具体介绍如下：<br><img src="../../../images/tcp13.png" style="zoom:60%"></li></ul></li><li><p>类型</p></li></ul><p><img src="../../../images/tcp14.png" style="zoom:60%"></p><p>下面，将主要讲解 上述3类协议</p><p><em>类型1：停等式ARQ（Stop-and-Wait）</em> </p><ul><li>原理：（单帧滑动窗口）停止 - 等待协议 + 超时重传</li></ul><blockquote><p>即 ：发送窗口大小=1、接收窗口大小=1</p></blockquote><ul><li>停止 - 等待协议的协议原理如下：</li></ul><blockquote><p>发送方每发送一帧，要等到接收方的应答信号后才能发送下一帧<br>接收方每接收一帧，都要反馈一个应答信号，表示可接下一帧<br>若接收方不反馈应答信号，则发送方必须一直等待</p></blockquote><p><em>类型2：后退N帧协议</em><br>也称：连续ARQ协议</p><ul><li>原理<ul><li>多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传</li></ul></li></ul><blockquote><p>即 ：发送窗口大小&gt;1、接收窗口大小=1</p></blockquote><ul><li>具体描述</li></ul><p>a. 发送方：采用多帧滑动窗口的原理，可连续发送多个数据帧 而不需等待对方确认<br>b. 接收方：采用 累计确认 &amp; 后退N帧的原理，只允许按顺序接收帧。具体原理如下：</p><p><img src="../../../images/tcp15.png" style="zoom:60%"></p><p><em>示例讲解</em></p><p>本示例 = 源站 向 目的站 发送数据帧。具体示例如下：<br><img src="../../../images/tcp16.png" style="zoom:60%"></p><p><strong>类型3：选择重传ARQ（Selective Repeat）</strong></p><ul><li>原理<ul><li>多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传<blockquote><p>即 ：发送窗口大小&gt;1、接收窗口大小&gt;1</p></blockquote></li></ul></li></ul><p>类似于类型2（后退N帧协议），此处仅仅是接收窗口大小的区别，故此处不作过多描述</p><ul><li>特点<ul><li>a. 优：因连续发送数据帧而提高了信道的利用率</li><li>b. 缺：重传时又必须把原来已经传送正确的数据帧进行重传（仅因为这些数据帧前面有一个数据帧出了错），将导致传送效率降低</li></ul></li></ul><blockquote><p>由此可见，若信道传输质量很差，导致误码率较大时，后退N帧协议不一定优于停止-等待协议</p></blockquote><p><strong>解决方案2：流量控制 &amp; 拥塞控制（针对 速度匹配）</strong></p><p><em>措施1：流量控制</em></p><ul><li>简介</li></ul><p><img src="../../../images/tcp17.png" style="zoom:60%"></p><ul><li><p>示例<br><img src="../../../images/tcp18.png" style="zoom:60%"></p></li><li><p>特别注意：死锁问题<br><img src="../../../images/tcp19.png" style="zoom:60%"></p></li><li><p>措施2：拥塞控制 *</p></li><li><p>定义</p><ul><li>防止过多的数据注入到网络中，使得网络中的路由器 &amp; 链路不致于过载<blockquote><p>拥塞：对网络中的资源需求 &gt; 该资源所能提供的部分</p></blockquote></li></ul></li><li><p>与 “流量控制”的区别</p></li></ul><p><img src="../../../images/tcp20.png" style="zoom:60%"></p><ul><li>具体解决方案<ul><li>共分为2个解决方案：慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复<blockquote><p>其中，涉及4种算法，即 慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复</p></blockquote></li></ul></li></ul><h4 id="解决方案1：慢开始-amp-拥塞避免"><a href="#解决方案1：慢开始-amp-拥塞避免" class="headerlink" title="解决方案1：慢开始 &amp; 拥塞避免"></a>解决方案1：慢开始 &amp; 拥塞避免</h4><h5 id="储备知识：拥塞窗口、慢开始算法、拥塞避免算法"><a href="#储备知识：拥塞窗口、慢开始算法、拥塞避免算法" class="headerlink" title="储备知识：拥塞窗口、慢开始算法、拥塞避免算法"></a>储备知识：拥塞窗口、慢开始算法、拥塞避免算法</h5><h6 id="a-拥塞窗口"><a href="#a-拥塞窗口" class="headerlink" title="a. 拥塞窗口"></a>a. 拥塞窗口</h6><ul><li>发送方维持一个状态变量：拥塞窗口（cwnd， congestion window ），具体介绍如下</li></ul><p><img src="../../../images/tcp21.png" style="zoom:60%"></p><h6 id="b-慢开始算法"><a href="#b-慢开始算法" class="headerlink" title="b. 慢开始算法"></a>b. 慢开始算法</h6><ul><li><p>原理</p><ul><li>当主机开始发送数据时，由小到大逐渐增大 拥塞窗口数值（即 发送窗口数值），从而<em> 由小到大 </em>逐渐增大发送报文段</li></ul></li><li><p>目的</p><ul><li>开始传输时，试探网络的拥塞情况</li></ul></li><li><p>具体措施</p></li></ul><p><img src="../../../images/tcp22.png" style="zoom:60%"></p><ul><li>示意图</li></ul><p><img src="../../../images/tcp23.png" style="zoom:60%"></p><ul><li>特别注意<ul><li>慢开始的“慢”指：一开始发送报文段时拥塞窗口（cwnd）设置得较小（为1），使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况）</li></ul></li></ul><blockquote><p>并不是指拥塞窗口（cwnd）的增长速率慢</p></blockquote><h6 id="c-拥塞避免-算法"><a href="#c-拥塞避免-算法" class="headerlink" title="c. 拥塞避免 算法"></a>c. 拥塞避免 算法</h6><ul><li>原理<ul><li>使得拥塞窗口（cwnd）按线性规律 缓慢增长：每经过一个往返时间RTT，发送方的拥塞窗口（cwnd）加1</li></ul></li></ul><blockquote><p>拥塞避免 并不可避免拥塞，只是将拥塞窗口按现行规律缓慢增长，使得网络比较不容易出现拥塞<br>相比慢开始算法的加倍，拥塞窗口增长速率缓慢得多</p></blockquote><ul><li>示意图</li></ul><p><img src="../../../images/tcp24.png" style="zoom:60%"></p><h5 id="解决方案1描述（慢开始-amp-拥塞避免）"><a href="#解决方案1描述（慢开始-amp-拥塞避免）" class="headerlink" title="解决方案1描述（慢开始 &amp; 拥塞避免）"></a>解决方案1描述（慢开始 &amp; 拥塞避免）</h5><ul><li>为了防止拥塞窗口（cwnd）增长过大而引起网络拥塞，采用慢开始 &amp; 拥塞避免 2种算法，具体规则如下</li></ul><p><img src="../../../images/tcp25.png" style="zoom:60%"></p><ul><li>实例说明</li></ul><p><img src="../../../images/tcp26.png" style="zoom:60%"></p><h4 id="解决方案2：快重传-amp-快恢复"><a href="#解决方案2：快重传-amp-快恢复" class="headerlink" title="解决方案2：快重传 &amp; 快恢复"></a>解决方案2：快重传 &amp; 快恢复</h4><p>快重传 &amp; 快恢复的解决方案 是对慢开始 &amp; 拥塞避免算法的改进</p><ul><li>2.1 储备知识：快重传算法、快恢复算法 *</li></ul><h5 id="a-快重传算法"><a href="#a-快重传算法" class="headerlink" title="a. 快重传算法"></a>a. 快重传算法</h5><ul><li><p>原理</p><ul><li>接收方 每收到一个失序的报文段后 就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认</li><li>发送方只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必 继续等待设置的重传计时器到期</li></ul></li><li><p>作用</p><ul><li>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%</li></ul></li><li><p>示意图<br><img src="../../../images/tcp27.png" style="zoom:60%"></p></li></ul><h5 id="b-快恢复"><a href="#b-快恢复" class="headerlink" title="b. 快恢复"></a>b. 快恢复</h5><p>当发送方连续收到3个重复确认后，就：</p><ul><li>执行 乘法减小 算法：把 慢开始门限（ssthresh）设置为 出现拥塞时发送方窗口值的一半 = 拥塞窗口的1半</li><li>将拥塞窗口（cwnd）值设置为 慢开始门限ssthresh减半后的数值 = 拥塞窗口的1半</li><li>执行 加法增大 算法：执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</li></ul><blockquote><p>注：</p><ul><li>由于跳过了拥塞窗口（cwnd）从1起始的慢开始过程，所以称为：快恢复</li><li>此处网络不会发生网络拥塞，因若拥塞，则不会收到多个重复确认报文</li></ul></blockquote><h5 id="解决方案描述（快重传-amp-快恢复）"><a href="#解决方案描述（快重传-amp-快恢复）" class="headerlink" title="解决方案描述（快重传 &amp; 快恢复）"></a>解决方案描述（快重传 &amp; 快恢复）</h5><ul><li>原理<ul><li>为了优化慢开始 &amp; 拥塞避免的解决方案，在上述方案中加入快重传 &amp; 快恢复 2种算法，具体规则如下</li></ul></li></ul><p><img src="../../../images/tcp28.png" style="zoom:60%"></p><ul><li>示意图</li></ul><p><img src="../../../images/tcp29.png" style="zoom:60%"></p><p>至此，关于TCP无差错传输的知识讲解完毕。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址：&lt;a href=&quot;https://www.jianshu.com/p/65605622234b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/65605622234b&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="hexo/blog/2022/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"/>
    <id>hexo/blog/2022/07/计算机网络.html</id>
    <published>2022-07-06T05:54:20.000Z</published>
    <updated>2022-07-08T03:52:31.408Z</updated>
    
    <content type="html"><![CDATA[<p>参考地址：<a href="https://www.jianshu.com/p/45d27f3e1196" target="_blank" rel="noopener">https://www.jianshu.com/p/45d27f3e1196</a></p><h2 id="1、计算机网络结构"><a href="#1、计算机网络结构" class="headerlink" title="1、计算机网络结构"></a>1、计算机网络结构</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul><li><p>定义<br>计算机网络各层 + 其协议的集合</p></li><li><p>作用<br>定义该计算机网络的所能完成的功能</p></li></ul><h3 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h3><p>计算机网络体系结构分为三种：</p><ul><li>OSI体系结构</li><li>TCP/IP体系结构</li><li>五层体系结构</li></ul><blockquote><ul><li>OSI体系结构：概念清楚 &amp; 理念完整，但复杂 &amp; 不实用 </li><li>TCP / IP体系结构：含了一系列构成互联网基础的网络协议，是Internet的核心协议 &amp; 被广泛应用于局域网 和 广域网 </li><li>五层体系结构：融合了OSI 与 TCP / IP的体系结构，目的是为了学习 &amp; 讲解计算机原理 </li></ul></blockquote><table><br>  <tr><br>    <th>OSI体系结构(7层)</th><br>    <th>TCP/IP协议体系(4层)</th><br>    <th>五层体系结构(5层)</th><br>  </tr><br>  <tr><br>    <td>7.应用层</td><br>    <td rowspan="3">4.应用层<br>(HTTP)</td><br>    <td rowspan="3">5.应用层</td><br>  </tr><br>  <tr><br>    <td>6.表示层</td><br>  </tr><br>  <tr><br>    <td>5.会话层</td><br>  </tr><br>  <tr><br>    <td>4.传输层</td><br>    <td>3.运输层<br>(TCP、UDP)</td><br>    <td>4.运输层</td><br>  </tr><br>  <tr><br>    <td>3.网络层</td><br>    <td>2. 网际层<br>(IP)</td><br>    <td>3.网络层</td><br>  </tr><br>  <tr><br>    <td>2.链路层</td><br>    <td rowspan="2">1.网络接口层</td><br>    <td>2.链路层</td><br>  </tr><br>  <tr><br>    <td>1.物理层</td><br>    <td>1.物理层</td><br>  </tr><br></table><blockquote><p>低三层为通信子网，负责数据传输<br>高三层为资源子网，相当于计算机系统，完成数据处理；<br>传输层承上启下 </p></blockquote><h4 id="TCP-IP体系结构详细介绍"><a href="#TCP-IP体系结构详细介绍" class="headerlink" title="TCP/IP体系结构详细介绍"></a>TCP/IP体系结构详细介绍</h4><p>由于 TCP / IP体系结构较为广泛，故主要讲解</p><table><br>  <tr><br>    <th>层级</th><br>    <th>作用</th><br>    <th>传输单位</th><br>    <th>功能</th><br>    <th>具体协议</th><br>  </tr><br>  <tr><br>    <td>1、网络接口层</td><br>    <td>负责与链路(传输媒介)的数据运输工作</td><br>    <td>帧</td><br>    <td><em> 组帧、差错控制、流量控制和运输管理</em></td><br>    <td> EIA-232C、CCITT的X.21<br><br>      <em> SDLC、HDLC、PPP、STP、帧中继<br>    </em></td><br>  </tr><br><br>  <tr><br>    <td>2、网际层</td><br>    <td>为不同主机提供通信服务：网络层的分组数据从源端传到目的端</td><br>    <td>数据报</td><br>    <td> 封装数据成分组/包、路由选择<br>      <br><em> 流量控制、拥塞控制、差错控制 &amp; 网际互连<br>    </em></td><br>    <td> IP协议、ARP协议、RARP协议、ICMP协议、IGMP协议、IPX、OSPF</td><br>  </tr><br><br>  <tr><br>    <td>3、运输层</td><br>    <td>为不同主机进程间提供通信服务</td><br>    <td>报文段TCP、用户数据报UDP</td><br>    <td>为端到端的连接提供可靠的传输服务、流量控制、差错控制、数据传输管理服务</td><br>    <td>TCP协议、UDP协议</td><br>  </tr><br><br>  <tr><br>    <td>4、应用层</td><br>    <td>定义应用进程间通信  &amp; 交互的规则</td><br>    <td>/</td><br>    <td>/</td><br>    <td><br>      HTTP协议<br>      <br><br>      DNS协议<br>      <br><br>      SMTP协议<br>      <br><br>      POP协议<br>      <br><br>      FTP协议<br>      <br><br>      SMB协议<br>      <br><br>      Telnet协议<br>      <br><br>      SSH协议<br>    </td><br>  </tr><br><br></table><h2 id="2、TCP协议"><a href="#2、TCP协议" class="headerlink" title="2、TCP协议"></a>2、TCP协议</h2><p>Transmission Control Protocol，即 传输控制协议</p><blockquote><ul><li>属于 传输层通信协议</li><li>基于TCP的应用层协议有HTTP、SMTP、FTP、Telnet 和 POP3</li></ul></blockquote><p>关于TCP具体信息，可以查看 <a href="TCP协议详解.md">TCP协议</a></p><h2 id="3、UDP协议"><a href="#3、UDP协议" class="headerlink" title="3、UDP协议"></a>3、UDP协议</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>User Datagram Protocol，即 用户数据报协议</p><blockquote><ul><li>属于 传输层通信协议</li><li>基于UDP的应用层协议有 TFTP、SNMP 与 DNS</li></ul></blockquote><h3 id="3-2-特定"><a href="#3-2-特定" class="headerlink" title="3.2 特定"></a>3.2 特定</h3><p>无连接的、不可靠的、面向报文、无拥塞控制，具体介绍如下：</p><table><thead><tr><th>特定</th><th>描述</th></tr></thead><tbody><tr><td>无连接</td><td>使用UDP传输数据前，不需要建立UDP连接</td></tr><tr><td>不可靠</td><td>UDP数据包传输后，不管数据接收包是否接收到</td></tr><tr><td>面向报文</td><td>数据以数据报文的形式传输</td></tr><tr><td>无拥塞控制</td><td>由于是不可靠传输，即不考虑是否接收到数据，所以也就不需要拥塞控制</td></tr></tbody></table><h3 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h3><ul><li>优点：速度快</li><li>缺点：数据容易丢失</li></ul><h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h3><p>要求通信速度高</p><blockquote><ul><li>域名转换：DNS协议</li><li>文件传输：FTP协议</li><li>网络管理：SNMP协议</li><li>远程文件服务器：NFS协议</li></ul></blockquote><h3 id="3-5-TCP-amp-UDP-的区别"><a href="#3-5-TCP-amp-UDP-的区别" class="headerlink" title="3.5 TCP &amp; UDP 的区别"></a>3.5 TCP &amp; UDP 的区别</h3><table><br>  <tr><br>    <th rowspan="2">类型</th><br>    <th colspan="3">特点</th><br>    <th colspan="2">性能</th><br>    <th rowspan="2">应用场景</th><br>    <th rowspan="2">首部字节</th><br>  </tr><br>  <tr><br>    <th>是否面向连接</th><br>    <th>传输可靠性</th><br>    <th>传输形式</th><br>    <th>传输效率</th><br>    <th>所需资源</th><br>  </tr><br>  <tr><br>    <td>TCP</td><br>    <td>面向连接</td><br>    <td>可靠</td><br>    <td>字节流</td><br>    <td>慢</td><br>    <td>多</td><br>    <td>要求通信数据可靠</td><br>    <td>20-60</td><br>  </tr><br>  <tr><br>    <td>UDP</td><br>    <td>无连接</td><br>    <td>不可靠</td><br>    <td>数据报文段</td><br>    <td>快</td><br>    <td>少</td><br>    <td>要求通信速度快</td><br>    <td>8字节，由4个字段组成</td><br>  </tr><br></table><h2 id="4、HTTP协议"><a href="#4、HTTP协议" class="headerlink" title="4、HTTP协议"></a>4、HTTP协议</h2><h2 id="5、Socket"><a href="#5、Socket" class="headerlink" title="5、Socket"></a>5、Socket</h2><h2 id="6、Other"><a href="#6、Other" class="headerlink" title="6、Other"></a>6、Other</h2><h3 id="6-1-在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#6-1-在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="6.1 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>6.1 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h3><blockquote><p>打开一个网页，整个过程会使用哪些协议</p></blockquote><p><img src="../../../images/other.png" style="zoom:60%"></p><h3 id="6-2-IP地址（IPv4地址）"><a href="#6-2-IP地址（IPv4地址）" class="headerlink" title="6.2 IP地址（IPv4地址）"></a>6.2 IP地址（IPv4地址）</h3><ul><li><p>定义<br>连接在Internet中的每一台主机（或 路由器）的全球唯一的标识符</p></li><li><p>组成<br>IP地址 = 32位 = 网络号 + 主机号；即IP地址::={&lt;网络号&gt;，&lt;主机号&gt;}</p></li></ul><blockquote><p>其中：<br>网络号：标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。<br>主机号：标志该主机（或路由器）。一个主机号在它面前的网络号所指明的网络范围必须是唯一的。 </p></blockquote><p>不同类型的IP地址，其主机号 &amp; 网络号所占字节数不同；<em> 故：一个IP地址在整个网络范围内是唯一的 </em></p><ul><li>分类<br>传统的IP地址是分类的地址，分为A，B，C，D，E五类</li></ul><blockquote><p>区别在于网络号 &amp; 主机号占的字节数不同 </p></blockquote><p><img src="../../../images/ip1.png" style="zoom:60%"></p><h3 id="6-3-ICMP协议"><a href="#6-3-ICMP协议" class="headerlink" title="6.3 ICMP协议"></a>6.3 ICMP协议</h3><ul><li>定义<br>Internet Control Message Protocol，即 网际控制报文协议</li></ul><blockquote><ul><li>属于IP层协议 </li><li>注：ICMP报文不是高层协议，而是作为IP层数据报的数据，加上数据报首部，组成IP数据报发出去</li></ul></blockquote><ul><li><p>作用<br>更有效地转发IP数据包 &amp; 提高交付成功的机会</p></li><li><p>分类<br>ICMP差错报告报文 &amp; ICMP询问报文</p></li><li><p>主要应用<br>PING（分组网间探测）、Traceroute（跟踪1个分组从源点到终点的路径，原理 = 从源主机向目的主机发送一连串的IP数据报）</p></li></ul><h3 id="6-4-Ping的过程"><a href="#6-4-Ping的过程" class="headerlink" title="6.4 Ping的过程"></a>6.4 Ping的过程</h3><ul><li>定义<br>Packet InterNet Groper，即分组网间探测</li></ul><blockquote><ul><li>是 ICMP报文的1个重要应用：使用了IPCM回送请求 &amp; 回送回答报文</li><li>是应用层直接使用网络层ICMP的1个例子，无经过传输层的TCP、UDP</li></ul></blockquote><ul><li><p>作用<br>测试2个主机的连通性</p></li><li><p>原理</p><ul><li>向目的主机发送多个ICMP回送请求报文</li><li>根据 目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间</li><li>最终显示的结果：发送到目的主机的IP地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大 &amp; 平均值</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考地址：&lt;a href=&quot;https://www.jianshu.com/p/45d27f3e1196&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/45d27f3e1196&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>程序设计语言</title>
    <link href="hexo/blog/2022/07/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80.html"/>
    <id>hexo/blog/2022/07/程序设计语言.html</id>
    <published>2022-07-06T03:29:19.000Z</published>
    <updated>2022-07-06T03:32:17.055Z</updated>
    
    <content type="html"><![CDATA[<p>计算机语言分为高级语言、低级语言</p><p>语言越低级，离01代码越近，中间“翻译”的步骤也就越简洁，计算机执行的越快，对计算机很友好；</p><p>语言越高级，封装程度就越高，人类就可以用更少的代码来实现功能。编写高级语言并不需要知道他是怎么转换为计算机识别的语言；</p><p>越高级，就越”龟速”，能做的事情也就越少，但同样代码量也比较少。</p><p>低级与高级，省时间与省力气的关系。人写的代码少了，CPU处理的代码就多，。</p><ul><li>低级：机器码，汇编，Base语言</li><li>次低级：C，C++</li><li>高级：Java，C#</li><li>更高级：Python，PHP，JavaScript</li></ul><p>高级语言一般为解释型语言：<br>  在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。<br>  最典型的代表语言为JavaScript、Python、Ruby和Perl等 </p><p>低级语言一般为编译型语言：<br>  运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。<br>  最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件</p><p>编译型：<br>  运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。<br>  最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件。 </p><p>解释型：<br>  在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。<br>  最典型的代表语言为JavaScript、Python、Ruby和Perl等 </p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机语言分为高级语言、低级语言&lt;/p&gt;
&lt;p&gt;语言越低级，离01代码越近，中间“翻译”的步骤也就越简洁，计算机执行的越快，对计算机很友好；&lt;/p&gt;
&lt;p&gt;语言越高级，封装程度就越高，人类就可以用更少的代码来实现功能。编写高级语言并不需要知道他是怎么转换为计算机识别的语言；
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="hexo/blog/2022/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>hexo/blog/2022/07/面向对象.html</id>
    <published>2022-07-05T06:33:03.000Z</published>
    <updated>2022-07-05T07:47:49.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h2><p>把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形成类。<br>类中的大多数数据，只能用本类的方法进行处理。<br>类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。</p><blockquote><p>面向对象的三大特征</p><ul><li>封装</li><li>继承</li><li>多态</li></ul></blockquote><p>参考地址： <a href="https://blog.csdn.net/sugar_no1/article/details/86366714" target="_blank" rel="noopener">https://blog.csdn.net/sugar_no1/article/details/86366714</a></p><h2 id="面向对象分析与设计"><a href="#面向对象分析与设计" class="headerlink" title="面向对象分析与设计"></a>面向对象分析与设计</h2><p>参考地址：<a href="https://blog.csdn.net/huangshanchun/article/details/121727557" target="_blank" rel="noopener">https://blog.csdn.net/huangshanchun/article/details/121727557</a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>参考地址：<a href="https://blog.csdn.net/gghhb12/article/details/124269575" target="_blank" rel="noopener">https://blog.csdn.net/gghhb12/article/details/124269575</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象基本概念&quot;&gt;&lt;a href=&quot;#面向对象基本概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象基本概念&quot;&gt;&lt;/a&gt;面向对象基本概念&lt;/h2&gt;&lt;p&gt;把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件工程基础知识</title>
    <link href="hexo/blog/2022/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>hexo/blog/2022/07/软件工程基础知识.html</id>
    <published>2022-07-05T03:35:36.000Z</published>
    <updated>2022-07-06T03:00:16.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h2><p>共有9种开发模型，适用范围各不相同</p><ul><li><p>瀑布模型（Waterfall Model）</p><ul><li>瀑布模型适合应用的项目类型：需求明确 或者 二次开发</li><li>瀑布模型是结构化方法中的模型，一般应用于结构化的开发</li></ul></li><li><p>原型模型（Prototype Model）</p><ul><li>适合应用的项目类型：需求不明确</li><li>强调构造一个简易的系统</li></ul></li><li><p>演化模型（Evolutionary Model）</p><ul><li>系统的原型经过多轮调整最终形成了产品</li></ul></li><li><p>螺旋模型（Spiral Model）</p><ul><li>包含原型模式和瀑布模型，演化模型，它由多个模型组成</li><li>螺旋模型具有风险分析这个特征，这是其他模型所不具备的</li></ul></li><li><p>增量模型（Incremental Model）</p><ul><li>由原型模型的思想 + 瀑布模型的思想构成</li><li>风险低，用户会多次接触到项目的核心模块到，能尽早的发现问题并修正。</li></ul></li><li><p>V模型</p><ul><li>强调测试要伴随着整个软件开发的过程</li><li>需求分析阶段进行验收测试&amp;系统测试</li></ul></li><li><p>喷泉模型（Water Fountain Model）</p><ul><li>面向对象的，具有迭代和无间隙的特点；</li></ul></li><li><p>快速(应用)开发（RAD）模型</p><ul><li>RAD模型是由瀑布模型（SDLC）和构建组装模型（CBSD）组成</li><li>使用VB，Delphi，C#等可以通过拖动控件来快速实现界面地构建</li></ul></li><li><p>构建组装模型（CBSD）</p></li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>6大设计原则：</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p>对类来说，⼀个类应该只负责⼀项职责。如果⼀个类负责两个职责，可能存在职责1变化，引起职责2的变化情况。可以基于抽象逻<br>辑，或者业务逻辑对类进⾏细化。</p></blockquote><h3 id="接⼝隔离原则"><a href="#接⼝隔离原则" class="headerlink" title="接⼝隔离原则"></a>接⼝隔离原则</h3><blockquote><p>客户端不应该依赖它不需要的接⼝，⼀个类对另外⼀个类的依赖，应该建⽴在最⼩的接⼝上。</p></blockquote><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><blockquote><p>⾼层模块不应该依赖低层模块，两者应依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；中⼼思想是⾯向接⼝编程。</p></blockquote><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>假设有以下场景：</p><ul><li>存在类型T1，和实例对象O1</li><li>存在类型T2，和实例对象O2</li></ul><blockquote><p>如果将所有类型T1的对象都替换成类型T2的对象O2，程序的行为不会发生变化。那么类型T2是类型T1的子类型。<br>换句话说，有引用基类的地方必须能透明的使用其子类的对象</p></blockquote><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p>开闭原则是编程中最基础、最重要的设计原则，在代码结构的设计时，应该考虑对扩展开发，对修改关闭，抽象思维搭建结构，具体实现扩展细节。</p></blockquote><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><blockquote><p>迪⽶特原则⼜叫最少知道原则，即⼀个类对⾃⼰依赖的类知道的越要越好。也就是说，对于依赖的类不管多么复杂，都尽量将逻辑封<br>装在类的内部。对外除了提供的public⽅法，不对外开放任何信息。类与类关系越密切，耦合度越⼤，耦合的⽅式很多，依赖，关<br>联，组合，聚合等。</p></blockquote><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>参考地址：<a href="https://blog.csdn.net/weixin_43421142/article/details/108038676" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43421142/article/details/108038676</a></p><h2 id="质量特性"><a href="#质量特性" class="headerlink" title="质量特性"></a>质量特性</h2><p>参考地址：<a href="https://blog.csdn.net/shuaihj/article/details/7599528" target="_blank" rel="noopener">https://blog.csdn.net/shuaihj/article/details/7599528</a></p><h2 id="Pert图"><a href="#Pert图" class="headerlink" title="Pert图"></a>Pert图</h2><p>参考地址：<a href="https://blog.csdn.net/Daisy74RJ/article/details/106593226" target="_blank" rel="noopener">https://blog.csdn.net/Daisy74RJ/article/details/106593226</a></p><h2 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h2><p>参考地址：<a href="https://zhuanlan.zhihu.com/p/431021736" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/431021736</a></p><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p>参考地址：<a href="https://blog.csdn.net/baidu_32492845/article/details/89604337" target="_blank" rel="noopener">https://blog.csdn.net/baidu_32492845/article/details/89604337</a></p><h2 id="各种码"><a href="#各种码" class="headerlink" title="各种码"></a>各种码</h2><p>原码、补码、反码参考地址：<a href="https://blog.csdn.net/lluojian/article/details/119579921" target="_blank" rel="noopener">https://blog.csdn.net/lluojian/article/details/119579921</a></p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数<br>[+127]原 = 0111 1111<br>[-127]原 = 1111 1111<br>数值“0”由两种原码表示形式：<br>[+0]原 = 0000 0000<br>[-0]原 = 1000 0000</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>源码的范围：-128 ~ +127，最高位是符号位，0表示正数，1表示负数</p><p>[+127]补 = 0111 1111<br>[-128]补 = 1000 0000<br>因为 [-127]反 = 1000 0000 而 [-127]补 = 反 + 1 = 1 0000001<br>所以 [-128]补 = 1000 0000</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数</p><p>[+127]反 = 0111 1111<br>[-127]反 = 1000 0000<br>数值“0”由两种反码表示形式：<br>[+0]反 = 0000 0000<br>[-0]反 = 1111 1111</p><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>使用二进制来编码的十进制。<br>分为三种：</p><ul><li>8421码</li><li>余3码（8421码+）</li><li>2421码</li></ul><h4 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h4><p>一种有权码，四个二进制的权值分配分别为8、4、2、1。</p><p>就是直接将10进制的每位数都转化为长度为4的二进制数，如：</p><p>0——0000</p><p>1——0001</p><p>2——0010</p><p>3——0011</p><p>4——0100</p><p>5——0101</p><p>6——0110</p><p>7——0111</p><p>8——1000</p><p>9——1001</p><p>123——0001 0010 0011（就是先把1的8421码写下来，再写2的，最后写3的）</p><blockquote><p>使用8421码表示的数字怎么进行加法运算？<br>步骤：1.二进制加法运算<br>2.落到1010—10010非合法范围加6修正，0000—1001合法范围就不用+6修正<br>举例：1+1         0001+ 0001 =0010 （=2）不用修正<br>     4+7         0100+ 0111 =1011   （=11）不合法要修正    1011+0110=10001 补0 =0001 0001<br>     9+9         1001+1001=1  0010    修正，后四位加6   0010+0110=1000<br>     补0，结果为 0001 1000 （=18）</p></blockquote><h4 id="余3码（8421码-）"><a href="#余3码（8421码-）" class="headerlink" title="余3码（8421码+）"></a>余3码（8421码+）</h4><p>0——0000+0011=0011</p><p>1——0001+0011=0100</p><p>2——0010+0011=0101</p><p>3——0011+0011=0110</p><p>4——0100+0011=0111</p><p>5——0101+0011=1000</p><p>6——0110+0011=1001</p><p>7——0111+0011=1010</p><p>8——1000+0011=1011</p><p>9——1001+0011=1100</p><p>四个二进制位的权值不固定，是无权码</p><h4 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h4><p>有权码</p><p>四个二进制权值分别为2、4、2、1</p><p>0——0000</p><p>1——0001</p><p>2——0010</p><p>3——0011</p><p>4——0100</p><p>在这里加个分隔，why？注意：0-4编码第一位是0，5-9编码第一位是1。</p><p>这又是为什么呢？避免歧义的发生！你看，0100和1010都可以表示4，这就麻烦了，所以规定0-4编码第一位是0，5-9编码第一位是1，从而使表示方法唯一！</p><p>5——1011</p><p>6——1100</p><p>7——1101</p><p>8——1110</p><p>9——1111</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="10进制转为其他任意进制"><a href="#10进制转为其他任意进制" class="headerlink" title="10进制转为其他任意进制"></a>10进制转为其他任意进制</h3><p>如十进制数 m 转换为 n 进制的数， 此时用 m 一直除以 n 并留余，除到商为0时，将 余数 从下往上排列，即为最终结果。</p><h3 id="二进制转换为10进制"><a href="#二进制转换为10进制" class="headerlink" title="二进制转换为10进制"></a>二进制转换为10进制</h3><p>如 1001 0101 1010 转换为 10进制</p><p> 1001 0101 1010  从左往右排列： 0101 1010 1001</p><p>从左往右开始累加计算： 0 <em> 2^0 + 1 </em> 2^1 + 0 <em> 2^2 + 1 </em> 2^3 + 1 <em> 2^4 + 0 </em> 2^5 + ….<br>相当于累加 当前位数n对应的值m(0 或 1) * 2^(n-1) 即为最终的结果</p><p>如上述数据 1001 0101 1010 转为 10进制为 4342</p><h3 id="其他任意进制转为10进制"><a href="#其他任意进制转为10进制" class="headerlink" title="其他任意进制转为10进制"></a>其他任意进制转为10进制</h3><p>与 二进制 转为 10进制类似<br>只不过在二进制转10进制中，都是乘以2的幂等，n进制转换就是乘以n的幂等</p><ul><li>如 9进制表示的数140 转换为 10进制</li></ul><p>0 <em> 9^0 + 4 </em> 9^1 + 1 * 9^2 = 0 + 36 + 81 = 117</p><h3 id="二进制转换为8、16进制"><a href="#二进制转换为8、16进制" class="headerlink" title="二进制转换为8、16进制"></a>二进制转换为8、16进制</h3><ul><li><p>转换为8进制时，直接将数据分割为每3位一段，不足3位的在前面补0，再将每段直接转换为10进制数即可</p><ul><li>如1110101，因只有7位，不是3的倍数，在前面补两个0，再分割。 001 110 101，再将三段转为10进制，最终结果：165</li></ul></li><li><p>转换为16进制，直接将数据分割为每4位一段，不足4位的在前面补0，再将每段直接转换为16进制数即可</p><ul><li>如1110101，因只有7位，不是4的倍数，在前面补1个0，再分割。 0111 0101，再将此两端都转为16进制，最终结果：75H</li></ul></li></ul><p>16进制的数可以使用H后缀、或者 0x前缀标识</p><p>75H = 0x75</p><h3 id="二进制转换为其他进制"><a href="#二进制转换为其他进制" class="headerlink" title="二进制转换为其他进制"></a>二进制转换为其他进制</h3><p>先进二进制转为10进制，再将10进制转为其他进制</p><ul><li>1110101 转为9进制<br>1110101 转为10进制为 117，再将117转换为9进制，即为 140</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开发模型&quot;&gt;&lt;a href=&quot;#开发模型&quot; class=&quot;headerlink&quot; title=&quot;开发模型&quot;&gt;&lt;/a&gt;开发模型&lt;/h2&gt;&lt;p&gt;共有9种开发模型，适用范围各不相同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;瀑布模型（Waterfall Model）&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>UML图</title>
    <link href="hexo/blog/2022/07/UML%E5%9B%BE.html"/>
    <id>hexo/blog/2022/07/UML图.html</id>
    <published>2022-07-04T08:09:13.000Z</published>
    <updated>2022-07-05T03:10:04.473Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>UML图有可以分类为</p><ul><li>类图</li><li>状态图</li><li>活动图</li><li>交互图-时序图</li><li>交互图-协作图</li><li>用例图</li><li>ER图</li></ul></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>参考地址：<a href="https://blog.csdn.net/zhaxun/article/details/124048871" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124048871</a></p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>参考地址： <a href="https://blog.csdn.net/zhaxun/article/details/124201040" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124201040</a></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>参考地址： <a href="https://blog.csdn.net/qq_41784749/article/details/112242348" target="_blank" rel="noopener">https://blog.csdn.net/qq_41784749/article/details/112242348</a></p><h2 id="交互图-时序图"><a href="#交互图-时序图" class="headerlink" title="交互图-时序图"></a>交互图-时序图</h2><p>参考地址：<a href="https://blog.csdn.net/qq_23024699/article/details/120444441" target="_blank" rel="noopener">https://blog.csdn.net/qq_23024699/article/details/120444441</a></p><h2 id="交互图-协作图"><a href="#交互图-协作图" class="headerlink" title="交互图-协作图"></a>交互图-协作图</h2><p>参考地址：<a href="https://blog.csdn.net/neusoft2016/article/details/116195191" target="_blank" rel="noopener">https://blog.csdn.net/neusoft2016/article/details/116195191</a></p><p>时序图与协作图的区别与联系：</p><ul><li><p>协作图和时序图都表示出了对象间的交互作用，但是它们侧重点不同。</p></li><li><p>时序图清楚地表示了交互作用中的时间顺序(强调时间)，但没有明确表示对象间的关系。</p></li><li><p>协作图清楚地表示了对象间的关系(强调空间)，但时间顺序必须从顺序号获得。</p></li><li><p>协作图不能体现对象的初始化和消亡的时间</p></li><li><p>协作图和时序图可以相互转化。</p></li></ul><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>参考地址：<a href="https://blog.csdn.net/zhaxun/article/details/124047015" target="_blank" rel="noopener">https://blog.csdn.net/zhaxun/article/details/124047015</a></p><h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p>参考地址：<a href="https://blog.csdn.net/caohongxing/article/details/122398825" target="_blank" rel="noopener">https://blog.csdn.net/caohongxing/article/details/122398825</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;UML图有可以分类为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类图&lt;/li&gt;
&lt;li&gt;状态图&lt;/li&gt;
&lt;li&gt;活动图&lt;/li&gt;
&lt;li&gt;交互图-时序图&lt;/li&gt;
&lt;li&gt;交互图-协作图&lt;/li&gt;
&lt;li&gt;用例图&lt;/li&gt;
&lt;li&gt;ER图&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软考-软件设计师</title>
    <link href="hexo/blog/2022/07/%E8%BD%AF%E8%80%83-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88.html"/>
    <id>hexo/blog/2022/07/软考-软件设计师.html</id>
    <published>2022-07-04T06:39:48.000Z</published>
    <updated>2022-07-04T08:07:30.190Z</updated>
    
    <content type="html"><![CDATA[<p>准备报考2022年下半年的软考-软件设计师，</p><ul><li><p>为什么要考？</p><ul><li>减税</li><li>学习</li><li>考证</li></ul></li><li><p>为什么是软件设计师？</p><ul><li>因为之前没有想过去考证书，这是第一次，准备先考个中级的证书试试水</li><li>中级的证书有多个，只有软件设计师稍微有点符合自己的工作岗位，能使用到自己的一些开发经验，也能起到一定的学习作用</li></ul></li><li><p>怎么备考？</p><ul><li>bilibili</li><li>先了解大纲</li><li>逐一学习各个知识点</li><li>写真题</li></ul></li></ul><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li><p>软件工程基础知识</p><ul><li>开发模型</li><li>设计原则</li><li>测试方法</li><li>质量特性</li><li>CMM, Pert图</li><li>风险管理</li></ul></li><li><p>面向对象</p><ul><li>面向对象基本概念</li><li>面向对象分析与设计</li><li>UML</li><li>设计模式</li></ul></li><li><p>数据结构与算法</p><ul><li>数组</li><li>栈</li><li>队列</li><li>树与二叉树</li><li>图</li><li>查找与排序</li><li>常见算法</li></ul></li><li><p>程序设计语言</p><ul><li>文法</li><li>有限自动机</li><li>正规式</li><li>语句的作用</li><li>语句的语义</li><li>程序的控制结构</li><li>函数调用的参数传递</li><li>各种程序语言的特点比较</li></ul></li><li><p>计算机硬件基础</p><ul><li>浮点数运算、溢出</li><li>算术、逻辑运算</li><li>计算机体系结构分类</li><li>指令系统基础</li><li>CISC与RISC</li><li>流水线</li><li>Cache存储器可靠性分析</li><li>校验方法</li></ul></li><li><p>操作系统</p><ul><li>进程状态转换图</li><li>信号量与PV操作</li><li>死锁问题</li><li>银行家算法</li><li>段页式存储</li><li>页面置换算法</li><li>磁盘调度</li><li>树形文件系统</li></ul></li><li><p>数据库系统</p><ul><li>E-R模型</li><li>关系代数</li><li>元组演算</li><li>规范化理论(键、范式、模式分解)</li><li>并发控制</li></ul></li><li><p>计算机网络</p><ul><li>OSI模型</li><li>TCP/IP协议族</li><li>子网划分</li><li>常用的网络命令</li></ul></li><li><p>信息安全知识</p><ul><li>加密解密技术</li><li>网络安全</li><li>计算机病毒</li></ul></li><li><p>多媒体基础</p><ul><li>多媒体基本概念</li><li>计算声音</li><li>图像</li><li>视频文件的容量</li><li>JPEG, MPEG</li></ul></li><li><p>知识产权与标准化</p><ul><li>作品保护时间</li><li>侵权判定</li><li>知识产权归属</li><li>标准的分类</li><li>标准代号</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;准备报考2022年下半年的软考-软件设计师，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么要考？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减税&lt;/li&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;考证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么是软件设计师？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为之
      
    
    </summary>
    
    
      <category term="软考" scheme="hexo/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>减肥计划</title>
    <link href="hexo/blog/2022/06/%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92.html"/>
    <id>hexo/blog/2022/06/减肥计划.html</id>
    <published>2022-06-27T08:26:27.000Z</published>
    <updated>2022-06-27T08:32:55.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="减肥大计"><a href="#减肥大计" class="headerlink" title="减肥大计"></a>减肥大计</h1><p>暂时定为三个阶段，每个阶段目标均为 -5kg</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>通过修改饮食，加上 低运动量减肥操</p><h3 id="早餐"><a href="#早餐" class="headerlink" title="早餐"></a>早餐</h3><p>两个鸡蛋+ 一杯豆浆/一杯牛奶</p><h3 id="中餐"><a href="#中餐" class="headerlink" title="中餐"></a>中餐</h3><p>一碗米饭 + 青菜 + 适量牛肉、虾，保证蛋白质摄入</p><h3 id="晚餐"><a href="#晚餐" class="headerlink" title="晚餐"></a>晚餐</h3><p>玉米面/荞面 + 适量牛肉、虾</p><p>零食以 牛肉干、黄瓜 为准。</p><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>通过饮食， 加上适量有氧运动， 跑步<br>目标：75kg</p><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>通过饮食， 加上中等有氧运动， 跑步</p><p>目标：70kg</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;减肥大计&quot;&gt;&lt;a href=&quot;#减肥大计&quot; class=&quot;headerlink&quot; title=&quot;减肥大计&quot;&gt;&lt;/a&gt;减肥大计&lt;/h1&gt;&lt;p&gt;暂时定为三个阶段，每个阶段目标均为 -5kg&lt;/p&gt;
&lt;h2 id=&quot;第一阶段&quot;&gt;&lt;a href=&quot;#第一阶段&quot; class
      
    
    </summary>
    
    
      <category term="live" scheme="hexo/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>android API 更新</title>
    <link href="hexo/blog/2022/06/android-API-%E6%9B%B4%E6%96%B0.html"/>
    <id>hexo/blog/2022/06/android-API-更新.html</id>
    <published>2022-06-27T08:05:51.000Z</published>
    <updated>2022-06-27T08:08:54.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-API-更新记录"><a href="#android-API-更新记录" class="headerlink" title="android API 更新记录"></a>android API 更新记录</h1><h2 id="android-API-30-（android11）应用文件管理权限"><a href="#android-API-30-（android11）应用文件管理权限" class="headerlink" title="android API 30 （android11）应用文件管理权限"></a>android API 30 （android11）应用文件管理权限</h2><p>在andorid6之后需要动态请求权限，如针对文件写入、读取权限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">    <span class="keyword">var</span> permissionArray = arrayOf(</span><br><span class="line">        Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">    )</span><br><span class="line">    requestPermissions(permissionArray, <span class="number">101</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在android 11之后，这样也会弹出应用权限请求，但写入文件到sdcrd还是会失败，报错：/storage/emulated/0/io/okio.txt: open failed: ENOENT (No such file or directory)</p><p>需要修改请求权限的方式为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Environment.isExternalStorageManager()) &#123;</span><br><span class="line">    <span class="keyword">var</span> intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">    startActivityForResult(intent, <span class="number">102</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-API-更新记录&quot;&gt;&lt;a href=&quot;#android-API-更新记录&quot; class=&quot;headerlink&quot; title=&quot;android API 更新记录&quot;&gt;&lt;/a&gt;android API 更新记录&lt;/h1&gt;&lt;h2 id=&quot;android-A
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="hexo/blog/2022/06/io.html"/>
    <id>hexo/blog/2022/06/io.html</id>
    <published>2022-06-22T08:51:23.000Z</published>
    <updated>2022-06-27T03:18:42.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO是什么"><a href="#IO是什么" class="headerlink" title="IO是什么"></a>IO是什么</h2><blockquote><p>程序内部和外部进行数据交互的过程，就叫输入输出。</p><blockquote><p>程序内部是谁?内存<br>程序外部是谁?</p><blockquote><p>一般来说是两类:本地文件和网络。<br>也有别的情况，比如你和别的程序做交互，和你交互的程序也属于外部，但一般来说，就是文件和网络这么两种。</p></blockquote></blockquote></blockquote><blockquote><p>从文件里或者从网络上读数据到内存里，就叫输入;从内存里写到文件里或者发送到网络上，就叫输出</p></blockquote><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><p>使用流，例如 FileInputStream / FileOutputStream</p></li><li><p>可以用 Reader 和 Writer 来对字符进行读写</p></li><li><p>流的外面还可以套别的流，层层嵌套都可以</p></li><li><p>BufferedXXXX 可以给流加上缓冲。对于输入流，是每次多读一些放在内存 里面，下次再去数据就不用再和外部做交互(即不必做 IO 操作);对于输 出流，是把数据先在内存里面攒一下，攒够一波了再往外部去写。</p></li></ul><p>通过缓存的方式减少和和外部的交互，从而可以提高效率</p><ul><li><p>文件的关闭:close()</p></li><li><p>需要用到的写过的数据，flush() 一下可以保证数据真正写到外部去(读数据 没有这样的担忧)</p></li><li><p>这个就是 Java 的 I/O，它的原理就是内存和外界的交互</p></li></ul><p>IO 又可以分为 BIO、NIO、AIO</p><h2 id="BIO、NIO、AIO-区别"><a href="#BIO、NIO、AIO-区别" class="headerlink" title="BIO、NIO、AIO 区别"></a>BIO、NIO、AIO 区别</h2><h3 id="IO模型主要分类："><a href="#IO模型主要分类：" class="headerlink" title="IO模型主要分类："></a>IO模型主要分类：</h3><ul><li><p>同步(synchronous)IO与异步(asynchronous)IO</p></li><li><p>阻塞(blocking)IO与非阻塞(non-blocking)IO</p></li><li><p>同步阻塞IO(blocking-IO)即为 BIO</p></li><li><p>同步非阻塞IO(non-blocking-IO)即为 NIO</p></li><li><p>异步非阻塞IO(synchronous-non-blocking-IO)即为 AIO</p></li></ul><h3 id="BIO（同步阻塞I-O模式）"><a href="#BIO（同步阻塞I-O模式）" class="headerlink" title="BIO（同步阻塞I/O模式）"></a>BIO（同步阻塞I/O模式）</h3><p>数据的读取、写入等操作必须阻塞在一个线程内等待操作完成</p><h3 id="NIO（同步非阻塞I-O模式）"><a href="#NIO（同步非阻塞I-O模式）" class="headerlink" title="NIO（同步非阻塞I/O模式）"></a>NIO（同步非阻塞I/O模式）</h3><p>同时支持阻塞与非阻塞模式，NIO的做法是叫一个线程不断的轮询IO操作的的状态，看看是否有任务的状态发生了改变，从而进行下一步的操作。</p><p>默认是阻塞式的</p><h3 id="AIO-（异步非阻塞I-O模型）"><a href="#AIO-（异步非阻塞I-O模型）" class="headerlink" title="AIO （异步非阻塞I/O模型）"></a>AIO （异步非阻塞I/O模型）</h3><p>异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p><p>对应到IO操作中就是，为每次IO操作上面装了一个开关，IO操作完毕之后，会自动通知任务完成。</p><h3 id="IO-与-NIO-的区别"><a href="#IO-与-NIO-的区别" class="headerlink" title="IO 与 NIO 的区别"></a>IO 与 NIO 的区别</h3><p>IO 面向流</p><p>NIO 面向缓冲区，具备 选择器(Selectors)</p><h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><ul><li><p>同步</p><ul><li>发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生。</li></ul></li><li><p>异步</p><ul><li>发送一个请求，不等待返回，随时可以再发送下一个请求，可以提高效率，保证并发。</li></ul></li></ul><h3 id="阻塞与非阻塞的区别"><a href="#阻塞与非阻塞的区别" class="headerlink" title="阻塞与非阻塞的区别"></a>阻塞与非阻塞的区别</h3><ul><li>阻塞</li></ul><blockquote><p>传统的IO流都是阻塞式的。也就是说，当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务。在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降。  </p></blockquote><ul><li>非阻塞</li></ul><blockquote><p>JavaNIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。  </p></blockquote><h2 id="NIO-3个核心概念"><a href="#NIO-3个核心概念" class="headerlink" title="NIO 3个核心概念"></a>NIO 3个核心概念</h2><p><img src="../../../images/nio.png" style="zoom:70%"></p><p>NIO重点是把Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系弄清楚。</p><h3 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。  </p><p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。  </p><p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。  </p><p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：  </p><ul><li><p>ByteBuffer：字节缓冲区  </p></li><li><p>CharBuffer:字符缓冲区  </p></li><li><p>ShortBuffer：短整型缓冲区  </p></li><li><p>IntBuffer：整型缓冲区  </p></li><li><p>LongBuffer:长整型缓冲区  </p></li><li><p>FloatBuffer：浮点型缓冲区  </p></li><li><p>DoubleBuffer：双精度浮点型缓冲区  </p></li></ul><h3 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p><p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p><p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p><p>Channel有四种实现：</p><ul><li><p>FileChannel:是从文件中读取数据。</p></li><li><p>DatagramChannel:从UDP网络中读取或者写入数据。</p></li><li><p>SocketChannel:从TCP网络中读取或者写入数据。</p></li><li><p>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</p></li></ul><h3 id="多路复用器Selector"><a href="#多路复用器Selector" class="headerlink" title="多路复用器Selector"></a>多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p><h4 id="关键对象"><a href="#关键对象" class="headerlink" title="关键对象"></a>关键对象</h4><ul><li><p>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</p></li><li><p>SelectorKey：通道监听关键字，通过它来监听通道状态。</p></li></ul><h4 id="监听注册"><a href="#监听注册" class="headerlink" title="监听注册"></a>监听注册</h4><p>监听注册在Selector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><h4 id="监听的事件有"><a href="#监听的事件有" class="headerlink" title="监听的事件有"></a>监听的事件有</h4><ul><li><p>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</p></li><li><p>OP_READ: 读取就绪，socketChannel使用</p></li><li><p>OP_WRITE: 写入就绪，socketChannel使用</p></li><li><p>OP_CONNECT: 连接就绪，socketChannel使用</p></li></ul><h2 id="OKIO"><a href="#OKIO" class="headerlink" title="OKIO"></a>OKIO</h2><p>okhttp框架中，使用的io</p><p>OKio本质上是对Java的NIO的一次扩展，并且做了缓存的优化，</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>它也是基于插管的，而且是单向的，输入源叫 Source，输出目标叫 Sink</li><li>支持 Buffer<ul><li>像 NIO 一样，可以对 Buffer 进行操作</li><li>但不强制使用 Buffer</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h1&gt;&lt;h2 id=&quot;IO是什么&quot;&gt;&lt;a href=&quot;#IO是什么&quot; class=&quot;headerlink&quot; title=&quot;IO是什么&quot;&gt;&lt;/a&gt;IO是什
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jetpack hilt</title>
    <link href="hexo/blog/2022/06/jetpack-hilt.html"/>
    <id>hexo/blog/2022/06/jetpack-hilt.html</id>
    <published>2022-06-16T06:09:19.000Z</published>
    <updated>2022-06-22T08:50:59.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a>Hilt</h1><p>先讲使用，再讲原理</p><p>google文档地址：<a href="https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn</a></p><p><a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/hilt" target="_blank" rel="noopener">示例源码地址</a></p><h2 id="使用示例：-Hilt-ViewModel-Repository"><a href="#使用示例：-Hilt-ViewModel-Repository" class="headerlink" title="使用示例： Hilt + ViewModel + Repository"></a>使用示例： Hilt + ViewModel + Repository</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ul><li>注意事项不要参考google文档中的地址设置版本号，因为文档中使用的是 aplha 版本，API会随时变动，很可能使用此版本但运行结果与文档不同，本人就碰到了，（@HiltViewModel 不可用） *</li></ul><p>在项目根目录的 build.gradle 中添加：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.hilt_version = <span class="string">"2.36"</span></span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">// hilt</span></span><br><span class="line">        classpath <span class="string">"com.google.dagger:hilt-android-gradle-plugin:$hilt_version"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在需要使用 hilt 的 module 的 build.gradle 文件中添加依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hilt</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:hilt-android:$hilt_version"</span></span><br><span class="line">kapt <span class="string">"com.google.dagger:hilt-android-compiler:$hilt_version"</span></span><br></pre></td></tr></table></figure><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltAndroidApp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> : <span class="type">Application</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HiltViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">var</span> repository: HiltRepository,</span><br><span class="line">): ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repository.login()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor"><a href="#注意，Repository中即使构造函数无需入参，也必须-使用-Inject-constructor" class="headerlink" title="注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()"></a>注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiltActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityHiltBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: HiltViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityHiltBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，此时生成 viewModel实例时，无需再次传入参数，也不需要另外使用ViewModelFactory来生成。<br>原因就是在 Repository 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(ActivityComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> HiltRepositoryModule&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerHiltRepository</span><span class="params">()</span></span> :HiltRepository = HiltRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过注解已经提供了生成 HiltRepository 实例的方式。</p><p>以上就是一次简单的使用。</p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hilt&quot;&gt;&lt;a href=&quot;#Hilt&quot; class=&quot;headerlink&quot; title=&quot;Hilt&quot;&gt;&lt;/a&gt;Hilt&lt;/h1&gt;&lt;p&gt;先讲使用，再讲原理&lt;/p&gt;
&lt;p&gt;google文档地址：&lt;a href=&quot;https://developer.android
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CameraX</title>
    <link href="hexo/blog/2022/03/CameraX.html"/>
    <id>hexo/blog/2022/03/CameraX.html</id>
    <published>2022-03-28T07:51:31.000Z</published>
    <updated>2022-03-28T09:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。</p><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> camerax_version = <span class="string">"1.0.2"</span></span><br><span class="line">  <span class="comment">// The following line is optional, as the core library is included indirectly by camera-camera2</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-core:$&#123;camerax_version&#125;"</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-camera2:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Lifecycle library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX VideoCapture library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-video:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX View class</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-view:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Extensions library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-extensions:1.1.0-beta02"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-CameraX-开启预览"><a href="#使用-CameraX-开启预览" class="headerlink" title="使用 CameraX 开启预览"></a>使用 CameraX 开启预览</h2><p>在向应用添加预览时，请使用 PreviewView，这是一种可以剪裁、缩放和旋转以确保正确显示的 View。</p><p>当相机处于活动状态时，图片预览会流式传输到 PreviewView 中的 Surface。</p><h3 id="将-PreviewView-添加到布局"><a href="#将-PreviewView-添加到布局" class="headerlink" title="将 PreviewView 添加到布局"></a>将 PreviewView 添加到布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".camera.CameraActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.camera.view.PreviewView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/previewView"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="请求-CameraProvider"><a href="#请求-CameraProvider" class="headerlink" title="请求 CameraProvider"></a>请求 CameraProvider</h3><p>以下代码展示了如何请求 CameraProvider：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> cameraProviderFuture: ListenableFuture&lt;ProcessCameraProvider&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> dataBinding: ActivityCameraBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        dataBinding = ActivityCameraBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(dataBinding.root)</span><br><span class="line">        cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查-CameraProvider-可用性"><a href="#检查-CameraProvider-可用性" class="headerlink" title="检查 CameraProvider 可用性"></a>检查 CameraProvider 可用性</h3><p>请求 CameraProvider 后，请验证它能否在视图创建后成功初始化。以下代码展示了如何执行此操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">  <span class="keyword">val</span> cameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line">  bindPreview(cameraProvider)</span><br><span class="line"></span><br><span class="line">&#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure><h3 id="选择相机并绑定生命周期和用例"><a href="#选择相机并绑定生命周期和用例" class="headerlink" title="选择相机并绑定生命周期和用例"></a>选择相机并绑定生命周期和用例</h3><p>创建并确认 CameraProvider 后，请执行以下操作:</p><ul><li><p>1、创建 Preview。</p></li><li><p>2、指定所需的相机 LensFacing 选项。</p></li><li><p>3、将所选相机和任意用例绑定到生命周期。</p></li><li><p>4、将 Preview 连接到 PreviewView。</p></li></ul><p>以下代码展示了一个示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindPreview</span><span class="params">(cameraProvider: <span class="type">ProcessCameraProvider</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> preview: Preview = Preview.Builder()</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cameraSelector: CameraSelector = CameraSelector.Builder()</span><br><span class="line">        .requireLensFacing(CameraSelector.LENS_FACING_BACK)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    preview.setSurfaceProvider(dataBinding.previewView.getSurfaceProvider())</span><br><span class="line">    <span class="keyword">var</span> camera = cameraProvider?.bindToLifecycle(<span class="keyword">this</span> <span class="keyword">as</span> LifecycleOwner, cameraSelector, preview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，bindToLifecycle() 会返回一个 Camera 对象。如需详细了解如何控制相机输出（如变焦和曝光），请参阅此指南。</p><p>现在，您已完成实现相机预览的操作。请构建您的应用，然后确认预览是否出现在您的应用中并能按预期工作。</p><p>PS: 记得需要相机权限</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。&lt;/p&gt;
&lt;h2 id=&quot;添加依赖项&quot;&gt;&lt;a href=&quot;#添加依赖项&quot; class=&quot;headerlink&quot; title=&quot;添加依赖项&quot;&gt;&lt;/a&gt;添加依赖项&lt;/h2&gt;&lt;fig
      
    
    </summary>
    
    
      <category term="android-Jetpack" scheme="hexo/tags/android-Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法</title>
    <link href="hexo/blog/2022/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2022/02/常用的排序方法.html</id>
    <published>2022-02-18T03:08:05.000Z</published>
    <updated>2022-07-04T06:39:26.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，当前元素与下一个元素对比，将较大值放于右侧，<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//选择排序算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length-<span class="number">1</span> ;i++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;args.length ;j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[min]&gt;args[j])&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=args[i];</span><br><span class="line">            args[i]=args[min];</span><br><span class="line">            args[min]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，取出最小值或者最大值，交互数组位置，使最值位于数组两侧，最后得出一个升序/降序数组<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//插入排序算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[j]&lt;args[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=args[j-<span class="number">1</span>];</span><br><span class="line">                args[j-<span class="number">1</span>]=args[j];</span><br><span class="line">                args[j]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>使用系统自带的排序方法 sorts<br>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的遍历一般根据节点可分为三种：前序、中序、后序遍历<br>根据树的层级又有层级遍历</p><p>下面的代码就是一个树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Node left;</span><br><span class="line"><span class="keyword">private</span> Node right;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node[ no = "</span> + no + <span class="string">", name ="</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>先取父节点，再取左节点，再取右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>先取左节点，再取父节点，再取右节点<br>中序遍历可以得出一个升序结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LDR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>先取左节点，再取右节点，再取父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LRD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-ViewModel</title>
    <link href="hexo/blog/2022/02/jetpack-ViewModel.html"/>
    <id>hexo/blog/2022/02/jetpack-ViewModel.html</id>
    <published>2022-02-08T07:08:05.000Z</published>
    <updated>2022-02-18T02:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考 android developer 中的文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>当 ViewModel 构造函数为有参构造函数时，使用 private val model : OverTimeViewModel by activityViewModels() 会报错<br>此时处理方案为新建一个Factory类<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> dataSource: OverTimeDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span>(modelClass.isAssignableFrom(OverTimeViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OverTimeViewModel(dataSource) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在写一个静态类，作为Factory作为Provider</span></span><br><span class="line"><span class="keyword">object</span> Injection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideUserDataSource</span><span class="params">(context: <span class="type">Context</span>)</span></span>: OverTimeDao &#123;</span><br><span class="line">        <span class="keyword">val</span> database = AppDatabase.getInstance(context)</span><br><span class="line">        <span class="keyword">return</span> database.overTimeDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideViewModelFactory</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ViewModelFactory &#123;</span><br><span class="line">        <span class="keyword">val</span> dataSource = provideUserDataSource(context)</span><br><span class="line">        <span class="keyword">return</span> ViewModelFactory(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModelFactory: ViewModelFactory</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> model : OverTimeViewModel <span class="keyword">by</span> activityViewModels&#123; viewModelFactory &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定的生命函数中实例化ViewModelFactory</span></span><br><span class="line">viewModelFactory = Injection.provideViewModelFactory(activity!!)</span><br></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 android developer 中的文档：&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager2</title>
    <link href="hexo/blog/2022/02/ViewPager2.html"/>
    <id>hexo/blog/2022/02/ViewPager2.html</id>
    <published>2022-02-07T07:59:48.000Z</published>
    <updated>2022-02-07T09:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2</a></p><p>需要对比 ViewPager2 与 ViewPager 的差异、优劣</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deve
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-Navigation</title>
    <link href="hexo/blog/2022/02/jetpack-Navigation.html"/>
    <id>hexo/blog/2022/02/jetpack-Navigation.html</id>
    <published>2022-02-07T07:56:06.000Z</published>
    <updated>2022-02-07T07:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>具体参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-getting-started</a></p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>Navigation 其实是对 Fragment 跳转的管理，而不是 Activity，需要配置到某个 Activity 中。<br>其实是单 Activity 模式</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-getting-started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack Room</title>
    <link href="hexo/blog/2021/12/jetpack-Room.html"/>
    <id>hexo/blog/2021/12/jetpack-Room.html</id>
    <published>2021-12-22T10:44:10.000Z</published>
    <updated>2022-06-28T08:27:30.560Z</updated>
    
    <content type="html"><![CDATA[<p>处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的使用场景是缓存相关的数据，这样一来，当设备无法访问网络时，用户仍然可以在离线状态下浏览该内容。</p><p>Room 持久性库在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。<br>具体来说，Room 具有以下优势：</p><ul><li>针对 SQL 查询的编译时验证</li><li>可最大限度减少重复和容易出错的样板代码的方便注解。</li><li>简化了数据库迁移路径。</li></ul><p>出于这些方面的考虑，我们强烈建议您使用 Room，而不是直接使用 SQLite API。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在build.gradle中添加 kapt plugin<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.android.application'</span></span><br><span class="line">    id <span class="string">'kotlin-android'</span></span><br><span class="line">    id <span class="string">'kotlin-kapt'</span> <span class="comment">// 新增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加room依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Room</span></span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.4.1"</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    kapt <span class="string">"androidx.room:room-compiler:$room_version"</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><p>Room 包含三个主要组件：</p><ul><li>数据库类，用于保存数据库并作为应用持久性数据底层连接的主要访问点。</li><li>数据实体，用于表示应用的数据库中的表。</li><li>数据访问对象 (DAO)，提供您的应用可用于查询、更新、插入和删除数据库中的数据的方法。</li></ul><p>数据库类为应用提供与该数据库关联的 DAO 的实例。反过来，应用可以使用 DAO 从数据库中检索数据，作为关联的数据实体对象的实例。<br>此外，应用还可以使用定义的数据实体更新相应表中的行，或者创建新行供插入。</p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><p>本部分介绍了具有单个数据实体和单个 DAO 的 Room 数据库实现示例。</p><h3 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h3><p>使用 Room 时，每个表都由一个类表示。在 Room 等 ORM（对象关系映射）库中，这些类通常称为模型类或实体。</p><ul><li>1、创建一个名为 Schedule.kt 的新文件，并定义一个名为 Schedule 的数据类。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedule</span> </span>()</span><br></pre></td></tr></table></figure></li></ul><p>注意要使用注解@Dao,标注这是数据库实体类</p><ul><li>2、添加主键</li></ul><p>据表应该有一个用于唯一标识每行的主键。您要添加到 Schedule 类中的第一个属性是用于表示唯一 ID 的一个整数。<br>添加一个新属性，并使用 @PrimaryKey 注解对其进行标记。<br>此注解会告知 Room 在插入新行时将此属性视为主键。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedule</span> </span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line"></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><ul><li>3、添加其他信息列</li></ul><p>对于新列，您需要添加 @ColumnInfo 注解，用于为该列指定名称。<br>通常，SQL 列名称使用以下划线分隔的单词，而 Kotlin 属性采用小驼峰命名法。<br>对于此列，我们还希望其值为非 null 值，因此您应该使用 @NonNull 注解对其进行标记。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Schedule</span> </span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="meta-string">"stop_name"</span>)</span> <span class="keyword">val</span> stopName: String,</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="meta-string">"arrival_time"</span>)</span> <span class="keyword">val</span> arrivalTime: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="定义DAO"><a href="#定义DAO" class="headerlink" title="定义DAO"></a>定义DAO</h3><p>为了集成 Room 而需要添加的下一个类是 DAO。DAO 代表数据访问对象，是一个提供数据访问的 Kotlin 类。<br>具体而言，您会在 DAO 中包含用于读取和操作数据的函数。对 DAO 调用函数相当于对数据库执行 SQL 命令。<br>实际上，像您要在此应用中定义的函数这样的 DAO 函数通常会指定一个 SQL 命令，以便您可以精确地指定您希望该函数执行什么操作。<br>在定义 DAO 时，您从上一个 Codelab 中学到的 SQL 知识将派上用场。</p><ul><li>为 Schedule 实体添加一个 DAO 类。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ScheduleDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加一条查询语句</li></ul><p>根据到达时间升序查询所有车次</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="meta-string">"SELECT * FROM schedule ORDER BY arrival_time ASC"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: List&lt;Schedule&gt;</span><br></pre></td></tr></table></figure><p>在增加一条条件查询语句<br>指定stop_name的查询</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="meta-string">"SELECT * FROM schedule WHERE stop_name = :stopName ORDER BY arrival_time ASC"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getByStopName</span><span class="params">(stopName: <span class="type">String</span>)</span></span>: List&lt;Schedule&gt;</span><br></pre></td></tr></table></figure><h2 id="异常情况记录"><a href="#异常情况记录" class="headerlink" title="异常情况记录"></a>异常情况记录</h2><ul><li>Room AppDatabase_Impl does not exist</li></ul><p>使用了 kotlin 构建了项目,并且使用 kotlin 编写 room 创建数据库,在 build.gradle 文件里做如下修改</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.android.library'</span></span><br><span class="line">    id <span class="string">'kotlin-android'</span></span><br><span class="line">    id <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">    id <span class="string">'kotlin-kapt'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略...</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api<span class="string">"android.arch.persistence.room:runtime:$rootProject.room_version"</span></span><br><span class="line">    kapt<span class="string">"android.arch.persistence.room:compiler:$rootProject.room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 annotationProcessor 替换成 kapt,请注意需要导入 id ‘kotlin-kapt’ 才能使用 kapt</p><p>参考地址：<a href="https://www.cnblogs.com/guanxinjing/p/14990401.html" target="_blank" rel="noopener">https://www.cnblogs.com/guanxinjing/p/14990401.html</a></p><p><a href="https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/Room" target="_blank" rel="noopener">样例代码地址</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的使用场景是缓存相关的数据，这样一来，当设备无法访问网络时，用户仍然可以在离线状态下浏览该内容。&lt;/p&gt;
&lt;p&gt;Room 持久性库在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack DataSource</title>
    <link href="hexo/blog/2021/12/jetpack-DataSource.html"/>
    <id>hexo/blog/2021/12/jetpack-DataSource.html</id>
    <published>2021-12-22T10:29:42.000Z</published>
    <updated>2021-12-22T10:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。</p><p>DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。</p><ul><li>Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。</li><li>Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。&lt;/p&gt;
&lt;p&gt;DataStore 提供两种不同的实现：Preferences 
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack lifecycle</title>
    <link href="hexo/blog/2021/12/jetpack-lifecycle.html"/>
    <id>hexo/blog/2021/12/jetpack-lifecycle.html</id>
    <published>2021-12-22T03:08:25.000Z</published>
    <updated>2021-12-22T03:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 库中用来感知生命周期的组件</p><h2 id="使用生命周期感知型组件处理生命周期"><a href="#使用生命周期感知型组件处理生命周期" class="headerlink" title="使用生命周期感知型组件处理生命周期"></a>使用生命周期感知型组件处理生命周期</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。</p><p>一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。</p><p>androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p><p>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p><p><strong>事件</strong><br>从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。<br><strong>状态</strong><br>由 Lifecycle 对象跟踪的组件的当前状态</p><p><img src="../../../images/lifecycle.svg" style="zoom:60%"></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MainLifecycleObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainLifecycleObserver</span></span>() : LifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> TAG: String  = <span class="string">"MainLifecycleObserver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityCreated: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityResume: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityStopped: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，就可以實現在 Activity 之外獲取到生命週期的變化，避免在 Activity/Fragment 中的生命週期中寫大量業務代碼</p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>LifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。</p><p>此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。</p><p>实现 DefaultLifecycleObserver 的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p><h3 id="自定義-LifecycleOwner"><a href="#自定義-LifecycleOwner" class="headerlink" title="自定義 LifecycleOwner"></a>自定義 LifecycleOwner</h3><p>我們不只是可以綁定視圖的生命週期，可以通過 LifecycleOwner 自定義對應色生命週期<br>如當處於 Activity 的 onCreate、onStart 中都需執行 onStart</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), LifecycleOwner &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LifeCycle 组件实际上并没有带来什么新的功能，他通过观察者模式+注解来让我们更方便的监听 Activity 和 Fragment 的生命周期变化。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle 是 Jetpack 库中用来感知生命周期的组件&lt;/p&gt;
&lt;h2 id=&quot;使用生命周期感知型组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知型组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知型组件处理生命周期
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
</feed>
