<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2022-03-28T09:48:40.000Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CameraX</title>
    <link href="hexo/blog/2022/03/CameraX.html"/>
    <id>hexo/blog/2022/03/CameraX.html</id>
    <published>2022-03-28T07:51:31.000Z</published>
    <updated>2022-03-28T09:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。</p><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> camerax_version = <span class="string">"1.0.2"</span></span><br><span class="line">  <span class="comment">// The following line is optional, as the core library is included indirectly by camera-camera2</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-core:$&#123;camerax_version&#125;"</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-camera2:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Lifecycle library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX VideoCapture library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-video:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX View class</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-view:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Extensions library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-extensions:1.1.0-beta02"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-CameraX-开启预览"><a href="#使用-CameraX-开启预览" class="headerlink" title="使用 CameraX 开启预览"></a>使用 CameraX 开启预览</h2><p>在向应用添加预览时，请使用 PreviewView，这是一种可以剪裁、缩放和旋转以确保正确显示的 View。</p><p>当相机处于活动状态时，图片预览会流式传输到 PreviewView 中的 Surface。</p><h3 id="将-PreviewView-添加到布局"><a href="#将-PreviewView-添加到布局" class="headerlink" title="将 PreviewView 添加到布局"></a>将 PreviewView 添加到布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".camera.CameraActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.camera.view.PreviewView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/previewView"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="请求-CameraProvider"><a href="#请求-CameraProvider" class="headerlink" title="请求 CameraProvider"></a>请求 CameraProvider</h3><p>以下代码展示了如何请求 CameraProvider：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> cameraProviderFuture: ListenableFuture&lt;ProcessCameraProvider&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> dataBinding: ActivityCameraBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        dataBinding = ActivityCameraBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(dataBinding.root)</span><br><span class="line">        cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查-CameraProvider-可用性"><a href="#检查-CameraProvider-可用性" class="headerlink" title="检查 CameraProvider 可用性"></a>检查 CameraProvider 可用性</h3><p>请求 CameraProvider 后，请验证它能否在视图创建后成功初始化。以下代码展示了如何执行此操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">  <span class="keyword">val</span> cameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line">  bindPreview(cameraProvider)</span><br><span class="line"></span><br><span class="line">&#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure><h3 id="选择相机并绑定生命周期和用例"><a href="#选择相机并绑定生命周期和用例" class="headerlink" title="选择相机并绑定生命周期和用例"></a>选择相机并绑定生命周期和用例</h3><p>创建并确认 CameraProvider 后，请执行以下操作:</p><ul><li><p>1、创建 Preview。</p></li><li><p>2、指定所需的相机 LensFacing 选项。</p></li><li><p>3、将所选相机和任意用例绑定到生命周期。</p></li><li><p>4、将 Preview 连接到 PreviewView。</p></li></ul><p>以下代码展示了一个示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindPreview</span><span class="params">(cameraProvider: <span class="type">ProcessCameraProvider</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> preview: Preview = Preview.Builder()</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cameraSelector: CameraSelector = CameraSelector.Builder()</span><br><span class="line">        .requireLensFacing(CameraSelector.LENS_FACING_BACK)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    preview.setSurfaceProvider(dataBinding.previewView.getSurfaceProvider())</span><br><span class="line">    <span class="keyword">var</span> camera = cameraProvider?.bindToLifecycle(<span class="keyword">this</span> <span class="keyword">as</span> LifecycleOwner, cameraSelector, preview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，bindToLifecycle() 会返回一个 Camera 对象。如需详细了解如何控制相机输出（如变焦和曝光），请参阅此指南。</p><p>现在，您已完成实现相机预览的操作。请构建您的应用，然后确认预览是否出现在您的应用中并能按预期工作。</p><p>PS: 记得需要相机权限</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。&lt;/p&gt;
&lt;h2 id=&quot;添加依赖项&quot;&gt;&lt;a href=&quot;#添加依赖项&quot; class=&quot;headerlink&quot; title=&quot;添加依赖项&quot;&gt;&lt;/a&gt;添加依赖项&lt;/h2&gt;&lt;fig
      
    
    </summary>
    
    
      <category term="android-Jetpack" scheme="hexo/tags/android-Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法</title>
    <link href="hexo/blog/2022/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2022/02/常用的排序方法.html</id>
    <published>2022-02-18T03:08:05.000Z</published>
    <updated>2022-02-18T03:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，当前元素与下一个元素对比，将较大值放于右侧，<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//选择排序算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length-<span class="number">1</span> ;i++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;args.length ;j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[min]&gt;args[j])&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=args[i];</span><br><span class="line">            args[i]=args[min];</span><br><span class="line">            args[min]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，取出最小值或者最大值，交互数组位置，使最值位于数组两侧，最后得出一个升序/降序数组<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//插入排序算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[j]&lt;args[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=args[j-<span class="number">1</span>];</span><br><span class="line">                args[j-<span class="number">1</span>]=args[j];</span><br><span class="line">                args[j]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>使用系统自带的排序方法 sorts<br>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的遍历一般根据节点可分为三种：前序、中序、后序遍历<br>根据树的层级又有层级遍历</p><p>下面的代码就是一个树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Node left;</span><br><span class="line"><span class="keyword">private</span> Node right;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node[ no = "</span> + no + <span class="string">", name ="</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>先取父节点，再取左节点，再去右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>先取左节点，再取父节点，再去右节点<br>中序遍历可以得出一个升序结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LDR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>先取左节点，再取右节点，再去父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LRD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-ViewModel</title>
    <link href="hexo/blog/2022/02/jetpack-ViewModel.html"/>
    <id>hexo/blog/2022/02/jetpack-ViewModel.html</id>
    <published>2022-02-08T07:08:05.000Z</published>
    <updated>2022-02-18T02:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考 android developer 中的文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>当 ViewModel 构造函数为有参构造函数时，使用 private val model : OverTimeViewModel by activityViewModels() 会报错<br>此时处理方案为新建一个Factory类<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> dataSource: OverTimeDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span>(modelClass.isAssignableFrom(OverTimeViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OverTimeViewModel(dataSource) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在写一个静态类，作为Factory作为Provider</span></span><br><span class="line"><span class="keyword">object</span> Injection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideUserDataSource</span><span class="params">(context: <span class="type">Context</span>)</span></span>: OverTimeDao &#123;</span><br><span class="line">        <span class="keyword">val</span> database = AppDatabase.getInstance(context)</span><br><span class="line">        <span class="keyword">return</span> database.overTimeDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideViewModelFactory</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ViewModelFactory &#123;</span><br><span class="line">        <span class="keyword">val</span> dataSource = provideUserDataSource(context)</span><br><span class="line">        <span class="keyword">return</span> ViewModelFactory(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModelFactory: ViewModelFactory</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> model : OverTimeViewModel <span class="keyword">by</span> activityViewModels&#123; viewModelFactory &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定的生命函数中实例化ViewModelFactory</span></span><br><span class="line">viewModelFactory = Injection.provideViewModelFactory(activity!!)</span><br></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 android developer 中的文档：&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager2</title>
    <link href="hexo/blog/2022/02/ViewPager2.html"/>
    <id>hexo/blog/2022/02/ViewPager2.html</id>
    <published>2022-02-07T07:59:48.000Z</published>
    <updated>2022-02-07T09:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2</a></p><p>需要对比 ViewPager2 与 ViewPager 的差异、优劣</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deve
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-Navigation</title>
    <link href="hexo/blog/2022/02/jetpack-Navigation.html"/>
    <id>hexo/blog/2022/02/jetpack-Navigation.html</id>
    <published>2022-02-07T07:56:06.000Z</published>
    <updated>2022-02-07T07:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>具体参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-getting-started</a></p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>Navigation 其实是对 Fragment 跳转的管理，而不是 Activity，需要配置到某个 Activity 中。<br>其实是单 Activity 模式</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-getting-started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack Room</title>
    <link href="hexo/blog/2021/12/jetpack-Room.html"/>
    <id>hexo/blog/2021/12/jetpack-Room.html</id>
    <published>2021-12-22T10:44:10.000Z</published>
    <updated>2022-06-09T06:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用 Room 将数据保存到本地数据库</strong></p><p>Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。</p><p>处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的用例是缓存相关数据。这样，当设备无法访问网络时，用户仍可在离线状态下浏览相应内容。设备重新连接到网络后，用户发起的所有内容更改都会同步到服务器。</p><p>由于 Room 负责为您处理这些问题，因此我们强烈建议您使用 Room（而不是 SQLite）。不过，如果您想直接使用 SQLite API，请参阅使用 SQLite 保存数据。</p><p>如需在应用中使用 Room，请将以下依赖项添加到应用的 build.gradle 文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.3.0"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava3 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava3:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers</span></span><br><span class="line">    testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Paging 3 Integration</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-paging:2.4.0-rc01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常情况记录"><a href="#异常情况记录" class="headerlink" title="异常情况记录"></a>异常情况记录</h2><ul><li>Room AppDatabase_Impl does not exist</li></ul><p>使用了 kotlin 构建了项目,并且使用 kotlin 编写 room 创建数据库,在 build.gradle 文件里做如下修改</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.android.library'</span></span><br><span class="line">    id <span class="string">'kotlin-android'</span></span><br><span class="line">    id <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">    id <span class="string">'kotlin-kapt'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略...</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api<span class="string">"android.arch.persistence.room:runtime:$rootProject.room_version"</span></span><br><span class="line">    kapt<span class="string">"android.arch.persistence.room:compiler:$rootProject.room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 annotationProcessor 替换成 kapt,请注意需要导入 id ‘kotlin-kapt’ 才能使用 kapt</p><p>参考地址：<a href="https://www.cnblogs.com/guanxinjing/p/14990401.html" target="_blank" rel="noopener">https://www.cnblogs.com/guanxinjing/p/14990401.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用 Room 将数据保存到本地数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。&lt;/p&gt;
&lt;p&gt;处理大量结构化数据的应用可极大地受益于在本地保留这些
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack DataSource</title>
    <link href="hexo/blog/2021/12/jetpack-DataSource.html"/>
    <id>hexo/blog/2021/12/jetpack-DataSource.html</id>
    <published>2021-12-22T10:29:42.000Z</published>
    <updated>2021-12-22T10:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。</p><p>DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。</p><ul><li>Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。</li><li>Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。&lt;/p&gt;
&lt;p&gt;DataStore 提供两种不同的实现：Preferences 
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack lifecycle</title>
    <link href="hexo/blog/2021/12/jetpack-lifecycle.html"/>
    <id>hexo/blog/2021/12/jetpack-lifecycle.html</id>
    <published>2021-12-22T03:08:25.000Z</published>
    <updated>2021-12-22T03:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 库中用来感知生命周期的组件</p><h2 id="使用生命周期感知型组件处理生命周期"><a href="#使用生命周期感知型组件处理生命周期" class="headerlink" title="使用生命周期感知型组件处理生命周期"></a>使用生命周期感知型组件处理生命周期</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。</p><p>一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。</p><p>androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p><p>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p><p><strong>事件</strong><br>从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。<br><strong>状态</strong><br>由 Lifecycle 对象跟踪的组件的当前状态</p><p><img src="../../../images/lifecycle.svg" style="zoom:60%"></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MainLifecycleObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainLifecycleObserver</span></span>() : LifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> TAG: String  = <span class="string">"MainLifecycleObserver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityCreated: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityResume: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityStopped: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，就可以實現在 Activity 之外獲取到生命週期的變化，避免在 Activity/Fragment 中的生命週期中寫大量業務代碼</p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>LifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。</p><p>此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。</p><p>实现 DefaultLifecycleObserver 的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p><h3 id="自定義-LifecycleOwner"><a href="#自定義-LifecycleOwner" class="headerlink" title="自定義 LifecycleOwner"></a>自定義 LifecycleOwner</h3><p>我們不只是可以綁定視圖的生命週期，可以通過 LifecycleOwner 自定義對應色生命週期<br>如當處於 Activity 的 onCreate、onStart 中都需執行 onStart</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), LifecycleOwner &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LifeCycle 组件实际上并没有带来什么新的功能，他通过观察者模式+注解来让我们更方便的监听 Activity 和 Fragment 的生命周期变化。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle 是 Jetpack 库中用来感知生命周期的组件&lt;/p&gt;
&lt;h2 id=&quot;使用生命周期感知型组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知型组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知型组件处理生命周期
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>kotlin学习指南一</title>
    <link href="hexo/blog/2021/12/kotlin%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80.html"/>
    <id>hexo/blog/2021/12/kotlin学习指南一.html</id>
    <published>2021-12-20T06:22:11.000Z</published>
    <updated>2021-12-22T00:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin 是 google 推出的一門新語言，也是基於 JVM 的。</p><h2 id="kotlin-基础"><a href="#kotlin-基础" class="headerlink" title="kotlin 基础"></a>kotlin 基础</h2><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>新建一个 kt 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主入口 main 方法， 无需新建类即可运行，函数声明用 fun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int, b:Int):Int&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值写在参数之后</p><p>表达式可以作为函数体，返回值类型自动推断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sun(a:Int, b:Int) = a+b;</span><br></pre></td></tr></table></figure><p>返回无意义的值用 Unit 表示</p><p>fun test():Unit {<br>println(“test”);<br>}</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>变量赋值声明关键字：var、val<br>var：声明变量<br>val：声明常量</p><p>var i:Int = 1;<br>val PI:Double = 3.14;</p><p>当声明并赋值时，数据类型可以省略, 会自动推断数据类型<br>var i = 1;<br>val PI = 3.14</p><p>当声明但不赋值时，不能省略数据类型<br>var i:Int;<br>val PI:Double;</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;aaaaa&quot;;</span><br><span class="line">var b = &quot;str = $s&quot;;</span><br><span class="line">var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testIf(a:Int, b:Int):Int &#123;</span><br><span class="line">    if(a &gt; b) return a;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kotlin 中，if 还可以用作表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun max(a:Int, b:Int) = if(a &gt; b) a else b</span><br></pre></td></tr></table></figure><h2 id="空值与-null-检测"><a href="#空值与-null-检测" class="headerlink" title="空值与 null 检测"></a>空值与 null 检测</h2><p>当某个值可以为空时，需要在类型后添加?表示可以为空<br>此时，声明时不能省略类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj:Objects ? = null;</span><br><span class="line">// 表示返回值可以为null</span><br><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型检测与自动类型转换"><a href="#类型检测与自动类型转换" class="headerlink" title="类型检测与自动类型转换"></a>类型检测与自动类型转换</h2><p>is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 </strong></p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);</span><br><span class="line">// 根据元素遍历</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据下标便利</span><br><span class="line">for (item in items.indices) &#123;</span><br><span class="line">    println(items[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = 0;</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(items[index]);</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when-表达式"><a href="#when-表达式" class="headerlink" title="when 表达式"></a>when 表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private fun testWhen(s: Any?) &#123;</span><br><span class="line">        when(s) &#123;</span><br><span class="line">            &quot;a&quot; -&gt; 1;</span><br><span class="line">            &quot;b&quot; -&gt; 2;</span><br><span class="line">            is String -&gt; 3;</span><br><span class="line">            1 -&gt; &quot;n&quot;;</span><br><span class="line">            2 -&gt; &#123;</span><br><span class="line">              println(&quot;222&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            else -&gt; &quot;else&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有点类似 java 中的 switch</p><h2 id="区间-range"><a href="#区间-range" class="headerlink" title="区间 range"></a>区间 range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = 9;</span><br><span class="line">if(x in 0..y) &#123;</span><br><span class="line">    println(&quot;x in 0 - y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间只用于数字</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的迭代可以用的上面的 for in 循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">for(item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断集合中是否包含某元素 用 while in || when</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (&quot;a&quot; in items) &#123;</span><br><span class="line">    println(&quot;items include a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when &#123;</span><br><span class="line">    &quot;a&quot; in items -&gt; println(&quot;aaa&quot;);</span><br><span class="line">    &quot;d&quot; in items -&gt; println(&quot;ddd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 lambda 来过滤和映射集合 ，与 java8 lambda stream 大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125;</span><br><span class="line">    .sortBy&#123; it &#125;</span><br><span class="line">    .map&#123; it.toUpperCase() &#125;</span><br><span class="line">    .forEach&#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>什么是协程？<br>官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。<br>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</p><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。<br>CPU 调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。<br>而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p><p>协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。</p><p>build.gralde 中引入依赖<br>implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1”</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity4 : AppCompatActivity() &#123;</span><br><span class="line">    val TAG = &quot;MainActivity4&quot;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main2)</span><br><span class="line">        test()</span><br><span class="line">        Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun test() = runBlocking &#123;</span><br><span class="line">        repeat(8) &#123;</span><br><span class="line">            Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>协程执行 0 线程 id：1<br>协程执行 1 线程 id：1<br>协程执行 2 线程 id：1<br>协程执行 3 线程 id：1<br>协程执行 4 线程 id：1<br>协程执行 5 线程 id：1<br>协程执行 6 线程 id：1<br>协程执行 7 线程 id：1<br>线程 main ：1</p><p>我们可以得出结论：<br>runBlocking 会阻塞线程，但允许还是在当前线程</p><h3 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch:Job"></a>launch:Job</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testJob() &#123;</span><br><span class="line">        val job = GlobalScope.launch &#123;</span><br><span class="line">            repeat(8) &#123;</span><br><span class="line">                delay(2000)</span><br><span class="line">                Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>testJob: 线程 main：2<br>testJob: 线程 id:6809<br>testJob: 线程 id:6807<br>testJob: 线程 id:6807<br>testJob: 线程 id:6815<br>testJob: 线程 id:6807<br>testJob: 线程 id:6808<br>testJob: 线程 id:6818<br>testJob: 线程 id:6809</p><p>说明使用 GlobalScope.launch</p><ul><li>并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务</li><li>是非阻塞、异步执行，相当于开启了子线程</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun testAsync()&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        var result1 = GlobalScope.async &#123;</span><br><span class="line">            getResult1()</span><br><span class="line">        &#125;</span><br><span class="line">        var result2 = GlobalScope.async &#123;</span><br><span class="line">            getResult2()</span><br><span class="line">        &#125;</span><br><span class="line">        val result = result1.await() + result2.await()</span><br><span class="line">        Log.e(TAG, &quot;testAsync: ThreadId =  $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult1():Int &#123;</span><br><span class="line">    delay(3000)</span><br><span class="line">    Log.e(TAG, &quot;getResult1: ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult2():Int &#123;</span><br><span class="line">    delay(5000)</span><br><span class="line">    Log.e(TAG, &quot;getResult2:  ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>E/MainActivity4: 线程 main ：2<br>E/MainActivity4: getResult1: ThreadId = 7870<br>E/MainActivity4: getResult2: ThreadId = 7870<br>E/MainActivity4: testAsync: ThreadId = 7870 result = 9</p><p>其中当打印 getResult2 后就打印了 testAsync: result = 9<br>阻塞时间为 5 秒，而不是 8 秒，说明 getResult1、getResult2 是并行的。</p><p>而且发现 threadId 都一样，说明处于同一个线程。<br>但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。</p><ul><li>协程并不等于线程，协程内部会根据任务情况自动调度线程。</li></ul><p>launch()有三个入参： 1.协程下上文；2.协程启动模式；3.协程体：block 是一个带接收者的函数字面量，接收者是 CoroutineScope</p><p>我们在线程中执行的代码就是第三个参数</p><h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>上下文可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，Kotlin 协程使用调度器来确定哪些线程用于协程执行，Kotlin 提供了调度器给我们使用：</p><p>Dispatchers.Main：使用这个调度器在 Android 主线程上运行一个协程。可以用来更新 UI 。在 UI 线程中执行</p><p>Dispatchers.IO：这个调度器被优化在主线程之外执行磁盘或网络 I/O。在线程池中执行</p><p>Dispatchers.Default：这个调度器经过优化，可以在主线程之外执行 cpu 密集型的工作。例如对列表进行排序和解析 JSON。在线程池中执行。</p><p>Dispatchers.Unconfined：在调用的线程直接执行。</p><p>调度器实现了 CoroutineContext 接口。</p><p>我们还可以自己自定义调度器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dis = Executors.newCachedThreadPool().asCoroutineDispatcher()</span><br><span class="line">runBlocking &#123;</span><br><span class="line">    launch(dis) &#123;</span><br><span class="line">        println(&quot;dis 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>在 Kotlin 协程当中，启动模式定义在一个枚举类中：</p><p>public enum class CoroutineStart {<br>DEFAULT,<br>LAZY,<br>@ExperimentalCoroutinesApi<br>ATOMIC,<br>@ExperimentalCoroutinesApi<br>UNDISPATCHED;<br>}<br>一共定义了 4 种启动模式，<br>DEFAULT: 默认的模式，立即执行协程体<br>LAZY: 只有在需要的情况下运行<br>ATOMIC: 立即执行协程体，但在开始运行之前无法取消<br>UNDISPATCHED :立即在当前线程执行协程体，直到第一个 suspend 调用</p><h3 id="协程体"><a href="#协程体" class="headerlink" title="协程体"></a>协程体</h3><p>协程体是一个用 suspend 关键字修饰的一个无参，无返回值的函数类型。被 suspend 修饰的函数称为挂起函数,与之对应的是关键字 resume（恢复）<br>注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>Kotlin 的硬关键宇包括:</p><p>as 一一 用于做类型转换或为 import 语句指定别名<br>as?一一类型安全 的类型转换运算符。<br>break 一一中断循环<br>class 一一声明类。<br>continue 一忽略本次循环剩下的语句，重新开始下一次循环。<br>do 一一用于 do while 循环<br>else 一一在 if 分支中使用<br>false 一一在 Boolean 类型中表示假 的直接量。<br>for 一一用于 for 循环<br>fun 一一声 明函数<br>if－在 if 分支中使用<br>in 一一在 for 循环中使用； in 还可作为双目运算符，检查 一个值是否处于区间或集合 内；<br>in 也可 在 when 表达式中使用； in 还可用于修饰泛型参数，表明该泛型参数支持逆变<br>!in 一一可作为双目运算符 的反义词：！in 也可在 when 表达式中使用<br>is 一一用于做类型检查（类 Java instanceof) 或在 when 表达式中使用<br>!is 一一 用于做类型检查（ is 的反义词〉或在 when 表达式中使用<br>null 一一 代表空的直接量。<br>object ——用于声明对象表达式或定义命名对象<br>package 一一用于为当 前文件指定包<br>return 一一声明函数的返回<br>super 一－用于引用父类实现的方法或属性，或者在子类构造器中调用父类构造器<br>this 一一 代表当前类的对象或在构造器中调用当前类的其他构造器<br>throw 一一用于抛出异常<br>true 一一在 Boolean 类型中表示真的直接量。<br>try 一一开始异常处理<br>typealias 一一用于定义类型别名。<br>val 一声明只读属性或变量。<br>var 一一声明可变属性或变量。<br>when 一一用于 when 表达式。while 一一－用于 while 循环或 do while 循环</p><p>Kotlin 的软关键宇包括：</p><p>by 一一用于将接口或祖先类的实现代理给其他对象。<br>catch 一一在异常处理中用于捕捉异常<br>constructor 一一用于声明构造器。<br>delegate 一用于指定该注解修饰委托属性存储其委托实例的字段<br>dynamic 一一主要用于在 Kotlin/JavaScript 中引用 一个动态类型<br>field 一一用于指定该注解修饰属性的幕后字段。<br>file 一一用于指定该注解修饰该源文件本身<br>finally 一一异常处理中的 finally<br>get 一一用于声明属性的 getter 方法，或者用于指定该注解修饰属性的 getter 方法<br>import 一一用于导包。<br>init 一一用于声明初始化块<br>param 一一用于指定该注解修饰构造器参数<br>property 一一用于指定该注解修饰整个属性（这种目标的注解对 Java 不可见，因为 Java<br>并没有真正的属性）。<br>receiveris 一一用于指定该注解修饰扩展方法或扩展属性的接收者<br>set 一一用于声明属性的 setter 方法，或者用于指定该注解修饰属性的 setter 方法<br>setparam 一一用于指定该注解修饰 setter 方法的参数<br>where 一一用于为泛型参数增加限制。</p><p>Kotlin 的修饰符关键宇包括：</p><p>abstract 一一用于修饰抽象类或抽象成员<br>annotation 一一用于修饰一个注解类。<br>companion 一一用于声明一个伴生对象<br>const 一一用于声明编译时常量<br>crossinline 一一用于禁止在传给内联函数的 Lambd 表达式中执行非局部返回<br>data 一一用于声明数据类。<br>enum 一一用于声明枚举<br>external 一一用于声明某个方法不由 Kotlin 实现（与 Java 的 native 相似〉。<br>final 一一用于禁止被重写<br>infix 一一声明该函数能以双目运算符的格式执行<br>inline 一一用于声明内联函数， Lambda 表达式可在内联函数中执行局部返回。<br>inner 一一用于声明内部类，内部类可以访问外部类的实例<br>internal 一一用于表示被修饰的声明只能在当前模块内可见<br>lateinit——-用于修饰 non-null 属性，用于指定该属性可在构造器以外的地方<br>初始化<br>noinline 一一用于禁止内联函数中个别 Lambda 表达式被内联化<br>open 一一用于修饰类，表示该类可派生子类；或者用于修饰成员，表示该成员可以被<br>重写。<br>out 一一用于修饰泛型参数，表明该泛型参数支持协变。<br>override 一一用于声明重写父类的成员<br>private ——private 访问权限<br>protected ——–protected 访问权限<br>public——-public 访问权限。<br>reified 一一用于修饰内联函数中的泛型形参，接下来在该函数中就可像使用普通类型<br>一样使用该类型参数。<br>sealed 一一用于声明一个密封类。<br>suspend 一一用于标识一个函数后 Lambda 表达式可作为暂停。<br>tailrec 一一用于修饰一个函数可作为尾随递归函数使用。<br>vararg 一一用于修饰形参，表明该参数是个数可变的形参。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;kotlin 是 google 推出的一門新語言，也是基於 JVM 的。&lt;/p&gt;
&lt;h2 id=&quot;kotlin-基础&quot;&gt;&lt;a href=&quot;#kotlin-基础&quot; class=&quot;headerlink&quot; title=&quot;kotlin 基础&quot;&gt;&lt;/a&gt;kotlin 基础&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="kotlin" scheme="hexo/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/12/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html"/>
    <id>hexo/blog/2021/12/NDK-C-基础-四.html</id>
    <published>2021-12-08T08:16:22.000Z</published>
    <updated>2021-12-08T08:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>在之前讲过的拷贝构造函数，其实就是一种 浅拷贝<br>但是在浅拷贝中，无法拷贝堆内存中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Student1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student1() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student1(char * name) :Student1(name, 99) &#123; cout &lt;&lt; &quot;一个入参 构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    Student1(char * name, int age) &#123; </span><br><span class="line">cout &lt;&lt; &quot;两个入参构造函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">this-&gt;name = (char *) malloc(sizeof(char * ) * 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line"></span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student1() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上所示，Student 类中，在构造函数中，name 是动态开辟在堆内存上的，在析构函数中，会使用free释放 name 在堆内存的内存空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line">Student1 s1;</span><br><span class="line">Student1 s2 = s1; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行完上述代码时，会运行异常，<br>Student1 s2 = s1;  会执行 拷贝构造函数，将 s2 的值都复制给 s1<br>但是之前说过 <em> 拷贝构造函数是 浅拷贝 </em><br>浅拷贝 是不会拷贝堆内存中的数据的， 所以其实 s2 与 s1 中的 name 指向的同一块堆内存空间，<br>当main函数执行完毕，出栈时，会调用 s2、s1的析构函数，当指向s1的析构函数时，会释放 name 中的堆内存空间。<br>等到执行 s2 的析构函数时，又会执行 free(this-&gt;name); 但此时 this-&gt;name已经是一块指向NULL的指针了，此时就会抛出异常。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>上面讲了深拷贝与浅拷贝的区别，以及默认的拷贝构造函数是一次浅拷贝，接下来手动实现一下 深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student(char * name) :Student(name, 99) &#123;</span><br><span class="line">cout &lt;&lt; &quot;一个参数构造函数 this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(char * name, int age) &#123;</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数 &amp;this-&gt;name:&quot; &lt;&lt; (int)this-&gt;name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(const Student &amp; stu) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;stu的地址 &amp;stu:&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot; this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">// 重新开辟一个堆内存存放新的 stu对象中的 name</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">        // 复制name中的值</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = stu.age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void showStudent(Student stu) &#123;</span><br><span class="line">cout &lt;&lt; &quot;showStudent的内存地址&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot;  &quot; &lt;&lt; stu.name &lt;&lt; &quot;,&quot; &lt;&lt; stu.age&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">Student stu(&quot;justin&quot;, 31);</span><br><span class="line"></span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，在函数 showStudent 中会调用拷贝构造函数 然后执行完毕出栈，调用 析构函数，<br>但上述代码不会出现异常，因为在我们自定义的拷贝构造函数中，我们手动实现了堆内存的拷贝。并每次执行析构函数时，又会释放掉name的堆内存。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅拷贝与深拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝与深拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝与深拷贝&quot;&gt;&lt;/a&gt;浅拷贝与深拷贝&lt;/h2&gt;&lt;p&gt;浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/12/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB.html"/>
    <id>hexo/blog/2021/12/java数据类型汇总.html</id>
    <published>2021-12-08T08:16:22.000Z</published>
    <updated>2021-12-08T08:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>再java中，数据类型可分为两种：集合（Collection）、图（Map）<br>而这两大类中又可以细分，常用的子类为：<br>ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap</p><h2 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h2><p>集合可以细分为三类：List、Set、Queue</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口扩展自Collection，它可以定义一个允许重复的有序集合</p><p>List中常用的子类有：ArrayList、LinkerList、CopyOnWriteArrayList</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList内部的数据结构为数组，当增加元素数量大于初始容量，会触发扩容，即新建一个之前容量两位的数组，并将之前的元素拷贝过来。<br>查询快，增删慢<br><strong><em>非线程安全</em></strong></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList内部的数据结构为链表，双向链表。<br>查询慢，增删快<br><strong><em>非线程安全</em></strong></p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。<br><strong><em>线程安全，通过ReentrantLock实现</em></strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。<br>Set接口有三个具体实现类：散列集HashSet、链式散列集LinkedHashSet、树形集TreeSet</p><p>Set判断是否重复的原理是，先判断Hash，如果Hash相同再判断equals</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>散列集HashSet是一个用于实现Set接口的具体类，<br>有两个名词需要关注，初始容量和客座率。<br>客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，就会触发扩容。</p><p><strong><em>非线程安全</em></strong></p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>内部数据是链表，是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序<br>HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。<br><strong><em>非线程安全</em></strong></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>内部数据结构为树，<br>扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。<br><strong><em>非线程安全</em></strong></p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>数据结构为队列，特点是先进先出，后进后出<br>而关于队列的实现又有多个：优先级队列、异步队列、同步队列、阻塞队列等。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map中常用的子类有: HashMap、HashTable、LinkedHashMap、TreeMap、ConcurrentHashMap</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap在jdk1.8时发生了变更<br>在JDK1.7及以前的版本中：内部数据结构为：数组+链表，并且链表插入数据的方式为 头插法<br>在jdk1.8以及之后的版本中：内部的数据结构为：数组+链表+红黑树，并且链表插入数据的方式为 尾插法</p><p>数据存放方式为 key value，一一对应，key不允许重复<br>大致原理：根据key得出hash值，根据hash值对数组长度取模得出存放数组的下标，每个数组下标对于的为一个链表，将数据放入到链表，当链表长度大于阈值时，则链表转换为红黑树，红黑树节点数减少小于阈值时，则又转换回链表<br>取值大致过程相同：根据key获取hash，然后得出下标，然后再去链表或者红黑树中根据key对比取值</p><p><strong><em>非线程安全</em></strong></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，<br>HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，<br>也可以按它们最后一次被访问的顺序排<br><strong><em>非线程安全</em></strong></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。<br><strong><em>非线程安全</em></strong></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 是并发包concurrent下针对HashMap的一种实现，线程安全<br>同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高</p><p><strong><em>线程安全</em></strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;再java中，数据类型可分为两种：集合（Collection）、图（Map）&lt;br&gt;而这两大类中又可以细分，常用的子类为：&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java 类加载机制</title>
    <link href="hexo/blog/2021/11/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
    <id>hexo/blog/2021/11/java-类加载机制.html</id>
    <published>2021-11-01T10:14:26.000Z</published>
    <updated>2022-02-21T05:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul><li><p>了解 java 类加载机制</p></li><li><p>理解类加载器 ClassLoader</p></li></ul><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ul><li><p>隐式加载 new 创建类的实例,</p></li><li><p>显式加载：loaderClass,forName 等</p></li><li><p>访问类的静态变量，或者为静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>使用反射方式创建某个类或者接口对象的 Class 对象。</p></li><li><p>初始化某个类的子类</p></li><li><p>直接使用 java.exe 命令来运行某个主类</p></li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类加载有五步：<br>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的一个阶段，ClassLoader 通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个 class 对象</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量（static 修饰的字段变量）分配内存并且设置该类变量的初始值，（如 static int i = 5 这里只是将 i 赋值为 0，在初始化的阶段再把 i 赋值为 5)，<br>这里不包含 final 修饰的 static ，因为 final 在编译的时候就已经分配了。<br>这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到 Java 堆中</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这里主要的任务是把常量池中的符号引用替换成直接引用</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。<br>（前面已经对 static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）</p><h2 id="forName-和-loaderClass-区别"><a href="#forName-和-loaderClass-区别" class="headerlink" title="forName 和 loaderClass 区别"></a>forName 和 loaderClass 区别</h2><ul><li><p>Class.forName()得到的 class 是已经初始化完成的</p></li><li><p>ClassLoader.loaderClass 得到的 class 是还没有链接（验证，准备，解析三个过程被称为链接）的。</p></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派模式要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，<br>但是在双亲委派模式中父子关系采取的并不是继承的关系，而是采用组合关系来复用父类加载器的相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>通过 loadClass 加载类时，会先通过 findLoadClass 查找该类是否已加载，<br>如果未加载，会先通过父加载期加载，依次向上递归，到最上级父加载器加载，<br>如果此时还未加载，再依次向下递归调用 findClass</p><p>就是每个儿子都很懒，遇到类加载的活都给它爸爸干，直到爸爸说我也做不来的时候，儿子才会想办法自己去加载。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>采用双亲委派模式的好处就是 Java 类随着它的类加载器一起具备一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类的时候，就没有必要子类加载器（ClassLoader）再加载一次。其次是考虑到安全因素，Java 核心 API 中定义类型不会被随意替换，假设通过网路传递一个名为 java.lang.Integer 的类，通过双亲委派的的模式传递到启动类加载器，而启动类加载器在核心 Java API 发现这个名字类，发现该类已经被加载，并不会重新加载网络传递过来的 java.lang.Integer.而之际返回已经加载过的 Integer.class，这样便可以防止核心 API 库被随意篡改。可能你会想，如果我们在 calsspath 路径下自定义一个名为 java.lang.SingInteger?该类并不存在 java.lang 中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器，最终会通过系统类加载器加载该类，但是这样做是不允许的，因为 java.lang 是核心的 API 包，需要访问权限，强制加载将会报出如下异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException:Prohibited <span class="keyword">package</span> name: java.lang</span><br></pre></td></tr></table></figure><h2 id="类与加载器"><a href="#类与加载器" class="headerlink" title="类与加载器"></a>类与加载器</h2><p>在 JVM 中标识两个 Class 对象，是否是同一个对象存在的两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个 ClassLoader（指 ClassLoader 实例对象）必须相同。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;了解 java 类加载机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解类加载器 ClassLoader&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/11/java-%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8Eclass.html"/>
    <id>hexo/blog/2021/11/java-反射基本概念与class.html</id>
    <published>2021-11-01T10:12:43.000Z</published>
    <updated>2021-11-01T10:12:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 *</li></ul><p>类名 用途<br>Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口<br>Field 类 代表类的成员变量（成员变量也称为类的属性）<br>Method 类 代表类的方法<br>Constructor 类 代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法 用途<br>asSubclass(Class<u> clazz) 把传递的类的对象转换成代表其子类的对象<br>Cast 把对象转换成代表类或是接口的对象<br>getClassLoader() 获得类的加载器<br>getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className) 根据类名返回类的对象<br>getName() 获得类的完整路径名字<br>newInstance() 创建类的实例<br>getPackage() 获得类的包<br>getSimpleName() 获得类的名字<br>getSuperclass() 获得当前类继承的父类的名字<br>getInterfaces() 获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法 用途<br>getField(String name) 获得某个公有的属性对象<br>getFields() 获得所有公有的属性对象<br>getDeclaredField(String name) 获得某个属性对象<br>getDeclaredFields() 获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法 用途<br>getAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的公有注解对象<br>getAnnotations() 返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations() 返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法 用途<br>getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法<br>getConstructors() 获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors() 获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法 用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法<br>getMethods() 获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数<br>getDeclaredMethods() 获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法 用途<br>isAnnotation() 如果是注解类型则返回 true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 true<br>isAnonymousClass() 如果是匿名类则返回 true<br>isArray() 如果是一个数组类则返回 true<br>isEnum() 如果是枚举类则返回 true<br>isInstance(Object obj) 如果 obj 是该类的实例则返回 true<br>isInterface() 如果是接口类则返回 true<br>isLocalClass() 如果是局部类则返回 true<br>isMemberClass() 如果是内部类则返回 true</p><h3 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h3><p>Field 代表类的成员变量（成员变量也称为类的属性）。</p><p>方法 用途<br>equals(Object obj) 属性与 obj 相等则返回 true<br>get(Object obj) 获得 obj 中对应的属性值<br>set(Object obj, Object value) 设置 obj 中对应属性值</p><h3 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h3><p>Method 代表类的方法。</p><p>方法 用途<br>invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法</p><h3 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h3><p>Constructor 代表类的构造方法。</p><p>方法 用途<br>newInstance(Object… initargs) 根据传递的参数创建类的对象</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先写一个被反射调用的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReflex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ExampleReflex.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String LOG = <span class="string">"LOG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String privateName = <span class="string">"privateName"</span>;</span><br><span class="line">    <span class="keyword">public</span> String publicName = <span class="string">"publicName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"defaultName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FINAL_NAME = <span class="string">"FINAL_NAME"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATIC_FINAL_NAME = <span class="string">"STATIC_FINAL_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodNoParams: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodHasParams: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Private No Params getName: "</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethodHasParams</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateMethodHasParams: "</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"size:"</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodNoParams: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"staticMethodNoParams"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodHasParams: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"_____"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">privateStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateStaticMethod: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPrivateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPrivateName: "</span> + privateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPublicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPublicName: "</span> + publicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logStatic: A: "</span> + A + <span class="string">"   LOG: "</span> + LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logFinal: finalName: "</span> + FINAL_NAME + <span class="string">" STATIC_FINAL_NAME: "</span>+ STATIC_FINAL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，其中包含 public、private、static、final 修饰的属性、以及函数</p><h3 id="返回调用函数"><a href="#返回调用函数" class="headerlink" title="返回调用函数"></a>返回调用函数</h3><h4 id="调用-public-函数"><a href="#调用-public-函数" class="headerlink" title="调用 public 函数"></a>调用 public 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取class</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 根据class 获取一个对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象</span></span><br><span class="line">Method method1 = clazz.getMethod(<span class="string">"publicMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">method1.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公有有参函数 第二个参数是入参参数签名</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"publicMethodHasParams"</span>, String.class);</span><br><span class="line">method2.invoke(obj, <span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用-private-函数"><a href="#调用-private-函数" class="headerlink" title="调用 private 函数"></a>调用 private 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取私有函数</span></span><br><span class="line">Method method3 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 私有函数需要设置允许访问 否则会报错</span></span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">String name = (String) method3.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethod Result: "</span> + name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有有参函数</span></span><br><span class="line">Method method4 = clazz.getDeclaredMethod(<span class="string">"privateMethodHasParams"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">method4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String size = (String) method4.invoke(obj, <span class="number">22</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethodHasParams Result: "</span> + size);</span><br></pre></td></tr></table></figure><p>可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。<br>getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数</p><h4 id="调用-static-函数"><a href="#调用-static-函数" class="headerlink" title="调用 static 函数"></a>调用 static 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态无参函数</span></span><br><span class="line">Method method5 = clazz.getDeclaredMethod(<span class="string">"staticMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line">method5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method5.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态有参函数</span></span><br><span class="line">Method method6 = clazz.getDeclaredMethod(<span class="string">"staticMethodHasParams"</span>, String.class);</span><br><span class="line">method6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String result_str6 = (String) method6.invoke(obj, <span class="string">"public static method"</span>);</span><br><span class="line">Log.d(tag, <span class="string">"staticMethodHasParams Result: "</span> + result_str6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有静态函数</span></span><br><span class="line">Method method7 = clazz.getDeclaredMethod(<span class="string">"privateStaticMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">method7.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method7.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>反射调用静态函数与调用私有函数其实没有不同</p><h3 id="调用反射修改属性"><a href="#调用反射修改属性" class="headerlink" title="调用反射修改属性"></a>调用反射修改属性</h3><h4 id="修改-public、private、static-变量"><a href="#修改-public、private、static-变量" class="headerlink" title="修改 public、private、static 变量"></a>修改 public、private、static 变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改public变量，并输出</span></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field publicField = clazz.getDeclaredField(<span class="string">"publicName"</span>);</span><br><span class="line"><span class="comment">// 在obj实例对象上设置属性新值</span></span><br><span class="line">publicField.set(obj, <span class="string">"publicName_New"</span>);</span><br><span class="line">Method method8 = clazz.getDeclaredMethod(<span class="string">"logPublicName"</span>);</span><br><span class="line">method8.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改private变量</span></span><br><span class="line">Field privateField = clazz.getDeclaredField(<span class="string">"privateName"</span>);</span><br><span class="line"><span class="comment">// 私有属性需要设置可访问</span></span><br><span class="line">privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateField.set(obj, <span class="string">"privateName_New"</span>);</span><br><span class="line">Method method9 = clazz.getDeclaredMethod(<span class="string">"logPrivateName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method9.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态属性</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"A"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(obj, <span class="number">2222</span>);</span><br><span class="line">Method method10 = clazz.getDeclaredMethod(<span class="string">"logStatic"</span>, <span class="keyword">null</span>);</span><br><span class="line">method10.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method10.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意，私有变量时需要调用 setAccessible，不然会报错</p><h4 id="修改-final-修饰的常量"><a href="#修改-final-修饰的常量" class="headerlink" title="修改 final 修饰的常量"></a>修改 final 修饰的常量</h4><p>在 java 中，使用 final 修饰的代表常量，不允许修改。<br>当我们通过反射修改时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改final常量</span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method11 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method11.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method11.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。</p><p>针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的修改final常量方式</span></span><br><span class="line">Field field3 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field3.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method12 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method12.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="反射构造函数"><a href="#反射构造函数" class="headerlink" title="反射构造函数"></a>反射构造函数</h3><p>在上面调用生成实例中：<br>Object obj = clazz.newInstance();</p><p>其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。<br>修改 ExampleReflex.java 中的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Constructor ExampleReflex: "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例</p><p>通过 public 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 获取public 有参的构造函数</span></span><br><span class="line">Constructor constructor1 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 通过构造函数生成对象 参数为入参类型class</span></span><br><span class="line">Object obj = constructor1.newInstance(<span class="string">"NNNNN"</span>);</span><br><span class="line">Method method81 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method81.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method81.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>通过 private 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取private 有参构造函数</span></span><br><span class="line">Constructor constructor2 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line">Object obj2 = constructor2.newInstance(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="hexo/blog/2021/10/%E5%8F%8D%E5%B0%84.html"/>
    <id>hexo/blog/2021/10/反射.html</id>
    <published>2021-10-25T07:01:37.000Z</published>
    <updated>2022-02-18T03:55:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 *</li></ul><p>类名 用途<br>Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口<br>Field 类 代表类的成员变量（成员变量也称为类的属性）<br>Method 类 代表类的方法<br>Constructor 类 代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法 用途<br>asSubclass(Class<u> clazz) 把传递的类的对象转换成代表其子类的对象<br>Cast 把对象转换成代表类或是接口的对象<br>getClassLoader() 获得类的加载器<br>getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className) 根据类名返回类的对象<br>getName() 获得类的完整路径名字<br>newInstance() 创建类的实例<br>getPackage() 获得类的包<br>getSimpleName() 获得类的名字<br>getSuperclass() 获得当前类继承的父类的名字<br>getInterfaces() 获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法 用途<br>getField(String name) 获得某个公有的属性对象<br>getFields() 获得所有公有的属性对象<br>getDeclaredField(String name) 获得某个属性对象<br>getDeclaredFields() 获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法 用途<br>getAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的公有注解对象<br>getAnnotations() 返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations() 返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法 用途<br>getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法<br>getConstructors() 获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors() 获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法 用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法<br>getMethods() 获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数<br>getDeclaredMethods() 获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法 用途<br>isAnnotation() 如果是注解类型则返回 true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 true<br>isAnonymousClass() 如果是匿名类则返回 true<br>isArray() 如果是一个数组类则返回 true<br>isEnum() 如果是枚举类则返回 true<br>isInstance(Object obj) 如果 obj 是该类的实例则返回 true<br>isInterface() 如果是接口类则返回 true<br>isLocalClass() 如果是局部类则返回 true<br>isMemberClass() 如果是内部类则返回 true</p><h3 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h3><p>Field 代表类的成员变量（成员变量也称为类的属性）。</p><p>方法 用途<br>equals(Object obj) 属性与 obj 相等则返回 true<br>get(Object obj) 获得 obj 中对应的属性值<br>set(Object obj, Object value) 设置 obj 中对应属性值</p><h3 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h3><p>Method 代表类的方法。</p><p>方法 用途<br>invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法</p><h3 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h3><p>Constructor 代表类的构造方法。</p><p>方法 用途<br>newInstance(Object… initargs) 根据传递的参数创建类的对象</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先写一个被反射调用的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReflex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ExampleReflex.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String LOG = <span class="string">"LOG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String privateName = <span class="string">"privateName"</span>;</span><br><span class="line">    <span class="keyword">public</span> String publicName = <span class="string">"publicName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"defaultName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FINAL_NAME = <span class="string">"FINAL_NAME"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATIC_FINAL_NAME = <span class="string">"STATIC_FINAL_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodNoParams: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodHasParams: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Private No Params getName: "</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethodHasParams</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateMethodHasParams: "</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"size:"</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodNoParams: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"staticMethodNoParams"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodHasParams: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"_____"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">privateStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateStaticMethod: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPrivateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPrivateName: "</span> + privateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPublicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPublicName: "</span> + publicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logStatic: A: "</span> + A + <span class="string">"   LOG: "</span> + LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logFinal: finalName: "</span> + FINAL_NAME + <span class="string">" STATIC_FINAL_NAME: "</span>+ STATIC_FINAL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，其中包含 public、private、static、final 修饰的属性、以及函数</p><h3 id="返回调用函数"><a href="#返回调用函数" class="headerlink" title="返回调用函数"></a>返回调用函数</h3><h4 id="调用-public-函数"><a href="#调用-public-函数" class="headerlink" title="调用 public 函数"></a>调用 public 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取class</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 根据class 获取一个对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象</span></span><br><span class="line">Method method1 = clazz.getMethod(<span class="string">"publicMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">method1.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公有有参函数 第二个参数是入参参数签名</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"publicMethodHasParams"</span>, String.class);</span><br><span class="line">method2.invoke(obj, <span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用-private-函数"><a href="#调用-private-函数" class="headerlink" title="调用 private 函数"></a>调用 private 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取私有函数</span></span><br><span class="line">Method method3 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 私有函数需要设置允许访问 否则会报错</span></span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">String name = (String) method3.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethod Result: "</span> + name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有有参函数</span></span><br><span class="line">Method method4 = clazz.getDeclaredMethod(<span class="string">"privateMethodHasParams"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">method4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String size = (String) method4.invoke(obj, <span class="number">22</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethodHasParams Result: "</span> + size);</span><br></pre></td></tr></table></figure><p>可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。<br>getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数</p><h4 id="调用-static-函数"><a href="#调用-static-函数" class="headerlink" title="调用 static 函数"></a>调用 static 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态无参函数</span></span><br><span class="line">Method method5 = clazz.getDeclaredMethod(<span class="string">"staticMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line">method5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method5.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态有参函数</span></span><br><span class="line">Method method6 = clazz.getDeclaredMethod(<span class="string">"staticMethodHasParams"</span>, String.class);</span><br><span class="line">method6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String result_str6 = (String) method6.invoke(obj, <span class="string">"public static method"</span>);</span><br><span class="line">Log.d(tag, <span class="string">"staticMethodHasParams Result: "</span> + result_str6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有静态函数</span></span><br><span class="line">Method method7 = clazz.getDeclaredMethod(<span class="string">"privateStaticMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">method7.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method7.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>反射调用静态函数与调用私有函数其实没有不同</p><h3 id="调用反射修改属性"><a href="#调用反射修改属性" class="headerlink" title="调用反射修改属性"></a>调用反射修改属性</h3><h4 id="修改-public、private、static-变量"><a href="#修改-public、private、static-变量" class="headerlink" title="修改 public、private、static 变量"></a>修改 public、private、static 变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改public变量，并输出</span></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field publicField = clazz.getDeclaredField(<span class="string">"publicName"</span>);</span><br><span class="line"><span class="comment">// 在obj实例对象上设置属性新值</span></span><br><span class="line">publicField.set(obj, <span class="string">"publicName_New"</span>);</span><br><span class="line">Method method8 = clazz.getDeclaredMethod(<span class="string">"logPublicName"</span>);</span><br><span class="line">method8.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改private变量</span></span><br><span class="line">Field privateField = clazz.getDeclaredField(<span class="string">"privateName"</span>);</span><br><span class="line"><span class="comment">// 私有属性需要设置可访问</span></span><br><span class="line">privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateField.set(obj, <span class="string">"privateName_New"</span>);</span><br><span class="line">Method method9 = clazz.getDeclaredMethod(<span class="string">"logPrivateName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method9.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态属性</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"A"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(obj, <span class="number">2222</span>);</span><br><span class="line">Method method10 = clazz.getDeclaredMethod(<span class="string">"logStatic"</span>, <span class="keyword">null</span>);</span><br><span class="line">method10.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method10.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意，私有变量时需要调用 setAccessible，不然会报错</p><h4 id="修改-final-修饰的常量"><a href="#修改-final-修饰的常量" class="headerlink" title="修改 final 修饰的常量"></a>修改 final 修饰的常量</h4><p>在 java 中，使用 final 修饰的代表常量，不允许修改。<br>当我们通过反射修改时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改final常量</span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method11 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method11.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method11.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。</p><p>针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的修改final常量方式</span></span><br><span class="line">Field field3 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field3.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method12 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method12.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="反射构造函数"><a href="#反射构造函数" class="headerlink" title="反射构造函数"></a>反射构造函数</h3><p>在上面调用生成实例中：<br>Object obj = clazz.newInstance();</p><p>其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。<br>修改 ExampleReflex.java 中的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Constructor ExampleReflex: "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例</p><p>通过 public 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 获取public 有参的构造函数</span></span><br><span class="line">Constructor constructor1 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 通过构造函数生成对象 参数为入参类型class</span></span><br><span class="line">Object obj = constructor1.newInstance(<span class="string">"NNNNN"</span>);</span><br><span class="line">Method method81 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method81.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method81.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>通过 private 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取private 有参构造函数</span></span><br><span class="line">Constructor constructor2 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line">Object obj2 = constructor2.newInstance(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p>在上面其实讲的都是反射的使用，包括函数、属性、构造器等<br>而关于反射能够使用的原理，大概描述：<br>当类被加载时，会将类中的构造器、属性、函数，都缓存到 Class 类的内部类 ReflectionData 中。<br>而反射就是，先判断该类是否加载过，加载过则直接去 ReflectionData 中取，<br>如果没加载过就报错。</p><ol><li><p>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</p></li><li><p>每个类都会有一个与之对应的 Class 实例，从而每个类都可以获取 method 反射方法，并作用到其他实例身上；</p></li><li><p>反射也是考虑了线程安全的，放心使用；</p></li><li><p>反射使用软引用 relectionData 缓存 class 信息，避免每次重新从 jvm 获取带来的开销；</p></li><li><p>反射调用多次生成新代理 Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</p></li><li><p>当找到需要的方法，都会 copy 一份出来，而不是使用原来的实例，从而保证数据隔离；</p></li><li><p>调度反射方法，最终是由 jvm 执行 invoke0()执行；</p></li></ol><p>參考連結：<a href="https://www.cnblogs.com/yougewe/p/10125073.html" target="_blank" rel="noopener">https://www.cnblogs.com/yougewe/p/10125073.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android 复习导航</title>
    <link href="hexo/blog/2021/10/android-%E5%A4%8D%E4%B9%A0%E5%AF%BC%E8%88%AA.html"/>
    <id>hexo/blog/2021/10/android-复习导航.html</id>
    <published>2021-10-18T06:30:39.000Z</published>
    <updated>2021-12-08T08:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-篇"><a href="#java-篇" class="headerlink" title="java 篇"></a>java 篇</h1><ul><li>类加载机制<ul><li>双亲委派机制</li></ul></li><li>反射</li><li>注解</li><li>注入</li><li>序列化</li><li><p>范型</p></li><li><p>集合</p><ul><li>Map</li><li>List</li><li>LinkedList</li><li>Set</li><li>HashMap</li></ul></li><li><p>内存</p><ul><li>内存抖动</li><li>内存泄露</li><li>内存溢出</li><li>GC 算法</li><li>JVM 结构</li><li>JMM（java 内存模型）</li><li>四种引用类型</li></ul></li><li><p>多线程</p><ul><li>线程池</li><li>wait/notify</li><li>锁</li><li>原子类</li><li>ThreadLocal</li><li>线程的状态、转换</li></ul></li></ul><h1 id="android-篇"><a href="#android-篇" class="headerlink" title="android 篇"></a>android 篇</h1><ul><li><p>四大组件</p><ul><li>Activity</li><li>Service</li><li>BroadcastReceiver<br>-LocalBroadcastReceiver (為何更高效)</li><li>Provider</li></ul></li><li><p>生命周期</p><ul><li>Activity 生命周期</li><li>Service 生命周期</li></ul></li><li><p>消息机制</p><ul><li>Handler</li><li>IdleHandler</li><li>Looper</li><li>MessageQueue</li></ul></li><li><p>事件分发机制</p><ul><li>View/ViewGroup</li><li>滑动冲突</li></ul></li><li><p>自定义 View</p><ul><li>onMeasure</li><li>onLayout</li><li>onDraw</li></ul></li><li><p>注入</p></li><li><p>数据持久化 SharePreferences</p></li><li><p>跨进城通信</p><ul><li>AIDL</li><li>Binder</li></ul></li><li><p>设计模式</p><ul><li>MVC</li><li>MVP</li><li>MVVM</li></ul></li><li><p>第三方插件</p><ul><li>GSON</li><li>okHttp</li><li>Rxjava</li><li>Dagger</li><li>Dagger2</li><li>APT</li><li>ARouter</li><li>Glide</li></ul></li><li><p>UI</p><ul><li>ListView</li><li>ViewPager</li><li>Fragment</li><li>Stub</li><li>RecyclerView</li><li>Adapter</li></ul></li></ul><h1 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h1><ul><li>Kotlin</li><li>C/C++</li></ul><h1 id="混合开发平台"><a href="#混合开发平台" class="headerlink" title="混合开发平台"></a>混合开发平台</h1><ul><li>Cordova</li><li>react-native</li><li>Flutter<ul><li>原理</li><li>渲染机制</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-篇&quot;&gt;&lt;a href=&quot;#java-篇&quot; class=&quot;headerlink&quot; title=&quot;java 篇&quot;&gt;&lt;/a&gt;java 篇&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;类加载机制&lt;ul&gt;
&lt;li&gt;双亲委派机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反射&lt;/li
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jvm内存说明</title>
    <link href="hexo/blog/2021/08/jvm%E5%86%85%E5%AD%98%E8%AF%B4%E6%98%8E.html"/>
    <id>hexo/blog/2021/08/jvm内存说明.html</id>
    <published>2021-08-16T09:55:13.000Z</published>
    <updated>2021-08-16T10:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出</p><h2 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h2><p>在一定时间内，频繁的创建对象然后又回收，使内存存在明显的上下波动<br>一般可能发生在循环中大量创建了局部对象</p><p>内存抖动的影响，抖动频繁的话会导致回收也频繁，而频繁的 GC 是会造成性能影响的。<br>因为每次 GC 时会挂起线程两次，二次还会产生内存碎片。</p><p>要考虑多复用对象，涉及模式：享元模式</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在程序运行期间，已经没有被使用的对象，引用却一直被持有，导致该对象无法被回收，此时就会造成内存泄漏</p><p>内存泄漏的影响：会造成无用对象无法被回收，使内存空间越来越小，最终可能会造成内存溢出</p><p>一般示例：Inflater 的创建需要 Context 对象，传入 Actiivty 时创建完后，需要将 Inflater 的实例对象置空，此时就会消除对 Activity 对象引用的持有，不然就会造成 Activity 的内存泄漏</p><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>当创建对象时，JVM 无法分配足够的内存，此时就会执行 GC，清理内存已获取足够的空间。<br>但如果 GC 后仍然无法获取足够的空间时，此时就会抛出异常 OOM（内存溢出），中断程序的运行</p><p>影响：会抛出异常，中断程序的运行<br>与内存抖动、内存泄漏不同，内存抖动、内存泄漏都不会影响程序的运行，最多只会影响程序运行的性能，内存溢出则会直接报错，中断程序的运行。<br>内存溢出是内存泄漏的持续结果。</p><p>解决办法：程序内存溢出后会在特定目录输出 .trace 文件，需要分析文件确定造成内存溢出的代码块。</p><p>常见的内存溢出：流使用完后未关闭、Cursor 使用完后未关闭、短时间创建大量的大内存对象</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出&lt;/p&gt;
&lt;h2 id=&quot;内存抖动&quot;&gt;&lt;a href=&quot;#内存抖动&quot; class=&quot;headerlink&quot; title=&quot;内存抖动&quot;&gt;&lt;/a&gt;内存抖动&lt;/h2&gt;&lt;p&gt;在一定时间内，频繁的创建对象然后又回收，
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android学习导航</title>
    <link href="hexo/blog/2021/08/android%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA.html"/>
    <id>hexo/blog/2021/08/android学习导航.html</id>
    <published>2021-08-16T07:10:03.000Z</published>
    <updated>2021-08-16T07:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>android 学习思维导图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">JVM知识点 --&gt; A(内存问题)</span><br><span class="line">A --&gt; 内存抖动</span><br><span class="line">A --&gt; 内存泄漏</span><br><span class="line">A --&gt; 内存溢出</span><br><span class="line"></span><br><span class="line">JVM知识点 --&gt; B(JVM结构)</span><br><span class="line">B --&gt; JVM结构</span><br><span class="line">B --&gt; GC回收算法</span><br><span class="line">B --&gt; JMM内存模型</span><br><span class="line"></span><br><span class="line">JVM知识点 --&gt; C(四种引用类型)</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;android 学习思维导图&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android应用启动过程</title>
    <link href="hexo/blog/2021/07/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html"/>
    <id>hexo/blog/2021/07/android应用启动过程.html</id>
    <published>2021-07-06T06:40:17.000Z</published>
    <updated>2021-07-07T02:44:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>android 应用启动过程</p><p>首先，手机中的主页面、以及显示各个应用图标的页面本身就是一个 Activity<br>android 应用启动就是我们点击应用图标后的过程</p><p>以下以 API28 为例</p><p>应用启动涉及 L：三个进程、六个大类</p><p>三个进程：<br>Launcher 进程：整个 App 启动流程的起点，负责接收用户点击屏幕事件，它其实就是一个 Activity，里面实现了点击事件，长按事件，触摸等事件，可以这么理解，把 Launcher 想象成一个总的 Activity，屏幕上各种 App 的 Icon 就是这个 Activity 的 button，当点击 Icon 时，会从 Launcher 跳转到其他页面。</p><p>SystemServer 进程：这个进程在整个的 Android 进程中是非常重要的一个，地位和 Zygote 等同，它是属于 Application Framework 层的，Android 中的所有服务，例如 AMS, WindowsManager, PackageManagerService 等等都是由这个 SystemServer fork 出来的。</p><p>App 进程：你要启动的 App 所运行的进程。</p><p>六个大类：<br>ActivityManagerService：（AMS）AMS 是 Android 中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要，它本身也是一个 Binder 的实现类。</p><p>Instrumentation：监控应用程序和系统的交互。</p><p>ActivityThread：应用的入口类，通过调用 main 方法，开启消息循环队列。ActivityThread 所在的线程被称为主线程。</p><p>ApplicationThread：ApplicationThread 提供 Binder 通讯接口，AMS 则通过代理调用此 App 进程的本地方法。</p><p>ActivityManagerProxy：AMS 服务在当前进程的代理类，负责与 AMS 通信。</p><p>ApplicationThreadProxy：ApplicationThread 在 AMS 服务中的代理类，负责与 ApplicationThread 通信。</p><p><strong><em>可以说，启动的流程就是通过这六个大类在这三个进程之间不断通信的过程。</em></strong></p><h2 id="LauncherActivity"><a href="#LauncherActivity" class="headerlink" title="LauncherActivity"></a>LauncherActivity</h2><p>package android.app;</p><p>LauncherActivity 既是显示所有应用图标的系统页面<br>LauncherActivity 布局是一个 ListView</p><p>listView 的数据集就是 所有应用的数据集合，每个应用信息为 ListItem</p><h3 id="ListItem"><a href="#ListItem" class="headerlink" title="ListItem"></a>ListItem</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ResolveInfo resolveInfo;</span><br><span class="line">    <span class="keyword">public</span> CharSequence label;</span><br><span class="line">    <span class="keyword">public</span> Drawable icon; <span class="comment">// 图标</span></span><br><span class="line">    <span class="keyword">public</span> String packageName; <span class="comment">// 应用包名</span></span><br><span class="line">    <span class="keyword">public</span> String className; <span class="comment">// 启动Activity的类名</span></span><br><span class="line">    <span class="keyword">public</span> Bundle extras;</span><br><span class="line"></span><br><span class="line">    ListItem(PackageManager pm, ResolveInfo resolveInfo, IconResizer resizer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resolveInfo = resolveInfo;</span><br><span class="line">        label = resolveInfo.loadLabel(pm);</span><br><span class="line">        ComponentInfo ci = resolveInfo.activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (ci == <span class="keyword">null</span>) ci = resolveInfo.serviceInfo;</span><br><span class="line">        <span class="keyword">if</span> (label == <span class="keyword">null</span> &amp;&amp; ci != <span class="keyword">null</span>) &#123;</span><br><span class="line">            label = resolveInfo.activityInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resizer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            icon = resizer.createIconThumbnail(resolveInfo.loadIcon(pm));</span><br><span class="line">        &#125;</span><br><span class="line">        packageName = ci.applicationInfo.packageName;</span><br><span class="line">        className = ci.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ListView 涉及的所有信息信息是在 Adapter 的构造函数中获取的，<br>也就是说其实在启动 LauncherActivity 时，已经获取到所有应用信息</p><p>接下来查看 Item 的点击事件，即启动应用的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">    Intent intent = intentForPosition(position);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就会进入到 Activity 的 startActivity，最后会进入 Activity 的下列方法中：<br>requestCode: -1 options: null<br>是在系统页面开启另一个应用，所以 mParent = null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options = transferSpringboardActivityOptions(options);</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">                <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">                <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">                <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">                <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">                <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">                <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">                <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时会进入 Instrumentation.java 中的 execStartActivity 函数（7 个参数的）<br>然后又会调用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br></pre></td></tr></table></figure><p>又会调用到 ActivityManagerService 中的 startActivity<br>然后会调用到 ActivityManagerService 中的 startActivityAsUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">        <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">                .setCaller(caller)</span><br><span class="line">                .setCallingPackage(callingPackage)</span><br><span class="line">                .setResolvedType(resolvedType)</span><br><span class="line">                .setResultTo(resultTo)</span><br><span class="line">                .setResultWho(resultWho)</span><br><span class="line">                .setRequestCode(requestCode)</span><br><span class="line">                .setStartFlags(startFlags)</span><br><span class="line">                .setProfilerInfo(profilerInfo)</span><br><span class="line">                .setActivityOptions(bOptions)</span><br><span class="line">                .setMayWait(userId)</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处使用构建者模式，execute 执行的是 ActivityStarter.java 中的 execute 函数</p><p>而最终会调用到 1193 行的 startActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会执行 ActivityStackSupervisor 中的 resumeFocusedStackTopActivityLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又会执行到 ActivityStack 中的 resumeTopActivityUncheckedLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">    result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又会回到 ActivityStackSupervisor 中的 startSpecificActivityLocked 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                    || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                <span class="comment">// separate apk in the process.</span></span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会通过 AMS 获取进程信息，判断进程是否存在，<br>应用进程存在时会调用 realStartActivityLocked<br>应用进程不存在时会调用 AMS 中的 startProcessLocked 去开启新进程</p><p>暂时先看 应用进程不存在的情景：</p><p>AMS startProcessLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType, String hostingNameStr, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingType, hostingNameStr,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingNameStr, <span class="keyword">boolean</span> disableHiddenApiChecks, String abiOverride)</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">     <span class="keyword">return</span> startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                    startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,</span><br><span class="line">                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,</span><br><span class="line">                            requiredAbi, instructionSet, invokeWith, app.startTime);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ProcessStartResult <span class="title">startProcess</span><span class="params">(String hostingType, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">        <span class="keyword">final</span> ProcessStartResult startResult;</span><br><span class="line">        <span class="keyword">if</span> (hostingType.equals(<span class="string">"webview_service"</span>)) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith,</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用 Process 中 start 去开启进程<br>同时注意，此处会判断进程类型， webview</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后又会调用到 ZygoteStartFailedEx 中的 start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                zygoteArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Throw early if any of the arguments are malformed. This means we can</span></span><br><span class="line">        <span class="comment">// avoid writing a partial response to the zygote.</span></span><br><span class="line">        <span class="keyword">int</span> sz = args.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span></span><br><span class="line"><span class="comment">            * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">            * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">            * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * After the zygote process reads these it will write the pid of</span></span><br><span class="line"><span class="comment">            * the child or -1 on failure, followed by boolean to</span></span><br><span class="line"><span class="comment">            * indicate whether a wrapper process was used.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">        Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">        <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">        <span class="comment">// upon.</span></span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终执行 zygoteSendArgsAndGetResult 函数来完成进程的创建。<br>注意：<br>Android 中有一个重要的进程 Zygote，翻译为受精卵进程，所有的应用程序进程都是通过 Zygote 进程 fork 得来的。</p><p>简单来说就是通过 Binder 请求 AMS 进程，然后 AMS 再发送 Socket 消息给 Zygote 进程，最后统一由 Zygote 进程 fork 出应用进程。</p><p>当进程创建完成后，会执行 ActivityThread 中的 main 方法</p><p>在 ActivityThread 中就会启动 消息分发 、 Application 的创建、Activity 的创建</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;android 应用启动过程&lt;/p&gt;
&lt;p&gt;首先，手机中的主页面、以及显示各个应用图标的页面本身就是一个 Activity&lt;br&gt;android 应用启动就是我们点击应用图标后的过程&lt;/p&gt;
&lt;p&gt;以下以 API28 为例&lt;/p&gt;
&lt;p&gt;应用启动涉及 L：三个进程、六个大类
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>c++高级</title>
    <link href="hexo/blog/2021/05/c-%E9%AB%98%E7%BA%A7.html"/>
    <id>hexo/blog/2021/05/c-高级.html</id>
    <published>2021-05-06T10:04:46.000Z</published>
    <updated>2021-05-11T06:54:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-高级部分-STL-容器"><a href="#c-高级部分-STL-容器" class="headerlink" title="c++ 高级部分 STL 容器"></a>c++ 高级部分 STL 容器</h1><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。</p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p><h2 id="Vector-数组"><a href="#Vector-数组" class="headerlink" title="Vector 数组"></a>Vector 数组</h2><p>数组的特征：只能保存相同类型的数据、内存连续，数据具备索引，根据索引查找快，增、删慢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 标准模版库 容器学习1 Vector"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector1; <span class="comment">// 创建数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector2(<span class="number">8</span>); <span class="comment">// 创建8个容量的数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector3(<span class="number">10</span>, <span class="number">-1</span>); <span class="comment">// 创建10个容量的数组，且默认值都是 -1</span></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; vector3.size(); i ++) &#123;</span><br><span class="line">        <span class="comment">// 修改值</span></span><br><span class="line">        vector3[i] = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"i:"</span> &lt;&lt; i &lt;&lt; <span class="string">" value:"</span> &lt;&lt; vector3[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入值</span></span><br><span class="line">    <span class="comment">// 从头部插入</span></span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">40</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">30</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">20</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 从尾部插入</span></span><br><span class="line">    vector1.insert(vector1.end(), <span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = vector1.begin(); ite != vector1.end(); ite ++) &#123;</span><br><span class="line">        <span class="comment">// 迭代器获取的是地址</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器遍历"</span> &lt;&lt; *ite &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为vector2在构造函数中申明了容量为8，此时不能进行插入或者删除操作。会报错</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 22);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.end(), 33);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 22);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.end(), 33);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line">    <span class="comment">// 删除尾部</span></span><br><span class="line"><span class="comment">//    vector2.erase(vector2.end());</span></span><br><span class="line"><span class="comment">//    // 删除头部</span></span><br><span class="line"><span class="comment">//    vector2.erase(vector2.begin());</span></span><br><span class="line">    <span class="comment">//  迭代器自动推导类型 类似于kotlin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = vector2.begin(); iter != vector2.end(); iter++) &#123;</span><br><span class="line">        *iter = <span class="number">88</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"自动推导迭代器遍历"</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><p>栈的数据特点：先进后出、后进先出，类似于方法栈进栈、出栈<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL stack 栈的学习"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="comment">// 压栈</span></span><br><span class="line">    stack1.push(<span class="number">1</span>);</span><br><span class="line">    stack1.push(<span class="number">2</span>);</span><br><span class="line">    stack1.push(<span class="number">20</span>);</span><br><span class="line">    stack1.push(<span class="number">22</span>);</span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    stack1.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈顶元素:"</span> &lt;&lt; stack1.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 栈没有迭代器，也没有索引 这样遍历的话，会将栈内元素都弹出。</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历栈元素："</span> &lt;&lt; stack1.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>压栈、弹栈函数都是没有返回值的，<br>top函数获取栈顶元素</p><h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h2><p>队列的数据特点： FIFO 先进先出，后进后出。与栈不同<br>队列内部可以使用数组实现、也可以使用链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 三 队列queue学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(<span class="number">1</span>);</span><br><span class="line">    que.push(<span class="number">2</span>);</span><br><span class="line">    que.push(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列队头元素："</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列队尾元素"</span> &lt;&lt; que.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 队列也是没有迭代器的，只能采用与栈相同的方式遍历数据</span></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历 队列队头元素："</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列是队列的一个子集，内部数据结构通过数组实现，而且是数据有序排练，默认是降序。<br>不论数据push的顺序，直接给你降序处理，可以设置成升序排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 三 优先级队列priority_queue学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 默认是降序排列</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int&gt; que;</span></span><br><span class="line">    <span class="comment">// 设置成升序排列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;que;</span><br><span class="line">    </span><br><span class="line">    que.push(<span class="number">20</span>);</span><br><span class="line">    que.push(<span class="number">50</span>);</span><br><span class="line">    que.push(<span class="number">60</span>);</span><br><span class="line">    que.push(<span class="number">30</span>);</span><br><span class="line">    que.push(<span class="number">10</span>);</span><br><span class="line">    que.push(<span class="number">70</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历 优先级队列队头元素："</span> &lt;&lt; que.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h2><p>链表的数据特点，内存非连续，每个节点有下一个节点的指针，增删快，但查询慢，增加、删除都只能在表头操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 四 链表list学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; listArr;</span><br><span class="line">    <span class="comment">// push</span></span><br><span class="line">    listArr.push_front(<span class="number">11</span>); <span class="comment">// 从链头添加一个值</span></span><br><span class="line">    listArr.push_back(<span class="number">80</span>); <span class="comment">// 从链尾添加一个值</span></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    listArr.insert(listArr.end(), <span class="number">99</span>); <span class="comment">// 插入一个值到链尾</span></span><br><span class="line">    listArr.insert(listArr.end(), <span class="number">98</span>); <span class="comment">// 插入一个值到链尾</span></span><br><span class="line">    listArr.insert(listArr.begin(), <span class="number">20</span>); <span class="comment">// 插入一个值到链头</span></span><br><span class="line">    listArr.insert(listArr.begin(), <span class="number">22</span>); <span class="comment">// 插入一个值到链头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    listArr.erase(listArr.begin());</span><br><span class="line"><span class="comment">//    listArr.erase(listArr.end()); // 这一句在运行时报错，不知道为何</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表迭代器遍历："</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    listArr.clear();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"clear"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表迭代器遍历："</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-红黑树"><a href="#set-红黑树" class="headerlink" title="set 红黑树"></a>set 红黑树</h2><p>内部结构 红黑树 会对你存入的数据进行排序，但是绝对不允许元素相同</p><p>默认会升序排列，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 五 set 学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;setV;</span><br><span class="line">    <span class="comment">// 插入值</span></span><br><span class="line">    <span class="comment">// 默认会升序排列</span></span><br><span class="line">    setV.insert(<span class="number">80</span>);</span><br><span class="line">    setV.insert(<span class="number">70</span>);</span><br><span class="line">    setV.insert(<span class="number">50</span>);</span><br><span class="line">    setV.insert(<span class="number">90</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当插入已经存在的值时，会失败，因为不允许重复</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>, less&lt;<span class="keyword">int</span>&gt;&gt;::iterator, <span class="keyword">bool</span>&gt; result = setV.insert(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// 注意set的insert函数是有返回值的，first是迭代器 second是插入的结果</span></span><br><span class="line">    <span class="keyword">if</span>(result.second) &#123;</span><br><span class="line">        <span class="comment">// 插入成功</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 注意此处取得的迭代器不是从begin开始，而是从插入的值60处开始的。</span></span><br><span class="line">        <span class="keyword">for</span>(; result.first != setV.end(); result.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入结果迭代器遍历的值:"</span> &lt;&lt; * result.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = setV.begin(); it != setV.end(); it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器遍历的值:"</span> &lt;&lt; * it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>转自：<a href="https://www.cnblogs.com/xym4869/p/12250174.html" target="_blank" rel="noopener">https://www.cnblogs.com/xym4869/p/12250174.html</a></p><p>1.函数(function)谓词<br>通过传递函数名, 匹配二元谓词(binary predicates), 根据函数提供的策略, 输出值;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function Predicate*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLarger</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.size() &gt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), isLarger);</span><br></pre></td></tr></table></figure><p>2.函数指针(function pointer)谓词<br>建立一个函数指针, 传入算法, 使用指针代替函数名, 用法类似函数谓词.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s2);</span><br><span class="line">pf = &amp;isLarger;</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), *pf);</span><br></pre></td></tr></table></figure><p>3.Lambda表达式(lambda expression)谓词<br>Lambda表达式格式: [capture list] (parameter list) -&gt; return type { function body }<br>需要匹配谓词数, 一元(unary) 或 二元(binary), 也可以通过[capture list]传递函数的变量;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(),</span><br><span class="line">    [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s2)&#123; <span class="keyword">return</span> s1.size()&gt;s2.size(); &#125;);</span><br></pre></td></tr></table></figure><p>4.函数对象(Function Object)谓词<br>类中重载函数的调用”()”, 使类可以被调用, 并且传入算法谓词中, 进行使用.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function Object*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargerString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), LargerString());</span><br></pre></td></tr></table></figure><p>5、结构体谓词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doCompareAction2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Person&amp; __x, <span class="keyword">const</span> Person&amp; __y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.id &lt; __y.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;Person, doCompareAction2&gt; setVar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map: key value键值对容器，默认会对key进行排序，所以不能存在重复的key，会添加失败 value可以重复<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 六 map学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;mapVar;</span><br><span class="line">    <span class="comment">// 插入值 需要借助 std::pair</span></span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"justin"</span>));</span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">5</span>, <span class="string">"justinA"</span>));</span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"justin"</span>));</span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mapVar.begin(); it != mapVar.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; it-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取插入值的结果</span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">4</span>, <span class="string">"novia"</span>));</span><br><span class="line">    <span class="keyword">if</span>(result.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入值成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 因为有排序，只会遍历从4以及4以后的元素</span></span><br><span class="line">        <span class="keyword">for</span>(; result.first != mapVar.end(); result.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; result.first-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; result.first-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入值失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询 是根据key查询的</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator findResult = mapVar.find(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(findResult != mapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"已找到"</span> &lt;&lt; findResult -&gt; first &lt;&lt; <span class="string">", "</span> &lt;&lt; findResult-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找key失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>multimap 属于 map下的子集<br>// 1.key可以重复， 2.key重复的数据可以分组,  3.key会排序，  4.value不会排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 七 multimap学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;multimapVar;</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"justin"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"novia"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"justin"</span>));</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"justin"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"novia"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"coco"</span>));</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin1"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin2"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin3"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = multimapVar.begin(); it != multimapVar.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; it -&gt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO 核心功能是分组</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你要查询的key，为int类型:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iteratorVar = multimapVar.find(result);</span><br><span class="line">    <span class="keyword">while</span> (iteratorVar != multimapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iteratorVar-&gt;first &lt;&lt; <span class="string">","</span> &lt;&lt; iteratorVar-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 需要自己做逻辑控制，不然有问题</span></span><br><span class="line">        iteratorVar++;</span><br><span class="line">        <span class="keyword">if</span> (iteratorVar-&gt;first != result) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 严谨性</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorVar == multimapVar.end()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="防函数"><a href="#防函数" class="headerlink" title="防函数"></a>防函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForEach</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> _size() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"size："</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义防函数"</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义函数"</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"防函数学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    TestForEach forEach;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;setVar;</span><br><span class="line">    setVar.insert(<span class="number">10</span>);</span><br><span class="line">    setVar.insert(<span class="number">20</span>);</span><br><span class="line">    setVar.insert(<span class="number">500</span>);</span><br><span class="line">    setVar.insert(<span class="number">40</span>);</span><br><span class="line">    setVar.insert(<span class="number">30</span>);</span><br><span class="line">    setVar.insert(<span class="number">50</span>);</span><br><span class="line">    setVar.insert(<span class="number">60</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set 红黑树本身没有没有记录size，我们可以通过防函数记录</span></span><br><span class="line">    <span class="comment">// for_each是有返回值的，返回值是 防函数本身</span></span><br><span class="line">    for_each(setVar.begin(), setVar.end(), fake);</span><br><span class="line">    forEach = for_each(setVar.begin(), setVar.end(), forEach);</span><br><span class="line">    forEach._size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中有很多防函数的使用，其实我们自己可以手动实现一个防函数，并替换源码中的 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义加法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; x, <span class="keyword">const</span> T &amp; y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义实现算法"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用系统自带的加法</span></span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt;sum_int;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int相加"</span> &lt;&lt; sum_int(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    plus&lt;<span class="built_in">string</span>&gt;sum_str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符相加"</span> &lt;&lt; sum_str(<span class="string">"AAA"</span>,<span class="string">"BBB"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接下来自己实现加法</span></span><br><span class="line">    plus_d&lt;<span class="keyword">float</span>&gt;sum_flo;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义 float相加"</span> &lt;&lt; sum_flo(<span class="number">1.78f</span>, <span class="number">2.56f</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    plus_d&lt;<span class="built_in">string</span>&gt;sum_s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义 字符相加"</span> &lt;&lt; sum_s(<span class="string">"justin "</span>, <span class="string">"and novia"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模版函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模版 Params1 第一个参数类型 Params2 第二个参数类型 ReturnType 返回值类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Params1, <span class="keyword">typename</span> Params2, <span class="keyword">typename</span> ReturnType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Params1 first_argument_type; <span class="comment">// 第一个参数的别名</span></span><br><span class="line">    <span class="keyword">typedef</span> Params2 second_argument_type; <span class="comment">// 第二个参数的别名</span></span><br><span class="line">    <span class="keyword">typedef</span> ReturnType result_type; <span class="comment">// 返回值别名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-高级部分-STL-容器&quot;&gt;&lt;a href=&quot;#c-高级部分-STL-容器&quot; class=&quot;headerlink&quot; title=&quot;c++ 高级部分 STL 容器&quot;&gt;&lt;/a&gt;c++ 高级部分 STL 容器&lt;/h1&gt;&lt;p&gt;STL，英文全称 standard temp
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>c++基础 五</title>
    <link href="hexo/blog/2021/04/c-%E5%9F%BA%E7%A1%80-%E4%BA%94.html"/>
    <id>hexo/blog/2021/04/c-基础-五.html</id>
    <published>2021-04-26T09:25:50.000Z</published>
    <updated>2021-05-06T09:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-基础-五"><a href="#c-基础-五" class="headerlink" title="c++基础 五"></a>c++基础 五</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>与kotlin中一样，类的继承使用 : 表示。<br>不同的是，c++继承分为私有继承、公开继承，默认为私有继承</p><ul><li>1.默认是 隐式代码： : private Person</li><li>2.私有继承：在子类里面是可以访问父类的成员，但是在类的外面不行</li><li>3.必须公开继承，才可以访问父类的成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> Father &#123; <span class="comment">// 默认私有 private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19;// 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"son"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daugther</span> :</span> <span class="keyword">public</span> Father &#123; <span class="comment">// 公开继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19; // 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"dauther"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Son son;</span><br><span class="line">    son.setName();</span><br><span class="line"><span class="comment">//    son.name; //报错 'name' is a private member of 'Father'</span></span><br><span class="line">    Daugther daugther;</span><br><span class="line">    daugther.setName();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"daugther.name : "</span> &lt;&lt; daugther.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>子类不能访问父类的私有属性</li><li>子类直接继承为私有继承</li><li>私有继承的子类对象不能访问父类的属性，只能在类中访问</li><li>公开继承的子类对象可以访问父类的属性，在类中同样可以</li></ul><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><ul><li>C++ 是允许多继承的</li><li>Java语言不允许多继承，多继承有歧义，如果Java语言多继承 就会导致代码不健壮，（二义性）</li><li>Java多实现：做的非常棒，严格避免出现 二义性问题（歧义）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">raisChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother raisChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playWithChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother playWithChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father smoking"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playWithChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father playWithChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span> <span class="keyword">public</span> Mother, <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Son son;</span><br><span class="line">    <span class="comment">// 这个是优先寻找子类的函数，因为特别明确，没有问题，还没有产生歧义（二义性）</span></span><br><span class="line">    son.work();</span><br><span class="line">    son.play();</span><br><span class="line">    son.raisChild();</span><br><span class="line">    son.playWithChild(); <span class="comment">// 报错 Member 'playWithChild' found in multiple base classes of different types</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，Son类同时继承自Father、Mother类，这两个类有一些相同的函数work、play、playWithChild<br>但子类Son也实现了work、play时，执行这些函数不会报错，<br>但调用playWithChild则会报错，因为两个父类都有该函数、但子类未实现，此时就存在二义性问题。<br>解决这样的问题，存在两个办法：</p><ul><li>1、指定调用哪个父类的该函数 使用 ::父类.函数名<br><code>son.Father::playWithChild();</code></li><li>2、在子类也实现该函数<br>  在Son类中添加playWithChild函数。</li></ul><p>总结：</p><ul><li>1、c++可以多继承</li><li>2、多继承时，如果多个父类间存在同名同参函数，子类指针使用时，会存在二义性问题，需要子类也实现该函数，或者指定父类调用</li><li>3、真实开发时，一般时子类也会定义同名成员，覆盖掉多个父类同名成员。</li></ul><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>二义性问题出现在菱形继承。<br>关于二义性问题，还有一种解决办法，就是虚继承。<br>第三种解决方案： 【虚基类】 属于 虚继承的范畴<br>真实C++开始，是很少出现，二义性（歧义） 如果出现， 系统源码（系统用 第三种解决方案）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 祖父类</span><br><span class="line">class Object&#123;</span><br><span class="line">public:</span><br><span class="line">    int number;</span><br><span class="line">    void show() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Object show run...&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等下讲 virtual 的原理是什么 ...</span><br><span class="line"></span><br><span class="line">// 父类1</span><br><span class="line">class BaseActivity1 : virtual public Object &#123;</span><br><span class="line">// public:int number; // 人为制作二义性  error: request for member &apos;number&apos; is ambiguous</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 父类2</span><br><span class="line">class BaseActivity2 : virtual public Object &#123;</span><br><span class="line">// public:int number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Son : public BaseActivity1, public BaseActivity2 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;HELLO WORLD!!!!&quot; &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    Object object;</span><br><span class="line">    BaseActivity1 baseActivity1;</span><br><span class="line">    BaseActivity2 baseActivity2;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    object.number = 100;</span><br><span class="line">    baseActivity1.number = 200;</span><br><span class="line">    baseActivity2.number = 300;</span><br><span class="line">    son.number = 400;</span><br><span class="line"></span><br><span class="line">    object.show();</span><br><span class="line">    baseActivity1.show();</span><br><span class="line">    baseActivity2.show();</span><br><span class="line">    son.show();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; object.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; baseActivity1.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; baseActivity2.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; son.number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）</p><p>上面的例子中：Object就是虚基类，BaseActivity1、BaseActivity2都是虚继承于Object，然后Son都公开继承于BaseActivity1、BaseActivity2<br>在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>多态（虚函数）。   动态多态（程序的角度上：程序在运行期间才能确定调用哪个类的函数 == 动态多态的范畴）<br>Java语言默认支持多态<br>C++默认关闭多态，怎么开启多态？ 虚函数  在父类上给函数增加 virtual关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"BaseActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"MyActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onActivityStart</span><span class="params">(BaseActivity * baseActivity)</span> </span>&#123;</span><br><span class="line">    baseActivity-&gt;onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    HomeActivity * homeActivity = <span class="keyword">new</span> HomeActivity();</span><br><span class="line">    MyActivity * myActivity = <span class="keyword">new</span> MyActivity();</span><br><span class="line">    </span><br><span class="line">    onActivityStart(homeActivity);</span><br><span class="line">    onActivityStart(myActivity);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(myActivity &amp;&amp; homeActivity) &#123;</span><br><span class="line">        <span class="keyword">delete</span> homeActivity;</span><br><span class="line">        homeActivity = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> myActivity;</span><br><span class="line">        myActivity = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多态的定义 *<br>父类的引用指向之类的对象，同一个方法有不同的实现，重写（动态多态）和   重载(静态多态)</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载即为 静态多态<br>重载：函数名相同，但入参不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span> <span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    add(<span class="number">1.3f</span>, <span class="number">4.5f</span>);</span><br><span class="line">    add(<span class="number">1.45</span>, <span class="number">1.67</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>c++纯虚函数类似于java中的抽象类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutId)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"XmlResourceParser解析布局文件信息... 反射"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        setContentView(getLayoutId());</span><br><span class="line">        initData();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    virtual int getLayoutId(); // 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity initData"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity initView"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//  错误：抽象类型 BaseActivity 绝对不能实例化</span></span><br><span class="line">    <span class="comment">// BaseActivity ba; // 報錯 Variable type 'BaseActivity' is an abstract class</span></span><br><span class="line">    HomeActivity home;</span><br><span class="line">    home.onCreate();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意纯虚函数记得在函数后面写 = 0<br>如果不写 = 0 则会运行报错</p><h3 id="全纯虚函数"><a href="#全纯虚函数" class="headerlink" title="全纯虚函数"></a>全纯虚函数</h3><p>如果类中的函数都是虚函数，则这个类可以被成为全纯虚函数， 相当于java中的接口</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>与java中的函数回调类似<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> mobile;</span><br><span class="line">    </span><br><span class="line">    User(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> mobile): id(id), name(name), mobile(mobile)&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"用户名:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">" 用户id："</span> &lt;&lt; <span class="keyword">this</span>-&gt;id &lt;&lt; <span class="string">" 用户手机号:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;mobile  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILognResult</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(<span class="keyword">int</span> code, User user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, <span class="built_in">string</span> message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginAction</span><span class="params">(<span class="built_in">string</span> userName, <span class="built_in">string</span> password, ILognResult &amp; loginResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(userName.empty() || password.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"登录的账号与用户名都不能为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"justin"</span> == userName &amp;&amp; <span class="string">"123321qQ"</span> == password) &#123;</span><br><span class="line">        loginResult.success(<span class="number">200</span>, User(<span class="number">1121</span>, <span class="string">"justin"</span>, <span class="string">"13163396276"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loginResult.fail(<span class="number">404</span>, <span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginResultImpl</span> :</span> <span class="keyword">public</span> ILognResult &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">(<span class="keyword">int</span> code, User user)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"登录成功：userName:"</span> &lt;&lt; user.name &lt;&lt; <span class="string">" mobile: "</span> &lt;&lt; user.mobile  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, <span class="built_in">string</span> message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"登录失败：错误状态码:"</span> &lt;&lt; code &lt;&lt; <span class="string">" 错误信息: "</span> &lt;&lt; message  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入用户名"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; userName;</span><br><span class="line">    <span class="built_in">string</span> password;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入密码"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; password;</span><br><span class="line">    LoginResultImpl loginResult;</span><br><span class="line">    loginAction(userName, password, loginResult);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码就是一个登录操作的回调 其实是非常类似于 java中的接口回调的</p><h2 id="模版函数"><a href="#模版函数" class="headerlink" title="模版函数"></a>模版函数</h2><p>c++ 中没有范型概念，但是有模版函数，与java中的范型类似</p><p>像我们在之前的 静态多态中对于重载时的举例，加法<br>当我们针对不同的数据类型都需要进行一次重载，但当我们使用函数模版时，写一次即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"result:"</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> a = add(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">float</span> f = add(<span class="number">1.4f</span>, <span class="number">66.8f</span>);</span><br><span class="line">    <span class="keyword">double</span> d = add(<span class="number">3.6</span>, <span class="number">88.99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"f:"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"d:"</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，使用模版函数完成了各个类型的加法计算，使用也与java中的范型及其类似</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-基础-五&quot;&gt;&lt;a href=&quot;#c-基础-五&quot; class=&quot;headerlink&quot; title=&quot;c++基础 五&quot;&gt;&lt;/a&gt;c++基础 五&lt;/h1&gt;&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
</feed>
