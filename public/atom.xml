<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2022-02-18T02:44:38.623Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jetpack-ViewModel</title>
    <link href="hexo/blog/2022/02/jetpack-ViewModel.html"/>
    <id>hexo/blog/2022/02/jetpack-ViewModel.html</id>
    <published>2022-02-08T07:08:05.000Z</published>
    <updated>2022-02-18T02:44:38.623Z</updated>
    
    <content type="html"><![CDATA[<p>参考 android developer 中的文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>当 ViewModel 构造函数为有参构造函数时，使用 private val model : OverTimeViewModel by activityViewModels() 会报错<br>此时处理方案为新建一个Factory类<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> dataSource: OverTimeDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span>(modelClass.isAssignableFrom(OverTimeViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OverTimeViewModel(dataSource) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在写一个静态类，作为Factory作为Provider</span></span><br><span class="line"><span class="keyword">object</span> Injection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideUserDataSource</span><span class="params">(context: <span class="type">Context</span>)</span></span>: OverTimeDao &#123;</span><br><span class="line">        <span class="keyword">val</span> database = AppDatabase.getInstance(context)</span><br><span class="line">        <span class="keyword">return</span> database.overTimeDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideViewModelFactory</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ViewModelFactory &#123;</span><br><span class="line">        <span class="keyword">val</span> dataSource = provideUserDataSource(context)</span><br><span class="line">        <span class="keyword">return</span> ViewModelFactory(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModelFactory: ViewModelFactory</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> model : OverTimeViewModel <span class="keyword">by</span> activityViewModels&#123; viewModelFactory &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定的生命函数中实例化ViewModelFactory</span></span><br><span class="line">viewModelFactory = Injection.provideViewModelFactory(activity!!)</span><br></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 android developer 中的文档：&lt;a href=&quot;https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager2</title>
    <link href="hexo/blog/2022/02/ViewPager2.html"/>
    <id>hexo/blog/2022/02/ViewPager2.html</id>
    <published>2022-02-07T07:59:48.000Z</published>
    <updated>2022-02-07T09:29:32.770Z</updated>
    
    <content type="html"><![CDATA[<p>参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2</a></p><p>需要对比 ViewPager2 与 ViewPager 的差异、优劣</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deve
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack-Navigation</title>
    <link href="hexo/blog/2022/02/jetpack-Navigation.html"/>
    <id>hexo/blog/2022/02/jetpack-Navigation.html</id>
    <published>2022-02-07T07:56:06.000Z</published>
    <updated>2022-02-07T07:57:55.570Z</updated>
    
    <content type="html"><![CDATA[<p>具体参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-getting-started</a></p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>Navigation 其实是对 Fragment 跳转的管理，而不是 Activity，需要配置到某个 Activity 中。<br>其实是单 Activity 模式</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体参考指南地址：&lt;a href=&quot;https://developer.android.google.cn/guide/navigation/navigation-getting-started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:/
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jetpack Room</title>
    <link href="hexo/blog/2021/12/jetpack-Room.html"/>
    <id>hexo/blog/2021/12/jetpack-Room.html</id>
    <published>2021-12-22T10:44:10.000Z</published>
    <updated>2022-02-08T07:07:21.500Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用 Room 将数据保存到本地数据库</strong></p><p>Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。</p><p>处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的用例是缓存相关数据。这样，当设备无法访问网络时，用户仍可在离线状态下浏览相应内容。设备重新连接到网络后，用户发起的所有内容更改都会同步到服务器。</p><p>由于 Room 负责为您处理这些问题，因此我们强烈建议您使用 Room（而不是 SQLite）。不过，如果您想直接使用 SQLite API，请参阅使用 SQLite 保存数据。</p><p>如需在应用中使用 Room，请将以下依赖项添加到应用的 build.gradle 文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.3.0"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava3 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava3:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers</span></span><br><span class="line">    testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Paging 3 Integration</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-paging:2.4.0-rc01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常情况记录"><a href="#异常情况记录" class="headerlink" title="异常情况记录"></a>异常情况记录</h2><ul><li>Room AppDatabase_Impl does not exist</li></ul><p>使用了 kotlin 构建了项目,并且使用 kotlin 编写 room 创建数据库,在 build.gradle 文件里做如下修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &apos;com.android.library&apos;</span><br><span class="line">    id &apos;kotlin-android&apos;</span><br><span class="line">    id &apos;kotlin-android-extensions&apos;</span><br><span class="line">    id &apos;kotlin-kapt&apos;</span><br><span class="line">&#125;</span><br><span class="line">//略...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    api&quot;android.arch.persistence.room:runtime:$rootProject.room_version&quot;</span><br><span class="line">    kapt&quot;android.arch.persistence.room:compiler:$rootProject.room_version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 annotationProcessor 替换成 kapt,请注意需要导入 id ‘kotlin-kapt’ 才能使用 kapt</p><p>参考地址：<a href="https://www.cnblogs.com/guanxinjing/p/14990401.html" target="_blank" rel="noopener">https://www.cnblogs.com/guanxinjing/p/14990401.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用 Room 将数据保存到本地数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。&lt;/p&gt;
&lt;p&gt;处理大量结构化数据的应用可极大地受益于在本地保留这些
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack DataSource</title>
    <link href="hexo/blog/2021/12/jetpack-DataSource.html"/>
    <id>hexo/blog/2021/12/jetpack-DataSource.html</id>
    <published>2021-12-22T10:29:42.000Z</published>
    <updated>2021-12-22T10:31:01.001Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。</p><p>DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。</p><ul><li>Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。</li><li>Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。&lt;/p&gt;
&lt;p&gt;DataStore 提供两种不同的实现：Preferences 
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>jetpack lifecycle</title>
    <link href="hexo/blog/2021/12/jetpack-lifecycle.html"/>
    <id>hexo/blog/2021/12/jetpack-lifecycle.html</id>
    <published>2021-12-22T03:08:25.000Z</published>
    <updated>2021-12-22T03:46:23.456Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 库中用来感知生命周期的组件</p><h2 id="使用生命周期感知型组件处理生命周期"><a href="#使用生命周期感知型组件处理生命周期" class="headerlink" title="使用生命周期感知型组件处理生命周期"></a>使用生命周期感知型组件处理生命周期</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。</p><p>一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。</p><p>androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p><p>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p><p><strong>事件</strong><br>从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。<br><strong>状态</strong><br>由 Lifecycle 对象跟踪的组件的当前状态</p><p><img src="../../../images/lifecycle.svg" style="zoom:60%"></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MainLifecycleObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainLifecycleObserver</span></span>() : LifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> TAG: String  = <span class="string">"MainLifecycleObserver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityCreated: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityResume: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityStopped: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，就可以實現在 Activity 之外獲取到生命週期的變化，避免在 Activity/Fragment 中的生命週期中寫大量業務代碼</p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>LifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。</p><p>此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。</p><p>实现 DefaultLifecycleObserver 的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p><h3 id="自定義-LifecycleOwner"><a href="#自定義-LifecycleOwner" class="headerlink" title="自定義 LifecycleOwner"></a>自定義 LifecycleOwner</h3><p>我們不只是可以綁定視圖的生命週期，可以通過 LifecycleOwner 自定義對應色生命週期<br>如當處於 Activity 的 onCreate、onStart 中都需執行 onStart</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), LifecycleOwner &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LifeCycle 组件实际上并没有带来什么新的功能，他通过观察者模式+注解来让我们更方便的监听 Activity 和 Fragment 的生命周期变化。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle 是 Jetpack 库中用来感知生命周期的组件&lt;/p&gt;
&lt;h2 id=&quot;使用生命周期感知型组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知型组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知型组件处理生命周期
      
    
    </summary>
    
    
      <category term="Jetpack" scheme="hexo/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>kotlin学习指南一</title>
    <link href="hexo/blog/2021/12/kotlin%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80.html"/>
    <id>hexo/blog/2021/12/kotlin学习指南一.html</id>
    <published>2021-12-20T06:22:11.000Z</published>
    <updated>2021-12-22T00:56:49.471Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin 是 google 推出的一門新語言，也是基於 JVM 的。</p><h2 id="kotlin-基础"><a href="#kotlin-基础" class="headerlink" title="kotlin 基础"></a>kotlin 基础</h2><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>新建一个 kt 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主入口 main 方法， 无需新建类即可运行，函数声明用 fun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int, b:Int):Int&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值写在参数之后</p><p>表达式可以作为函数体，返回值类型自动推断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sun(a:Int, b:Int) = a+b;</span><br></pre></td></tr></table></figure><p>返回无意义的值用 Unit 表示</p><p>fun test():Unit {<br>println(“test”);<br>}</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>变量赋值声明关键字：var、val<br>var：声明变量<br>val：声明常量</p><p>var i:Int = 1;<br>val PI:Double = 3.14;</p><p>当声明并赋值时，数据类型可以省略, 会自动推断数据类型<br>var i = 1;<br>val PI = 3.14</p><p>当声明但不赋值时，不能省略数据类型<br>var i:Int;<br>val PI:Double;</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;aaaaa&quot;;</span><br><span class="line">var b = &quot;str = $s&quot;;</span><br><span class="line">var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testIf(a:Int, b:Int):Int &#123;</span><br><span class="line">    if(a &gt; b) return a;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kotlin 中，if 还可以用作表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun max(a:Int, b:Int) = if(a &gt; b) a else b</span><br></pre></td></tr></table></figure><h2 id="空值与-null-检测"><a href="#空值与-null-检测" class="headerlink" title="空值与 null 检测"></a>空值与 null 检测</h2><p>当某个值可以为空时，需要在类型后添加?表示可以为空<br>此时，声明时不能省略类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj:Objects ? = null;</span><br><span class="line">// 表示返回值可以为null</span><br><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型检测与自动类型转换"><a href="#类型检测与自动类型转换" class="headerlink" title="类型检测与自动类型转换"></a>类型检测与自动类型转换</h2><p>is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 </strong></p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);</span><br><span class="line">// 根据元素遍历</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据下标便利</span><br><span class="line">for (item in items.indices) &#123;</span><br><span class="line">    println(items[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = 0;</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(items[index]);</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when-表达式"><a href="#when-表达式" class="headerlink" title="when 表达式"></a>when 表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private fun testWhen(s: Any?) &#123;</span><br><span class="line">        when(s) &#123;</span><br><span class="line">            &quot;a&quot; -&gt; 1;</span><br><span class="line">            &quot;b&quot; -&gt; 2;</span><br><span class="line">            is String -&gt; 3;</span><br><span class="line">            1 -&gt; &quot;n&quot;;</span><br><span class="line">            2 -&gt; &#123;</span><br><span class="line">              println(&quot;222&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            else -&gt; &quot;else&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有点类似 java 中的 switch</p><h2 id="区间-range"><a href="#区间-range" class="headerlink" title="区间 range"></a>区间 range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = 9;</span><br><span class="line">if(x in 0..y) &#123;</span><br><span class="line">    println(&quot;x in 0 - y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间只用于数字</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的迭代可以用的上面的 for in 循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">for(item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断集合中是否包含某元素 用 while in || when</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (&quot;a&quot; in items) &#123;</span><br><span class="line">    println(&quot;items include a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when &#123;</span><br><span class="line">    &quot;a&quot; in items -&gt; println(&quot;aaa&quot;);</span><br><span class="line">    &quot;d&quot; in items -&gt; println(&quot;ddd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 lambda 来过滤和映射集合 ，与 java8 lambda stream 大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125;</span><br><span class="line">    .sortBy&#123; it &#125;</span><br><span class="line">    .map&#123; it.toUpperCase() &#125;</span><br><span class="line">    .forEach&#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>什么是协程？<br>官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。<br>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</p><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。<br>CPU 调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。<br>而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p><p>协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。</p><p>build.gralde 中引入依赖<br>implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1”</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity4 : AppCompatActivity() &#123;</span><br><span class="line">    val TAG = &quot;MainActivity4&quot;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main2)</span><br><span class="line">        test()</span><br><span class="line">        Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun test() = runBlocking &#123;</span><br><span class="line">        repeat(8) &#123;</span><br><span class="line">            Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>协程执行 0 线程 id：1<br>协程执行 1 线程 id：1<br>协程执行 2 线程 id：1<br>协程执行 3 线程 id：1<br>协程执行 4 线程 id：1<br>协程执行 5 线程 id：1<br>协程执行 6 线程 id：1<br>协程执行 7 线程 id：1<br>线程 main ：1</p><p>我们可以得出结论：<br>runBlocking 会阻塞线程，但允许还是在当前线程</p><h3 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch:Job"></a>launch:Job</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testJob() &#123;</span><br><span class="line">        val job = GlobalScope.launch &#123;</span><br><span class="line">            repeat(8) &#123;</span><br><span class="line">                delay(2000)</span><br><span class="line">                Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>testJob: 线程 main：2<br>testJob: 线程 id:6809<br>testJob: 线程 id:6807<br>testJob: 线程 id:6807<br>testJob: 线程 id:6815<br>testJob: 线程 id:6807<br>testJob: 线程 id:6808<br>testJob: 线程 id:6818<br>testJob: 线程 id:6809</p><p>说明使用 GlobalScope.launch</p><ul><li>并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务</li><li>是非阻塞、异步执行，相当于开启了子线程</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun testAsync()&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        var result1 = GlobalScope.async &#123;</span><br><span class="line">            getResult1()</span><br><span class="line">        &#125;</span><br><span class="line">        var result2 = GlobalScope.async &#123;</span><br><span class="line">            getResult2()</span><br><span class="line">        &#125;</span><br><span class="line">        val result = result1.await() + result2.await()</span><br><span class="line">        Log.e(TAG, &quot;testAsync: ThreadId =  $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult1():Int &#123;</span><br><span class="line">    delay(3000)</span><br><span class="line">    Log.e(TAG, &quot;getResult1: ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult2():Int &#123;</span><br><span class="line">    delay(5000)</span><br><span class="line">    Log.e(TAG, &quot;getResult2:  ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>E/MainActivity4: 线程 main ：2<br>E/MainActivity4: getResult1: ThreadId = 7870<br>E/MainActivity4: getResult2: ThreadId = 7870<br>E/MainActivity4: testAsync: ThreadId = 7870 result = 9</p><p>其中当打印 getResult2 后就打印了 testAsync: result = 9<br>阻塞时间为 5 秒，而不是 8 秒，说明 getResult1、getResult2 是并行的。</p><p>而且发现 threadId 都一样，说明处于同一个线程。<br>但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。</p><ul><li>协程并不等于线程，协程内部会根据任务情况自动调度线程。</li></ul><p>launch()有三个入参： 1.协程下上文；2.协程启动模式；3.协程体：block 是一个带接收者的函数字面量，接收者是 CoroutineScope</p><p>我们在线程中执行的代码就是第三个参数</p><h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>上下文可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，Kotlin 协程使用调度器来确定哪些线程用于协程执行，Kotlin 提供了调度器给我们使用：</p><p>Dispatchers.Main：使用这个调度器在 Android 主线程上运行一个协程。可以用来更新 UI 。在 UI 线程中执行</p><p>Dispatchers.IO：这个调度器被优化在主线程之外执行磁盘或网络 I/O。在线程池中执行</p><p>Dispatchers.Default：这个调度器经过优化，可以在主线程之外执行 cpu 密集型的工作。例如对列表进行排序和解析 JSON。在线程池中执行。</p><p>Dispatchers.Unconfined：在调用的线程直接执行。</p><p>调度器实现了 CoroutineContext 接口。</p><p>我们还可以自己自定义调度器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dis = Executors.newCachedThreadPool().asCoroutineDispatcher()</span><br><span class="line">runBlocking &#123;</span><br><span class="line">    launch(dis) &#123;</span><br><span class="line">        println(&quot;dis 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>在 Kotlin 协程当中，启动模式定义在一个枚举类中：</p><p>public enum class CoroutineStart {<br>DEFAULT,<br>LAZY,<br>@ExperimentalCoroutinesApi<br>ATOMIC,<br>@ExperimentalCoroutinesApi<br>UNDISPATCHED;<br>}<br>一共定义了 4 种启动模式，<br>DEFAULT: 默认的模式，立即执行协程体<br>LAZY: 只有在需要的情况下运行<br>ATOMIC: 立即执行协程体，但在开始运行之前无法取消<br>UNDISPATCHED :立即在当前线程执行协程体，直到第一个 suspend 调用</p><h3 id="协程体"><a href="#协程体" class="headerlink" title="协程体"></a>协程体</h3><p>协程体是一个用 suspend 关键字修饰的一个无参，无返回值的函数类型。被 suspend 修饰的函数称为挂起函数,与之对应的是关键字 resume（恢复）<br>注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>Kotlin 的硬关键宇包括:</p><p>as 一一 用于做类型转换或为 import 语句指定别名<br>as?一一类型安全 的类型转换运算符。<br>break 一一中断循环<br>class 一一声明类。<br>continue 一忽略本次循环剩下的语句，重新开始下一次循环。<br>do 一一用于 do while 循环<br>else 一一在 if 分支中使用<br>false 一一在 Boolean 类型中表示假 的直接量。<br>for 一一用于 for 循环<br>fun 一一声 明函数<br>if－在 if 分支中使用<br>in 一一在 for 循环中使用； in 还可作为双目运算符，检查 一个值是否处于区间或集合 内；<br>in 也可 在 when 表达式中使用； in 还可用于修饰泛型参数，表明该泛型参数支持逆变<br>!in 一一可作为双目运算符 的反义词：！in 也可在 when 表达式中使用<br>is 一一用于做类型检查（类 Java instanceof) 或在 when 表达式中使用<br>!is 一一 用于做类型检查（ is 的反义词〉或在 when 表达式中使用<br>null 一一 代表空的直接量。<br>object ——用于声明对象表达式或定义命名对象<br>package 一一用于为当 前文件指定包<br>return 一一声明函数的返回<br>super 一－用于引用父类实现的方法或属性，或者在子类构造器中调用父类构造器<br>this 一一 代表当前类的对象或在构造器中调用当前类的其他构造器<br>throw 一一用于抛出异常<br>true 一一在 Boolean 类型中表示真的直接量。<br>try 一一开始异常处理<br>typealias 一一用于定义类型别名。<br>val 一声明只读属性或变量。<br>var 一一声明可变属性或变量。<br>when 一一用于 when 表达式。while 一一－用于 while 循环或 do while 循环</p><p>Kotlin 的软关键宇包括：</p><p>by 一一用于将接口或祖先类的实现代理给其他对象。<br>catch 一一在异常处理中用于捕捉异常<br>constructor 一一用于声明构造器。<br>delegate 一用于指定该注解修饰委托属性存储其委托实例的字段<br>dynamic 一一主要用于在 Kotlin/JavaScript 中引用 一个动态类型<br>field 一一用于指定该注解修饰属性的幕后字段。<br>file 一一用于指定该注解修饰该源文件本身<br>finally 一一异常处理中的 finally<br>get 一一用于声明属性的 getter 方法，或者用于指定该注解修饰属性的 getter 方法<br>import 一一用于导包。<br>init 一一用于声明初始化块<br>param 一一用于指定该注解修饰构造器参数<br>property 一一用于指定该注解修饰整个属性（这种目标的注解对 Java 不可见，因为 Java<br>并没有真正的属性）。<br>receiveris 一一用于指定该注解修饰扩展方法或扩展属性的接收者<br>set 一一用于声明属性的 setter 方法，或者用于指定该注解修饰属性的 setter 方法<br>setparam 一一用于指定该注解修饰 setter 方法的参数<br>where 一一用于为泛型参数增加限制。</p><p>Kotlin 的修饰符关键宇包括：</p><p>abstract 一一用于修饰抽象类或抽象成员<br>annotation 一一用于修饰一个注解类。<br>companion 一一用于声明一个伴生对象<br>const 一一用于声明编译时常量<br>crossinline 一一用于禁止在传给内联函数的 Lambd 表达式中执行非局部返回<br>data 一一用于声明数据类。<br>enum 一一用于声明枚举<br>external 一一用于声明某个方法不由 Kotlin 实现（与 Java 的 native 相似〉。<br>final 一一用于禁止被重写<br>infix 一一声明该函数能以双目运算符的格式执行<br>inline 一一用于声明内联函数， Lambda 表达式可在内联函数中执行局部返回。<br>inner 一一用于声明内部类，内部类可以访问外部类的实例<br>internal 一一用于表示被修饰的声明只能在当前模块内可见<br>lateinit——-用于修饰 non-null 属性，用于指定该属性可在构造器以外的地方<br>初始化<br>noinline 一一用于禁止内联函数中个别 Lambda 表达式被内联化<br>open 一一用于修饰类，表示该类可派生子类；或者用于修饰成员，表示该成员可以被<br>重写。<br>out 一一用于修饰泛型参数，表明该泛型参数支持协变。<br>override 一一用于声明重写父类的成员<br>private ——private 访问权限<br>protected ——–protected 访问权限<br>public——-public 访问权限。<br>reified 一一用于修饰内联函数中的泛型形参，接下来在该函数中就可像使用普通类型<br>一样使用该类型参数。<br>sealed 一一用于声明一个密封类。<br>suspend 一一用于标识一个函数后 Lambda 表达式可作为暂停。<br>tailrec 一一用于修饰一个函数可作为尾随递归函数使用。<br>vararg 一一用于修饰形参，表明该参数是个数可变的形参。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;kotlin 是 google 推出的一門新語言，也是基於 JVM 的。&lt;/p&gt;
&lt;h2 id=&quot;kotlin-基础&quot;&gt;&lt;a href=&quot;#kotlin-基础&quot; class=&quot;headerlink&quot; title=&quot;kotlin 基础&quot;&gt;&lt;/a&gt;kotlin 基础&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="kotlin" scheme="hexo/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/12/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html"/>
    <id>hexo/blog/2021/12/常用的排序方法.html</id>
    <published>2021-12-08T08:16:22.990Z</published>
    <updated>2021-12-08T08:16:22.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重for循环，当前元素与下一个元素对比，将较大值放于右侧，<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//选择排序算法   </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length-<span class="number">1</span> ;i++ )&#123;   </span><br><span class="line">        <span class="keyword">int</span> min=i;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;args.length ;j++ )&#123;   </span><br><span class="line">            <span class="keyword">if</span> (args[min]&gt;args[j])&#123;   </span><br><span class="line">                min=j;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> (min!=i)&#123;  </span><br><span class="line">            <span class="keyword">int</span> temp=args[i];  </span><br><span class="line">            args[i]=args[min];  </span><br><span class="line">            args[min]=temp;          </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> args;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重for循环，取出最小值或者最大值，交互数组位置，使最值位于数组两侧，最后得出一个升序/降序数组<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//插入排序算法   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;args.length;i++)&#123;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;   </span><br><span class="line">            <span class="keyword">if</span> (args[j]&lt;args[j-<span class="number">1</span>])&#123;   </span><br><span class="line">                <span class="keyword">int</span> temp=args[j-<span class="number">1</span>];  </span><br><span class="line">                args[j-<span class="number">1</span>]=args[j];  </span><br><span class="line">                args[j]=temp;          </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> args;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>使用系统自带的排序方法 sorts<br>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的遍历一般根据节点可分为三种：前序、中序、后序遍历<br>根据树的层级又有层级遍历</p><p>下面的代码就是一个树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Node left;</span><br><span class="line"><span class="keyword">private</span> Node right;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node[ no = "</span> + no + <span class="string">", name ="</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>先取父节点，再取左节点，再去右节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>先取左节点，再取父节点，再去右节点<br>中序遍历可以得出一个升序结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LDR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>先取左节点，再取右节点，再去父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LRD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/12/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB.html"/>
    <id>hexo/blog/2021/12/java数据类型汇总.html</id>
    <published>2021-12-08T08:16:22.989Z</published>
    <updated>2021-12-08T08:16:22.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>再java中，数据类型可分为两种：集合（Collection）、图（Map）<br>而这两大类中又可以细分，常用的子类为：<br>ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap</p><h2 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h2><p>集合可以细分为三类：List、Set、Queue</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口扩展自Collection，它可以定义一个允许重复的有序集合</p><p>List中常用的子类有：ArrayList、LinkerList、CopyOnWriteArrayList</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList内部的数据结构为数组，当增加元素数量大于初始容量，会触发扩容，即新建一个之前容量两位的数组，并将之前的元素拷贝过来。<br>查询快，增删慢<br><strong><em>非线程安全</em></strong></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList内部的数据结构为链表，双向链表。<br>查询慢，增删快<br><strong><em>非线程安全</em></strong></p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。<br><strong><em>线程安全，通过ReentrantLock实现</em></strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。<br>Set接口有三个具体实现类：散列集HashSet、链式散列集LinkedHashSet、树形集TreeSet</p><p>Set判断是否重复的原理是，先判断Hash，如果Hash相同再判断equals</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>散列集HashSet是一个用于实现Set接口的具体类，<br>有两个名词需要关注，初始容量和客座率。<br>客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，就会触发扩容。</p><p><strong><em>非线程安全</em></strong></p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>内部数据是链表，是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序<br>HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。<br><strong><em>非线程安全</em></strong></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>内部数据结构为树，<br>扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。<br><strong><em>非线程安全</em></strong></p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>数据结构为队列，特点是先进先出，后进后出<br>而关于队列的实现又有多个：优先级队列、异步队列、同步队列、阻塞队列等。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map中常用的子类有: HashMap、HashTable、LinkedHashMap、TreeMap、ConcurrentHashMap</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap在jdk1.8时发生了变更<br>在JDK1.7及以前的版本中：内部数据结构为：数组+链表，并且链表插入数据的方式为 头插法<br>在jdk1.8以及之后的版本中：内部的数据结构为：数组+链表+红黑树，并且链表插入数据的方式为 尾插法</p><p>数据存放方式为 key value，一一对应，key不允许重复<br>大致原理：根据key得出hash值，根据hash值对数组长度取模得出存放数组的下标，每个数组下标对于的为一个链表，将数据放入到链表，当链表长度大于阈值时，则链表转换为红黑树，红黑树节点数减少小于阈值时，则又转换回链表<br>取值大致过程相同：根据key获取hash，然后得出下标，然后再去链表或者红黑树中根据key对比取值</p><p><strong><em>非线程安全</em></strong></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，<br>HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，<br>也可以按它们最后一次被访问的顺序排<br><strong><em>非线程安全</em></strong></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。<br><strong><em>非线程安全</em></strong></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 是并发包concurrent下针对HashMap的一种实现，线程安全<br>同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高</p><p><strong><em>线程安全</em></strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;再java中，数据类型可分为两种：集合（Collection）、图（Map）&lt;br&gt;而这两大类中又可以细分，常用的子类为：&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="hexo/blog/2021/12/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html"/>
    <id>hexo/blog/2021/12/NDK-C-基础-四.html</id>
    <published>2021-12-08T08:16:22.988Z</published>
    <updated>2021-12-08T08:16:22.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>在之前讲过的拷贝构造函数，其实就是一种 浅拷贝<br>但是在浅拷贝中，无法拷贝堆内存中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Student1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student1() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student1(char * name) :Student1(name, 99) &#123; cout &lt;&lt; &quot;一个入参 构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    Student1(char * name, int age) &#123; </span><br><span class="line">cout &lt;&lt; &quot;两个入参构造函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">this-&gt;name = (char *) malloc(sizeof(char * ) * 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line"></span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student1() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上所示，Student 类中，在构造函数中，name 是动态开辟在堆内存上的，在析构函数中，会使用free释放 name 在堆内存的内存空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line">Student1 s1;</span><br><span class="line">Student1 s2 = s1; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行完上述代码时，会运行异常，<br>Student1 s2 = s1;  会执行 拷贝构造函数，将 s2 的值都复制给 s1<br>但是之前说过 <em> 拷贝构造函数是 浅拷贝 </em><br>浅拷贝 是不会拷贝堆内存中的数据的， 所以其实 s2 与 s1 中的 name 指向的同一块堆内存空间，<br>当main函数执行完毕，出栈时，会调用 s2、s1的析构函数，当指向s1的析构函数时，会释放 name 中的堆内存空间。<br>等到执行 s2 的析构函数时，又会执行 free(this-&gt;name); 但此时 this-&gt;name已经是一块指向NULL的指针了，此时就会抛出异常。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>上面讲了深拷贝与浅拷贝的区别，以及默认的拷贝构造函数是一次浅拷贝，接下来手动实现一下 深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student(char * name) :Student(name, 99) &#123;</span><br><span class="line">cout &lt;&lt; &quot;一个参数构造函数 this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(char * name, int age) &#123;</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数 &amp;this-&gt;name:&quot; &lt;&lt; (int)this-&gt;name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(const Student &amp; stu) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;stu的地址 &amp;stu:&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot; this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">// 重新开辟一个堆内存存放新的 stu对象中的 name</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">        // 复制name中的值</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = stu.age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void showStudent(Student stu) &#123;</span><br><span class="line">cout &lt;&lt; &quot;showStudent的内存地址&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot;  &quot; &lt;&lt; stu.name &lt;&lt; &quot;,&quot; &lt;&lt; stu.age&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">Student stu(&quot;justin&quot;, 31);</span><br><span class="line"></span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，在函数 showStudent 中会调用拷贝构造函数 然后执行完毕出栈，调用 析构函数，<br>但上述代码不会出现异常，因为在我们自定义的拷贝构造函数中，我们手动实现了堆内存的拷贝。并每次执行析构函数时，又会释放掉name的堆内存。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅拷贝与深拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝与深拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝与深拷贝&quot;&gt;&lt;/a&gt;浅拷贝与深拷贝&lt;/h2&gt;&lt;p&gt;浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java 类加载机制</title>
    <link href="hexo/blog/2021/11/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
    <id>hexo/blog/2021/11/java-类加载机制.html</id>
    <published>2021-11-01T10:14:26.000Z</published>
    <updated>2021-11-03T10:16:55.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul><li><p>了解 java 类加载机制</p></li><li><p>理解类加载器 ClassLoader</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载&quot;&gt;&lt;a href=&quot;#类加载&quot; class=&quot;headerlink&quot; title=&quot;类加载&quot;&gt;&lt;/a&gt;类加载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;了解 java 类加载机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;理解类加载器 ClassLoader&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="hexo/blog/2021/10/%E5%8F%8D%E5%B0%84.html"/>
    <id>hexo/blog/2021/10/反射.html</id>
    <published>2021-10-25T07:01:37.000Z</published>
    <updated>2021-11-01T10:12:40.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 *</li></ul><p>类名 用途<br>Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口<br>Field 类 代表类的成员变量（成员变量也称为类的属性）<br>Method 类 代表类的方法<br>Constructor 类 代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法 用途<br>asSubclass(Class<u> clazz) 把传递的类的对象转换成代表其子类的对象<br>Cast 把对象转换成代表类或是接口的对象<br>getClassLoader() 获得类的加载器<br>getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className) 根据类名返回类的对象<br>getName() 获得类的完整路径名字<br>newInstance() 创建类的实例<br>getPackage() 获得类的包<br>getSimpleName() 获得类的名字<br>getSuperclass() 获得当前类继承的父类的名字<br>getInterfaces() 获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法 用途<br>getField(String name) 获得某个公有的属性对象<br>getFields() 获得所有公有的属性对象<br>getDeclaredField(String name) 获得某个属性对象<br>getDeclaredFields() 获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法 用途<br>getAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的公有注解对象<br>getAnnotations() 返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations() 返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法 用途<br>getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法<br>getConstructors() 获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors() 获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法 用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法<br>getMethods() 获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数<br>getDeclaredMethods() 获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法 用途<br>isAnnotation() 如果是注解类型则返回 true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 true<br>isAnonymousClass() 如果是匿名类则返回 true<br>isArray() 如果是一个数组类则返回 true<br>isEnum() 如果是枚举类则返回 true<br>isInstance(Object obj) 如果 obj 是该类的实例则返回 true<br>isInterface() 如果是接口类则返回 true<br>isLocalClass() 如果是局部类则返回 true<br>isMemberClass() 如果是内部类则返回 true</p><h3 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h3><p>Field 代表类的成员变量（成员变量也称为类的属性）。</p><p>方法 用途<br>equals(Object obj) 属性与 obj 相等则返回 true<br>get(Object obj) 获得 obj 中对应的属性值<br>set(Object obj, Object value) 设置 obj 中对应属性值</p><h3 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h3><p>Method 代表类的方法。</p><p>方法 用途<br>invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法</p><h3 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h3><p>Constructor 代表类的构造方法。</p><p>方法 用途<br>newInstance(Object… initargs) 根据传递的参数创建类的对象</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先写一个被反射调用的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReflex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ExampleReflex.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String LOG = <span class="string">"LOG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String privateName = <span class="string">"privateName"</span>;</span><br><span class="line">    <span class="keyword">public</span> String publicName = <span class="string">"publicName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"defaultName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FINAL_NAME = <span class="string">"FINAL_NAME"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATIC_FINAL_NAME = <span class="string">"STATIC_FINAL_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodNoParams: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodHasParams: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Private No Params getName: "</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethodHasParams</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateMethodHasParams: "</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"size:"</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodNoParams: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"staticMethodNoParams"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodHasParams: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"_____"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">privateStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateStaticMethod: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPrivateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPrivateName: "</span> + privateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPublicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPublicName: "</span> + publicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logStatic: A: "</span> + A + <span class="string">"   LOG: "</span> + LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logFinal: finalName: "</span> + FINAL_NAME + <span class="string">" STATIC_FINAL_NAME: "</span>+ STATIC_FINAL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，其中包含 public、private、static、final 修饰的属性、以及函数</p><h3 id="返回调用函数"><a href="#返回调用函数" class="headerlink" title="返回调用函数"></a>返回调用函数</h3><h4 id="调用-public-函数"><a href="#调用-public-函数" class="headerlink" title="调用 public 函数"></a>调用 public 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取class</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 根据class 获取一个对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象</span></span><br><span class="line">Method method1 = clazz.getMethod(<span class="string">"publicMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">method1.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公有有参函数 第二个参数是入参参数签名</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"publicMethodHasParams"</span>, String.class);</span><br><span class="line">method2.invoke(obj, <span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用-private-函数"><a href="#调用-private-函数" class="headerlink" title="调用 private 函数"></a>调用 private 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取私有函数</span></span><br><span class="line">Method method3 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 私有函数需要设置允许访问 否则会报错</span></span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">String name = (String) method3.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethod Result: "</span> + name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有有参函数</span></span><br><span class="line">Method method4 = clazz.getDeclaredMethod(<span class="string">"privateMethodHasParams"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">method4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String size = (String) method4.invoke(obj, <span class="number">22</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethodHasParams Result: "</span> + size);</span><br></pre></td></tr></table></figure><p>可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。<br>getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数</p><h4 id="调用-static-函数"><a href="#调用-static-函数" class="headerlink" title="调用 static 函数"></a>调用 static 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态无参函数</span></span><br><span class="line">Method method5 = clazz.getDeclaredMethod(<span class="string">"staticMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line">method5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method5.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态有参函数</span></span><br><span class="line">Method method6 = clazz.getDeclaredMethod(<span class="string">"staticMethodHasParams"</span>, String.class);</span><br><span class="line">method6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String result_str6 = (String) method6.invoke(obj, <span class="string">"public static method"</span>);</span><br><span class="line">Log.d(tag, <span class="string">"staticMethodHasParams Result: "</span> + result_str6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有静态函数</span></span><br><span class="line">Method method7 = clazz.getDeclaredMethod(<span class="string">"privateStaticMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">method7.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method7.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>反射调用静态函数与调用私有函数其实没有不同</p><h3 id="调用反射修改属性"><a href="#调用反射修改属性" class="headerlink" title="调用反射修改属性"></a>调用反射修改属性</h3><h4 id="修改-public、private、static-变量"><a href="#修改-public、private、static-变量" class="headerlink" title="修改 public、private、static 变量"></a>修改 public、private、static 变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改public变量，并输出</span></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field publicField = clazz.getDeclaredField(<span class="string">"publicName"</span>);</span><br><span class="line"><span class="comment">// 在obj实例对象上设置属性新值</span></span><br><span class="line">publicField.set(obj, <span class="string">"publicName_New"</span>);</span><br><span class="line">Method method8 = clazz.getDeclaredMethod(<span class="string">"logPublicName"</span>);</span><br><span class="line">method8.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改private变量</span></span><br><span class="line">Field privateField = clazz.getDeclaredField(<span class="string">"privateName"</span>);</span><br><span class="line"><span class="comment">// 私有属性需要设置可访问</span></span><br><span class="line">privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateField.set(obj, <span class="string">"privateName_New"</span>);</span><br><span class="line">Method method9 = clazz.getDeclaredMethod(<span class="string">"logPrivateName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method9.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态属性</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"A"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(obj, <span class="number">2222</span>);</span><br><span class="line">Method method10 = clazz.getDeclaredMethod(<span class="string">"logStatic"</span>, <span class="keyword">null</span>);</span><br><span class="line">method10.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method10.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意，私有变量时需要调用 setAccessible，不然会报错</p><h4 id="修改-final-修饰的常量"><a href="#修改-final-修饰的常量" class="headerlink" title="修改 final 修饰的常量"></a>修改 final 修饰的常量</h4><p>在 java 中，使用 final 修饰的代表常量，不允许修改。<br>当我们通过反射修改时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改final常量</span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method11 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method11.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method11.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。</p><p>针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的修改final常量方式</span></span><br><span class="line">Field field3 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field3.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method12 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method12.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="反射构造函数"><a href="#反射构造函数" class="headerlink" title="反射构造函数"></a>反射构造函数</h3><p>在上面调用生成实例中：<br>Object obj = clazz.newInstance();</p><p>其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。<br>修改 ExampleReflex.java 中的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Constructor ExampleReflex: "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例</p><p>通过 public 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 获取public 有参的构造函数</span></span><br><span class="line">Constructor constructor1 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 通过构造函数生成对象 参数为入参类型class</span></span><br><span class="line">Object obj = constructor1.newInstance(<span class="string">"NNNNN"</span>);</span><br><span class="line">Method method81 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method81.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method81.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>通过 private 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取private 有参构造函数</span></span><br><span class="line">Constructor constructor2 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line">Object obj2 = constructor2.newInstance(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p>在上面其实讲的都是反射的使用，包括函数、属性、构造器等<br>而关于反射能够使用的原理，大概描述：<br>当类被加载时，会将类中的构造器、属性、函数，都缓存到 Class 类的内部类 ReflectionData 中。<br>而反射就是，先判断该类是否加载过，加载过则直接去 ReflectionData 中取，<br>如果没加载过就报错。</p><p>其中又涉及到类加载过程</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android 复习导航</title>
    <link href="hexo/blog/2021/10/android-%E5%A4%8D%E4%B9%A0%E5%AF%BC%E8%88%AA.html"/>
    <id>hexo/blog/2021/10/android-复习导航.html</id>
    <published>2021-10-18T06:30:39.000Z</published>
    <updated>2021-12-08T08:20:29.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-篇"><a href="#java-篇" class="headerlink" title="java 篇"></a>java 篇</h1><ul><li>类加载机制<ul><li>双亲委派机制</li></ul></li><li>反射</li><li>注解</li><li>注入</li><li>序列化</li><li><p>范型</p></li><li><p>集合</p><ul><li>Map</li><li>List</li><li>LinkedList</li><li>Set</li><li>HashMap</li></ul></li><li><p>内存</p><ul><li>内存抖动</li><li>内存泄露</li><li>内存溢出</li><li>GC 算法</li><li>JVM 结构</li><li>JMM（java 内存模型）</li><li>四种引用类型</li></ul></li><li><p>多线程</p><ul><li>线程池</li><li>wait/notify</li><li>锁</li><li>原子类</li><li>ThreadLocal</li><li>线程的状态、转换</li></ul></li></ul><h1 id="android-篇"><a href="#android-篇" class="headerlink" title="android 篇"></a>android 篇</h1><ul><li><p>四大组件</p><ul><li>Activity</li><li>Service</li><li>BroadcastReceiver<br>-LocalBroadcastReceiver (為何更高效)</li><li>Provider</li></ul></li><li><p>生命周期</p><ul><li>Activity 生命周期</li><li>Service 生命周期</li></ul></li><li><p>消息机制</p><ul><li>Handler</li><li>IdleHandler</li><li>Looper</li><li>MessageQueue</li></ul></li><li><p>事件分发机制</p><ul><li>View/ViewGroup</li><li>滑动冲突</li></ul></li><li><p>自定义 View</p><ul><li>onMeasure</li><li>onLayout</li><li>onDraw</li></ul></li><li><p>注入</p></li><li><p>数据持久化 SharePreferences</p></li><li><p>跨进城通信</p><ul><li>AIDL</li><li>Binder</li></ul></li><li><p>设计模式</p><ul><li>MVC</li><li>MVP</li><li>MVVM</li></ul></li><li><p>第三方插件</p><ul><li>GSON</li><li>okHttp</li><li>Rxjava</li><li>Dagger</li><li>Dagger2</li><li>APT</li><li>ARouter</li><li>Glide</li></ul></li><li><p>UI</p><ul><li>ListView</li><li>ViewPager</li><li>Fragment</li><li>Stub</li><li>RecyclerView</li><li>Adapter</li></ul></li></ul><h1 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h1><ul><li>Kotlin</li><li>C/C++</li></ul><h1 id="混合开发平台"><a href="#混合开发平台" class="headerlink" title="混合开发平台"></a>混合开发平台</h1><ul><li>Cordova</li><li>react-native</li><li>Flutter<ul><li>原理</li><li>渲染机制</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-篇&quot;&gt;&lt;a href=&quot;#java-篇&quot; class=&quot;headerlink&quot; title=&quot;java 篇&quot;&gt;&lt;/a&gt;java 篇&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;类加载机制&lt;ul&gt;
&lt;li&gt;双亲委派机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反射&lt;/li
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>jvm内存说明</title>
    <link href="hexo/blog/2021/08/jvm%E5%86%85%E5%AD%98%E8%AF%B4%E6%98%8E.html"/>
    <id>hexo/blog/2021/08/jvm内存说明.html</id>
    <published>2021-08-16T09:55:13.000Z</published>
    <updated>2021-08-16T10:11:36.785Z</updated>
    
    <content type="html"><![CDATA[<p>针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出</p><h2 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h2><p>在一定时间内，频繁的创建对象然后又回收，使内存存在明显的上下波动<br>一般可能发生在循环中大量创建了局部对象</p><p>内存抖动的影响，抖动频繁的话会导致回收也频繁，而频繁的 GC 是会造成性能影响的。<br>因为每次 GC 时会挂起线程两次，二次还会产生内存碎片。</p><p>要考虑多复用对象，涉及模式：享元模式</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在程序运行期间，已经没有被使用的对象，引用却一直被持有，导致该对象无法被回收，此时就会造成内存泄漏</p><p>内存泄漏的影响：会造成无用对象无法被回收，使内存空间越来越小，最终可能会造成内存溢出</p><p>一般示例：Inflater 的创建需要 Context 对象，传入 Actiivty 时创建完后，需要将 Inflater 的实例对象置空，此时就会消除对 Activity 对象引用的持有，不然就会造成 Activity 的内存泄漏</p><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>当创建对象时，JVM 无法分配足够的内存，此时就会执行 GC，清理内存已获取足够的空间。<br>但如果 GC 后仍然无法获取足够的空间时，此时就会抛出异常 OOM（内存溢出），中断程序的运行</p><p>影响：会抛出异常，中断程序的运行<br>与内存抖动、内存泄漏不同，内存抖动、内存泄漏都不会影响程序的运行，最多只会影响程序运行的性能，内存溢出则会直接报错，中断程序的运行。<br>内存溢出是内存泄漏的持续结果。</p><p>解决办法：程序内存溢出后会在特定目录输出 .trace 文件，需要分析文件确定造成内存溢出的代码块。</p><p>常见的内存溢出：流使用完后未关闭、Cursor 使用完后未关闭、短时间创建大量的大内存对象</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出&lt;/p&gt;
&lt;h2 id=&quot;内存抖动&quot;&gt;&lt;a href=&quot;#内存抖动&quot; class=&quot;headerlink&quot; title=&quot;内存抖动&quot;&gt;&lt;/a&gt;内存抖动&lt;/h2&gt;&lt;p&gt;在一定时间内，频繁的创建对象然后又回收，
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android学习导航</title>
    <link href="hexo/blog/2021/08/android%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA.html"/>
    <id>hexo/blog/2021/08/android学习导航.html</id>
    <published>2021-08-16T07:10:03.000Z</published>
    <updated>2021-08-16T07:55:20.023Z</updated>
    
    <content type="html"><![CDATA[<p>android 学习思维导图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">JVM知识点 --&gt; A(内存问题)</span><br><span class="line">A --&gt; 内存抖动</span><br><span class="line">A --&gt; 内存泄漏</span><br><span class="line">A --&gt; 内存溢出</span><br><span class="line"></span><br><span class="line">JVM知识点 --&gt; B(JVM结构)</span><br><span class="line">B --&gt; JVM结构</span><br><span class="line">B --&gt; GC回收算法</span><br><span class="line">B --&gt; JMM内存模型</span><br><span class="line"></span><br><span class="line">JVM知识点 --&gt; C(四种引用类型)</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;android 学习思维导图&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android应用启动过程</title>
    <link href="hexo/blog/2021/07/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html"/>
    <id>hexo/blog/2021/07/android应用启动过程.html</id>
    <published>2021-07-06T06:40:17.000Z</published>
    <updated>2021-07-07T02:44:41.329Z</updated>
    
    <content type="html"><![CDATA[<p>android 应用启动过程</p><p>首先，手机中的主页面、以及显示各个应用图标的页面本身就是一个 Activity<br>android 应用启动就是我们点击应用图标后的过程</p><p>以下以 API28 为例</p><p>应用启动涉及 L：三个进程、六个大类</p><p>三个进程：<br>Launcher 进程：整个 App 启动流程的起点，负责接收用户点击屏幕事件，它其实就是一个 Activity，里面实现了点击事件，长按事件，触摸等事件，可以这么理解，把 Launcher 想象成一个总的 Activity，屏幕上各种 App 的 Icon 就是这个 Activity 的 button，当点击 Icon 时，会从 Launcher 跳转到其他页面。</p><p>SystemServer 进程：这个进程在整个的 Android 进程中是非常重要的一个，地位和 Zygote 等同，它是属于 Application Framework 层的，Android 中的所有服务，例如 AMS, WindowsManager, PackageManagerService 等等都是由这个 SystemServer fork 出来的。</p><p>App 进程：你要启动的 App 所运行的进程。</p><p>六个大类：<br>ActivityManagerService：（AMS）AMS 是 Android 中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要，它本身也是一个 Binder 的实现类。</p><p>Instrumentation：监控应用程序和系统的交互。</p><p>ActivityThread：应用的入口类，通过调用 main 方法，开启消息循环队列。ActivityThread 所在的线程被称为主线程。</p><p>ApplicationThread：ApplicationThread 提供 Binder 通讯接口，AMS 则通过代理调用此 App 进程的本地方法。</p><p>ActivityManagerProxy：AMS 服务在当前进程的代理类，负责与 AMS 通信。</p><p>ApplicationThreadProxy：ApplicationThread 在 AMS 服务中的代理类，负责与 ApplicationThread 通信。</p><p><strong><em>可以说，启动的流程就是通过这六个大类在这三个进程之间不断通信的过程。</em></strong></p><h2 id="LauncherActivity"><a href="#LauncherActivity" class="headerlink" title="LauncherActivity"></a>LauncherActivity</h2><p>package android.app;</p><p>LauncherActivity 既是显示所有应用图标的系统页面<br>LauncherActivity 布局是一个 ListView</p><p>listView 的数据集就是 所有应用的数据集合，每个应用信息为 ListItem</p><h3 id="ListItem"><a href="#ListItem" class="headerlink" title="ListItem"></a>ListItem</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ResolveInfo resolveInfo;</span><br><span class="line">    <span class="keyword">public</span> CharSequence label;</span><br><span class="line">    <span class="keyword">public</span> Drawable icon; <span class="comment">// 图标</span></span><br><span class="line">    <span class="keyword">public</span> String packageName; <span class="comment">// 应用包名</span></span><br><span class="line">    <span class="keyword">public</span> String className; <span class="comment">// 启动Activity的类名</span></span><br><span class="line">    <span class="keyword">public</span> Bundle extras;</span><br><span class="line"></span><br><span class="line">    ListItem(PackageManager pm, ResolveInfo resolveInfo, IconResizer resizer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resolveInfo = resolveInfo;</span><br><span class="line">        label = resolveInfo.loadLabel(pm);</span><br><span class="line">        ComponentInfo ci = resolveInfo.activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (ci == <span class="keyword">null</span>) ci = resolveInfo.serviceInfo;</span><br><span class="line">        <span class="keyword">if</span> (label == <span class="keyword">null</span> &amp;&amp; ci != <span class="keyword">null</span>) &#123;</span><br><span class="line">            label = resolveInfo.activityInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resizer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            icon = resizer.createIconThumbnail(resolveInfo.loadIcon(pm));</span><br><span class="line">        &#125;</span><br><span class="line">        packageName = ci.applicationInfo.packageName;</span><br><span class="line">        className = ci.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ListView 涉及的所有信息信息是在 Adapter 的构造函数中获取的，<br>也就是说其实在启动 LauncherActivity 时，已经获取到所有应用信息</p><p>接下来查看 Item 的点击事件，即启动应用的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">    Intent intent = intentForPosition(position);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就会进入到 Activity 的 startActivity，最后会进入 Activity 的下列方法中：<br>requestCode: -1 options: null<br>是在系统页面开启另一个应用，所以 mParent = null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options = transferSpringboardActivityOptions(options);</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">                <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">                <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">                <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">                <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">                <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">                <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">                <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时会进入 Instrumentation.java 中的 execStartActivity 函数（7 个参数的）<br>然后又会调用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br></pre></td></tr></table></figure><p>又会调用到 ActivityManagerService 中的 startActivity<br>然后会调用到 ActivityManagerService 中的 startActivityAsUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">        <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">                .setCaller(caller)</span><br><span class="line">                .setCallingPackage(callingPackage)</span><br><span class="line">                .setResolvedType(resolvedType)</span><br><span class="line">                .setResultTo(resultTo)</span><br><span class="line">                .setResultWho(resultWho)</span><br><span class="line">                .setRequestCode(requestCode)</span><br><span class="line">                .setStartFlags(startFlags)</span><br><span class="line">                .setProfilerInfo(profilerInfo)</span><br><span class="line">                .setActivityOptions(bOptions)</span><br><span class="line">                .setMayWait(userId)</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处使用构建者模式，execute 执行的是 ActivityStarter.java 中的 execute 函数</p><p>而最终会调用到 1193 行的 startActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会执行 ActivityStackSupervisor 中的 resumeFocusedStackTopActivityLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又会执行到 ActivityStack 中的 resumeTopActivityUncheckedLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">    result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又会回到 ActivityStackSupervisor 中的 startSpecificActivityLocked 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                    || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                <span class="comment">// separate apk in the process.</span></span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会通过 AMS 获取进程信息，判断进程是否存在，<br>应用进程存在时会调用 realStartActivityLocked<br>应用进程不存在时会调用 AMS 中的 startProcessLocked 去开启新进程</p><p>暂时先看 应用进程不存在的情景：</p><p>AMS startProcessLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType, String hostingNameStr, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingType, hostingNameStr,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingNameStr, <span class="keyword">boolean</span> disableHiddenApiChecks, String abiOverride)</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">     <span class="keyword">return</span> startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                    startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,</span><br><span class="line">                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,</span><br><span class="line">                            requiredAbi, instructionSet, invokeWith, app.startTime);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ProcessStartResult <span class="title">startProcess</span><span class="params">(String hostingType, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">        <span class="keyword">final</span> ProcessStartResult startResult;</span><br><span class="line">        <span class="keyword">if</span> (hostingType.equals(<span class="string">"webview_service"</span>)) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith,</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用 Process 中 start 去开启进程<br>同时注意，此处会判断进程类型， webview</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后又会调用到 ZygoteStartFailedEx 中的 start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                zygoteArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Throw early if any of the arguments are malformed. This means we can</span></span><br><span class="line">        <span class="comment">// avoid writing a partial response to the zygote.</span></span><br><span class="line">        <span class="keyword">int</span> sz = args.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span></span><br><span class="line"><span class="comment">            * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">            * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">            * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * After the zygote process reads these it will write the pid of</span></span><br><span class="line"><span class="comment">            * the child or -1 on failure, followed by boolean to</span></span><br><span class="line"><span class="comment">            * indicate whether a wrapper process was used.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">        Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">        <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">        <span class="comment">// upon.</span></span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终执行 zygoteSendArgsAndGetResult 函数来完成进程的创建。<br>注意：<br>Android 中有一个重要的进程 Zygote，翻译为受精卵进程，所有的应用程序进程都是通过 Zygote 进程 fork 得来的。</p><p>简单来说就是通过 Binder 请求 AMS 进程，然后 AMS 再发送 Socket 消息给 Zygote 进程，最后统一由 Zygote 进程 fork 出应用进程。</p><p>当进程创建完成后，会执行 ActivityThread 中的 main 方法</p><p>在 ActivityThread 中就会启动 消息分发 、 Application 的创建、Activity 的创建</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;android 应用启动过程&lt;/p&gt;
&lt;p&gt;首先，手机中的主页面、以及显示各个应用图标的页面本身就是一个 Activity&lt;br&gt;android 应用启动就是我们点击应用图标后的过程&lt;/p&gt;
&lt;p&gt;以下以 API28 为例&lt;/p&gt;
&lt;p&gt;应用启动涉及 L：三个进程、六个大类
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>c++高级</title>
    <link href="hexo/blog/2021/05/c-%E9%AB%98%E7%BA%A7.html"/>
    <id>hexo/blog/2021/05/c-高级.html</id>
    <published>2021-05-06T10:04:46.000Z</published>
    <updated>2021-05-11T06:54:03.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-高级部分-STL-容器"><a href="#c-高级部分-STL-容器" class="headerlink" title="c++ 高级部分 STL 容器"></a>c++ 高级部分 STL 容器</h1><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。</p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p><h2 id="Vector-数组"><a href="#Vector-数组" class="headerlink" title="Vector 数组"></a>Vector 数组</h2><p>数组的特征：只能保存相同类型的数据、内存连续，数据具备索引，根据索引查找快，增、删慢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 标准模版库 容器学习1 Vector"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector1; <span class="comment">// 创建数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector2(<span class="number">8</span>); <span class="comment">// 创建8个容量的数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector3(<span class="number">10</span>, <span class="number">-1</span>); <span class="comment">// 创建10个容量的数组，且默认值都是 -1</span></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; vector3.size(); i ++) &#123;</span><br><span class="line">        <span class="comment">// 修改值</span></span><br><span class="line">        vector3[i] = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"i:"</span> &lt;&lt; i &lt;&lt; <span class="string">" value:"</span> &lt;&lt; vector3[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入值</span></span><br><span class="line">    <span class="comment">// 从头部插入</span></span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">40</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">30</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">20</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 从尾部插入</span></span><br><span class="line">    vector1.insert(vector1.end(), <span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = vector1.begin(); ite != vector1.end(); ite ++) &#123;</span><br><span class="line">        <span class="comment">// 迭代器获取的是地址</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器遍历"</span> &lt;&lt; *ite &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为vector2在构造函数中申明了容量为8，此时不能进行插入或者删除操作。会报错</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 22);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.end(), 33);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 22);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.end(), 33);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line">    <span class="comment">// 删除尾部</span></span><br><span class="line"><span class="comment">//    vector2.erase(vector2.end());</span></span><br><span class="line"><span class="comment">//    // 删除头部</span></span><br><span class="line"><span class="comment">//    vector2.erase(vector2.begin());</span></span><br><span class="line">    <span class="comment">//  迭代器自动推导类型 类似于kotlin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = vector2.begin(); iter != vector2.end(); iter++) &#123;</span><br><span class="line">        *iter = <span class="number">88</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"自动推导迭代器遍历"</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><p>栈的数据特点：先进后出、后进先出，类似于方法栈进栈、出栈<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL stack 栈的学习"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="comment">// 压栈</span></span><br><span class="line">    stack1.push(<span class="number">1</span>);</span><br><span class="line">    stack1.push(<span class="number">2</span>);</span><br><span class="line">    stack1.push(<span class="number">20</span>);</span><br><span class="line">    stack1.push(<span class="number">22</span>);</span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    stack1.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈顶元素:"</span> &lt;&lt; stack1.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 栈没有迭代器，也没有索引 这样遍历的话，会将栈内元素都弹出。</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历栈元素："</span> &lt;&lt; stack1.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>压栈、弹栈函数都是没有返回值的，<br>top函数获取栈顶元素</p><h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h2><p>队列的数据特点： FIFO 先进先出，后进后出。与栈不同<br>队列内部可以使用数组实现、也可以使用链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 三 队列queue学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(<span class="number">1</span>);</span><br><span class="line">    que.push(<span class="number">2</span>);</span><br><span class="line">    que.push(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列队头元素："</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列队尾元素"</span> &lt;&lt; que.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 队列也是没有迭代器的，只能采用与栈相同的方式遍历数据</span></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历 队列队头元素："</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列是队列的一个子集，内部数据结构通过数组实现，而且是数据有序排练，默认是降序。<br>不论数据push的顺序，直接给你降序处理，可以设置成升序排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 三 优先级队列priority_queue学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 默认是降序排列</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int&gt; que;</span></span><br><span class="line">    <span class="comment">// 设置成升序排列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;que;</span><br><span class="line">    </span><br><span class="line">    que.push(<span class="number">20</span>);</span><br><span class="line">    que.push(<span class="number">50</span>);</span><br><span class="line">    que.push(<span class="number">60</span>);</span><br><span class="line">    que.push(<span class="number">30</span>);</span><br><span class="line">    que.push(<span class="number">10</span>);</span><br><span class="line">    que.push(<span class="number">70</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历 优先级队列队头元素："</span> &lt;&lt; que.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h2><p>链表的数据特点，内存非连续，每个节点有下一个节点的指针，增删快，但查询慢，增加、删除都只能在表头操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 四 链表list学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; listArr;</span><br><span class="line">    <span class="comment">// push</span></span><br><span class="line">    listArr.push_front(<span class="number">11</span>); <span class="comment">// 从链头添加一个值</span></span><br><span class="line">    listArr.push_back(<span class="number">80</span>); <span class="comment">// 从链尾添加一个值</span></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    listArr.insert(listArr.end(), <span class="number">99</span>); <span class="comment">// 插入一个值到链尾</span></span><br><span class="line">    listArr.insert(listArr.end(), <span class="number">98</span>); <span class="comment">// 插入一个值到链尾</span></span><br><span class="line">    listArr.insert(listArr.begin(), <span class="number">20</span>); <span class="comment">// 插入一个值到链头</span></span><br><span class="line">    listArr.insert(listArr.begin(), <span class="number">22</span>); <span class="comment">// 插入一个值到链头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    listArr.erase(listArr.begin());</span><br><span class="line"><span class="comment">//    listArr.erase(listArr.end()); // 这一句在运行时报错，不知道为何</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表迭代器遍历："</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    listArr.clear();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"clear"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表迭代器遍历："</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-红黑树"><a href="#set-红黑树" class="headerlink" title="set 红黑树"></a>set 红黑树</h2><p>内部结构 红黑树 会对你存入的数据进行排序，但是绝对不允许元素相同</p><p>默认会升序排列，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 五 set 学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;setV;</span><br><span class="line">    <span class="comment">// 插入值</span></span><br><span class="line">    <span class="comment">// 默认会升序排列</span></span><br><span class="line">    setV.insert(<span class="number">80</span>);</span><br><span class="line">    setV.insert(<span class="number">70</span>);</span><br><span class="line">    setV.insert(<span class="number">50</span>);</span><br><span class="line">    setV.insert(<span class="number">90</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当插入已经存在的值时，会失败，因为不允许重复</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>, less&lt;<span class="keyword">int</span>&gt;&gt;::iterator, <span class="keyword">bool</span>&gt; result = setV.insert(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// 注意set的insert函数是有返回值的，first是迭代器 second是插入的结果</span></span><br><span class="line">    <span class="keyword">if</span>(result.second) &#123;</span><br><span class="line">        <span class="comment">// 插入成功</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 注意此处取得的迭代器不是从begin开始，而是从插入的值60处开始的。</span></span><br><span class="line">        <span class="keyword">for</span>(; result.first != setV.end(); result.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入结果迭代器遍历的值:"</span> &lt;&lt; * result.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = setV.begin(); it != setV.end(); it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器遍历的值:"</span> &lt;&lt; * it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>转自：<a href="https://www.cnblogs.com/xym4869/p/12250174.html" target="_blank" rel="noopener">https://www.cnblogs.com/xym4869/p/12250174.html</a></p><p>1.函数(function)谓词<br>通过传递函数名, 匹配二元谓词(binary predicates), 根据函数提供的策略, 输出值;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function Predicate*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLarger</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.size() &gt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), isLarger);</span><br></pre></td></tr></table></figure><p>2.函数指针(function pointer)谓词<br>建立一个函数指针, 传入算法, 使用指针代替函数名, 用法类似函数谓词.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s2);</span><br><span class="line">pf = &amp;isLarger;</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), *pf);</span><br></pre></td></tr></table></figure><p>3.Lambda表达式(lambda expression)谓词<br>Lambda表达式格式: [capture list] (parameter list) -&gt; return type { function body }<br>需要匹配谓词数, 一元(unary) 或 二元(binary), 也可以通过[capture list]传递函数的变量;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(),</span><br><span class="line">    [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s2)&#123; <span class="keyword">return</span> s1.size()&gt;s2.size(); &#125;);</span><br></pre></td></tr></table></figure><p>4.函数对象(Function Object)谓词<br>类中重载函数的调用”()”, 使类可以被调用, 并且传入算法谓词中, 进行使用.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function Object*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargerString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), LargerString());</span><br></pre></td></tr></table></figure><p>5、结构体谓词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doCompareAction2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Person&amp; __x, <span class="keyword">const</span> Person&amp; __y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.id &lt; __y.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;Person, doCompareAction2&gt; setVar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map: key value键值对容器，默认会对key进行排序，所以不能存在重复的key，会添加失败 value可以重复<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 六 map学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;mapVar;</span><br><span class="line">    <span class="comment">// 插入值 需要借助 std::pair</span></span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"justin"</span>));</span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">5</span>, <span class="string">"justinA"</span>));</span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"justin"</span>));</span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mapVar.begin(); it != mapVar.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; it-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取插入值的结果</span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">4</span>, <span class="string">"novia"</span>));</span><br><span class="line">    <span class="keyword">if</span>(result.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入值成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 因为有排序，只会遍历从4以及4以后的元素</span></span><br><span class="line">        <span class="keyword">for</span>(; result.first != mapVar.end(); result.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; result.first-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; result.first-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入值失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询 是根据key查询的</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator findResult = mapVar.find(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(findResult != mapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"已找到"</span> &lt;&lt; findResult -&gt; first &lt;&lt; <span class="string">", "</span> &lt;&lt; findResult-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找key失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>multimap 属于 map下的子集<br>// 1.key可以重复， 2.key重复的数据可以分组,  3.key会排序，  4.value不会排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 七 multimap学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;multimapVar;</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"justin"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"novia"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"justin"</span>));</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"justin"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"novia"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"coco"</span>));</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin1"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin2"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin3"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = multimapVar.begin(); it != multimapVar.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; it -&gt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO 核心功能是分组</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你要查询的key，为int类型:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iteratorVar = multimapVar.find(result);</span><br><span class="line">    <span class="keyword">while</span> (iteratorVar != multimapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iteratorVar-&gt;first &lt;&lt; <span class="string">","</span> &lt;&lt; iteratorVar-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 需要自己做逻辑控制，不然有问题</span></span><br><span class="line">        iteratorVar++;</span><br><span class="line">        <span class="keyword">if</span> (iteratorVar-&gt;first != result) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 严谨性</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorVar == multimapVar.end()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="防函数"><a href="#防函数" class="headerlink" title="防函数"></a>防函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForEach</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> _size() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"size："</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义防函数"</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义函数"</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"防函数学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    TestForEach forEach;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;setVar;</span><br><span class="line">    setVar.insert(<span class="number">10</span>);</span><br><span class="line">    setVar.insert(<span class="number">20</span>);</span><br><span class="line">    setVar.insert(<span class="number">500</span>);</span><br><span class="line">    setVar.insert(<span class="number">40</span>);</span><br><span class="line">    setVar.insert(<span class="number">30</span>);</span><br><span class="line">    setVar.insert(<span class="number">50</span>);</span><br><span class="line">    setVar.insert(<span class="number">60</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set 红黑树本身没有没有记录size，我们可以通过防函数记录</span></span><br><span class="line">    <span class="comment">// for_each是有返回值的，返回值是 防函数本身</span></span><br><span class="line">    for_each(setVar.begin(), setVar.end(), fake);</span><br><span class="line">    forEach = for_each(setVar.begin(), setVar.end(), forEach);</span><br><span class="line">    forEach._size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中有很多防函数的使用，其实我们自己可以手动实现一个防函数，并替换源码中的 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义加法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; x, <span class="keyword">const</span> T &amp; y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义实现算法"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用系统自带的加法</span></span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt;sum_int;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int相加"</span> &lt;&lt; sum_int(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    plus&lt;<span class="built_in">string</span>&gt;sum_str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符相加"</span> &lt;&lt; sum_str(<span class="string">"AAA"</span>,<span class="string">"BBB"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接下来自己实现加法</span></span><br><span class="line">    plus_d&lt;<span class="keyword">float</span>&gt;sum_flo;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义 float相加"</span> &lt;&lt; sum_flo(<span class="number">1.78f</span>, <span class="number">2.56f</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    plus_d&lt;<span class="built_in">string</span>&gt;sum_s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义 字符相加"</span> &lt;&lt; sum_s(<span class="string">"justin "</span>, <span class="string">"and novia"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模版函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模版 Params1 第一个参数类型 Params2 第二个参数类型 ReturnType 返回值类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Params1, <span class="keyword">typename</span> Params2, <span class="keyword">typename</span> ReturnType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Params1 first_argument_type; <span class="comment">// 第一个参数的别名</span></span><br><span class="line">    <span class="keyword">typedef</span> Params2 second_argument_type; <span class="comment">// 第二个参数的别名</span></span><br><span class="line">    <span class="keyword">typedef</span> ReturnType result_type; <span class="comment">// 返回值别名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-高级部分-STL-容器&quot;&gt;&lt;a href=&quot;#c-高级部分-STL-容器&quot; class=&quot;headerlink&quot; title=&quot;c++ 高级部分 STL 容器&quot;&gt;&lt;/a&gt;c++ 高级部分 STL 容器&lt;/h1&gt;&lt;p&gt;STL，英文全称 standard temp
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>c++基础 五</title>
    <link href="hexo/blog/2021/04/c-%E5%9F%BA%E7%A1%80-%E4%BA%94.html"/>
    <id>hexo/blog/2021/04/c-基础-五.html</id>
    <published>2021-04-26T09:25:50.000Z</published>
    <updated>2021-05-06T09:49:35.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-基础-五"><a href="#c-基础-五" class="headerlink" title="c++基础 五"></a>c++基础 五</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>与kotlin中一样，类的继承使用 : 表示。<br>不同的是，c++继承分为私有继承、公开继承，默认为私有继承</p><ul><li>1.默认是 隐式代码： : private Person</li><li>2.私有继承：在子类里面是可以访问父类的成员，但是在类的外面不行</li><li>3.必须公开继承，才可以访问父类的成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> Father &#123; <span class="comment">// 默认私有 private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19;// 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"son"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daugther</span> :</span> <span class="keyword">public</span> Father &#123; <span class="comment">// 公开继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19; // 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"dauther"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Son son;</span><br><span class="line">    son.setName();</span><br><span class="line"><span class="comment">//    son.name; //报错 'name' is a private member of 'Father'</span></span><br><span class="line">    Daugther daugther;</span><br><span class="line">    daugther.setName();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"daugther.name : "</span> &lt;&lt; daugther.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>子类不能访问父类的私有属性</li><li>子类直接继承为私有继承</li><li>私有继承的子类对象不能访问父类的属性，只能在类中访问</li><li>公开继承的子类对象可以访问父类的属性，在类中同样可以</li></ul><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><ul><li>C++ 是允许多继承的</li><li>Java语言不允许多继承，多继承有歧义，如果Java语言多继承 就会导致代码不健壮，（二义性）</li><li>Java多实现：做的非常棒，严格避免出现 二义性问题（歧义）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">raisChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother raisChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playWithChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother playWithChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father smoking"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playWithChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father playWithChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span> <span class="keyword">public</span> Mother, <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Son son;</span><br><span class="line">    <span class="comment">// 这个是优先寻找子类的函数，因为特别明确，没有问题，还没有产生歧义（二义性）</span></span><br><span class="line">    son.work();</span><br><span class="line">    son.play();</span><br><span class="line">    son.raisChild();</span><br><span class="line">    son.playWithChild(); <span class="comment">// 报错 Member 'playWithChild' found in multiple base classes of different types</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，Son类同时继承自Father、Mother类，这两个类有一些相同的函数work、play、playWithChild<br>但子类Son也实现了work、play时，执行这些函数不会报错，<br>但调用playWithChild则会报错，因为两个父类都有该函数、但子类未实现，此时就存在二义性问题。<br>解决这样的问题，存在两个办法：</p><ul><li>1、指定调用哪个父类的该函数 使用 ::父类.函数名<br><code>son.Father::playWithChild();</code></li><li>2、在子类也实现该函数<br>  在Son类中添加playWithChild函数。</li></ul><p>总结：</p><ul><li>1、c++可以多继承</li><li>2、多继承时，如果多个父类间存在同名同参函数，子类指针使用时，会存在二义性问题，需要子类也实现该函数，或者指定父类调用</li><li>3、真实开发时，一般时子类也会定义同名成员，覆盖掉多个父类同名成员。</li></ul><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>二义性问题出现在菱形继承。<br>关于二义性问题，还有一种解决办法，就是虚继承。<br>第三种解决方案： 【虚基类】 属于 虚继承的范畴<br>真实C++开始，是很少出现，二义性（歧义） 如果出现， 系统源码（系统用 第三种解决方案）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 祖父类</span><br><span class="line">class Object&#123;</span><br><span class="line">public:</span><br><span class="line">    int number;</span><br><span class="line">    void show() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Object show run...&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等下讲 virtual 的原理是什么 ...</span><br><span class="line"></span><br><span class="line">// 父类1</span><br><span class="line">class BaseActivity1 : virtual public Object &#123;</span><br><span class="line">// public:int number; // 人为制作二义性  error: request for member &apos;number&apos; is ambiguous</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 父类2</span><br><span class="line">class BaseActivity2 : virtual public Object &#123;</span><br><span class="line">// public:int number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Son : public BaseActivity1, public BaseActivity2 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;HELLO WORLD!!!!&quot; &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    Object object;</span><br><span class="line">    BaseActivity1 baseActivity1;</span><br><span class="line">    BaseActivity2 baseActivity2;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    object.number = 100;</span><br><span class="line">    baseActivity1.number = 200;</span><br><span class="line">    baseActivity2.number = 300;</span><br><span class="line">    son.number = 400;</span><br><span class="line"></span><br><span class="line">    object.show();</span><br><span class="line">    baseActivity1.show();</span><br><span class="line">    baseActivity2.show();</span><br><span class="line">    son.show();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; object.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; baseActivity1.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; baseActivity2.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; son.number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）</p><p>上面的例子中：Object就是虚基类，BaseActivity1、BaseActivity2都是虚继承于Object，然后Son都公开继承于BaseActivity1、BaseActivity2<br>在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>多态（虚函数）。   动态多态（程序的角度上：程序在运行期间才能确定调用哪个类的函数 == 动态多态的范畴）<br>Java语言默认支持多态<br>C++默认关闭多态，怎么开启多态？ 虚函数  在父类上给函数增加 virtual关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"BaseActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"MyActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onActivityStart</span><span class="params">(BaseActivity * baseActivity)</span> </span>&#123;</span><br><span class="line">    baseActivity-&gt;onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    HomeActivity * homeActivity = <span class="keyword">new</span> HomeActivity();</span><br><span class="line">    MyActivity * myActivity = <span class="keyword">new</span> MyActivity();</span><br><span class="line">    </span><br><span class="line">    onActivityStart(homeActivity);</span><br><span class="line">    onActivityStart(myActivity);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(myActivity &amp;&amp; homeActivity) &#123;</span><br><span class="line">        <span class="keyword">delete</span> homeActivity;</span><br><span class="line">        homeActivity = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> myActivity;</span><br><span class="line">        myActivity = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多态的定义 *<br>父类的引用指向之类的对象，同一个方法有不同的实现，重写（动态多态）和   重载(静态多态)</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载即为 静态多态<br>重载：函数名相同，但入参不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span> <span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    add(<span class="number">1.3f</span>, <span class="number">4.5f</span>);</span><br><span class="line">    add(<span class="number">1.45</span>, <span class="number">1.67</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>c++纯虚函数类似于java中的抽象类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutId)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"XmlResourceParser解析布局文件信息... 反射"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        setContentView(getLayoutId());</span><br><span class="line">        initData();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    virtual int getLayoutId(); // 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity initData"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity initView"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//  错误：抽象类型 BaseActivity 绝对不能实例化</span></span><br><span class="line">    <span class="comment">// BaseActivity ba; // 報錯 Variable type 'BaseActivity' is an abstract class</span></span><br><span class="line">    HomeActivity home;</span><br><span class="line">    home.onCreate();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意纯虚函数记得在函数后面写 = 0<br>如果不写 = 0 则会运行报错</p><h3 id="全纯虚函数"><a href="#全纯虚函数" class="headerlink" title="全纯虚函数"></a>全纯虚函数</h3><p>如果类中的函数都是虚函数，则这个类可以被成为全纯虚函数， 相当于java中的接口</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>与java中的函数回调类似<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> mobile;</span><br><span class="line">    </span><br><span class="line">    User(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> mobile): id(id), name(name), mobile(mobile)&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"用户名:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">" 用户id："</span> &lt;&lt; <span class="keyword">this</span>-&gt;id &lt;&lt; <span class="string">" 用户手机号:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;mobile  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILognResult</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(<span class="keyword">int</span> code, User user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, <span class="built_in">string</span> message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginAction</span><span class="params">(<span class="built_in">string</span> userName, <span class="built_in">string</span> password, ILognResult &amp; loginResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(userName.empty() || password.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"登录的账号与用户名都不能为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"justin"</span> == userName &amp;&amp; <span class="string">"123321qQ"</span> == password) &#123;</span><br><span class="line">        loginResult.success(<span class="number">200</span>, User(<span class="number">1121</span>, <span class="string">"justin"</span>, <span class="string">"13163396276"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loginResult.fail(<span class="number">404</span>, <span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginResultImpl</span> :</span> <span class="keyword">public</span> ILognResult &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">(<span class="keyword">int</span> code, User user)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"登录成功：userName:"</span> &lt;&lt; user.name &lt;&lt; <span class="string">" mobile: "</span> &lt;&lt; user.mobile  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, <span class="built_in">string</span> message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"登录失败：错误状态码:"</span> &lt;&lt; code &lt;&lt; <span class="string">" 错误信息: "</span> &lt;&lt; message  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入用户名"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; userName;</span><br><span class="line">    <span class="built_in">string</span> password;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入密码"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; password;</span><br><span class="line">    LoginResultImpl loginResult;</span><br><span class="line">    loginAction(userName, password, loginResult);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码就是一个登录操作的回调 其实是非常类似于 java中的接口回调的</p><h2 id="模版函数"><a href="#模版函数" class="headerlink" title="模版函数"></a>模版函数</h2><p>c++ 中没有范型概念，但是有模版函数，与java中的范型类似</p><p>像我们在之前的 静态多态中对于重载时的举例，加法<br>当我们针对不同的数据类型都需要进行一次重载，但当我们使用函数模版时，写一次即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"result:"</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> a = add(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">float</span> f = add(<span class="number">1.4f</span>, <span class="number">66.8f</span>);</span><br><span class="line">    <span class="keyword">double</span> d = add(<span class="number">3.6</span>, <span class="number">88.99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"f:"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"d:"</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，使用模版函数完成了各个类型的加法计算，使用也与java中的范型及其类似</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c-基础-五&quot;&gt;&lt;a href=&quot;#c-基础-五&quot; class=&quot;headerlink&quot; title=&quot;c++基础 五&quot;&gt;&lt;/a&gt;c++基础 五&lt;/h1&gt;&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>NDK C++基础 四</title>
    <link href="hexo/blog/2021/04/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html"/>
    <id>hexo/blog/2021/04/NDK-C-基础-四.html</id>
    <published>2021-04-06T06:30:23.000Z</published>
    <updated>2021-04-26T09:25:49.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-可变参数"><a href="#c-可变参数" class="headerlink" title="c++可变参数"></a>c++可变参数</h2><p>在java中，可变参数使用 int … 需要声明类型<br>在c++中，可变参数直接使用 … 表示，不限制类型，而是在取值时，申明类型<br>在c++，获取可变参数使用 va_list va_start va_arg va_end</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp; <span class="comment">// 可变参数的动作</span></span><br><span class="line">    va_start(vp, count); <span class="comment">// 第二个参数：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num1： "</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sum(<span class="number">666</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 va_start 中第二个参数的解释：</p><ul><li>可变参数获取其实是根据内存地址来获取的，将函数传入的可变参数前的一个参数作为 va_start 的第二个参数，就是获取到前一个参数的地址，就可以获取到可变参数的首地址，然后再根据取值的类型，既可获取存储需要的size，就可以获取到每一个可变参数的值 *</li></ul><p>注意事项：</p><ul><li>取值可变参数多个值时，需要用同一个变量接收，即使用同一个内存地址接收</li><li>当取的值超出了可变参数的长度时，并不会报错，而是取到一个系统内存地址的值，随机</li><li>当取值完毕要调用 va_end 来结束可变参数的获取</li></ul><p>我们在使用可变参数时，必须传递一个具体的参数，用于确定可变参数的内存地址，</p><ul><li>同时为了方便使用，我们可以传递可变参数的长度。这样也就不会存在可变参数越界取到随机值的问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp;</span><br><span class="line">    va_start(vp, count);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        num = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">3</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id; <span class="comment">// statin int id = 99; 会报错 Non-const static data member must be initialized out of line</span></span><br><span class="line">    Person()&#123;</span><br><span class="line">        id = <span class="number">99</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = <span class="number">9</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = <span class="number">87</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::id= <span class="number">88</span>; <span class="comment">// 加上这一句，这样就可以了。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person person;</span><br><span class="line">    person.change();</span><br><span class="line">    Person::update(); <span class="comment">// 类名::可以调用静态函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  person.id &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// id没实现也会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">静态的总结：</span><br><span class="line">* <span class="number">1.</span>可以直接通过类名::静态成员（字段/函数）</span><br><span class="line">* <span class="number">2.</span>静态的属性必须要初始化，然后再实现（规则）</span><br><span class="line">* <span class="number">3.</span>静态的函数只能取操作静态的属性和方法（Java）</span><br><span class="line"></span><br><span class="line">#<span class="meta"># this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> 指当前的对象</span><br><span class="line"></span><br><span class="line">** <span class="keyword">const</span>修饰函数的<span class="keyword">this</span>意义何在。 **</span><br><span class="line">之前讲过常量指针、指针常量、常量指针常量</span><br><span class="line">使用<span class="keyword">const</span> 修饰的函数其实就是对该函数 内部隐式的 <span class="keyword">this</span> 进行<span class="keyword">const</span> 修饰，使当前<span class="keyword">this</span>变为一个 常量指针常量</span><br><span class="line"></span><br><span class="line">* 常量指针 常量是修饰值的，不能修改指，可以修改地址</span><br><span class="line">* 指针常量，不可修改指向的地址，但可以修改指针指向的值</span><br><span class="line">* 常量指针常量 既不能修改指向的地址，也不能修改指针指向的数据，即完全只读</span><br><span class="line"></span><br><span class="line">也就是说使用<span class="keyword">const</span>修饰的函数，既不能修改 当前对象 中属性的值，也不能修改地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = <span class="number">19</span>; <span class="comment">// 报错 Cannot assign to non-static data member within const member function 'test'</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">88</span>;</span><br><span class="line">    &amp;<span class="keyword">this</span> = <span class="literal">NULL</span>; <span class="comment">// 报错 Cannot take the address of an rvalue of type 'const Person *'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>常规来说，private的变量在类之外，都是无法访问的，即使是在外部生成的变量或者子类都是无法修改的。<br>但是在c++中，存在友元函数，可以在友元函数中，类对象可以访问对象的私有属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 友元函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WoRLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person person;</span><br><span class="line"><span class="comment">//    person.age = 10; // 会报错 'age' is a private member of 'Person'</span></span><br><span class="line">    person.setAge(<span class="number">19</span>);</span><br><span class="line">    updateAge(&amp;person, <span class="number">88</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"age: "</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>除了友元函数，还存在友元类，和友元类类似，在友元类中，类对象可以访问私有属性与私有函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>;</span> <span class="comment">// 友元类</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student student;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStudentAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        student.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getStudentAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  student.age;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Class cla;</span><br><span class="line">cla.setStudentAge(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"友元类中输出私有属性："</span> &lt;&lt; cla.getStudentAge() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>重写运算符的逻辑，使用关键字 <em> operator</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对+号做运算符重载</span></span><br><span class="line">Point <span class="keyword">operator</span> + (Point point1, Point point2) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = point1.getX() + point2.getX();</span><br><span class="line">    <span class="keyword">int</span> y = point1.getY() + point2.getY();</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(x, y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象1 + 对象2   C++默认不支持的， Java也不支持，Kotlin也不支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++/Kotlin 运算符重载 + 把+重载掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">point2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Point point = point1 + point2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符+重载 point x:"</span> &lt;&lt; point.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这里的加号还是可以正常运算</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是将 运算符重载函数写在类外，还可以将重载函数写在类的内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对+号重载</span></span><br><span class="line">    <span class="comment">// 系统是这样写的  常量引用：不允许修改，只读模式</span></span><br><span class="line">    <span class="comment">// const 关键字的解释</span></span><br><span class="line">    <span class="comment">// &amp; 性能的提高，如果没有&amp;  运行+ 构建新的副本，会浪费性能</span></span><br><span class="line">    <span class="comment">// 如果增加了&amp; 引用是给这块内存空间取一个别名而已</span></span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp; point) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + point.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + point.y;</span><br><span class="line">        <span class="keyword">return</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对-号重载</span></span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp; point) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x - point.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y - point.y;</span><br><span class="line">        <span class="keyword">return</span>  Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 ++对象 进行重载</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++ () &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"++对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 对象++ 进行重载</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"对象++"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">point2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Point point = point1 + point2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符+重载 point x:"</span> &lt;&lt; point.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    point1++;</span><br><span class="line">    ++point1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符++重载 point1 x:"</span> &lt;&lt; point1.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point1.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 ++对象 与 对象++ 的区别</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;c-可变参数&quot;&gt;&lt;a href=&quot;#c-可变参数&quot; class=&quot;headerlink&quot; title=&quot;c++可变参数&quot;&gt;&lt;/a&gt;c++可变参数&lt;/h2&gt;&lt;p&gt;在java中，可变参数使用 int … 需要声明类型&lt;br&gt;在c++中，可变参数直接使用 … 表示，不限
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android aidl</title>
    <link href="hexo/blog/2021/03/android-aidl.html"/>
    <id>hexo/blog/2021/03/android-aidl.html</id>
    <published>2021-03-19T03:48:34.000Z</published>
    <updated>2021-07-08T09:29:33.065Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL: Android Interface Definition Language （android 接口定义语言）<br>可以使用 AIDL 定于跨进程的客户端与服务端通信(IPC)的编程接口.</p><p>主要流程是在项目中新建一个 aidl 文件，此时会自动在 src 目录下生成 aidl 目录，并创建包名路径，并在路径下生成命名的 aidl 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.justin.ipc.application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 rebuild project，会在 app/build/generated/aidl_source_doutput_dir/denug/out/包名/下生成对应的 IMyAidlInterface.java 文件</p><p>会生成大量代码，首先是接口基本代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">/** Default implementation for IMyAidlInterface. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">justin</span>.<span class="title">ipc</span>.<span class="title">application</span>.<span class="title">IMyAidlInterface</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">         * and return values in AIDL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码， 是 IMyAidlInterface.java 文件中代码主体部分，IMyAidlInterface 继承 android.os.IInterface 接口<br>然后有一个默认的静态内部类 Default 实现 IMyAidlInterface 接口，具体的函数实现都是空，没有具体逻辑。<br>注意其中的 asBinder 函数，这是 android.os.IInterface 中的方法</p><h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>然后在 IMyAidlInterface 接口类中，还有一个静态内部抽象类 Stub 继承自 android.os.Binder 实现 IMyAidlInterface 接口<br>而 android.os.Binder 又实现于 IBinder 接口<br>介于 Binder 对象在系统底层的支持下，Stub 对象就具有了远程传输数据的能力，在生成 Stub 对象的时候会调用 asInterface 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检索 Binder 对象是否是本地接口的实现</span></span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.justin.ipc.application.IMyAidlInterface))) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((com.justin.ipc.application.IMyAidlInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Binder 为什么具有远程通信的能力，因为如上面所说 Stub 继承了 Binder 类<br>下面是官网对 IBinder 接口的描述：<br><code>远程对象的基础接口，轻量级远程过程调用机制的核心部分，专为执行进程内和跨进程调用时的高性能而设计。该接口描述了与可远程对象交互的抽象协议。不要直接实现这个接口，而是从Binder扩展。</code><br>这里我们知道 Binder 实现了 IBinder 接口，也就是说 Binder 具备了远程通信的能力，当不同进程之间（远程）之间通信时，显然使用的是 Stub 的代理对象 Proxy ，<br>而在 Proxy 中的具体函数中，只是将数据序列号，然后在系统跨进程支持下最终调用 onTransact() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">    <span class="keyword">switch</span> (code)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        reply.writeString(descriptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_basicTypes:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        <span class="keyword">int</span> _arg0;</span><br><span class="line">        _arg0 = data.readInt();</span><br><span class="line">        <span class="keyword">long</span> _arg1;</span><br><span class="line">        _arg1 = data.readLong();</span><br><span class="line">        <span class="keyword">boolean</span> _arg2;</span><br><span class="line">        _arg2 = (<span class="number">0</span>!=data.readInt());</span><br><span class="line">        <span class="keyword">float</span> _arg3;</span><br><span class="line">        _arg3 = data.readFloat();</span><br><span class="line">        <span class="keyword">double</span> _arg4;</span><br><span class="line">        _arg4 = data.readDouble();</span><br><span class="line">        java.lang.String _arg5;</span><br><span class="line">        _arg5 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_setName:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        java.lang.String _arg0;</span><br><span class="line">        _arg0 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.setName(_arg0);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_getName:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        <span class="keyword">this</span>.getName();</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这个方法在当系统回调给开发者的时候，传递回来的 code 是一个常量，在跨进程时，每个具体的服务（方法）都会对应一个编号<br>，然后根据这个编号来执行相应的服务（业务），这里说到了最后要执行的具体业务，<br>那么这个业务要体现在什么地方呢，从上面可知 Stub 是一个抽象类，那么它所提供的具体业务必然需要一个具体的实现类来完成，<br>而这个类就是需要我们自己手动根据需要来实现</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 是 Stub 中的一个 静态内部类，实现 IMyAidlInterface 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">justin</span>.<span class="title">ipc</span>.<span class="title">application</span>.<span class="title">IMyAidlInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">    Proxy(android.os.IBinder remote)</span><br><span class="line">    &#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">        * and return values in AIDL.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeInt(anInt);</span><br><span class="line">        _data.writeLong(aLong);</span><br><span class="line">        _data.writeInt(((aBoolean)?(<span class="number">1</span>):(<span class="number">0</span>)));</span><br><span class="line">        _data.writeFloat(aFloat);</span><br><span class="line">        _data.writeDouble(aDouble);</span><br><span class="line">        _data.writeString(aString);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().basicTypes(anInt, aLong, aBoolean, aFloat, aDouble, aString);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_setName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().setName(name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().getName();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.IMyAidlInterface sDefaultImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 Proxy 中的几个具体方法，主要是对数据做序列化处理，然后调用 mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0);</p><p>mRemote 在 Proxy 的构造函数内被赋值，而 Proxy 是在 Stub 中的 asInterface 函数， 所以又回到了 上面的逻辑。</p><h3 id="手动实现进程通信"><a href="#手动实现进程通信" class="headerlink" title="手动实现进程通信"></a>手动实现进程通信</h3><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>创建一个 Service，并运行在其他进程，模拟跨进程调用 Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestAIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestAIDLService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAIDLTestImp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AndroidManifest.xml 文件中，配置 Service</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyTestAIDLService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 process=”:remote” 表示运行在另一进程，进程号为： 主进程 + ‘:remote’</p><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><p>写三个按钮，一个绑定服务，一个解绑服务，一个调用服务中的 Binder 获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = MainActivity.class.getName() + <span class="string">"MYTEST："</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button btn_bind, btn_unbind, btn_get;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isConnected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        btn_bind = findViewById(R.id.bind_server);</span><br><span class="line">        btn_unbind = findViewById(R.id.unbind_server);</span><br><span class="line">        btn_get = findViewById(R.id.btn_getInfo);</span><br><span class="line"></span><br><span class="line">        btn_bind.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">            bindService();</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_unbind.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">           unbindService();</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_get.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">            getInfo();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isConnected = <span class="keyword">true</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyTestAIDLService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isConnected) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"unbindService: 已解绑，请勿重复提交"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isConnected = <span class="keyword">false</span>;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        Log.d(TAG, <span class="string">"unbindService: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaces.setName(<span class="string">"name"</span>);</span><br><span class="line">            String result = interfaces.getName();</span><br><span class="line">            Log.d(TAG, <span class="string">"getInfo: "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onServiceConnected: "</span>);</span><br><span class="line">            interfaces = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">            System.out.println(TAG + <span class="string">"具体的业务对象："</span>+interfaces);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onServiceDisconnected: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindingDied</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onBindingDied: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们依次点击绑定服务、获取信息，输出如下：<br>onServiceConnected:<br>具体的业务对象：com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157<br>getInfo: name</p><p>当我们在 AndroidManifest.xml 中去除 Service 的 process 配置，即让 service 与 MainActivity 处于同一进程时，<br>输出如下：<br>onServiceConnected:<br>具体的业务对象：com.justin.ipc.application.MyAIDLTestImp@da080a<br>getInfo: name</p><p>对比发现，输出的 interfaces 对象不同<br>原因是在 Stub 中 asInterface 函数中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.justin.ipc.application.IMyAidlInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.justin.ipc.application.IMyAidlInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在同一进程中，queryLocalInterface 返回的 iin 不为空，此时获取的就是 om.justin.ipc.application.MyAIDLTestImp@da080a</p><p>而处于跨进程通信时，queryLocalInterface 返回的 iin 为空，此时会返回 new com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);<br>一个新的 Proxy 对象，也就是上面的 com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157</p><h3 id="跨进程通信的身份认证"><a href="#跨进程通信的身份认证" class="headerlink" title="跨进程通信的身份认证"></a>跨进程通信的身份认证</h3><p>在跨进程通信时，可能需要对通信双方进行安全认证<br>认证方式一般包括：自定义权限、数据认证</p><h4 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h4><p>自定义权限，一般适用于需要提供功能给第三方应用使用时，做一个权限认证。<br>需要我们先在自己应用中申明我们的自定义权限</p><h4 id="申明自定义权限"><a href="#申明自定义权限" class="headerlink" title="申明自定义权限"></a>申明自定义权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.justin.ipc.application"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.justin.custom.permission.PERSONAL"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:description</span>=<span class="string">"自定义权限描述"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:permissionGroup</span>=<span class="string">"MINE_CUSTOM_PERMISSION_GROUP"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释下各个属性：</p><ul><li>name，该标签就是权限的名字。</li><li>您需要为权限提供标签和说明。这些是用户在查看权限列表 (android:label) 或有关单个权限的详细信息 (android:description) 时能够看到的字符串资源。标签应当简短，用几个词描述该权限所保护的关键功能。说明应该用几个句子描述权限允许权限获得者执行哪些操作。我们通常会使用包含两个句子的说明：第一句描述权限；第二句提醒用户在向应用授予权限后可能会出现哪类错误。</li><li>android:permissionGroup 属性为可选项，仅用于帮助系统向用户显示权限。在大多数情况下，您应将其设置为标准系统组（在 android.Manifest.permission_group 中列出），但您也可以自行定义组。最好使用现有的组，因为这可以简化用户看到的权限界面。</li><li>protectionLevel 属性为必需项，用于指示系统如何向用户告知哪些应用正在请求权限或者谁可以获得该权限</li></ul><p>Android 将权限分为若干个保护级别:normal, dangerous, signature 等。<br>normal 就是正常权限，该权限并不会给用户或者设备的隐私带来风险； 在 6.0 后不需要动态申请<br>dangerous 就是危险权限，该级别的权限通常会给用户的数据或设备的隐私带来风险； 在 6.0 后需要动态申请<br>signature 指的是，只有相同签名的应用才能使用该权限。 在 6.0 后需要动态申请</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>当我们申明了自定义权限后，在其他应用中使用时，就与系统的权限使用是一样的配置。</p><p>而我们也会对权限进行校验</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AIDL: Android Interface Definition Language （android 接口定义语言）&lt;br&gt;可以使用 AIDL 定于跨进程的客户端与服务端通信(IPC)的编程接口.&lt;/p&gt;
&lt;p&gt;主要流程是在项目中新建一个 aidl 文件，此时会自动在 
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
</feed>
