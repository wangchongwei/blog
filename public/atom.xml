<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watch And Learn</title>
  
  <subtitle>Plan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="hexo/"/>
  <updated>2021-03-11T10:11:47.334Z</updated>
  <id>hexo/</id>
  
  <author>
    <name>justin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>andorid MVC</title>
    <link href="hexo/blog/2021/03/andorid-MVC.html"/>
    <id>hexo/blog/2021/03/andorid-MVC.html</id>
    <published>2021-03-11T09:42:14.000Z</published>
    <updated>2021-03-11T10:11:47.334Z</updated>
    
    <content type="html"><![CDATA[<p>MVC 模式：</p><p>1）Model (模型层) 在 MVC 中 Model 一般用来保存数据的状态，比如数据存储，网络请求。同时还与View 存在一定的耦合，通过某种事件机制（比如观察者模式） 通知 View 状态的改变来让view 更新。</p><p>2）View (视图层)一般由一些GUI 组建组成，同时响应用户的交互行为并触发 Controller 的逻辑，View 还有可能修改Model 的状态 以使其与 Model 同步，View 还会在model 中注册 model 事件的改变。以此来刷新自己并展示给用户。</p><p>3）Control （控制层）控制器由View 根据用户行为触发并响应来自view 的用户交互，然后根据view 的事件逻辑来修改对应的Model, Control 并不关心 View 如何展示 相关数据或状态，而是通过修改 Model 来实现view 的数据的刷新。</p><p>view 层即指 xml文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MVC 模式：&lt;/p&gt;
&lt;p&gt;1）Model (模型层) 在 MVC 中 Model 一般用来保存数据的状态，比如数据存储，网络请求。同时还与View 存在一定的耦合，通过某种事件机制（比如观察者模式） 通知 View 状态的改变来让view 更新。&lt;/p&gt;
&lt;p&gt;2）Vi
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>NDK-c++基础 三</title>
    <link href="hexo/blog/2021/03/NDK-c-%E5%9F%BA%E7%A1%80-%E4%B8%89.html"/>
    <id>hexo/blog/2021/03/NDK-c-基础-三.html</id>
    <published>2021-03-11T06:20:48.000Z</published>
    <updated>2021-03-11T06:49:27.857Z</updated>
    
    <content type="html"><![CDATA[<p>c++语言基础，<br>c++中能运行c语言，但c语言不能运行c++</p><p>C++语言面向对象 + 标准特性<br>C语言面向过程，函数+结构体<br>C++里面可以运行C语言，可以调用C语言，反之 就不行C语言无法运行C++<br>以后我们85%以上 都是 用C++去写功能</p><p>在c语言中基本运行需要引入<br><code>#include &lt;stdio.h&gt;</code><br>在c++中需要引入<br><code>#include &lt;iostream&gt;</code></p><h2 id="打印语句"><a href="#打印语句" class="headerlink" title="打印语句"></a>打印语句</h2><ul><li>cout *<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;HELLO WORLD!&quot; &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; &quot;YYYYYY\n&quot;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Line1\n&quot;</span><br><span class="line">        &lt;&lt; &quot;Line2\n&quot;</span><br><span class="line">        &lt;&lt; &quot;line3\n&quot;;</span><br></pre></td></tr></table></figure></li></ul><p>需要引入<br><code>using namespace std;</code><br>namespace 命名空间</p><p>&lt;&lt; 是一个操作重载符，cout 更正确的写法是： std::cout<br>因为我们已经引入 命名空间，所以可以省略为： cout</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在c或者c++中，常量使用 const 声明，但是在c语言中，常量是个伪命题，因为c中可以直接修改指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int i = 90;</span><br><span class="line">int * p = &amp;i; // c++ Cannot initialize a variable of type &apos;int *&apos; with an rvalue of type &apos;const int *&apos;</span><br><span class="line">*p = 10;</span><br></pre></td></tr></table></figure><p>i 已经被定义成常量<br>上面这段代码在c语言中可以运行，并能修改i地址处的值为10，达到了修改常量值的目的。<br>但是在c++中会报错，ide工具就会直接报错：Cannot initialize a variable of type ‘int <em>‘ with an rvalue of type ‘const int </em>‘</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>&amp; *</li></ul><p>c++中 &amp; 标示引用类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int &amp; a = i;</span><br><span class="line">cout &lt;&lt; &quot;a地址:&quot; &lt;&lt; &amp;a &lt;&lt; &quot;\ni地址:&quot; &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">int c = 9;</span><br><span class="line">int d = 9;</span><br><span class="line">cout &lt;&lt; &quot;c地址:&quot; &lt;&lt; &amp;c &lt;&lt; &quot;\nd地址:&quot; &lt;&lt; &amp;d &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>打印结果：<br>a地址:0x7ffeefbff4c8<br>i地址:0x7ffeefbff4c8<br>c地址:0x7ffeefbff4bc<br>d地址:0x7ffeefbff4b8</p><p>因为 a 是 i 的引用。 a 指向 i， 所以 a 与 i 的地址一致。<br>而c 与 d 不同，c、d都是一个新的对于9的引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;c++语言基础，&lt;br&gt;c++中能运行c语言，但c语言不能运行c++&lt;/p&gt;
&lt;p&gt;C++语言面向对象 + 标准特性&lt;br&gt;C语言面向过程，函数+结构体&lt;br&gt;C++里面可以运行C语言，可以调用C语言，反之 就不行C语言无法运行C++&lt;br&gt;以后我们85%以上 都是 用C+
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android SharedPreferences</title>
    <link href="hexo/blog/2021/03/android-SharedPreferences.html"/>
    <id>hexo/blog/2021/03/android-SharedPreferences.html</id>
    <published>2021-03-09T08:29:28.000Z</published>
    <updated>2021-03-10T03:38:59.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SharedPreferences 存取值原理，其实还是将数据写入到xml文件 以及 缓存中。<br>Context.getSharedPreferences 都是在ContextImpl中实现，但是在API23之前、23之后实现方式却不同</p><h2 id="API-23"><a href="#API-23" class="headerlink" title="API 23"></a>API 23</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 第一次为空时，初始化值</span><br><span class="line">        if (sSharedPrefs == null) &#123;</span><br><span class="line">            sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取对应packageName下的 sp实例集合 也是当前应用第一次使用时初始化</span><br><span class="line">        final String packageName = getPackageName();</span><br><span class="line">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</span><br><span class="line">        if (packagePrefs == null) &#123;</span><br><span class="line">            packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</span><br><span class="line">            sSharedPrefs.put(packageName, packagePrefs);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">                Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            if (name == null) &#123;</span><br><span class="line">                name = &quot;null&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据传入的name获取对应的sp实例，第一次初始化  获取对应的文件</span><br><span class="line">        sp = packagePrefs.get(name);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            File prefsFile = getSharedPrefsFile(name);</span><br><span class="line">            sp = new SharedPreferencesImpl(prefsFile, mode);</span><br><span class="line">            packagePrefs.put(name, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public File getSharedPrefsFile(String name) &#123;</span><br><span class="line">    return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextImpl 中 维护有一个 静态集合 sSharedPrefs = ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;<br>sSharedPrefs 全局唯一</p><p>该map中 key为 应用包名，value 为一个 packagePrefs ArrayMap&lt;String, SharedPreferencesImpl&gt;,</p><p>SharedPreferencesImpl 是单个sp实例信息， 文件、数据map缓存</p><p>packagePrefs 存有一个应用中所有的 sp实例 SharedPreferencesImpl</p><p>sSharedPrefs 存有所有应用关于sp的实例信息</p><p><strong> 存取值其实就是在集合sSharedPrefs中通过包名packageName获取到 packagePrefs，再根据 初入的name获取到指定的 SharedPreferencesImpl实例，然后再通过实例来读写数据 </strong></p><p>getSharedPrefsFile 就是返回 应用data文件夹/shared_prefs/ name.xml</p><h2 id="API-24及以上"><a href="#API-24及以上" class="headerlink" title="API 24及以上"></a>API 24及以上</h2><p>ContextImp 中存在两个 getSharedPreferences函数，<br>public SharedPreferences getSharedPreferences(String name, int mode);<br>public SharedPreferences getSharedPreferences(File file, int mode);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</span><br><span class="line">private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">  </span><br><span class="line">    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (name == null) &#123;</span><br><span class="line">            name = &quot;null&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 获取name 对应的文件</span><br><span class="line">        if (mSharedPrefsPaths == null) &#123;</span><br><span class="line">            mSharedPrefsPaths = new ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file = mSharedPrefsPaths.get(name);</span><br><span class="line">        if (file == null) &#123;</span><br><span class="line">            file = getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 获取当前运行应用的 sp集合</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            checkMode(mode);</span><br><span class="line">            if (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                if (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;SharedPreferences in credential encrypted &quot;</span><br><span class="line">                            + &quot;storage are not available until after user is unlocked&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 新建 SharedPreferencesImpl 对象</span><br><span class="line">            sp = new SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        // If somebody else (some other process) changed the prefs</span><br><span class="line">        // file behind our back, we reload it.  This has been the</span><br><span class="line">        // historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    if (sSharedPrefsCache == null) &#123;</span><br><span class="line">        sSharedPrefsCache = new ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String packageName = getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    if (packagePrefs == null) &#123;</span><br><span class="line">        packagePrefs = new ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在api24以后，ContextImpl中不再维护有静态的sSharedPrefs集合，<br>而是维护有一个ArrayMap mSharedPrefsPaths ，以及一个静态集合ArrayMap sSharedPrefsCache<br>sSharedPrefs key为name，value为文件<br>sSharedPrefsCache ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt;  key为包名packageName， value 为集合ArrayMap&lt;File, SharedPreferencesImpl&gt;</p><p>getSharedPreferences(String name, int mode)函数中，先通过name获取到对应的文件，再调用public SharedPreferences getSharedPreferences(File file, int mode);</p><h2 id="API-23-与-24-的差异"><a href="#API-23-与-24-的差异" class="headerlink" title="API 23 与 24 的差异"></a>API 23 与 24 的差异</h2><p>从上面来看，API23与24差异很小，其实就是将内部的集合的key从 string 改成了 file，<br>在API24中，增多一个mSharedPrefsPaths集合，在集合中就有 name 与 file的映射关系。<br>对于需要频繁获取的sp实例来说，可能略有优化，但是也增加了内存消耗。</p><p>## </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = false;</span><br><span class="line">    mMap = null;</span><br><span class="line">    mThrowable = null;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = false;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mLoaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Debugging</span><br><span class="line">    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = null;</span><br><span class="line">    StructStat stat = null;</span><br><span class="line">    Throwable thrown = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                str = new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16 * 1024);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ErrnoException e) &#123;</span><br><span class="line">        // An errno exception means the stat failed. Treat as empty/non-existing by</span><br><span class="line">        // ignoring.</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = true;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        // It&apos;s important that we always signal waiters, even if we&apos;ll make</span><br><span class="line">        // them fail with an exception. The try-finally is pretty wide, but</span><br><span class="line">        // better safe than sorry.</span><br><span class="line">        try &#123;</span><br><span class="line">            if (thrown == null) &#123;</span><br><span class="line">                if (map != null) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mMap = new HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // In case of a thrown exception, we retain the old map. That allows</span><br><span class="line">            // any open editors to commit and store updates.</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新建 SharedPreferencesImpl 时，会初始化一些变量，并且执行startLoadFromDisk<br>在startLoadFromDisk 中会新开线程执行 loadFromDisk<br>在loadFromDisk 中，会删除原文件，然后将 备份文件重命名 </p><p>然后就是通过文件流读取 文件信息，将读取到的信息赋值给 SharedPreferencesImpl中的 map对象。<br>同时对文件的读取都是加锁操作的。当文件读取完成了，执行mLock.notifyAll();唤醒所有操作线程。 </p><p><code>loadFromDisk 需要新开线程也是互斥的问题，必须保证load 与读写不在同一线程，才能让不会一直await，在加载完能够唤醒读写的操作继续。</code></p><h3 id="getValue"><a href="#getValue" class="headerlink" title="getValue()"></a>getValue()</h3><p>内部有针对不同类型的get方法，基本都一致，看一个就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        return v != null ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读操作也是加锁的，防止读、写同时，导致数据异常，同时也跟上面的 loadFromDisk 中加锁呼应，防止问价还未加载完就进行读写操作</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put操作需要通过内部类EditorImpl来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public Editor edit() &#123;</span><br><span class="line">    // 当文件未加载完，即loadFromDisk未执行完时，会一直等待。</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    // 每次获取edit时都是重新创建一个对象。</span><br><span class="line">    return new EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次获取Edit对象时都是返回一个新的对象，所以尽量将数据操作合并，不要频繁去重新获取edit对象。<br>在看一下put数据的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, Object&gt; mModified = new HashMap&lt;&gt;();</span><br><span class="line">@Override</span><br><span class="line">public Editor putString(String key, @Nullable String value) &#123;</span><br><span class="line">    synchronized (mEditorLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行put方法时，只是将数据提交到 EditorImpl 中的一个HashMap中，<br>只有在commit 或者 apply时，才会将数据合并、写入到文件中。</p><ul><li>QA：为何要设计一个mModified，来保存数据，而不是直接提交合并到文件？<br>这样可以避免频繁操作文件，只有在执行commit、apply时才去操作文件，提高效率，是一种优化手段。</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean commit() &#123;</span><br><span class="line">    long startTime = 0;</span><br><span class="line"></span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    // 合并mModified数据到一个新的集合，并清除mModified数据，并记录哪些key的value发生更改，最后将合并的数据包装成一个MemoryCommitResult对象</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    // 将mcr加入文件写入队列，注意第二个参数为null，标示 直接写入，不需等待</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">        mcr, null /* sync write on this thread okay */);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 等待写入结果</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                    + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 唤醒监听器，发送消息，数据更改操作结束</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime = System.currentTimeMillis();</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 apply、commit两个函数基本相同，主要时在 enqueueDiskWrite 函数执行时，传入的第二个参数不同 </p><h3 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                                  final Runnable postWriteRunnable) &#123;</span><br><span class="line">    // commit时,传入的postWriteRunnable为null， isFromSyncCommit 为true， </span><br><span class="line">    // apply时 postWriteRunnable != null isFromSyncCommit = false</span><br><span class="line"></span><br><span class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</span><br><span class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable != null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // commit 才会进入这个判断，并最终执行writeToDiskRunnable 然后return</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty = false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // apply 会执行此处</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commit、apply差异"><a href="#commit、apply差异" class="headerlink" title="commit、apply差异"></a>commit、apply差异</h3><p>从上面的注释也可以看出， commit会直接在当前线程执行 writeToDiskRunnable.run();<br>而 apply 会将 writeToDiskRunnable 加入队列 QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);等待线程池执行任务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SP是线程安全的，通过锁、await、notifyAll，保证并行时不会读写异常。</p><p>SP通过全局静态ArrayMap维护一个集合，通过packageName、name找到对应的读写文件file、SPImpl实例。</p><p>读操作是加载file完之后，直接在缓存的一个集合Map中根据key读取即可。</p><p>写操作是先将需要写入的数据都缓存到一个HashMap中，再在commit或者apply时与file中的数据合并，并标示哪些key发生改变，包装成一个MemoryCommitResult对象。</p><p>写操作只是修改缓存的HashMap，修改持久化的数据还需要执行commit或者apply。</p><p>commit 是当前线程直接执行，而 apply是添加到任务队列等待线程池执行。</p><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><ul><li><p>不要存放大的key和value在SharedPreferences中，否则会一直存储在内存中得不到释放，内存使用过高会频发引发GC，导致界面丢帧甚至ANR。</p></li><li><p>不相关的配置选项最好不要放在一起，单个文件越大读取速度则越慢。</p></li><li><p>读取频繁的key和不频繁的key尽量不要放在一起（如果整个文件本身就较小则忽略，为了这点性能添加维护得不偿失）。</p></li><li><p>不要每次都edit，因为每次都会创建一个新的EditorImpl对象，最好是批量处理统一提交。否则edit().commit每次创建一个EditorImpl对象并且进行一次IO操作，严重影响性能。</p></li><li><p>commit发生在UI线程中，apply发生在工作线程中，对于数据的提交最好是批量操作统一提交。虽然apply发生在工作线程（不会因为IO阻塞UI线程）但是如果添加任务较多也有可能带来其他严重后果<br>  （参照ActivityThread源码中handleStopActivity方法实现）</p></li><li><p>尽量不要存放json和html，这种可以直接文件缓存。</p></li><li><p>不要指望它能够跨进程通信 Context.PROCESS</p></li><li><p>最好提前初始化SharedPreferences，避免SharedPreferences第一次创建时读取文件线程未结束而出现等待情况。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;SharedPreferences 存取值原理，其实还是将数据写入到xml文件 以及 缓存中。&lt;br&gt;Context.getSharedPr
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android 应用启动流程</title>
    <link href="hexo/blog/2021/03/android-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html"/>
    <id>hexo/blog/2021/03/android-应用启动流程.html</id>
    <published>2021-03-09T05:47:56.000Z</published>
    <updated>2021-03-09T05:48:02.584Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>NDK c语言基础 二</title>
    <link href="hexo/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C.html"/>
    <id>hexo/blog/2021/03/NDK-c语言基础-二.html</id>
    <published>2021-03-05T02:40:09.000Z</published>
    <updated>2021-03-09T05:47:34.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>申明关键字 struct</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    </span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似与java中的bean类，kotlin中的data class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    struct Person * person;</span><br><span class="line">    person-&gt;name = &quot;justin&quot;; // xcode可以这样写，其他工具可能需要使用 strcpy 函数来对字符串复制来进行赋值</span><br><span class="line">    person-&gt;age = 29;</span><br><span class="line">    printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以直接在结构体后实例化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; ppp1  = &#123;&quot;9999&quot;, 21&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>在不同的ide工具中，c语言的语法可能略有不同，为了统一，推出一个类型定义，<br>如此保证在不同的ide工具，使用一样的代码运行</p><p>在源码中也是大量使用</p><p>关键字 typedef</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; ppp1  = &#123;&quot;9999&quot;, 21&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">typedef struct Person Person; // 为结构体定义一个类型，后续申明结构体对象就不需要使用struct关键字</span><br><span class="line">typedef Person * Person_; // 为结构体指针定一个类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    Person_ person;</span><br><span class="line">    person-&gt;name = &quot;justin&quot;;</span><br><span class="line">    person-&gt;age = 29;</span><br><span class="line">    printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>file</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;p&gt;申明关键字 struct&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="c语言" scheme="hexo/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>JMM java内存模型</title>
    <link href="hexo/blog/2021/03/JMM-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"/>
    <id>hexo/blog/2021/03/JMM-java内存模型.html</id>
    <published>2021-03-03T06:55:28.000Z</published>
    <updated>2021-03-04T09:34:02.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、现代计算机内存模型"><a href="#一、现代计算机内存模型" class="headerlink" title="一、现代计算机内存模型"></a>一、现代计算机内存模型</h2><p>早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问内存地址的。<br>而在现代计算机中，CPU指令的运行速度远远超过了内存数据的读写速度，为了降低这两者间这高达几个数量级的差距，所以在CPU与主内存之间加入了CPU高速缓存。</p><p>高速缓存可以很好地解决CPU与主内存之间的速度差距，但CPU缓存并不是所有CPU共享的，因此产生了一个新的问题：数据一致性问题。</p><p><img src="../../../images/memory.png" style="zoom:70%"></p><h2 id="二、缓存一致性协议（MESI）"><a href="#二、缓存一致性协议（MESI）" class="headerlink" title="二、缓存一致性协议（MESI）"></a>二、缓存一致性协议（MESI）</h2><h3 id="MESI四种状态"><a href="#MESI四种状态" class="headerlink" title="MESI四种状态"></a>MESI四种状态</h3><p>因为存在多个cpu，也就存在多个cpu缓存，CPU缓存的一致性问题会导致并发处理的不同步。<br>所以引入一种解决办法：缓存一致性协议（MESI）</p><p>MESI 这个名称本身是由：Modified（修改）、Exclusive（独享）、Shared（共享）、Invalid（无效）。<br>这个四个单词也代表了缓存协议中对缓存行（即Cache Line，缓存存储数据的单元）声明的四种状态，用2 bit表示，它们所代表的含义如下所示</p><p>状态 ｜ 描述 ｜ 监听任务<br>Modified（修改 ｜ 这行数据有效，数据被修改了，和内存种的数据不一致，数据只存在于本Cache中 ｜ 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。<br>Exclusive（独享）｜ 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中 ｜ 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。<br>S共享（Shared ｜ 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中 ｜ 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。<br>I无效（Invalid） ｜ 这行数据无效 ｜ 无</p><p>理解： 某数据如果多个缓存读取，则处于S共享状态，如果只是单个则处于E独享状态。<br>    某个CPU2对CPU2缓存中某数据作出修改，则CPU2缓存该数据处于Modified状态，如果该数据是S共享状态，则其他缓存该行数据变成I无效状态。</p><h3 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="headerlink" title="如何保证缓存一致性"></a>如何保证缓存一致性</h3><pre><code>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存中的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</code></pre><h2 id="三、JMM-java-内存模型"><a href="#三、JMM-java-内存模型" class="headerlink" title="三、JMM java 内存模型"></a>三、JMM java 内存模型</h2><p><img src="../../../images/jmm.png" style="zoom:70%"></p><p>线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地工作内存（Local Memory），工作内存中存储了线程以读/写共享变量的副本。<br>（本地工作内存是 JMM 的一个抽象概念，并不真实存在，线程中所谓工作内存其实还是存在于主内存中的。）</p><h3 id="Java内存模型与现代计算机内存模型区分"><a href="#Java内存模型与现代计算机内存模型区分" class="headerlink" title="Java内存模型与现代计算机内存模型区分"></a>Java内存模型与现代计算机内存模型区分</h3><p>Java内存模型和现代计算机内存模型都需要解决一致性问题，但是这个一致性问题在现代计算机内存模型中指代的是缓存一致性问题，MESI协议所设计的目的也是为了解决这个问题。而在Java内存模型中，这个一致性问题则是指代内存一致性问题。两者之间有一定区别。</p><p>缓存一致性</p><p>计算机数据需要经过内存、计算机缓存再到寄存器，计算机缓存一致性是指硬件层面的问题，指的是由于多核计算机中有多套缓存，各个缓存之间的数据不一致问题。缓存一致性协议（如MESI）就是用来解决多个缓存副本之间的数据一致性问题。</p><p>内存一致性</p><p>线程的数据则是放在内存中，共享副本也是，内存一致性保证的是多线程程序并发时的数据一致性问题。我们常见的volatile、synchronized关键字就是用来解决内存一致性问题。这里屏蔽了计算机硬件问题，<br>主要解决原子性、可见性和有序性问题。</p><p>至于内存一致性与缓存一致性问题之间的关系，就是实现内存一致性时需要利用到底层的缓存一致性（之后的volatile关键字会涉及）。</p><h2 id="四、并发编程的特性"><a href="#四、并发编程的特性" class="headerlink" title="四、并发编程的特性"></a>四、并发编程的特性</h2><p>首先我们要先了解并发编程的三大特性：原子性，可见性，有序性；</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指一个操作是不可间断的，即使是多个线程同时执行，该操作也不会被其他线程所干扰。<br>既操作的连续性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 具有原子性，赋值</span><br></pre></td></tr></table></figure></p><p>i++;<br>不具备原子性<br><code>因为i++juyou多部操作1、读取 i 的值到内存空间2、i + 13、刷新结果到内存</code></p><p>多个具备原子性操作放在一起并不具备原子性<br>y=x</p><p>先读取x的值到内存空间 x = 10； 这一步具备原子性<br>在给y赋值 y = 10; 也一步也具备原子性<br>但y=x不具备原子性</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>内存可见性（Memory visibility）是指当某个线程正在使用对象状态而同时另一个线程正在修改该状态，此时需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><p>每个线程都有一个私有的本地工作内存并存储了线程间读/写的共享副本。</p><p>如果某个线程对这个副本中值进行修改，却没有对主内存进行同步，则会导致其他线程访问过时的数据。</p><p>使用volatile关键字就可以保证数据在不同线程副本的可见性，当有线程在副本中进行修改，就会强制修改主内存中值，同步到其他线程的副本中。<br>保证所有线程访问到值都为最新值</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性即程序按照我们代码所书写的那样，按其先后顺序执行。第一次接触这个特性可能会有所疑惑，所以在了解有序性之前我们需要来了解执行重排序以及相关概念。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了提高性能，编译器和处理器会对程序的指令做重排序操作，重排序分为3种类型：</p><ul><li>编译器优化的重排序：属于编译器重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</li><li>指令级并行的重排序：属于处理器重排序，现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序；</li><li>内存系统的重排序：处于处理器重排序由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul><p>指令重排序对于程序执行有利有弊，我们并不是要去完全禁止它。<br>对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型个的内存屏障指令，通过内存屏障指令来禁止特定的处理器重排序。</p><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>不管如何重排序，要保证程序运行的结果保持不变，编译器、runtime和处理器都必须遵循as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 1</span><br><span class="line">int y = 20; // 2</span><br><span class="line">int a = x + y; // 3</span><br></pre></td></tr></table></figure></p><p>明显第3行依赖于第2行、第1行，所以第三行不会重排序，而第1行、第2行可能会被重排序。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>如果说 as-if-serial 是 JMM 提供用来解决单线程间的内存可见性问题的话，那么 happens-before 就是JMM向程序员提供的可跨越线程的内存可见性保证。<br>具体表现为：如果线程A的写操作a与线程B的读操作b之间具有 happens-before 关系，那么JMM将保证这个操作a对操作b可见。<br>此外，happens-before 还有传递关系，表现为：a happens-before b，b happens-before c，那么a happens-before c。</p><p>注意：两个操作之间存在happens-before关系，并不意味着一个操作必须要在后一个操作之前执行，只要求前一个操作执行的结果对后一个操作可见。<br>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不违法（也就是说，JMM允许这种重排序）。</p><p><code>比对 happens-before 与 as-if-serial。</code></p><ul><li><p>1、as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</p></li><li><p>2、as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。</p></li><li><p>3、as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、现代计算机内存模型&quot;&gt;&lt;a href=&quot;#一、现代计算机内存模型&quot; class=&quot;headerlink&quot; title=&quot;一、现代计算机内存模型&quot;&gt;&lt;/a&gt;一、现代计算机内存模型&lt;/h2&gt;&lt;p&gt;早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>NDK c语言基础 (一)</title>
    <link href="hexo/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%80.html"/>
    <id>hexo/blog/2021/03/NDK-c语言基础-一.html</id>
    <published>2021-03-01T08:07:48.000Z</published>
    <updated>2021-03-05T03:32:37.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言基础"><a href="#c语言基础" class="headerlink" title="c语言基础"></a>c语言基础</h1><h2 id="创建C语言程序"><a href="#创建C语言程序" class="headerlink" title="创建C语言程序"></a>创建C语言程序</h2><p>xcode -&gt; create new xcode project -&gt; macos -&gt; command line tools<br>在macos系统即可创建一个c语言程序</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>int 整型，占4个字节<br>double 双精度小数 占8个字节<br>float 单精度小数 占4个字节<br>char 字符 占1个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d\n&quot;, i, sizeof(i));</span><br><span class="line">double db = 1.34;</span><br><span class="line">printf(&quot;db的值:%lf,所占字节%d\n&quot;, db, sizeof(db));</span><br><span class="line">float fl = 1.12;</span><br><span class="line">printf(&quot;fl的值:%f,所占字节%d\n&quot;, fl, sizeof(fl));</span><br><span class="line">char ch = &apos;A&apos;;</span><br><span class="line">printf(&quot;ch的值:%c,所占字节%d\n&quot;, ch, sizeof(ch));</span><br></pre></td></tr></table></figure><p>打印结果：<br>i的值:2,所占字节4<br>db的值:1.340000,所占字节8<br>fl的值:1.120000,所占字节4<br>ch的值:A,所占字节1</p><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>使用 &amp; 变量 即可获取到变量的内存地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d， 内存地址为%p\n&quot;, i, sizeof(i), &amp;i);</span><br></pre></td></tr></table></figure></p><p>i的值:2,所占字节4， 内存地址为0x7ffeefbff4c8</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>&amp;i 既是取出i的内存地址，也是i的指针。<br>或者换个说法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">int * i_p = &amp;i;</span><br></pre></td></tr></table></figure></p><p>取出指针的值使用 *</p><ul><li>i_p 既可取出值 i = 10；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 22;</span><br><span class="line">int * i_p = &amp;i;</span><br><span class="line">printf(&quot;i 的值：%d, i_p指针指向的值: %d \n&quot;, i, *i_p);</span><br><span class="line">printf(&quot;i的地址：%p, i_p的地址%p \n&quot;, i_p, &amp;i_p);</span><br></pre></td></tr></table></figure><p>打印：<br>    i 的值：22, i_p指针指向的值: 22<br>    i的地址：0x7ffeefbff4c8, i_p的地址0x7ffeefbff4c0<br>可以是 &amp; 对指针再次取内存地址</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5];</span><br><span class="line">printf(&quot;a的值：%p， a的内存地址：%p, a[0]的地址%p\n&quot;, a, &amp;a, &amp;a[0]);</span><br></pre></td></tr></table></figure><p>打印结果：a的值：0x7ffeefbff4b0， a的内存地址：0x7ffeefbff4b0, a[0]的地址0x7ffeefbff4b0</p><p>可以看到 打印 a、&amp;a、&amp;a[0]出现的结果都一样。</p><p><strong> 1、为何a与&amp;a一样 </strong><br>因为a是数组，除基本数据类型外的其他变量，变量本身就是指向内存地址的。所以 a == &amp;a<br><strong> 2、为何&amp;a与&amp;a[0]一样 </strong><br>因为a是数组，数组内存连续，所以数组下标为0的内存地址就是数组本身的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int j = 0;</span><br><span class="line">for (j = 0; j &lt; 5; j ++) &#123;</span><br><span class="line">    printf(&quot;当前下标为%d,下标内存地址为%p\n&quot;, j, &amp;a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>    当前下标为0,下标内存地址为0x7ffeefbff4b0<br>    当前下标为1,下标内存地址为0x7ffeefbff4b4<br>    当前下标为2,下标内存地址为0x7ffeefbff4b8<br>    当前下标为3,下标内存地址为0x7ffeefbff4bc<br>    当前下标为4,下标内存地址为0x7ffeefbff4c0<br>可以看到内存地址以每次为4增加，因为这是int数组，int占4个字节，所以每次增加4</p><h2 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * p = &amp;a[j] + 1;</span><br><span class="line">printf(&quot;p的值为:%p\n&quot;, p);</span><br><span class="line">*(&amp;a[j] + 0) = j;</span><br></pre></td></tr></table></figure><p>&amp;a[j] 是取出下标j处的地址。<br>&amp;a[j] + 1 是指针在a[j]处偏移1位，既指向a[j + 1];<br>*(&amp;a[j] + 0) = j; + 0 其实相当于未偏移，就是对a[j]赋值</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>首先函数指针的申明格式：函数返回值类型 (* 指针变量名) (函数参数列表);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void add(int a, int b)&#123;</span><br><span class="line">    printf(&quot;sum = %d\n&quot;, a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(void (*method)(int, int), int a, int b) &#123;</span><br><span class="line">    method(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello \n&quot;);</span><br><span class="line">    test(add, 3, 4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在test函数入参中，有一个函数指针，<br>在main函数中，调用test函数，并将add函数作为入参传递到test函数中。</p><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>指向指针的指针就是多级指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    </span><br><span class="line">    int a = 0;</span><br><span class="line">    int * b = &amp;a;</span><br><span class="line">    int **c = &amp;b;</span><br><span class="line">    int *** d = &amp;c;</span><br><span class="line">    printf(&quot;d的地址%p \n&quot;, d);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用来表示多维数组</p><h2 id="静态分配内存"><a href="#静态分配内存" class="headerlink" title="静态分配内存"></a>静态分配内存</h2><p>在c语言中，内存区域分为栈区、堆区</p><p>函数被调用时，就会进栈，函数执行完毕则会出栈，而在函数中默认方式申明生成的数据都是系统静态分配内存的，<br>当函数执行完毕，出栈后，在该函数中静态分配的内存会被回收，系统会自己执行，无需手动处理。<br>静态分配内存都是在栈区</p><p>栈区总容量较小，大约是2M，各个系统、设备可能不一致，超出会抛出异常</p><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>动态分配内存需要手动调用API才可，动态分配的内存不会自动回收，动态分配的内存都是在堆区。<br>堆区总容量较大，至少超过40M，各个系统、设备可能不一致， 超出也会抛出异常。</p><p>调用动态分配内存：malloc(int size)函数<br>调用回收动态内存：free(void *);</p><p>需要额外引入依赖文件：#include &lt;stdlib.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int num;</span><br><span class="line">    printf(&quot;请输入数字\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">    printf(&quot;num的值为：%d\n&quot;, num);</span><br><span class="line">    </span><br><span class="line">    int * arr = (int *)malloc(sizeof(int) * num);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0; i &lt; num; i ++) &#123;</span><br><span class="line">        arr[i] = i + 10000;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; num; ++i) &#123;</span><br><span class="line">        printf(&quot;%d对应值为%d\n&quot;, i, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重新分配"><a href="#重新分配" class="headerlink" title="重新分配"></a>重新分配</h3><p>就是将之前动态分配的内存重新分配，使用：realloc(void *<strong>ptr, size_t </strong>size);<br>第一个参数：原来的内存指针<br>第二个参数：新的内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int * new_arr = (int *)realloc(arr, sizeof(int) * (num + new_num));</span><br><span class="line">if(new_arr) &#123;</span><br><span class="line">    int j = num;</span><br><span class="line">    for (; j &lt; (num + new_num); j ++) &#123;</span><br><span class="line">        new_arr[j] = j + 100000;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt; (num + new_num); i ++) &#123;</span><br><span class="line">        printf(&quot;新数组第%d个值为%d\n&quot;, i, new_arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(new_arr);</span><br><span class="line">    new_arr = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 题目 </strong><br>截取字符串中指定字符<br>char c = “ABCDEFGHIJK”;</p><p>截取第3位到第6位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void substring(char * result, char *str, int start, int end) &#123;</span><br><span class="line">    for (int i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        printf(&quot;char:%c\n&quot;, *(str + i));</span><br><span class="line">        *(result++) = *(str + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char * str = &quot;ABCDEFGHIJK&quot;;</span><br><span class="line">    char * result;</span><br><span class="line">    substring(result, str, 3, 6);</span><br><span class="line">    printf(&quot;result:%c\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;c语言基础&quot;&gt;&lt;a href=&quot;#c语言基础&quot; class=&quot;headerlink&quot; title=&quot;c语言基础&quot;&gt;&lt;/a&gt;c语言基础&lt;/h1&gt;&lt;h2 id=&quot;创建C语言程序&quot;&gt;&lt;a href=&quot;#创建C语言程序&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="c语言" scheme="hexo/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>https详解</title>
    <link href="hexo/blog/2021/02/https%E8%AF%A6%E8%A7%A3.html"/>
    <id>hexo/blog/2021/02/https详解.html</id>
    <published>2021-02-25T07:57:53.000Z</published>
    <updated>2021-02-25T07:59:06.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Https详解"><a href="#Https详解" class="headerlink" title="Https详解"></a>Https详解</h1><h2 id="什么是Https"><a href="#什么是Https" class="headerlink" title="什么是Https"></a>什么是Https</h2><p>在说HTTPS之前先说说什么是HTTP，HTTP就是我们平时浏览网页时候使用的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。<br>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br>SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，<br>之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，<br>但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，<br>今后TLS将会继承SSL优良血统继续为我们进行加密服务。目前TLS的版本是1.2，定义在RFC 5246中，暂时还没有被广泛的使用 ()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Https详解&quot;&gt;&lt;a href=&quot;#Https详解&quot; class=&quot;headerlink&quot; title=&quot;Https详解&quot;&gt;&lt;/a&gt;Https详解&lt;/h1&gt;&lt;h2 id=&quot;什么是Https&quot;&gt;&lt;a href=&quot;#什么是Https&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="hexo/blog/2021/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>hexo/blog/2021/02/观察者模式.html</id>
    <published>2021-02-24T09:37:52.000Z</published>
    <updated>2021-02-25T07:55:59.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式的定义与特点："><a href="#观察者模式的定义与特点：" class="headerlink" title="观察者模式的定义与特点："></a>观察者模式的定义与特点：</h1><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><p>观察者模式是一种对象行为型模式，其主要优点如下：</p><ol><li><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</p></li><li><p>目标与观察者之间建立了一套触发机制。</p></li></ol><p>它的主要缺点如下：</p><ol><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;观察者模式的定义与特点：&quot;&gt;&lt;a href=&quot;#观察者模式的定义与特点：&quot; class=&quot;headerlink&quot; title=&quot;观察者模式的定义与特点：&quot;&gt;&lt;/a&gt;观察者模式的定义与特点：&lt;/h1&gt;&lt;p&gt;观察者（Observer）模式的定义：指多个对象间存在一对多
      
    
    </summary>
    
    
      <category term="设计模式" scheme="hexo/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>android 屏幕渲染</title>
    <link href="hexo/blog/2021/02/android-%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93.html"/>
    <id>hexo/blog/2021/02/android-屏幕渲染.html</id>
    <published>2021-02-23T09:31:33.000Z</published>
    <updated>2021-02-24T05:43:09.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h1><p> CPU负责计算数据，把计算好数据交给GPU,<br> GPU会对图形数据进行渲染，渲染好后放到buffer里存起来<br> display负责将buffer里的数据显示在屏幕</p><p> 简单的说就是CPU/GPU准备好数据，存入buffer，<br> display每隔一段时间去buffer里取数据，然后显示出来。<br> display读取的频率是固定的，比如每个16ms读一次，但是CPU/GPU写数据是完全无规律的</p><p>底层每16ms会发送一次VSync，更新界面</p><p>CPU：执行应用层的measure、layout、draw等操作，绘制完成后将数据提交给GPU<br>GPU：进一步处理数据，并将数据缓存起来<br>屏幕：由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点</p><p>因为display取buffer数据渲染的频率固定，而GPU往buffer写数据却是不固定的，难免存在场景：GPU还在往buffer写数据，但此时display正要显示，此时就会显示异常。</p><p>为避免这种现象，引入一种新方案：双缓存机制</p><h2 id="双缓存机制"><a href="#双缓存机制" class="headerlink" title="双缓存机制"></a>双缓存机制</h2><p>android的渲染机制中引入双缓存机制。新增一个缓存 back buffer, back buffer 会定时与 frame buffer交换数据</p><p><img src="../../../images/buffer.png" style="zoom:70%"></p><p><strong> 当你的应用正在往Back Buffer中填充数据时，系统会将Back Buffer锁定。<br>如果到了GPU交换两个Buffer的时间点，你的应用还在往Back Buffer中填充数据，GPU会发现Back Buffer被锁定了，它会放弃这次交换。 </strong></p><p>这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的丢帧，<br>所以为了避免丢帧的发生，我们就要尽量减少布局层级，减少不必要的View的invalidate调用，减少大量对象的创建（GC也会占用CPU时间）等等</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong> Q1：Android 每隔 16.6 ms 刷新一次屏幕到底指的是什么意思？是指每隔 16.6ms 调用 onDraw() 绘制一次么？<br>Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？</strong></p><p>答：我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面，而这个每一帧的画面数据就是我们 app 在接收到屏幕刷新信号之后去执行遍历绘制 View 树工作所计算出来的屏幕数据。而 app 并不是每隔 16.6ms 的屏幕刷新信号都可以接收到，只有当 app 向底层注册监听下一个屏幕刷新信号之后，才能接收到下一个屏幕刷新信号到来的通知。而只有当某个 View 发起了刷新请求时，app 才会去向底层注册监听下一个屏幕刷新信号。</p><p>也就是说，只有当界面有刷新的需要时，我们 app 才会在下一个屏幕刷新信号来时，遍历绘制 View 树来重新计算屏幕数据。如果界面没有刷新的需要，一直保持不变时，我们 app 就不会去接收每隔 16.6ms 的屏幕刷新信号事件了，但底层仍然会以这个固定频率来切换每一帧的画面，只是后面这些帧的画面都是相同的而已。</p><p><strong> Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？ </strong></p><p>答：我们 app 只负责计算屏幕数据而已，接收到屏幕刷新信号就去计算，计算完毕就计算完毕了。至于屏幕的刷新，这些是由底层以固定的频率来切换屏幕每一帧的画面。所以即使屏幕数据都计算完毕，屏幕会不会马上刷新就取决于底层是否到了要切换下一帧画面的时机了。</p><p><strong> Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？ </strong> </p><p>之所以提了这个问题，是因为之前是以为如果某个 View 发起了刷新请求，比如调用了 invalidte()，那么它的重绘工作就马上开始执行了，所以以前在看网上那些介绍屏幕刷新机制的博客时，经常看见下面这张图：</p><p>那个时候就是不大理解，为什么每一次 CPU 计算的工作都刚刚好是在每一个信号到来的那个瞬间开始的呢？毕竟代码里发起刷新屏幕的操作是动态的，不可能每次都刚刚好那么巧。</p><p>梳理完屏幕刷新机制后就清楚了，代码里调用了某个 View 发起的刷新请求，这个重绘工作并不会马上就开始，而是需要等到下一个屏幕刷新信号来的时候才开始，所以现在回过头来看这些图就清楚多了。</p><p><strong> Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？ </strong></p><p>答：造成丢帧大体上有两类原因，一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms；二是，主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。</p><p>第一个原因就是我们写的布局有问题了，需要进行优化了。而第二个原因则是我们常说的避免在主线程中做耗时的任务。</p><p>针对第二个原因，系统已经引入了同步屏障消息的机制，尽可能的保证遍历绘制 View 树的工作能够及时进行，但仍没办法完全避免，所以我们还是得尽可能避免主线程耗时工作。</p><p>其实第二个原因，可以拿出来细讲的，比如有这种情况， message 不怎么耗时，但数量太多，这同样可能会造成丢帧。如果有使用一些图片框架的，它内部下载图片都是开线程去下载，但当下载完成后需要把图片加载到绑定的 view 上，这个工作就是发了一个 message 切到主线程来做，如果一个界面这种 view 特别多的话，队列里就会有非常多的 message，虽然每个都 message 并不怎么耗时，但经不起量多啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渲染机制&quot;&gt;&lt;a href=&quot;#渲染机制&quot; class=&quot;headerlink&quot; title=&quot;渲染机制&quot;&gt;&lt;/a&gt;渲染机制&lt;/h1&gt;&lt;p&gt; CPU负责计算数据，把计算好数据交给GPU,&lt;br&gt; GPU会对图形数据进行渲染，渲染好后放到buffer里存起来&lt;br&gt;
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>面试题答案</title>
    <link href="hexo/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.html"/>
    <id>hexo/blog/2021/02/面试题答案.html</id>
    <published>2021-02-02T06:59:23.000Z</published>
    <updated>2021-02-23T07:23:30.115Z</updated>
    
    <content type="html"><![CDATA[<p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage</p><p>而在MessageQueue的enqueueMessage中。就会根据when大小插入到链表，when越小就在链表越前，其实相当于根据时间排序，越接近的时间越在链头</p><p>Looper中的消息既能同步也能异步，在Handler的构造时传入async = true；即为异步消息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息&lt;/p&gt;
&lt;p&gt;当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&amp;gt; enqueue
      
    
    </summary>
    
    
      <category term="面试" scheme="hexo/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题合集</title>
    <link href="hexo/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html"/>
    <id>hexo/blog/2021/02/面试题合集.html</id>
    <published>2021-02-02T06:54:45.000Z</published>
    <updated>2021-02-02T06:57:54.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android"><a href="#android" class="headerlink" title="android"></a>android</h1><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1、Object的方法有哪些？</p><p>2、为什么要有HashCode方法，hash算法的原理，在Java中哪些地方用到，进而问到了HashMap的源码</p><p>3、Java有几种锁，synchronized与Lock有什么区别，Lock的实现原理，有没有碰到死锁的情况</p><p>4、Android源码中用到了哪些设计模式，举例说明</p><p>5、一个Android正常启动有多少个线程?(这里当时是比较懵逼的，第一反应是一个主线程，然后觉得应该不止这么简单，想到应用Activity启动的话，应该还有2个Binder线程，可能一个管理JVM的线程，面试官接着问还有哪些。。果断放弃不知道…)</p><p>6、Binder机制的实现思想</p><p>7、简单描述Https的实现思路</p><p>8、描述下快速排序的思想，时间复杂度？什么场景对应着最坏情况？</p><p>9、给定无序数组和一个值，找到两个数和为值的元素，不能使用额外空间复杂度（不要使用HashMap）</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面是视频面试，还是个周六下午。。。</p><p>1、TCP/IP四层模型，网络层和传输层有什么区别？网络层的主要工作是什么</p><p>2、socket.accept()函数对应着TCP三次握手中哪一次握手，哪个函数代表连接建立完毕，四次挥手的过程？</p><p>3、有做过哪些优化工作，卡顿优化，内存优化，启动优化，APK体积优化，每个做了哪些工作</p><p>4、JNI开发中有碰到什么问题？怎么定位native crash</p><p>5、递归非递归反转链表</p><p>6、打印回环数组</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>2、事件分发机制的源码</p><p>3、android的屏幕刷新机制，怎么优化UI卡顿情况</p><p>4、有没有使用过插件化框架，实现原理？</p><p>5、你在项目中碰到什么比较棘手的问题？怎么解决的？</p><p>6、找到一个无序数组中第一次出现最多次数的元素</p><h2 id="某手机海外部门（offer）"><a href="#某手机海外部门（offer）" class="headerlink" title="某手机海外部门（offer）"></a>某手机海外部门（offer）</h2><p>上来就是笔试题，其实之前没怎么做过面试题，难道现在都是这个套路了….？20分钟后做完就开始面试了</p><p>1、手写线程安全的观察者模式</p><p>2、找到一个字符串中出现最多的字母</p><p>3、描述Java面对对象六大原则针对项目中谈谈自己的看法</p><p>4、android阅读过哪些源码，举例说明</p><p>5、项目中的优化工作，内存，卡顿优化，leakcanary的原理实现</p><p>6、Tcp/Udp的区别，项目中的C/S端双向认证如何实现</p><p>7、项目中有碰到过哪些比较难解决的问题。</p><p>8、android 8.0，9.0有哪些新特性，有没有了解过</p><h2 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h2><p>1、HashMap的原理以及android中为什么建议用ArrayMap和SpareArray替代HashMap？</p><p>2、android如何保证进程不被杀死</p><p>3、Java怎么与C++进行交互，以及native crash如何定位的</p><p>4、C/S如何保证双向认证（项目中使用到的，可以理解为Https的原理），用到了哪些加密算法</p><p>5、LBS定位如何去除野点（指因为定位偏差过大的点），大数据量如何和后台交互？</p><p>6、设计模式用过哪些，动态代理的原理？</p><p>7、项目中有做过哪些优化，优化成效如何？</p><h2 id="TCL（offer）"><a href="#TCL（offer）" class="headerlink" title="TCL（offer）"></a>TCL（offer）</h2><p>是一个猎头推荐的一个职位，主要应该是做TV上的相关项目，有VR类型类似的项目等等，一面居然是一个妹子和一个男的一起进来的，还是第一次遇到，没问多少基础知识点，更多的是根据自身项目问一些东西</p><p>1、TCP/UDP的区别，有看过具体报文的信息吗</p><p>2、你觉得开发一个SDK，需要注意哪些地方，有没有做过SDK性能测试</p><p>3、有了解过音视频的编解码吗</p><p>4、你觉得你这个项目中比较难的地方在哪里，你是如何解决的</p><p>5、开放题：让你加载一个200M左右的GIF，如何实现及优化，不可降低画质</p><p>6、如何优化一个列表滑动的流畅性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android&quot;&gt;&lt;a href=&quot;#android&quot; class=&quot;headerlink&quot; title=&quot;android&quot;&gt;&lt;/a&gt;android&lt;/h1&gt;&lt;h2 id=&quot;腾讯&quot;&gt;&lt;a href=&quot;#腾讯&quot; class=&quot;headerlink&quot; title=&quot;腾
      
    
    </summary>
    
    
      <category term="面试" scheme="hexo/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>并发</title>
    <link href="hexo/blog/2021/02/%E5%B9%B6%E5%8F%91.html"/>
    <id>hexo/blog/2021/02/并发.html</id>
    <published>2021-02-01T10:01:22.000Z</published>
    <updated>2021-03-02T07:30:59.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发指单位时间的访问量<br>并行指同一时刻的访问量</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><ul><li><p>ABA问题</p></li><li><p>开销问题</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h1&gt;&lt;p&gt;并发指单位时间的访问量&lt;br&gt;并行指同一时刻的访问量&lt;/p&gt;
&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoinTask</title>
    <link href="hexo/blog/2021/01/ForkJoinTask.html"/>
    <id>hexo/blog/2021/01/ForkJoinTask.html</id>
    <published>2021-01-27T05:59:20.000Z</published>
    <updated>2021-01-27T05:59:46.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h1><p>ForkJoin 是采用分而治之的思维，将一个大任务分解为若干个相互独立的子任务（异步），<br>达到提高运算效率。<br>我们做一个简单的运算 计算1-100000的累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class TestJoinTask &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; task = pool.submit(new MyForkJoinTask(1, 100000));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int result = task.get();</span><br><span class="line">            System.out.println(&quot;result = &quot; + result);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行完毕&quot; + &quot;   time = &quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传入的范型Integer是返回结果类型</span><br><span class="line">     */</span><br><span class="line">    static class MyForkJoinTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private int startValue;</span><br><span class="line"></span><br><span class="line">        private int endValue;</span><br><span class="line"></span><br><span class="line">        private int limitValue = 100;</span><br><span class="line"></span><br><span class="line">        public MyForkJoinTask(int startValue, int endValue) &#123;</span><br><span class="line">            if(startValue &gt; endValue) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;startValue &lt; endValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            this.startValue = startValue;</span><br><span class="line">            this.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Integer compute() &#123;</span><br><span class="line">            if(endValue - startValue &lt;= limitValue) &#123;</span><br><span class="line">                System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行计算&quot;);</span><br><span class="line">                // 两个值在限制值内 进行计算</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for(int i = startValue; i &lt;= endValue; i ++) &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">            MyForkJoinTask task1 = new MyForkJoinTask(startValue, (endValue + startValue) / 2);</span><br><span class="line">            task1.fork();</span><br><span class="line">            MyForkJoinTask task2 = new MyForkJoinTask((endValue + startValue) / 2 + 1, endValue);</span><br><span class="line">            task2.fork();</span><br><span class="line">            return task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们将一个从0 - 100000的累加任务分解为500个子任务：每200位数累加</p><p>在日志打印中，我们可以看到，有多个线程在执行任务，也就是说，分解的任务其实都是提交到线程池中执行，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ForkJoinTask&quot;&gt;&lt;a href=&quot;#ForkJoinTask&quot; class=&quot;headerlink&quot; title=&quot;ForkJoinTask&quot;&gt;&lt;/a&gt;ForkJoinTask&lt;/h1&gt;&lt;p&gt;ForkJoin 是采用分而治之的思维，将一个大任务分解为若
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>android ViewPager/ViewPager2解析</title>
    <link href="hexo/blog/2021/01/android-ViewPager-ViewPager2%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-ViewPager-ViewPager2解析.html</id>
    <published>2021-01-22T01:57:40.000Z</published>
    <updated>2021-01-22T02:49:39.745Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android RecyclerView解析</title>
    <link href="hexo/blog/2021/01/android-RecyclerView%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-RecyclerView解析.html</id>
    <published>2021-01-22T01:57:27.000Z</published>
    <updated>2021-01-22T02:49:34.798Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android ListView解析</title>
    <link href="hexo/blog/2021/01/android-ListView%E8%A7%A3%E6%9E%90.html"/>
    <id>hexo/blog/2021/01/android-ListView解析.html</id>
    <published>2021-01-22T01:57:15.000Z</published>
    <updated>2021-01-22T05:40:53.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ListView解析"><a href="#ListView解析" class="headerlink" title="ListView解析"></a>ListView解析</h1><p>首先是简单使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ListViewActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_list_view)</span><br><span class="line">        var list = arrayListOf(Person(&quot;novia&quot;, 24), Person(&quot;justin&quot;, 29), Person(&quot;doudou&quot;, 1))</span><br><span class="line">        var adapter = MyListAdapter(list, this)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyListAdapter(var list: ArrayList&lt;Person&gt;, var context: Context) : BaseAdapter() &#123;</span><br><span class="line">        override fun getCount(): Int &#123;</span><br><span class="line">            return list.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getItem(position: Int): Person &#123;</span><br><span class="line">            return list.get(position);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getItemId(position: Int): Long &#123;</span><br><span class="line">            return list.get(position).hashCode().toLong()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123;</span><br><span class="line">            var view = LayoutInflater.from(context).inflate(R.layout.item_listview, parent, false)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_name).setText(getItem(position).name)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_age).setText(&quot;&quot; + getItem(position).age + &quot;岁&quot;)</span><br><span class="line">            return view;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data class Person(var name: String, var age: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是ListView的特点是会将所有条目都渲染出来，当子条目较多时，会存在性能问题，当加载图片时，甚至会导致OOM</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ListView解析&quot;&gt;&lt;a href=&quot;#ListView解析&quot; class=&quot;headerlink&quot; title=&quot;ListView解析&quot;&gt;&lt;/a&gt;ListView解析&lt;/h1&gt;&lt;p&gt;首先是简单使用&lt;br&gt;&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>okhttp(二) 拦截器</title>
    <link href="hexo/blog/2021/01/okhttp-%E4%BA%8C-%E6%8B%A6%E6%88%AA%E5%99%A8.html"/>
    <id>hexo/blog/2021/01/okhttp-二-拦截器.html</id>
    <published>2021-01-13T10:29:12.000Z</published>
    <updated>2021-01-20T01:16:55.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="okhttp-二-拦截器"><a href="#okhttp-二-拦截器" class="headerlink" title="okhttp(二) 拦截器"></a>okhttp(二) 拦截器</h1><p>在前文中讲到了okhttp中的分发器</p><p>接下来讲okhttp中的拦截器</p><p>在上文中讲到，同步执行excuet时，会通过 getResponseWithInterceptorChain 获取response，<br>在异步enqueue后，后面会调用AsyncCall中execute，而里面也是通过getResponseWithInterceptorChain 来获取response。</p><p>调用的都是RealCall中的getResponseWithInterceptorChain函数。</p><h2 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain"></a>getResponseWithInterceptorChain</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors()); //自定义拦截器加入到集合</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">            originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个数组，添加各个拦截器，<br>然后初始化一个 Interceptor.Chain 对象，注意第2、3、4个参数都是null，而第5个参数是index：0<br>然后调用proceed函数</p><h2 id="RealInterceptorChain-java"><a href="#RealInterceptorChain-java" class="headerlink" title="RealInterceptorChain.java"></a>RealInterceptorChain.java</h2><p>RealInterceptorChain 实现 Interceptor接口中的Chain接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line">  private final int index;</span><br><span class="line">  private final Request request;</span><br><span class="line">  private final Call call;</span><br><span class="line">  private final EventListener eventListener;</span><br><span class="line">  private final int connectTimeout;</span><br><span class="line">  private final int readTimeout;</span><br><span class="line">  private final int writeTimeout;</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,</span><br><span class="line">      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123;</span><br><span class="line">    this.interceptors = interceptors;</span><br><span class="line">    this.connection = connection;</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line">    this.httpCodec = httpCodec;</span><br><span class="line">    this.index = index;</span><br><span class="line">    this.request = request;</span><br><span class="line">    this.call = call;</span><br><span class="line">    this.eventListener = eventListener;</span><br><span class="line">    this.connectTimeout = connectTimeout;</span><br><span class="line">    this.readTimeout = readTimeout;</span><br><span class="line">    this.writeTimeout = writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int connectTimeoutMillis() &#123;</span><br><span class="line">    return connectTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, millis, readTimeout, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int readTimeoutMillis() &#123;</span><br><span class="line">    return readTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, millis, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int writeTimeoutMillis() &#123;</span><br><span class="line">    return writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, readTimeout, millis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Call call() &#123;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EventListener eventListener() &#123;</span><br><span class="line">    return eventListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Confirm that the intercepted response isn&apos;t null.</span><br><span class="line">    if (response == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (response.body() == null) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是RealInterceptorChain的全部代码，注意看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 最开始index = 0，注意这里构造RealInterceptorChain时，传入的为index+1</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的最前面的，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 RetryAndFollowUpInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>看注释现在可能又点绕，接着往下看，Interceptor是一个接口，没必要看，可以直接先看RetryAndFollowUpInterceptor</p><h2 id="RetryAndFollowUpInterceptor-重试以及重定向拦截器"><a href="#RetryAndFollowUpInterceptor-重试以及重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor 重试以及重定向拦截器"></a>RetryAndFollowUpInterceptor 重试以及重定向拦截器</h2><p>RetryAndFollowUpInterceptor 实现 Interceptor 接口</p><p>查看其中的intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * todo  管理类，维护了 与服务器的连接、数据流与请求三者的关系。真正使用的拦截器为 Connect</span><br><span class="line">         */</span><br><span class="line">        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line"></span><br><span class="line">        // 在这里无限循环，只有抛出异常或者return response才会中断</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (canceled) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            boolean releaseConnection = true;</span><br><span class="line">            try &#123;</span><br><span class="line">                //todo 请求出现了异常，那么releaseConnection依旧为true。</span><br><span class="line">                response = realChain.proceed(request, streamAllocation, null, null);</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">            &#125; catch (RouteException e) &#123;</span><br><span class="line">                //todo 路由异常，连接未成功，请求还没发出去</span><br><span class="line">                //The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">                if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">                    throw e.getLastConnectException();</span><br><span class="line">                &#125;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span><br><span class="line">                // HTTP2才会抛出ConnectionShutdownException。所以对于HTTP1 requestSendStarted一定是true</span><br><span class="line">                //An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">                if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">                //todo 不是前两种的失败，那直接关闭清理所有资源</span><br><span class="line">                if (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed(null);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 如果进过重试/重定向才成功的，则在本次响应中记录上次响应的情况</span><br><span class="line">            //Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder()</span><br><span class="line">                        .priorResponse(</span><br><span class="line">                                priorResponse.newBuilder()</span><br><span class="line">                                        .body(null)</span><br><span class="line">                                        .build()</span><br><span class="line">                        )</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 处理3和4xx的一些状态码，如301 302重定向</span><br><span class="line">            Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                if (!forWebSocket) &#123;</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">            //todo 限制最大 followup 次数为20次</span><br><span class="line">            if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 判断是不是可以复用同一份连接</span><br><span class="line">            if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                        createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">                this.streamAllocation = streamAllocation;</span><br><span class="line">            &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">                        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到此处的主要逻辑，<br>将传入的chain对象转为RealInterceptorChain，<br>无限循环，然后在循环中调用chain.proceed函数，获取response，<br>循环的主要作用为catch异常，并针对RouteException 或者 IOException 做重试操作，其他异常则终止，</p><p>而chain.proceed又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 1； index + 1 = 2；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 1，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 BridgeInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"><a href="#BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应" class="headerlink" title="BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"></a>BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应</h2><p>BridgeInterceptor 也是实现 Interceptor 接口</p><p>同样直接查看intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also</span><br><span class="line">      // decompressing</span><br><span class="line">        // the transfer stream.</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest);</span><br><span class="line"></span><br><span class="line">        if (transparentGzip</span><br><span class="line">                &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">                &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                    .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">                    .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个函数的逻辑，<br>先对请求头信息进行再处理，然后执行chain.proceed获取networkResponse，<br>然后再对networkResponse进行再包装处理</p><p>同RetryAndFollowUpInterceptor一样，又会调用到chain.proceed函数，<br>又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 2； index + 1 = 3；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 2，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CacheInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>再看CacheInterceptor代码</p><h2 id="CacheInterceptor-负责读取缓存以及更新缓存"><a href="#CacheInterceptor-负责读取缓存以及更新缓存" class="headerlink" title="CacheInterceptor 负责读取缓存以及更新缓存"></a>CacheInterceptor 负责读取缓存以及更新缓存</h2><p>CacheInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    //todo 通过url的md5数据 从文件缓存查找 （GET请求才有缓存）</span><br><span class="line">    Response cacheCandidate = cache != null</span><br><span class="line">            ? cache.get(chain.request())</span><br><span class="line">            : null;</span><br><span class="line"></span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    //todo 缓存策略:根据各种条件(请求头)组成 请求与缓存</span><br><span class="line">    CacheStrategy strategy =</span><br><span class="line">            new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    //</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有网络请求也没有缓存</span><br><span class="line">    //If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        return new Response.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(504)</span><br><span class="line">                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-1L)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有请求，肯定就要使用缓存</span><br><span class="line">    //If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">    if (networkRequest == null) &#123;</span><br><span class="line">        return cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 去发起请求</span><br><span class="line">    Response networkResponse = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">        if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">    if (cacheResponse != null) &#123;</span><br><span class="line">        //todo 服务器返回304无修改，那就使用缓存的响应修改了时间等数据后作为本次请求的响应</span><br><span class="line">        if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">            // Update the cache after combining headers but before stripping the</span><br><span class="line">            // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            return response;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 走到这里说明缓存不可用 那就使用网络的响应</span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    //todo 进行缓存</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response,</span><br><span class="line">                networkRequest)) &#123;</span><br><span class="line">            // Offer this request to the cache.</span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; catch (IOException ignored) &#123;</span><br><span class="line">                // The cache cannot be written.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程就是获取一个networlRequets，以及一个缓存的cacheResponse，<br>如果networlRequets与cacheResponse，则直接报504的网络异常<br>如果networlRequets为空，则只能返回cacheResponse，<br>如果networlRequets不为空，则执行网络请求，获取networkResponse，<br>如果cacheResponse 不为空  且 networkResponse响应码304，代表无更改，则可以返回，</p><p>再往下就是对networlRequets进行处理，并加入缓存。</p><p>注意：此处获取networkResponse也是调用chain.proceed，于是与上面一直，也会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 3； index + 1 = 4；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 3，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 ConnectInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>此时会调用到ConnectInterceptor中的intercept函数</p><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>ConnectInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">    public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">        // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">        return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码就是ConnectInterceptor类中所有源码，<br>intercept函数中，重新获取了几个参数，和上面的几个Interceptor实现类不太一样，<br>最后调用的proceed函数是四个参数的，最后还是会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 4； index + 1 = 5；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 4，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CallServerInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>CallServerInterceptor 也是实现 Interceptor 接口，<br>CallServerInterceptor 中 intercept 函数就是直接与服务端通信的，<br>而在这里会获取到真正的response，并返回到上一层，也就是ConnectInterceptor的intercept，同理会依次向上返回。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>在上面看到的，一层一层拦截器向下调用，Interceptor类实现 调用 Interceptor类实现，<br>每一层的拦截器实现自己的功能，然后交付给下一层拦截器，<br>这种设计模式就是责任链模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;okhttp-二-拦截器&quot;&gt;&lt;a href=&quot;#okhttp-二-拦截器&quot; class=&quot;headerlink&quot; title=&quot;okhttp(二) 拦截器&quot;&gt;&lt;/a&gt;okhttp(二) 拦截器&lt;/h1&gt;&lt;p&gt;在前文中讲到了okhttp中的分发器&lt;/p&gt;
&lt;p&gt;接下
      
    
    </summary>
    
    
      <category term="java" scheme="hexo/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>react Hook</title>
    <link href="hexo/blog/2021/01/react-Hook.html"/>
    <id>hexo/blog/2021/01/react-Hook.html</id>
    <published>2021-01-11T03:27:26.000Z</published>
    <updated>2021-01-20T06:34:27.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><p>Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>在这里，useState 就是一个 Hook （等下我们会讲到这是什么意思）。通过在函数组件里调用它来给组件添加一些内部 state。<br>React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。<br>它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">    View,</span><br><span class="line">    Text,</span><br><span class="line">    TouchableOpacity,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default function test() &#123;</span><br><span class="line">    console.log(&apos;------test&apos;);</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    return (</span><br><span class="line">        &lt;View style=&#123;&#123; marginTop: 100 &#125;&#125;&gt;</span><br><span class="line">            &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;</span><br><span class="line">                &lt;Text&gt;点击获取次数：&#123;count&#125;&lt;/Text&gt;</span><br><span class="line">            &lt;/TouchableOpacity&gt;</span><br><span class="line">            &lt;Text onPress=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125; style=&#123;&#123; marginTop: 100, fontSize: 30 &#125;&#125;&gt;test&lt;/Text&gt;</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上图所示，是在react-native中简单使用Hook，使用其中的useState<br>const [count, setCount] = useState(0);<br>结构赋值，第一个count为获取的参数，<br>第二个参数setCount是修改第一个参数的函数，<br>useState(0)中，useState是在react中引入，后面的 0 是 count 的默认数据。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect 是一个副作用函数，默认在每次渲染之后都会执行。<br>而且保证每次运行effect时，DOM已经渲染完毕。</p><p>传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。<br>事实上这正是我们可以在 effect 中获取最新的 useState中 的值，而不用担心其过期的原因。<br>每次我们重新渲染，都会生成新的 effect，替换掉之前的。<br>某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。</p><ul><li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</li><li></li></ul><p>useEffect提供清除操作，当我们需要在React组件清除时，执行某一些操作，可以在useEffect中，返回清除函数。<br>当React清除时，会执行useEffect中的返回函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</li></ul><p>React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。<br>这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p><p>还可以对useEffect进行优化，useEffect接受两个参数，第二个参数为比较值，当这个值发生了变化，才会执行useEffect。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const [count, setCount] = useState(0)</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><p>这样，只有当count发生变化，即我们调用过 setCount来改变count的值，下一次渲染完毕，才会执行useEffect</p><p>所以，当我们需要执行一些只需执行一次的逻辑时，可以传入一个定值，一般使用空数组[]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    function request() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function remove() &#123;</span><br><span class="line">        // when react remove </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, []])</span><br></pre></td></tr></table></figure><p>如上所示，request只会在第一次渲染完毕执行一次，remove函数也时只会执行一次</p><h2 id="Hook规则"><a href="#Hook规则" class="headerlink" title="Hook规则"></a>Hook规则</h2><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则</p><ul><li><p>只在最顶层使用 Hook<br>  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。<br>  遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</p></li><li><p>只在 React 函数中调用 Hook<br>  不要在普通的 JavaScript 函数中调用 Hook</p></li></ul><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><ul><li>自定义一个Hook函数</li><li>函数命名以use开始</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hook技术&quot;&gt;&lt;a href=&quot;#Hook技术&quot; class=&quot;headerlink&quot; title=&quot;Hook技术&quot;&gt;&lt;/a&gt;Hook技术&lt;/h1&gt;&lt;p&gt;Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及
      
    
    </summary>
    
    
      <category term="react" scheme="hexo/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>IOC</title>
    <link href="hexo/blog/2021/01/IOC.html"/>
    <id>hexo/blog/2021/01/IOC.html</id>
    <published>2021-01-08T02:32:38.000Z</published>
    <updated>2021-01-29T09:14:22.342Z</updated>
    
    <content type="html"><![CDATA[<p>Android 推荐应用架构建议将代码划分为多个类，以从分离关注点这一原则（其中，层次结构的每个类都具有一项已定义的责任）中受益。这就需要将更多更小的类连接在一起，以实现彼此之间的依赖关系。</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>android ioc 技术</p><p>源码地址：<a href="https://github.com/wangchongwei/ioc.git" target="_blank" rel="noopener">https://github.com/wangchongwei/ioc.git</a></p><h2 id="dagger"><a href="#dagger" class="headerlink" title="dagger"></a>dagger</h2><p>dagger使用：<br>主要使用了工厂模式、APT技术</p><p>利用注解处理器，变异时生成大量代码，完成自动注入</p><p>dagger 的使用主要作用：不必编写冗长乏味且容易出错的样板代码。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>Dagger 可以执行以下操作，使您无需再编写冗长乏味又容易出错的样板代码：</p></li><li><p>生成您在手动 DI 部分手动实现的 AppContainer 代码（应用图）。</p></li><li><p>为应用图中提供的类创建 factory。这就是在内部满足依赖关系的方式。</p></li><li><p>重复使用依赖项或创建类型的新实例，具体取决于您如何使用作用域配置该类型。</p></li><li><p>为特定流程创建容器，操作方法与上一部分中使用 Dagger 子组件为登录流程创建容器的方法相同。这样可以释放内存中不再需要的对象，从而提升应用性能。</p></li></ul><p>只要您声明类的依赖项并指定如何使用注释满足它们的依赖关系，Dagger 便会在构建时自动执行以上所有操作。Dagger 生成的代码与您手动编写的代码类似。在内部，Dagger 会创建一个对象图，然后它可以参考该图来找到提供类实例的方式。对于图中的每个类，Dagger 都会生成一个 factory 类型类，它会使用该类在内部获取该类型的实例。</p><p>在构建时，Dagger 会走查您的代码，并执行以下操作：</p><ul><li><p>构建并验证依赖关系图，确保：</p><ul><li>每个对象的依赖关系都可以得到满足，从而避免出现运行时异常。</li><li>不存在任何依赖循环，从而避免出现无限循环。</li></ul></li><li><p>生成在运行时用于创建实际对象及其依赖项的类。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 推荐应用架构建议将代码划分为多个类，以从分离关注点这一原则（其中，层次结构的每个类都具有一项已定义的责任）中受益。这就需要将更多更小的类连接在一起，以实现彼此之间的依赖关系。&lt;/p&gt;
&lt;h1 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="android" scheme="hexo/tags/android/"/>
    
  </entry>
  
</feed>
