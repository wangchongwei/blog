<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ViewStub]]></title>
    <url>%2Fblog%2F2022%2F07%2FViewStub.html</url>
    <content type="text"><![CDATA[参考： https://blog.csdn.net/Demon_T/article/details/113941806 https://blog.csdn.net/a740169405/article/details/50351013 ViewStub 实现懒加载，针对 visible 在初始化时不显示的布局 ViewStub 优势 ViewStub可以做到按需加载一个布局,我们可以控制它加载的时机,而不是在Activity的onCreate方法中去加载.即懒加载 它存在于视图层级中，但只会在setVisibility和inflate方法调用只会才会填充视图，所以不会影响初始化加载速度。 合理使用ViewStub可以起到优化渲染功效 将复杂的视图放入ViewStub中，不在初始化中加载 特点 ViewStub是一个继承了View类的视图。 ViewStub是不可见的，实际上是把宽高都设置为0 可以通过布局文件的android:inflatedId或者调用ViewStub的setInflatedId方法为懒加载视图的跟节点设置ID ViewStub视图在首次调用setVisibility或者inflate方法之前，一直存在于视图树中 只需要调用ViewStub的setVisibility或者inflate方法即可显示懒加载的视图 调用setVisibility或者inflate方法之后，懒加载的视图会把ViewStub从父节点中替换掉 ViewStub的inflate只能被调用一次，第二次调用会抛出异常，setVisibility可以被调用多次，但不建议这么做（后面说原因） 为ViewStub赋值的android:layout_属性会替换待加载布局文件的根节点对应的属性 inflate方法会返回待加载视图的根节点]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock 解析]]></title>
    <url>%2Fblog%2F2022%2F07%2FReentrantLock-%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[参考地址： https://blog.csdn.net/persistence_PSH/article/details/114504207 1. ReentrantLock ReentrantLock是基于AQS实现，AQS的基础又是CAS ReentrantLock 中有三个内部类1234567891011121314151617181920212223242526272829303132333435public class ReentrantLock implements Lock, java.io.Serializable &#123; abstract static class Sync extends AbstractQueuedSynchronizer&#123;...&#125; // 非公平锁 static final class NonfairSync extends Sync &#123;...&#125; // 公平锁 static final class FairSync extends Sync &#123;...&#125; //默认为非公平锁 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; //可以通过构建对象时传入的boolean来设定锁是否公平 public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; //获取锁 public void lock() &#123; sync.lock(); &#125; //尝试获取锁 public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; //尝试获取锁，参数为尝试的时间和时间单位 public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; //释放锁 public void unlock() &#123; sync.release(1); &#125;&#125; 以上是 ReentrantLock 类中的一些主要结构 看到 Sync 类其实是继承 AbstractQueuedSynchronizer 2. AbstractQueuedSynchronizer 定义 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123;&#125; 构造器 1protected AbstractQueuedSynchronizer() &#123; &#125; 2.1 静态内部类Node ReentrantLock实现的前提就是AbstractQueuedSynchronizer，简称AQS，是java.util.concurrent的核心，CountDownLatch、FutureTask、Semaphore、ReentrantLock等都有一个内部类是这个抽象类的子类 AQS内部有一个内部类Node，每个node都是一个节点 12345678910111213141516171819202122232425262728293031323334353637383940414243static final class Node&#123; //表示Node处于共享模式 static final Node SHARED = new Node(); //表示Node处于独占模式 static final Node EXCLUSIVE = null; //因为超时或者中断，Node被设置为取消状态，被取消的Node不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态，处于这种状态的Node会被踢出队列，被GC回收 static final int CANCELLED = 1; //表示这个Node的继任Node被阻塞了，到时需要通知它 static final int SIGNAL = -1; //表示这个Node在条件队列中，因为等待某个条件而被阻塞 static final int CONDITION = -2; //使用在共享模式头Node有可能处于这种状态， 表示锁的下一次获取可以无条件传播 static final int PROPAGATE = -3; //0，新Node会处于这种状态 volatile int waitStatus; //队列中某个Node之前的Node volatile Node prev; //队列中某个Node之后的Node volatile Node next; //这个Node持有的线程，表示等待锁的线程 volatile Thread thread; //表示下一个等待condition的Node Node nextWaiter; //三个构造器 Node() &#123; &#125; Node(Thread thread, Node mode) &#123; this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 可以看得出来，Node 本身具备一种数据结构 双向链表 AQS中有的变量 12345678//FIFO队列中的头Node private transient volatile Node head; //FIFO队列中的尾Node private transient volatile Node tail; //同步状态，0表示未锁 private volatile int state; AQS是典型的模板模式的应用，FIFO队列的各种操作在AQS中已经实现，AQS的子类一般只需要重写tryAcquire(int arg)和tryRelease(int arg)两个方法即可。 3. ReentrantLock的实现 ReentrantLock根据传入构造方法的布尔型参数实例化出Sync的实现类FairSync和NonfairSync，分别表示公平的Sync和非公平的Sync。 ReentrantLock使用较多的为是非公平锁，因为非公平锁吞吐量大 下面都是以非公平锁举例： lock 假设线程1调用了ReentrantLock的lock()方法，那么线程1将会独占锁： 123456final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 第一个获取锁的线程就做了两件事情： 1、设置AbstractQueuedSynchronizer的state为1 2、设置AbstractOwnableSynchronizer的thread为当前线程 这两步做完之后就表示线程1独占了锁。然后线程2也要尝试获取同一个锁，在线程1没有释放锁的情况下，线程2会阻塞。因为锁已被线程1占有，此时 status = 1， 所以在 lock 函数中，会走到 else 中 acquire 函数是在父类 AbstractQueuedSynchronizer 中实现的。 123456789public final void acquire(int arg) &#123; //第一个判断条件尝试获取一次锁，如果获取的结果为false，才会走第二个判断条件添加FIFO等待队列 if (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 当调用 acquire 时，会调用 addWaiter 函数 &amp; acquireQueued 函数 addWaiter 1234567891011121314151617181920private Node addWaiter(Node mode) &#123; //创建一个当前线程的Node，模式为独占模式（因为传入的mode是一个NULL） Node node = new Node(mode); //死循环 for (;;) &#123; Node oldTail = tail; //尾部的node部位不为空，则等待队列不为空，线程2为第一个需要添加到等待队列的，因为多线程并发，所以等待队列有可能不为空 if (oldTail != null) &#123; U.putObject(node, Node.PREV, oldTail); if (compareAndSetTail(oldTail, node)) &#123; // oldTail 没有被其他线程修改，此时将 传入的 node 节点放置在 链表的尾部 oldTail.next = node; return node; &#125; &#125; else &#123; // 初始化链表 initializeSyncQueue(); &#125; &#125;&#125; acquireQueued 12345678910111213141516171819202122final boolean acquireQueued(final Node node, int arg) &#123; try &#123; boolean interrupted = false; //死循环： for (;;) &#123; final Node p = node.predecessor(); //再次判断一下线程2能不能获取锁（可能这段时间内线程1已经执行完了把锁释放了，state变为了0） if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC return interrupted; &#125; //不能，则调用AQS的shouldParkAfterFailedAcquire(p, node)方法，第一次会得到false,继续循环，第二次才会走第二个判断条件 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; catch (Throwable t) &#123; cancelAcquire(node); throw t; &#125;&#125; 当线程2仍无法获取到锁时，会调用 shouldParkAfterFailedAcquire &amp;&amp; parkAndCheckInterrupt 进行判断，是否进行阻塞 shouldParkAfterFailedAcquire 1234567891011121314151617 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //第一次这个waitStatus是h的waitStatus，很明显是0，第二次为-1，会返回true int s = pred.waitStatus; if (s &lt; 0) return true; if (s &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else //把h的waitStatus设置为Noed.SIGNAL即-1并返回false compareAndSetWaitStatus(pred, 0, Node.SIGNAL); return false;&#125; parkAndCheckInterrupt 1234567891011private final boolean parkAndCheckInterrupt() &#123; //阻塞住了当前的线程 LockSupport.park(this); return Thread.interrupted();&#125;public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); unsafe.park(false, 0L); setBlocker(t, null);&#125; tryLock 在上面的代码中可以看到，tryLock 会执行 tryAcquireNanos 函数 123456789101112131415161718192021final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread();//由于state是volatile的，所以state对线程2具有可见性，线程2拿到最新的state int c = getState(); //再次判断一下能否持有锁（可能线程1同步代码执行得比较快，这会儿已经释放了锁） if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //判断当前线程和持有锁的线程是否相同 //让某个线程可以多次调用同一个ReentrantLock，每调用一次给state+1，由于某个线程已经持有了锁，所以这里不会有竞争，因此不需要利用CAS设置state（相当于一个偏向锁*）。从这段代码可以看到，nextc每次加1，当nextc&lt;0的时候抛出error，那么同一个锁最多能重入Integer.MAX_VALUE次 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 上面部分是加锁部分，接下来看看解锁部分 unlock123public void unlock() &#123; sync.release(1);&#125; release 函数会调用到 AbstractQueuedSynchronizer 中的 release会调用 tryRelease 进行判断 1234567891011121314public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 但是 tryRelease 会直接抛出异常，也就是说，会调用子类中的 tryRelease 函数 tryRelease 函数为何不写成抽象函数？ tryRelease123456789101112131415161718protected final boolean tryRelease(int releases) &#123; //每次执行该方法，state都会减1 int c = getState() - releases; //判断当前线程和持有锁的线程是否相等，不相等抛异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 只有当c==0的时候才会让free=true，这和上面一个线程多次调用lock方法累加state是对应的， // 调用了多少次的lock()方法自然必须调用同样次数的unlock()方法才行，这样才把一个锁给全部解开 // 同一个线程可能持有多次锁 if (c == 0) &#123; free = true; //设置占有锁的线程为空 setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 当返回 free 为 true 时，release 函数中会执行 unparkSuccessor() 函数 1234567891011121314151617181920 private void unparkSuccessor(Node node) &#123; //下一个Node，也就是线程2 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //等待队列不为空，执行unPark if (s != null) LockSupport.unpark(s.thread);&#125;// LockSupport.unparkpublic static void unpark(Thread thread) &#123; if (thread != null) //jvm进行实现 UNSAFE.unpark(thread);&#125; 锁被解了怎样保证整个FIFO队列减少一个Node，回到了AQS的acquireQueued方法了 回到上面讲过的未获取到锁的线程被阻塞的 acquireQueued 函数中： 12345678910111213141516171819202122final boolean acquireQueued(final Node node, int arg) &#123; try &#123; boolean interrupted = false; //死循环： for (;;) &#123; final Node p = node.predecessor(); //再次判断一下线程2能不能获取锁（可能这段时间内线程1已经执行完了把锁释放了，state变为了0） if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC return interrupted; &#125; //不能，则调用AQS的shouldParkAfterFailedAcquire(p, node)方法，第一次会得到false,继续循环，第二次才会走第二个判断条件 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; catch (Throwable t) &#123; cancelAcquire(node); throw t; &#125;&#125; 被阻塞的线程2是被阻塞了，但是此处并没有return语句，所以，阻塞完成线程2依然会进行for循环。 然后，阻塞完成了，线程2所在的Node的前驱Node是p，线程2尝试tryAcquire，成功，然后线程2就成为了head节点了，把p的next设置为null，这样原头Node里面的所有对象都不指向任何块内存空间，h属于栈内存的内容，方法结束被自动回收，这样随着方法的调用完毕，原头Node也没有任何的引用指向它了，这样它就被GC自动回收了。此时，遇到一个return语句，acquireQueued方法结束 setHead 12345private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125; setHead方法里面的前驱Node是Null，也没有线程，那么为什么不用一个在等待的线程作为Head Node呢？ 因为一个线程随时有可能因为中断而取消，而取消的话，Node自然就要被GC了，那GC前必然要把头Node的后继Node变为一个新的头而且要应对多种情况，这样就很麻烦。用一个没有thread的Node作为头，相当于起了一个引导作用，因为head没有线程，自然也不会被取消。 从尾到头遍历，找出离head最近的一个node，对这个node进行unPark操作。 个人解读： 因为不知道之前被阻塞的线程会处于何种状态，直接让链表中下一个节点获取锁，可能会发生一些异常。所以直接只释放锁，让各个线程再次抢占，这也是非公平锁的原理。锁释放时，不是直接在阻塞链表中取下一个节点的线程，而且所有节点再次抢占，甚至可能让最新进来的线程获取到锁 ReentrantLock 中的其他函数 getHoldCount 获取state值 获取到state值，也就知道了锁的状态123final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0;&#125; getOwner 获取占有锁的线程 1234//获取当前占有锁的线程，就是AbstractOwnableSynchronizer中exclusiveOwnerThread的值final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread();&#125; getQueuedThreads 获取所有阻塞的线程 12345678910//从尾到头遍历一下，添加进ArrayList(等待队列)中public final Collection&lt;Thread&gt; getQueuedThreads() &#123; ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node p = tail; p != null; p = p.prev) &#123; Thread t = p.thread; if (t != null) list.add(t); &#125; return list;&#125; 死锁问题如何出现死锁 多个线程获取多个锁，形成了循环依赖锁，导致死锁 线程A获取到锁1，并尝试获取锁2。 线程B获取到锁2，并尝试获取锁1。 线程A获取到锁1时，锁2已经被线程B获取。 此时就形成了死锁 测试的线程类 12345678910111213141516171819202122232425class TestDeadLock(var flag: Boolean, var any1: Any, var any2: Any) : Runnable &#123; override fun run() &#123; if(flag) &#123; synchronized(any1) &#123; println("$&#123;flag&#125; 线程: 获取到any1的锁") Thread.sleep(1000) synchronized(any2) &#123; println("$&#123;flag&#125; 线程: 获取到any2的锁") &#125; &#125; &#125; else &#123; synchronized(any2) &#123; println("$&#123;flag&#125; 线程: 获取到any2的锁") Thread.sleep(1000) synchronized(any1) &#123; println("$&#123;flag&#125; 线程: 获取到any1的锁") &#125; &#125; &#125; println("$&#123;flag&#125; 线程: 未出现死锁!!!") &#125;&#125; 多个线程调用锁的地方 123456789binding.deadLock.setOnClickListener &#123; val any1 = Any() val any2 = Any() val thread1: Thread = Thread(TestDeadLock(true, any1, any2)) val thread2: Thread = Thread(TestDeadLock(false, any1, any2)) thread1.start() thread2.start() &#125; 最后可以发现， “未出现死锁!!!” 这一句输出永远不会出现，因为此时已经死锁 如何避免 synchronized 锁的对象保持顺序一致， 如上面示例，将 else 中 any2 与 any1 顺序对调以下即可避免死锁 lock 锁的顺序保持一致]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP详解]]></title>
    <url>%2Fblog%2F2022%2F07%2FHTTP%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[HTTP: HyperText Transfer Protocol,超文本传输协议，属于应用层 参考地址：https://www.jianshu.com/p/a6d086a3997d 1.简介 2.工作方式 HTTP协议采用 请求 / 响应 的工作方式 3.HTTP报文详解 HTTP在 应用层 交互数据的方式 = 报文 HTTP的报文分为：请求报文 &amp; 响应报文 分别用于 发送请求 &amp; 响应请求时 3.1 请求报文3.1.1 报文结构 HTTP的请求报文由 请求行、请求头 &amp; 请求体 组成，如下图 3.1.2 结构详细介绍组成1：请求行 作用：声明 请求方法 、主机域名、资源路径 &amp; 协议版本 结构：请求行的组成 = 请求方法 + 请求路径 + 协议版本 注：空格不能省 此处特意说明GET、PSOT方法的区别： 示例: 设：请求报文采用GET方法、 URL地址 = http://www.tsinghua.edu.cn/chn/yxsz/index.htm；、HTTP1.1版本 则请求行是：GET /chn/yxsz/index.htm HTTP/1.1 组成2：请求头 作用：声明 客户端、服务器 / 报文的部分信息 使用方式：采用”header（字段名）：value（值）“的方式 常用请求头1. 请求和响应报文的通用Header 2. 常见请求Header 举例：(URL地址：http://www.tsinghua.edu.cn/chn/yxsz/index.htm）Host：www.tsinghua.edu.cn (表示主机域名）User - Agent：Mozilla/5.0 (表示用户代理是使用Netscape浏览器） 组成3：请求体 作用：存放 需发送给服务器的数据信息 可选部分，如 GET请求就无请求数据 使用方式：共3种 至此，关于请求报文的请求行、请求头、请求体 均讲解完毕。 3.1.3 总结 关于 请求报文的总结如下 请求报文示例]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ip地址详解]]></title>
    <url>%2Fblog%2F2022%2F07%2Fip%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[参考地址：https://blog.csdn.net/qq_42499737/article/details/118859015 IP地址是一个唯一标识，是一段网络编码（二进制），由32位组成的，它为互联网上的每一个网络和每一台主机分配一个逻辑地址 常见的IP地址 IPv4 IPv6 IP地址的形式： x.x.x.x 每个X的范围：0-255 IP地址对应于OSI参考模型的第三层 网络层，对应TCP/IP体系结构中第二层网际层工作在网络层的路由器根据目标IP和源IP来判断是否属于同一网段，如果是不同网段，则转发数据包。 IP地址格式 &amp; 表示 在计算机二进制中，1个字节 = 8位 = 8bit（比特） IP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）每一段8位二进制，中间使用英文的标点符号“.”隔开 由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。 IP地址表示为：xxx.xxx.xxx.xxx IP地址的这种表示法叫做“点分十进制表示法”。举例： 210.21.196.6就是一个IP地址的表示。 子网掩码 局域网通信规则： 在同一个局域网中所有的IP必须在同一网段中才可以互相通信； IP地址构成： 网络位+主机位（网络位相同的地址才能称为同一个网段） 子网掩码： 用来确定主机位，常见的有三种： 255.0.0.0 255.255.0.0 255.255.255.0 例如： 10.1.1.1 255.255.255.0 这个网段是10.1.1 网段，名字叫.1 10.1.1.1 255.0.0.0 这个的网段是10. 名字叫.1.1.1 IP地址详解 国际标准组织ISO定义地址分类：五大类（以IP地址的第一位来进行区分的，与后三位没有关系） A类： 1-126 默认子网掩码 255.0.0.0 B类： 128-191 默认子网掩码 255.255.0.0 C类： 192-223 默认子网掩码 255.255.255.0 D类： 224-239 组播地址 E类： 240-254 科研使用 192.168.1.64 C类 因为第一位为192 处于 192-223 区间，所以是C类 ，网段就是 192.168.1 名字是 110.1.1.8 A类 因为第一位为10 处于 1-126 区间，所以是A类， 网段是 10. 名字叫 .1.1.8 A类地址： A类地址范围：1.0.0.0 - 126.255.255.255，其中0和127作为特殊地址。 A类网络默认子网掩码为255.0.0.0，也可写作/8。 A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址）。 在计算机网络中，主机ID全部为0的地址为网络地址，而主机ID全部为1的地址为广播地址，这2个地址是不能分配给主机用的 B类地址： B类地址第1字节（最高位固定是10）和第2字节为网络地址，另外2个字节为主机地址。 B类地址范围：128.0.0.0 - 191.255.255.255。 B类网络默认子网掩码为255.255.0.0，也可写作/16。 B类网络最大主机数量256×256-2=65534。 C类地址 C类地址第1字节（最高位固定是110）、第2字节和第3个字节，另外1个字节为主机地址。 C类地址范围：192.0.0.0 - 223.255.255.255。 C类网络默认子网掩码为255.255.255.0，也可写作/24。 C类网络最大主机数量256-2=254。 D类地址 D类地址不分网络地址和主机地址，它的第1个字节的最高位固定是1110。 D类地址用于组播（也称为多播）的地址，无子网掩码。 D类地址范围：224.0.0.0 - 239.255.255.255。 E类地址： E类地址也不分网络地址和主机地址，它的第1个字节的最高位固定是11110。 E类地址范围：240.0.0.0 - 255.255.255.255。 其中240.0.0.0-255.255.255.254作为保留地址，主要用于Internet试验和开发，255.255.255.255作为广播地址。 特殊IP地址以下这些特殊IP地址都是不能分配给主机用的地址： 主机ID全为0的地址：特指某个网段，比如：192.168.10.0 255.255.255.0，指192.168.10.0网段。 主机ID全为1的地址：特指该网段的全部主机，比如：192.168.10.255，如果你的计算机发送数据包使用主机ID全是1的IP地址，数据链层地址用广播地址FF-FF-FF-FF-FF-FF。 127.0.0.1：是本地环回地址，指本机地址，一般用来测试使用。回送地址(127.x.x.x)是本机回送地址(Loopback Address)，即主机IP堆栈内部的IP地址。 169.254.0.0：169.254.0.0-169.254.255.255实际上是自动私有IP地址。 0.0.0.0：如果计算机的IP地址和网络中的其他计算机地址冲突，使用ipconfig命令看到的就是0.0.0.0，子网掩码也是0.0.0.0。 问题问题一10.1.1.1255.255.255.0 10.1.1.1属于哪个网段，有多少可用IP地址？ 答： 10.1.1.1属于10.1.1.0网段10.1.1.0网段可用IP地址范围： 10.1.1.1-10.1.1.25410.1.1.0 网段的广播地址： 10.1.1.255 问题二10.1.1.1255.255.0.010.1.1.1属于哪个网段，有多少可用IP地址？ 答：答： 10.1.1.1属于10.1.0.0网段10.1.0.0网段可用IP地址范围： 10.1.0.1-10.1.255.254（65534）10.1.0.0 网段的广播地址： 10.1.255.255]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket详解]]></title>
    <url>%2Fblog%2F2022%2F07%2FSocket%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[Socket在网络通信中扮演及其重要的角色 1、定义 即套接字，是应用层 与 TCP/IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API） Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）即：通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信 成对出现，一对套接字： 1Socket =&#123;(IP地址1:PORT端口号)，(IP地址2:PORT端口号)\&#125; 一个 Socket 实例 唯一代表一个主机上的一个应用程序的通信链路 2、原理Socket的使用类型主要有两种： 流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务 数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务 具体原理图如下： 3、Socket建立连接过程 4、Socket 与 Http 对比 Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题 HTTP协议 属于 应用层，解决的是如何包装数据 由于二者不属于同一层面，所以本来是没有可比性的。但随着发展，默认的Http里封装了下面几层的使用，所以才会出现Socket &amp; HTTP协议的对比：（主要是工作方式的不同）： Http：采用 请求—响应 方式。 即建立网络连接后，当 客户端 向 服务器 发送请求后，服务器端才能向客户端返回数据。 可理解为：是客户端有需要才进行通信 Socket：采用 服务器主动发送数据 的方式 即建立网络连接后，服务器可主动发送消息给客户端，而不需要由客户端向服务器发送请求 可理解为：是服务器端有需要才进行通信 5.使用 Socket可基于TCP或者UDP协议，但TCP更加常用 所以下面的使用步骤 &amp; 实例的Socket将基于TCP协议 在客户端使用示例：https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/socket Socket源码解读建立连接过程当Socket实例创建完毕时，TCP三次握手就已完成，代表实例已创建。 客户端创建实例：1socket = Socket("192.168.101.130", 3333) 看一下Socket构造函数 123456public Socket(String host, int port) throws UnknownHostException, IOException &#123; // Android-changed: App compat. Socket ctor should try all addresses. http://b/30007735 this(InetAddress.getAllByName(host), port, (SocketAddress) null, true); &#125; 这里会把传入的主机域名解析成 ip地址集合，然后调用另一个构造函数 12345678910111213141516171819202122232425262728293031323334353637383940private Socket(InetAddress[] addresses, int port, SocketAddress localAddr, boolean stream) throws IOException &#123; if (addresses == null || addresses.length == 0) &#123; // 当ip解析为空时，抛出异常 throw new SocketException("Impossible: empty address list"); &#125; for (int i = 0; i &lt; addresses.length; i++) &#123; setImpl(); try &#123; InetSocketAddress address = new InetSocketAddress(addresses[i], port); createImpl(stream); if (localAddr != null) &#123; bind(localAddr); &#125; connect(address); break; &#125; catch (IOException | IllegalArgumentException | SecurityException e) &#123; try &#123; // Android-changed: Let ctor call impl.close() instead of overridable close(). // Subclasses may not expect a call to close() coming from this constructor. impl.close(); closed = true; &#125; catch (IOException ce) &#123; e.addSuppressed(ce); &#125; // Only stop on the last address. if (i == addresses.length - 1) &#123; throw e; &#125; &#125; // Discard the connection state and try again. impl = null; created = false; bound = false; closed = false; &#125; &#125; 可以看到，在此处的逻辑中，最主要只有如下四个函数 setImpl() createImpl(stream) bind(localAddr) connect(address) 再对以上四个函数进行逐一分析 先看一下 SocketImpl 及其子类的UML类图 setImpl123456789101112void setImpl() &#123; if (factory != null) &#123; impl = factory.createSocketImpl(); checkOldImpl(); &#125; else &#123; // No need to do a checkOldImpl() here, we know it's an up to date // SocketImpl! impl = new SocksSocketImpl(); &#125; if (impl != null) impl.setSocket(this);&#125; factory 默认为空，除非 通过调用 setSocketImplFactory 手动实现自己的 SocketImplFactory 所以此处的 impl = new SocksSocketImpl(); createImpl(stream)12345678910void createImpl(boolean stream) throws SocketException &#123; if (impl == null) setImpl(); try &#123; impl.create(stream); created = true; &#125; catch (IOException e) &#123; throw new SocketException(e.getMessage()); &#125;&#125; 上面说了 impl = new SocksSocketImpl();但 SocksSocketImpl 中并没有实现 create 函数， SocksSocketImpl 是继承自 PlainSocketImpl，而 PlainSocketImpl，而 中也没有实现 create 函数,而 PlainSocketImpl 又是继承自 AbstractPlainSocketImpl 也就是说最终是调用的 AbstractPlainSocketImpl 中的 create AbstractPlainSocketImpl create12345678910111213141516171819202122232425262728293031// stream = trueprotected synchronized void create(boolean stream) throws IOException &#123; this.stream = stream; if (!stream) &#123; ResourceManager.beforeUdpCreate(); // Android-removed: socketCreate should set fd if it succeeds. // fd = new FileDescriptor(); try &#123; socketCreate(false); &#125; catch (IOException ioe) &#123; ResourceManager.afterUdpClose(); // Android-changed: Closed sockets use an invalid fd, not null. b/26470377 // fd = null; throw ioe; &#125; &#125; else &#123; // Android-removed: socketCreate should set fd if it succeeds. // fd = new FileDescriptor(); socketCreate(true); &#125; if (socket != null) socket.setCreated(); if (serverSocket != null) serverSocket.setCreated(); // Android-added: CloseGuard. if (fd != null &amp;&amp; fd.valid()) &#123; guard.open("close"); &#125; &#125; 此处会调用 socketCreate 但 该函数是一个抽象函数，查看子类是否有实现， 在 类中，实现了该函数 1234567891011void socketCreate(boolean isStream) throws IOException &#123; // The fd object must not change after calling bind, because we rely on this undocumented // behaviour. See libcore.java.net.SocketTest#testFileDescriptorStaysSame. fd.setInt$(IoBridge.socket(AF_INET6, isStream ? SOCK_STREAM : SOCK_DGRAM, 0).getInt$()); IoUtils.setFdOwner(fd, this); if (serverSocket != null) &#123; IoUtils.setBlocking(fd, false); IoBridge.setSocketOption(fd, SO_REUSEADDR, true); &#125; &#125; 上次的调用还只是 生成一个 SocketImpl 的实例对象 接下来查看 bind 函数 bind123456789101112131415161718192021222324public void bind(SocketAddress bindpoint) throws IOException &#123; if (isClosed()) throw new SocketException("Socket is closed"); if (!oldImpl &amp;&amp; isBound()) throw new SocketException("Already bound"); if (bindpoint != null &amp;&amp; (!(bindpoint instanceof InetSocketAddress))) throw new IllegalArgumentException("Unsupported address type"); InetSocketAddress epoint = (InetSocketAddress) bindpoint; if (epoint != null &amp;&amp; epoint.isUnresolved()) throw new SocketException("Unresolved address"); if (epoint == null) &#123; epoint = new InetSocketAddress(0); &#125; InetAddress addr = epoint.getAddress(); int port = epoint.getPort(); checkAddress (addr, "bind"); SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkListen(port); &#125; getImpl().bind (addr, port); bound = true; &#125; getImpl().bind (addr, port);也就是说最终会调用到 AbstractPlainSocketImpl 中的 bind 函数 1234567891011121314protected synchronized void bind(InetAddress address, int lport) throws IOException &#123; synchronized (fdLock) &#123; if (!closePending &amp;&amp; (socket == null || !socket.isBound())) &#123; NetHooks.beforeTcpBind(fd, address, lport); &#125; &#125; socketBind(address, lport); if (socket != null) socket.setBound(); if (serverSocket != null) serverSocket.setBound(); &#125; 与 create 函数类似，此处也会调用一个抽象函数， socketBind(address, lport); 该函数的实现在 PlainSocketImpl 类中 1234567891011121314151617// PlainSocketImplvoid socketBind(InetAddress address, int port) throws IOException &#123; if (fd == null || !fd.valid()) &#123; throw new SocketException("Socket closed"); &#125; IoBridge.bind(fd, address, port); this.address = address; if (port == 0) &#123; // Now that we're a connected socket, let's extract the port number that the system // chose for us and store it in the Socket object. localport = IoBridge.getLocalInetSocketAddress(fd).getPort(); &#125; else &#123; localport = port; &#125; &#125; bind 函数的主要作用应该是 绑定 地址、端口、fd(FileDescriptor) connectconnect 过程代表的是 TCP 建立连接过程中的 第一次握手 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void connect(SocketAddress endpoint) throws IOException &#123; connect(endpoint, 0); &#125;public void connect(SocketAddress endpoint, int timeout) throws IOException &#123; if (endpoint == null) throw new IllegalArgumentException("connect: The address can't be null"); if (timeout &lt; 0) throw new IllegalArgumentException("connect: timeout can't be negative"); if (isClosed()) throw new SocketException("Socket is closed"); if (!oldImpl &amp;&amp; isConnected()) throw new SocketException("already connected"); if (!(endpoint instanceof InetSocketAddress)) throw new IllegalArgumentException("Unsupported address type"); InetSocketAddress epoint = (InetSocketAddress) endpoint; InetAddress addr = epoint.getAddress (); int port = epoint.getPort(); checkAddress(addr, "connect"); SecurityManager security = System.getSecurityManager(); if (security != null) &#123; if (epoint.isUnresolved()) security.checkConnect(epoint.getHostName(), port); else security.checkConnect(addr.getHostAddress(), port); &#125; if (!created) createImpl(true); if (!oldImpl) impl.connect(epoint, timeout); else if (timeout == 0) &#123; if (epoint.isUnresolved()) impl.connect(addr.getHostName(), port); else impl.connect(addr, port); &#125; else throw new UnsupportedOperationException("SocketImpl.connect(addr, timeout)"); connected = true; /* * If the socket was not bound before the connect, it is now because * the kernel will have picked an ephemeral port &amp; a local address */ bound = true; &#125; 此处会调用 impl.connect(addr, port); 最终实现在 AbstractPlainSocketImpl 类中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566protected void connect(String host, int port) throws UnknownHostException, IOException &#123; boolean connected = false; try &#123; InetAddress address = InetAddress.getByName(host); this.port = port; this.address = address; connectToAddress(address, port, timeout); connected = true; &#125; finally &#123; if (!connected) &#123; try &#123; close(); &#125; catch (IOException ioe) &#123; /* Do nothing. If connect threw an exception then it will be passed up the call stack */ &#125; &#125; &#125; &#125;private void connectToAddress(InetAddress address, int port, int timeout) throws IOException &#123; if (address.isAnyLocalAddress()) &#123; doConnect(InetAddress.getLocalHost(), port, timeout); &#125; else &#123; doConnect(address, port, timeout); &#125; &#125;synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException &#123; synchronized (fdLock) &#123; if (!closePending &amp;&amp; (socket == null || !socket.isBound())) &#123; NetHooks.beforeTcpConnect(fd, address, port); &#125; &#125; try &#123; acquireFD(); try &#123; // Android-added: BlockGuard. BlockGuard.getThreadPolicy().onNetwork(); socketConnect(address, port, timeout); /* socket may have been closed during poll/select */ synchronized (fdLock) &#123; if (closePending) &#123; throw new SocketException ("Socket closed"); &#125; &#125; // If we have a ref. to the Socket, then sets the flags // created, bound &amp; connected to true. // This is normally done in Socket.connect() but some // subclasses of Socket may call impl.connect() directly! if (socket != null) &#123; socket.setBound(); socket.setConnected(); &#125; &#125; finally &#123; releaseFD(); &#125; &#125; catch (IOException e) &#123; close(); throw e; &#125; &#125; 会调用到 socketConnect 函数， 该函数又是抽象函数， 会调用到 PlainSocketImpl 中的 socketConnect 12345678910111213141516171819void socketConnect(InetAddress address, int port, int timeout) throws IOException &#123; if (fd == null || !fd.valid()) &#123; throw new SocketException("Socket closed"); &#125; IoBridge.connect(fd, address, port, timeout); this.address = address; this.port = port; if (localport == 0) &#123; // If socket is pending close, fd becomes an AF_UNIX socket and calling // getLocalInetSocketAddress will fail. // http://b/34645743 if (!isClosedOrPending()) &#123; localport = IoBridge.getLocalInetSocketAddress(fd).getPort(); &#125; &#125; &#125; 此时，TCP连接中第一次握手完成，会发送一个 连接请求 报文段到服务端，报文段中首部信息：SYN = 1， 并随机一个起始序号 x， seq = x；不携带数据， 客户端进入 SYN_SENT 状态]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议详解]]></title>
    <url>%2Fblog%2F2022%2F07%2FTCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[参考地址：https://www.jianshu.com/p/65605622234b 1.定义Transmission Control Protocol，即 传输控制协议 属于 传输层通信协议 基于TCP的应用层协议有HTTP、SMTP、FTP、Telnet 和 POP3 位于TCP/IP协议体系结构中的第三层 传输层 2.特点 面向连接 使用TCP协议传输数据前，必须先建立TCP连接 全双工通信 通信双方都可以发送数据 可靠 不丢失、无差错、不重复、按序到达 面向字节流 一次传输的报文段有长度限制，可分块、分次传输 3.优缺点 优点： 可靠，不丢失 缺点： 效率低，因为每次使用都要建立连接 4.报文段格式 TCP虽面向字节流，但传送的数据单元 = 报文段 报文段 = 首部 + 数据 2部分 TCP的全部功能体现在它首部中各字段的作用，故下面主要讲解TCP报文段的首部 首部前20个字符固定、后面有4n个字节是根据需而增加的选项故 TCP首部最小长度 = 20字节 5.TCP连接建立过程 TCP协议建立需要经过 三次握手 第一次握手：客户端发送一个 连接请求 报文段到服务端，报文段中首部信息：SYN = 1， 并随机一个起始序号 x， seq = x；不携带数据， 客户端进入 SYN_SENT 状态 第二次握手：服务端接收到连接请求报文段，，也向客户端发送一个 连接确认 的报文段，报文段中首部信息：SYN = 1，ACK = 1，并随机一个起始序号 y， seq = y，确认号字段，ack = x + 1；不携带数据，服务端进入 SYN_RCVD 状态 第三次握手：客户端收到服务端发送的连接确认报文段，再向服务端发送一个 连接确认 的报文段，报文段首部信息：ACK = 1，seq = x + 1， ack = y + 1，因无SYN = 1，此报文段可携带数据.此时，客户端与服务端都进入ESTABLISHED状态 成功进行TCP的三次握手后，就建立起一条TCP连接，即可传送应用层数据 因 TCP提供的是全双工通信，故通信双方的应用进程在任何时候都能发送数据 三次握手期间，任何1次未收到对面的回复，则都会重发 特别说明：为什么TCP建立连接需三次握手？ answer: 防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源 具体描述 SYN洪泛攻击： 从上可看出：服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时这就使得服务器易于受到SYN洪泛攻击，即同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配 6.释放连接过程在通信结束后，需要释放TCP连接，需经历四次挥手过程，才能断开连接 四次挥手 第一次挥手，客户端向服务端发送一个 释放连接 的报文段，报文段信息：FIN = 1，seq = u，客户端进入 FIN_WAIT_1 状态 第二次挥手，服务端收到客户端发送的释放连接的请求报文，想客户端发送一个 连接释放确认 报文段，报文段信息： ACK = 1，seq = v，ack = u + 1， 服务端进入 CLOSE_WAIT 状态。此时，客户端 -&gt; 服务端的连接已断开，TCP连接处于半关闭状态 第三次挥手，服务端向客户端再发送一个 释放连接 的报文段，报文段信息：FIN= 1， ACK = 1，seq = w，ack = u + 1；服务端进入 LAST_ACK 状态 第四次挥手，客户端接收到服务端发送的释放连接报文，再向服务端发送一个 连接释放确认 报文段，报文段信息： ACK = 1，seq = u + 1，ack = w + 1。此时客户端进入 TIME_WAIT 状态，服务端进入 CLOSED 状态，此时TCP还未断开，需经过时间等待计时器设置的时间2MSL后，客户端才进入 CLOSED 状态，即服务端比客户端先关闭 特别说明：为什么TCP释放连接需四次挥手？ 结论 为了保证通信双方都能通知对方 需释放 &amp; 断开连接 即释放连接后，都无法接收 / 发送消息给对方 具体描述 延伸疑问：为什么客户端关闭连接前要等待2MSL时间？ 即 TIME - WAIT 状态的作用是什么；MSL = 最长报文段寿命（Maximum Segment Lifetime） 原因1：为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接 原因2：防止 上文提到的早已失效的连接请求报文 出现在本连接中客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失 即 在下1个新的连接中就不会出现早已失效的连接请求报文 7.无差错传输 对比于UDP，TCP的传输是可靠的、无差错的 那么，为什么TCP的传输为什么是可靠的、无差错的呢？ 下面，我将详细讲解TCP协议的无差错传输 含义 无差错：即 传输信道不出差错 发送 &amp; 接收效率匹配：即 无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据 基础：滑动窗口 协议 先理解2个基础概念：发送窗口、接收窗口 工作原理 对于发送端： 1、每收到一个确认帧，发送窗口就向前滑动一个帧的距离 2、当发送窗口内无可发送的帧时（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送 具体如下图： 只有收到服务端发送的确认帧，才会继续发送数据帧，否则停止发送 对于接收端：当收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。 也就是说，只有确保当前的数据帧是准确位置窗口的，否则丢弃 总的流程： 1、客户端向服务端发送数据帧 2、服务端接收数据帧，并判断该数据帧是否属于当前接收窗口，如果不是，则丢弃该数据帧。如果是，则放入该接收窗口，并右移，然后向客户端发送确认帧 3、客户端接收到确认帧，并检查发出的数据帧是否都收到确认帧，如果没有，则等待接收确认帧。如果都收到确认帧，则又从第1步开始。 滑动窗口 协议的重要特性 只有接收窗口向前滑动、接收方发送了确认帧时，发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动 停止-等待协议、后退N帧协议 &amp; 选择重传协议只是在发送窗口大小和接收窗口大小上有所差别： 停止等待协议：发送窗口大小=1，接收窗口大小=1；即 单帧滑动窗口 等于 停止-等待协议后退N帧协议：发送窗口大小&gt;1，接收窗口大小=1。选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1。 当接收窗口的大小为1时，可保证帧有序接收。 数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意要与TCP的滑动窗口协议区别） 实现无差错传输的解决方案核心思想：采用一些可靠传输协议，使得 出现差错时，让发送方重传差错数据：即 出错重传 当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率：即 速度匹配 针对上述2个问题，分别采用的解决方案是：自动重传协议 和 流量控制 &amp; 拥塞控制协议 解决方案1：自动重传请求协议ARQ（针对 出错重传） 定义 即 Auto Repeat reQuest，具体介绍如下： 类型 下面，将主要讲解 上述3类协议 类型1：停等式ARQ（Stop-and-Wait） 原理：（单帧滑动窗口）停止 - 等待协议 + 超时重传 即 ：发送窗口大小=1、接收窗口大小=1 停止 - 等待协议的协议原理如下： 发送方每发送一帧，要等到接收方的应答信号后才能发送下一帧接收方每接收一帧，都要反馈一个应答信号，表示可接下一帧若接收方不反馈应答信号，则发送方必须一直等待 类型2：后退N帧协议也称：连续ARQ协议 原理 多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传 即 ：发送窗口大小&gt;1、接收窗口大小=1 具体描述 a. 发送方：采用多帧滑动窗口的原理，可连续发送多个数据帧 而不需等待对方确认b. 接收方：采用 累计确认 &amp; 后退N帧的原理，只允许按顺序接收帧。具体原理如下： 示例讲解 本示例 = 源站 向 目的站 发送数据帧。具体示例如下： 类型3：选择重传ARQ（Selective Repeat） 原理 多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传 即 ：发送窗口大小&gt;1、接收窗口大小&gt;1 类似于类型2（后退N帧协议），此处仅仅是接收窗口大小的区别，故此处不作过多描述 特点 a. 优：因连续发送数据帧而提高了信道的利用率 b. 缺：重传时又必须把原来已经传送正确的数据帧进行重传（仅因为这些数据帧前面有一个数据帧出了错），将导致传送效率降低 由此可见，若信道传输质量很差，导致误码率较大时，后退N帧协议不一定优于停止-等待协议 解决方案2：流量控制 &amp; 拥塞控制（针对 速度匹配） 措施1：流量控制 简介 示例 特别注意：死锁问题 措施2：拥塞控制 * 定义 防止过多的数据注入到网络中，使得网络中的路由器 &amp; 链路不致于过载 拥塞：对网络中的资源需求 &gt; 该资源所能提供的部分 与 “流量控制”的区别 具体解决方案 共分为2个解决方案：慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复 其中，涉及4种算法，即 慢开始 &amp; 拥塞避免、快重传 &amp; 快恢复 解决方案1：慢开始 &amp; 拥塞避免储备知识：拥塞窗口、慢开始算法、拥塞避免算法a. 拥塞窗口 发送方维持一个状态变量：拥塞窗口（cwnd， congestion window ），具体介绍如下 b. 慢开始算法 原理 当主机开始发送数据时，由小到大逐渐增大 拥塞窗口数值（即 发送窗口数值），从而 由小到大 逐渐增大发送报文段 目的 开始传输时，试探网络的拥塞情况 具体措施 示意图 特别注意 慢开始的“慢”指：一开始发送报文段时拥塞窗口（cwnd）设置得较小（为1），使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况） 并不是指拥塞窗口（cwnd）的增长速率慢 c. 拥塞避免 算法 原理 使得拥塞窗口（cwnd）按线性规律 缓慢增长：每经过一个往返时间RTT，发送方的拥塞窗口（cwnd）加1 拥塞避免 并不可避免拥塞，只是将拥塞窗口按现行规律缓慢增长，使得网络比较不容易出现拥塞相比慢开始算法的加倍，拥塞窗口增长速率缓慢得多 示意图 解决方案1描述（慢开始 &amp; 拥塞避免） 为了防止拥塞窗口（cwnd）增长过大而引起网络拥塞，采用慢开始 &amp; 拥塞避免 2种算法，具体规则如下 实例说明 解决方案2：快重传 &amp; 快恢复快重传 &amp; 快恢复的解决方案 是对慢开始 &amp; 拥塞避免算法的改进 2.1 储备知识：快重传算法、快恢复算法 * a. 快重传算法 原理 接收方 每收到一个失序的报文段后 就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认 发送方只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必 继续等待设置的重传计时器到期 作用 由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20% 示意图 b. 快恢复当发送方连续收到3个重复确认后，就： 执行 乘法减小 算法：把 慢开始门限（ssthresh）设置为 出现拥塞时发送方窗口值的一半 = 拥塞窗口的1半 将拥塞窗口（cwnd）值设置为 慢开始门限ssthresh减半后的数值 = 拥塞窗口的1半 执行 加法增大 算法：执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 注： 由于跳过了拥塞窗口（cwnd）从1起始的慢开始过程，所以称为：快恢复 此处网络不会发生网络拥塞，因若拥塞，则不会收到多个重复确认报文 解决方案描述（快重传 &amp; 快恢复） 原理 为了优化慢开始 &amp; 拥塞避免的解决方案，在上述方案中加入快重传 &amp; 快恢复 2种算法，具体规则如下 示意图 至此，关于TCP无差错传输的知识讲解完毕。]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2Fblog%2F2022%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[参考地址：https://www.jianshu.com/p/45d27f3e1196 1、计算机网络结构1.1 简介 定义计算机网络各层 + 其协议的集合 作用定义该计算机网络的所能完成的功能 1.2 结构计算机网络体系结构分为三种： OSI体系结构 TCP/IP体系结构 五层体系结构 OSI体系结构：概念清楚 &amp; 理念完整，但复杂 &amp; 不实用 TCP / IP体系结构：含了一系列构成互联网基础的网络协议，是Internet的核心协议 &amp; 被广泛应用于局域网 和 广域网 五层体系结构：融合了OSI 与 TCP / IP的体系结构，目的是为了学习 &amp; 讲解计算机原理 OSI体系结构(7层) TCP/IP协议体系(4层) 五层体系结构(5层) 7.应用层 4.应用层(HTTP) 5.应用层 6.表示层 5.会话层 4.传输层 3.运输层(TCP、UDP) 4.运输层 3.网络层 2. 网际层(IP) 3.网络层 2.链路层 1.网络接口层 2.链路层 1.物理层 1.物理层 低三层为通信子网，负责数据传输高三层为资源子网，相当于计算机系统，完成数据处理；传输层承上启下 TCP/IP体系结构详细介绍由于 TCP / IP体系结构较为广泛，故主要讲解 层级 作用 传输单位 功能 具体协议 1、网络接口层 负责与链路(传输媒介)的数据运输工作 帧 组帧、差错控制、流量控制和运输管理 EIA-232C、CCITT的X.21 SDLC、HDLC、PPP、STP、帧中继 2、网际层 为不同主机提供通信服务：网络层的分组数据从源端传到目的端 数据报 封装数据成分组/包、路由选择 流量控制、拥塞控制、差错控制 &amp; 网际互连 IP协议、ARP协议、RARP协议、ICMP协议、IGMP协议、IPX、OSPF 3、运输层 为不同主机进程间提供通信服务 报文段TCP、用户数据报UDP 为端到端的连接提供可靠的传输服务、流量控制、差错控制、数据传输管理服务 TCP协议、UDP协议 4、应用层 定义应用进程间通信 &amp; 交互的规则 / / HTTP协议 DNS协议 SMTP协议 POP协议 FTP协议 SMB协议 Telnet协议 SSH协议 2、TCP协议Transmission Control Protocol，即 传输控制协议 属于 传输层通信协议 基于TCP的应用层协议有HTTP、SMTP、FTP、Telnet 和 POP3 关于TCP具体信息，可以查看 TCP协议 3、UDP协议3.1 定义User Datagram Protocol，即 用户数据报协议 属于 传输层通信协议 基于UDP的应用层协议有 TFTP、SNMP 与 DNS 3.2 特定无连接的、不可靠的、面向报文、无拥塞控制，具体介绍如下： 特定 描述 无连接 使用UDP传输数据前，不需要建立UDP连接 不可靠 UDP数据包传输后，不管数据接收包是否接收到 面向报文 数据以数据报文的形式传输 无拥塞控制 由于是不可靠传输，即不考虑是否接收到数据，所以也就不需要拥塞控制 3.3 优缺点 优点：速度快 缺点：数据容易丢失 3.4 应用场景要求通信速度高 域名转换：DNS协议 文件传输：FTP协议 网络管理：SNMP协议 远程文件服务器：NFS协议 3.5 TCP &amp; UDP 的区别 类型 特点 性能 应用场景 首部字节 是否面向连接 传输可靠性 传输形式 传输效率 所需资源 TCP 面向连接 可靠 字节流 慢 多 要求通信数据可靠 20-60 UDP 无连接 不可靠 数据报文段 快 少 要求通信速度快 8字节，由4个字段组成 4、HTTP协议5、Socket6、Other6.1 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程 打开一个网页，整个过程会使用哪些协议 6.2 IP地址（IPv4地址） 定义连接在Internet中的每一台主机（或 路由器）的全球唯一的标识符 组成IP地址 = 32位 = 网络号 + 主机号；即IP地址::={&lt;网络号&gt;，&lt;主机号&gt;} 其中：网络号：标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。主机号：标志该主机（或路由器）。一个主机号在它面前的网络号所指明的网络范围必须是唯一的。 不同类型的IP地址，其主机号 &amp; 网络号所占字节数不同； 故：一个IP地址在整个网络范围内是唯一的 分类传统的IP地址是分类的地址，分为A，B，C，D，E五类 区别在于网络号 &amp; 主机号占的字节数不同 6.3 ICMP协议 定义Internet Control Message Protocol，即 网际控制报文协议 属于IP层协议 注：ICMP报文不是高层协议，而是作为IP层数据报的数据，加上数据报首部，组成IP数据报发出去 作用更有效地转发IP数据包 &amp; 提高交付成功的机会 分类ICMP差错报告报文 &amp; ICMP询问报文 主要应用PING（分组网间探测）、Traceroute（跟踪1个分组从源点到终点的路径，原理 = 从源主机向目的主机发送一连串的IP数据报） 6.4 Ping的过程 定义Packet InterNet Groper，即分组网间探测 是 ICMP报文的1个重要应用：使用了IPCM回送请求 &amp; 回送回答报文 是应用层直接使用网络层ICMP的1个例子，无经过传输层的TCP、UDP 作用测试2个主机的连通性 原理 向目的主机发送多个ICMP回送请求报文 根据 目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间 最终显示的结果：发送到目的主机的IP地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大 &amp; 平均值]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计语言]]></title>
    <url>%2Fblog%2F2022%2F07%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80.html</url>
    <content type="text"><![CDATA[计算机语言分为高级语言、低级语言 语言越低级，离01代码越近，中间“翻译”的步骤也就越简洁，计算机执行的越快，对计算机很友好； 语言越高级，封装程度就越高，人类就可以用更少的代码来实现功能。编写高级语言并不需要知道他是怎么转换为计算机识别的语言； 越高级，就越”龟速”，能做的事情也就越少，但同样代码量也比较少。 低级与高级，省时间与省力气的关系。人写的代码少了，CPU处理的代码就多，。 低级：机器码，汇编，Base语言 次低级：C，C++ 高级：Java，C# 更高级：Python，PHP，JavaScript 高级语言一般为解释型语言： 在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。 最典型的代表语言为JavaScript、Python、Ruby和Perl等 低级语言一般为编译型语言： 运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。 最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件 编译型： 运行前先由编译器将高级语言代码编译为对应机器的cpu汇编指令集，再由汇编器汇编为目标机器码，生成可执行文件，然最后运行生成的可执行文件。 最典型的代表语言为C/C++，一般生成的可执行文件及.exe文件。 解释型： 在运行时由翻译器将高级语言代码翻译成易于执行的中间代码，并由解释器（例如浏览器、虚拟机）逐一将该中间代码解释成机器码并执行（可看做是将编译、运行合二为一了）。 最典型的代表语言为JavaScript、Python、Ruby和Perl等]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fblog%2F2022%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[面向对象基本概念把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形成类。类中的大多数数据，只能用本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。 面向对象的三大特征 封装 继承 多态 参考地址： https://blog.csdn.net/sugar_no1/article/details/86366714 面向对象分析与设计参考地址：https://blog.csdn.net/huangshanchun/article/details/121727557 设计模式参考地址：https://blog.csdn.net/gghhb12/article/details/124269575]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程基础知识]]></title>
    <url>%2Fblog%2F2022%2F07%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[开发模型共有9种开发模型，适用范围各不相同 瀑布模型（Waterfall Model） 瀑布模型适合应用的项目类型：需求明确 或者 二次开发 瀑布模型是结构化方法中的模型，一般应用于结构化的开发 原型模型（Prototype Model） 适合应用的项目类型：需求不明确 强调构造一个简易的系统 演化模型（Evolutionary Model） 系统的原型经过多轮调整最终形成了产品 螺旋模型（Spiral Model） 包含原型模式和瀑布模型，演化模型，它由多个模型组成 螺旋模型具有风险分析这个特征，这是其他模型所不具备的 增量模型（Incremental Model） 由原型模型的思想 + 瀑布模型的思想构成 风险低，用户会多次接触到项目的核心模块到，能尽早的发现问题并修正。 V模型 强调测试要伴随着整个软件开发的过程 需求分析阶段进行验收测试&amp;系统测试 喷泉模型（Water Fountain Model） 面向对象的，具有迭代和无间隙的特点； 快速(应用)开发（RAD）模型 RAD模型是由瀑布模型（SDLC）和构建组装模型（CBSD）组成 使用VB，Delphi，C#等可以通过拖动控件来快速实现界面地构建 构建组装模型（CBSD） 设计原则6大设计原则： 单一职责原则 对类来说，⼀个类应该只负责⼀项职责。如果⼀个类负责两个职责，可能存在职责1变化，引起职责2的变化情况。可以基于抽象逻辑，或者业务逻辑对类进⾏细化。 接⼝隔离原则 客户端不应该依赖它不需要的接⼝，⼀个类对另外⼀个类的依赖，应该建⽴在最⼩的接⼝上。 依赖倒转原则 ⾼层模块不应该依赖低层模块，两者应依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；中⼼思想是⾯向接⼝编程。 里氏替换原则假设有以下场景： 存在类型T1，和实例对象O1 存在类型T2，和实例对象O2 如果将所有类型T1的对象都替换成类型T2的对象O2，程序的行为不会发生变化。那么类型T2是类型T1的子类型。换句话说，有引用基类的地方必须能透明的使用其子类的对象 开闭原则 开闭原则是编程中最基础、最重要的设计原则，在代码结构的设计时，应该考虑对扩展开发，对修改关闭，抽象思维搭建结构，具体实现扩展细节。 迪米特原则 迪⽶特原则⼜叫最少知道原则，即⼀个类对⾃⼰依赖的类知道的越要越好。也就是说，对于依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public⽅法，不对外开放任何信息。类与类关系越密切，耦合度越⼤，耦合的⽅式很多，依赖，关联，组合，聚合等。 测试方法参考地址：https://blog.csdn.net/weixin_43421142/article/details/108038676 质量特性参考地址：https://blog.csdn.net/shuaihj/article/details/7599528 Pert图参考地址：https://blog.csdn.net/Daisy74RJ/article/details/106593226 CMM参考地址：https://zhuanlan.zhihu.com/p/431021736 风险管理参考地址：https://blog.csdn.net/baidu_32492845/article/details/89604337 各种码原码、补码、反码参考地址：https://blog.csdn.net/lluojian/article/details/119579921 原码源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数[+127]原 = 0111 1111[-127]原 = 1111 1111数值“0”由两种原码表示形式：[+0]原 = 0000 0000[-0]原 = 1000 0000 补码源码的范围：-128 ~ +127，最高位是符号位，0表示正数，1表示负数 [+127]补 = 0111 1111[-128]补 = 1000 0000因为 [-127]反 = 1000 0000 而 [-127]补 = 反 + 1 = 1 0000001所以 [-128]补 = 1000 0000 反码源码的范围：-127 ~ +127，最高位是符号位，0表示正数，1表示负数 [+127]反 = 0111 1111[-127]反 = 1000 0000数值“0”由两种反码表示形式：[+0]反 = 0000 0000[-0]反 = 1111 1111 BCD码使用二进制来编码的十进制。分为三种： 8421码 余3码（8421码+） 2421码 8421码一种有权码，四个二进制的权值分配分别为8、4、2、1。 就是直接将10进制的每位数都转化为长度为4的二进制数，如： 0——0000 1——0001 2——0010 3——0011 4——0100 5——0101 6——0110 7——0111 8——1000 9——1001 123——0001 0010 0011（就是先把1的8421码写下来，再写2的，最后写3的） 使用8421码表示的数字怎么进行加法运算？步骤：1.二进制加法运算2.落到1010—10010非合法范围加6修正，0000—1001合法范围就不用+6修正举例：1+1 0001+ 0001 =0010 （=2）不用修正 4+7 0100+ 0111 =1011 （=11）不合法要修正 1011+0110=10001 补0 =0001 0001 9+9 1001+1001=1 0010 修正，后四位加6 0010+0110=1000 补0，结果为 0001 1000 （=18） 余3码（8421码+）0——0000+0011=0011 1——0001+0011=0100 2——0010+0011=0101 3——0011+0011=0110 4——0100+0011=0111 5——0101+0011=1000 6——0110+0011=1001 7——0111+0011=1010 8——1000+0011=1011 9——1001+0011=1100 四个二进制位的权值不固定，是无权码 2421码有权码 四个二进制权值分别为2、4、2、1 0——0000 1——0001 2——0010 3——0011 4——0100 在这里加个分隔，why？注意：0-4编码第一位是0，5-9编码第一位是1。 这又是为什么呢？避免歧义的发生！你看，0100和1010都可以表示4，这就麻烦了，所以规定0-4编码第一位是0，5-9编码第一位是1，从而使表示方法唯一！ 5——1011 6——1100 7——1101 8——1110 9——1111 进制转换10进制转为其他任意进制如十进制数 m 转换为 n 进制的数， 此时用 m 一直除以 n 并留余，除到商为0时，将 余数 从下往上排列，即为最终结果。 二进制转换为10进制如 1001 0101 1010 转换为 10进制 1001 0101 1010 从左往右排列： 0101 1010 1001 从左往右开始累加计算： 0 2^0 + 1 2^1 + 0 2^2 + 1 2^3 + 1 2^4 + 0 2^5 + ….相当于累加 当前位数n对应的值m(0 或 1) * 2^(n-1) 即为最终的结果 如上述数据 1001 0101 1010 转为 10进制为 4342 其他任意进制转为10进制与 二进制 转为 10进制类似只不过在二进制转10进制中，都是乘以2的幂等，n进制转换就是乘以n的幂等 如 9进制表示的数140 转换为 10进制 0 9^0 + 4 9^1 + 1 * 9^2 = 0 + 36 + 81 = 117 二进制转换为8、16进制 转换为8进制时，直接将数据分割为每3位一段，不足3位的在前面补0，再将每段直接转换为10进制数即可 如1110101，因只有7位，不是3的倍数，在前面补两个0，再分割。 001 110 101，再将三段转为10进制，最终结果：165 转换为16进制，直接将数据分割为每4位一段，不足4位的在前面补0，再将每段直接转换为16进制数即可 如1110101，因只有7位，不是4的倍数，在前面补1个0，再分割。 0111 0101，再将此两端都转为16进制，最终结果：75H 16进制的数可以使用H后缀、或者 0x前缀标识 75H = 0x75 二进制转换为其他进制先进二进制转为10进制，再将10进制转为其他进制 1110101 转为9进制1110101 转为10进制为 117，再将117转换为9进制，即为 140]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML图]]></title>
    <url>%2Fblog%2F2022%2F07%2FUML%E5%9B%BE.html</url>
    <content type="text"><![CDATA[UML图有可以分类为 类图 状态图 活动图 交互图-时序图 交互图-协作图 用例图 ER图 类图参考地址：https://blog.csdn.net/zhaxun/article/details/124048871 状态图参考地址： https://blog.csdn.net/zhaxun/article/details/124201040 活动图参考地址： https://blog.csdn.net/qq_41784749/article/details/112242348 交互图-时序图参考地址：https://blog.csdn.net/qq_23024699/article/details/120444441 交互图-协作图参考地址：https://blog.csdn.net/neusoft2016/article/details/116195191 时序图与协作图的区别与联系： 协作图和时序图都表示出了对象间的交互作用，但是它们侧重点不同。 时序图清楚地表示了交互作用中的时间顺序(强调时间)，但没有明确表示对象间的关系。 协作图清楚地表示了对象间的关系(强调空间)，但时间顺序必须从顺序号获得。 协作图不能体现对象的初始化和消亡的时间 协作图和时序图可以相互转化。 用例图参考地址：https://blog.csdn.net/zhaxun/article/details/124047015 ER图参考地址：https://blog.csdn.net/caohongxing/article/details/122398825]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软考-软件设计师]]></title>
    <url>%2Fblog%2F2022%2F07%2F%E8%BD%AF%E8%80%83-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88.html</url>
    <content type="text"><![CDATA[准备报考2022年下半年的软考-软件设计师， 为什么要考？ 减税 学习 考证 为什么是软件设计师？ 因为之前没有想过去考证书，这是第一次，准备先考个中级的证书试试水 中级的证书有多个，只有软件设计师稍微有点符合自己的工作岗位，能使用到自己的一些开发经验，也能起到一定的学习作用 怎么备考？ bilibili 先了解大纲 逐一学习各个知识点 写真题 大纲 软件工程基础知识 开发模型 设计原则 测试方法 质量特性 CMM, Pert图 风险管理 面向对象 面向对象基本概念 面向对象分析与设计 UML 设计模式 数据结构与算法 数组 栈 队列 树与二叉树 图 查找与排序 常见算法 程序设计语言 文法 有限自动机 正规式 语句的作用 语句的语义 程序的控制结构 函数调用的参数传递 各种程序语言的特点比较 计算机硬件基础 浮点数运算、溢出 算术、逻辑运算 计算机体系结构分类 指令系统基础 CISC与RISC 流水线 Cache存储器可靠性分析 校验方法 操作系统 进程状态转换图 信号量与PV操作 死锁问题 银行家算法 段页式存储 页面置换算法 磁盘调度 树形文件系统 数据库系统 E-R模型 关系代数 元组演算 规范化理论(键、范式、模式分解) 并发控制 计算机网络 OSI模型 TCP/IP协议族 子网划分 常用的网络命令 信息安全知识 加密解密技术 网络安全 计算机病毒 多媒体基础 多媒体基本概念 计算声音 图像 视频文件的容量 JPEG, MPEG 知识产权与标准化 作品保护时间 侵权判定 知识产权归属 标准的分类 标准代号]]></content>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减肥计划]]></title>
    <url>%2Fblog%2F2022%2F06%2F%E5%87%8F%E8%82%A5%E8%AE%A1%E5%88%92.html</url>
    <content type="text"><![CDATA[减肥大计暂时定为三个阶段，每个阶段目标均为 -5kg 第一阶段通过修改饮食，加上 低运动量减肥操 早餐两个鸡蛋+ 一杯豆浆/一杯牛奶 中餐一碗米饭 + 青菜 + 适量牛肉、虾，保证蛋白质摄入 晚餐玉米面/荞面 + 适量牛肉、虾 零食以 牛肉干、黄瓜 为准。 第二阶段通过饮食， 加上适量有氧运动， 跑步目标：75kg 第三阶段通过饮食， 加上中等有氧运动， 跑步 目标：70kg]]></content>
      <tags>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android API 更新]]></title>
    <url>%2Fblog%2F2022%2F06%2Fandroid-API-%E6%9B%B4%E6%96%B0.html</url>
    <content type="text"><![CDATA[android API 更新记录android API 30 （android11）应用文件管理权限在andorid6之后需要动态请求权限，如针对文件写入、读取权限 1234567if(checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; var permissionArray = arrayOf( Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE, ) requestPermissions(permissionArray, 101)&#125; 但是在android 11之后，这样也会弹出应用权限请求，但写入文件到sdcrd还是会失败，报错：/storage/emulated/0/io/okio.txt: open failed: ENOENT (No such file or directory) 需要修改请求权限的方式为： 12345if (!Environment.isExternalStorageManager()) &#123; var intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION); intent.setData(Uri.parse("package:" + getPackageName())); startActivityForResult(intent, 102);&#125;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO]]></title>
    <url>%2Fblog%2F2022%2F06%2Fio.html</url>
    <content type="text"><![CDATA[IOIO是什么 程序内部和外部进行数据交互的过程，就叫输入输出。 程序内部是谁?内存程序外部是谁? 一般来说是两类:本地文件和网络。也有别的情况，比如你和别的程序做交互，和你交互的程序也属于外部，但一般来说，就是文件和网络这么两种。 从文件里或者从网络上读数据到内存里，就叫输入;从内存里写到文件里或者发送到网络上，就叫输出 用法 使用流，例如 FileInputStream / FileOutputStream 可以用 Reader 和 Writer 来对字符进行读写 流的外面还可以套别的流，层层嵌套都可以 BufferedXXXX 可以给流加上缓冲。对于输入流，是每次多读一些放在内存 里面，下次再去数据就不用再和外部做交互(即不必做 IO 操作);对于输 出流，是把数据先在内存里面攒一下，攒够一波了再往外部去写。 通过缓存的方式减少和和外部的交互，从而可以提高效率 文件的关闭:close() 需要用到的写过的数据，flush() 一下可以保证数据真正写到外部去(读数据 没有这样的担忧) 这个就是 Java 的 I/O，它的原理就是内存和外界的交互 IO 又可以分为 BIO、NIO、AIO BIO、NIO、AIO 区别IO模型主要分类： 同步(synchronous)IO与异步(asynchronous)IO 阻塞(blocking)IO与非阻塞(non-blocking)IO 同步阻塞IO(blocking-IO)即为 BIO 同步非阻塞IO(non-blocking-IO)即为 NIO 异步非阻塞IO(synchronous-non-blocking-IO)即为 AIO BIO（同步阻塞I/O模式）数据的读取、写入等操作必须阻塞在一个线程内等待操作完成 NIO（同步非阻塞I/O模式）同时支持阻塞与非阻塞模式，NIO的做法是叫一个线程不断的轮询IO操作的的状态，看看是否有任务的状态发生了改变，从而进行下一步的操作。 默认是阻塞式的 AIO （异步非阻塞I/O模型）异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。 对应到IO操作中就是，为每次IO操作上面装了一个开关，IO操作完毕之后，会自动通知任务完成。 IO 与 NIO 的区别IO 面向流 NIO 面向缓冲区，具备 选择器(Selectors) 同步与异步的区别 同步 发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生。 异步 发送一个请求，不等待返回，随时可以再发送下一个请求，可以提高效率，保证并发。 阻塞与非阻塞的区别 阻塞 传统的IO流都是阻塞式的。也就是说，当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务。在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降。 非阻塞 JavaNIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。 NIO 3个核心概念 NIO重点是把Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系弄清楚。 缓冲区BufferBuffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。 在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。 缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。 最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下： ByteBuffer：字节缓冲区 CharBuffer:字符缓冲区 ShortBuffer：短整型缓冲区 IntBuffer：整型缓冲区 LongBuffer:长整型缓冲区 FloatBuffer：浮点型缓冲区 DoubleBuffer：双精度浮点型缓冲区 通道ChannelChannel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。 通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。 因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。 Channel有四种实现： FileChannel:是从文件中读取数据。 DatagramChannel:从UDP网络中读取或者写入数据。 SocketChannel:从TCP网络中读取或者写入数据。 ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。 多路复用器SelectorSelector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。 关键对象 Selector：选择器对象，通道注册、通道监听对象和Selector相关。 SelectorKey：通道监听关键字，通过它来监听通道状态。 监听注册监听注册在Selector 1socketChannel.register(selector, SelectionKey.OP_READ); 监听的事件有 OP_ACCEPT: 接收就绪，serviceSocketChannel使用的 OP_READ: 读取就绪，socketChannel使用 OP_WRITE: 写入就绪，socketChannel使用 OP_CONNECT: 连接就绪，socketChannel使用 OKIOokhttp框架中，使用的io OKio本质上是对Java的NIO的一次扩展，并且做了缓存的优化， 特点 它也是基于插管的，而且是单向的，输入源叫 Source，输出目标叫 Sink 支持 Buffer 像 NIO 一样，可以对 Buffer 进行操作 但不强制使用 Buffer]]></content>
  </entry>
  <entry>
    <title><![CDATA[jetpack hilt]]></title>
    <url>%2Fblog%2F2022%2F06%2Fjetpack-hilt.html</url>
    <content type="text"><![CDATA[Hilt先讲使用，再讲原理 google文档地址：https://developer.android.google.cn/training/dependency-injection/hilt-android?hl=zh_cn 示例源码地址 使用示例： Hilt + ViewModel + Repository添加依赖 注意事项不要参考google文档中的地址设置版本号，因为文档中使用的是 aplha 版本，API会随时变动，很可能使用此版本但运行结果与文档不同，本人就碰到了，（@HiltViewModel 不可用） * 在项目根目录的 build.gradle 中添加：12345678buildscript &#123; ext.hilt_version = "2.36" dependencies &#123; // hilt classpath "com.google.dagger:hilt-android-gradle-plugin:$hilt_version" &#125;&#125; 在需要使用 hilt 的 module 的 build.gradle 文件中添加依赖 123// Hiltimplementation "com.google.dagger:hilt-android:$hilt_version"kapt "com.google.dagger:hilt-android-compiler:$hilt_version" Application12@HiltAndroidAppclass MyApplication : Application() &#123;&#125; ViewModel123456789@HiltViewModelclass HiltViewModel @Inject constructor( var repository: HiltRepository,): ViewModel() &#123; fun login() &#123; repository.login() &#125;&#125; Repository123456789101112class HiltRepository @Inject constructor() &#123; fun login()&#123; &#125;&#125;@Module@InstallIn(ActivityComponent::class)object HiltRepositoryModule&#123; @Provides fun providerHiltRepository() :HiltRepository = HiltRepository()&#125; 注意，Repository中即使构造函数无需入参，也必须 使用 @Inject constructor()Activity12345678910111213@AndroidEntryPointclass HiltActivity : AppCompatActivity() &#123; lateinit var binding: ActivityHiltBinding private val viewModel: HiltViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) binding = ActivityHiltBinding.inflate(layoutInflater) setContentView(binding.root) &#125;&#125; 可以发现，此时生成 viewModel实例时，无需再次传入参数，也不需要另外使用ViewModelFactory来生成。原因就是在 Repository 中的代码： 1234567@Module@InstallIn(ActivityComponent::class)object HiltRepositoryModule&#123; @Provides fun providerHiltRepository() :HiltRepository = HiltRepository()&#125; 这里通过注解已经提供了生成 HiltRepository 实例的方式。 以上就是一次简单的使用。 原理解析]]></content>
  </entry>
  <entry>
    <title><![CDATA[CameraX]]></title>
    <url>%2Fblog%2F2022%2F03%2FCameraX.html</url>
    <content type="text"><![CDATA[CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。 添加依赖项123456789101112131415dependencies &#123; def camerax_version = "1.0.2" // The following line is optional, as the core library is included indirectly by camera-camera2 implementation "androidx.camera:camera-core:$&#123;camerax_version&#125;" implementation "androidx.camera:camera-camera2:$&#123;camerax_version&#125;" // If you want to additionally use the CameraX Lifecycle library implementation "androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;" // If you want to additionally use the CameraX VideoCapture library implementation "androidx.camera:camera-video:1.1.0-beta02" // If you want to additionally use the CameraX View class implementation "androidx.camera:camera-view:1.1.0-beta02" // If you want to additionally use the CameraX Extensions library implementation "androidx.camera:camera-extensions:1.1.0-beta02"&#125; 使用 CameraX 开启预览在向应用添加预览时，请使用 PreviewView，这是一种可以剪裁、缩放和旋转以确保正确显示的 View。 当相机处于活动状态时，图片预览会流式传输到 PreviewView 中的 Surface。 将 PreviewView 添加到布局1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".camera.CameraActivity"&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/container" &gt; &lt;androidx.camera.view.PreviewView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/previewView" /&gt; &lt;/FrameLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 请求 CameraProvider以下代码展示了如何请求 CameraProvider： 123456789101112class CameraActivity : AppCompatActivity() &#123; private lateinit var cameraProviderFuture: ListenableFuture&lt;ProcessCameraProvider&gt; private lateinit var dataBinding: ActivityCameraBinding override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) dataBinding = ActivityCameraBinding.inflate(layoutInflater) setContentView(dataBinding.root) cameraProviderFuture = ProcessCameraProvider.getInstance(this) &#125;&#125; 检查 CameraProvider 可用性请求 CameraProvider 后，请验证它能否在视图创建后成功初始化。以下代码展示了如何执行此操作： 12345cameraProviderFuture.addListener(Runnable &#123; val cameraProvider = cameraProviderFuture.get() bindPreview(cameraProvider)&#125;, ContextCompat.getMainExecutor(this)) 选择相机并绑定生命周期和用例创建并确认 CameraProvider 后，请执行以下操作: 1、创建 Preview。 2、指定所需的相机 LensFacing 选项。 3、将所选相机和任意用例绑定到生命周期。 4、将 Preview 连接到 PreviewView。 以下代码展示了一个示例： 1234567891011private fun bindPreview(cameraProvider: ProcessCameraProvider?) &#123; var preview: Preview = Preview.Builder() .build() var cameraSelector: CameraSelector = CameraSelector.Builder() .requireLensFacing(CameraSelector.LENS_FACING_BACK) .build() preview.setSurfaceProvider(dataBinding.previewView.getSurfaceProvider()) var camera = cameraProvider?.bindToLifecycle(this as LifecycleOwner, cameraSelector, preview)&#125; 请注意，bindToLifecycle() 会返回一个 Camera 对象。如需详细了解如何控制相机输出（如变焦和曝光），请参阅此指南。 现在，您已完成实现相机预览的操作。请构建您的应用，然后确认预览是否出现在您的应用中并能按预期工作。 PS: 记得需要相机权限]]></content>
      <tags>
        <tag>android-Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的排序算法]]></title>
    <url>%2Fblog%2F2022%2F02%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[排序数组排序冒泡排序123456789101112131415int[] arr = &#123;5,2,66,3,7&#125;;int temp;for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125;&#125; 双重 for 循环，当前元素与下一个元素对比，将较大值放于右侧，时间复杂度：O(n^2)空间复杂度：O(1) 选择排序12345678910111213141516public static int[] selectSort(int[] args)&#123;//选择排序算法 for (int i=0;i&lt;args.length-1 ;i++ )&#123; int min=i; for (int j=i+1;j&lt;args.length ;j++ )&#123; if (args[min]&gt;args[j])&#123; min=j; &#125; &#125; if (min!=i)&#123; int temp=args[i]; args[i]=args[min]; args[min]=temp; &#125; &#125; return args;&#125; 双重 for 循环，取出最小值或者最大值，交互数组位置，使最值位于数组两侧，最后得出一个升序/降序数组时间复杂度：O(n^2)空间复杂度：O(1) 插入排序123456789101112public static int[] insertSort(int[] args)&#123;//插入排序算法 for(int i=1;i&lt;args.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if (args[j]&lt;args[j-1])&#123; int temp=args[j-1]; args[j-1]=args[j]; args[j]=temp; &#125;else break; &#125; &#125; return args;&#125; 时间复杂度：O(n^2)空间复杂度：O(1) 快排使用系统自带的排序方法 sorts时间复杂度：O(nlogn)空间复杂度：O(n) 树树的遍历一般根据节点可分为三种：前序、中序、后序遍历根据树的层级又有层级遍历 下面的代码就是一个树结构 123456789101112131415class Node &#123; private int no; private String name; private Node left; private Node right; //构造方法 public Node(int no, String name) &#123; this.no = no; this.name = name; &#125; @Override public String toString() &#123; return "Node[ no = " + no + ", name =" + name + " ]"; &#125;&#125; 前序先取父节点，再取左节点，再取右节点 123456789101112// 前序遍历public void DLR() &#123; System.out.println(this);// 先输出根节点 // 左子树递归 if (this.left != null) &#123; this.left.DLR(); &#125; // 右子树递归 if (this.right != null) &#123; this.right.DLR(); &#125;&#125; 中序先取左节点，再取父节点，再取右节点中序遍历可以得出一个升序结构 123456789101112// 中序遍历public void LDR() &#123; // 左子树递归 if (this.left != null) &#123; this.left.LDR(); &#125; System.out.println(this);// 先输出根节点 // 右子树递归 if (this.right != null) &#123; this.right.LDR(); &#125;&#125; 后序先取左节点，再取右节点，再取父节点 123456789101112// 后序遍历public void LRD() &#123; // 左子树递归 if (this.left != null) &#123; this.left.LRD(); &#125; // 右子树递归 if (this.right != null) &#123; this.right.LRD(); &#125; System.out.println(this);// 先输出根节点&#125; 二叉树红黑树B树B+树]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jetpack-ViewModel]]></title>
    <url>%2Fblog%2F2022%2F02%2Fjetpack-ViewModel.html</url>
    <content type="text"><![CDATA[参考 android developer 中的文档：https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn 问题记录 当 ViewModel 构造函数为有参构造函数时，使用 private val model : OverTimeViewModel by activityViewModels() 会报错此时处理方案为新建一个Factory类12345678910111213141516171819202122232425262728class ViewModelFactory(private val dataSource: OverTimeDao): ViewModelProvider.Factory &#123; override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123; if(modelClass.isAssignableFrom(OverTimeViewModel::class.java)) &#123; return OverTimeViewModel(dataSource) as T &#125; throw IllegalArgumentException("Unknown ViewModel class") &#125;&#125;// 在写一个静态类，作为Factory作为Providerobject Injection &#123; fun provideUserDataSource(context: Context): OverTimeDao &#123; val database = AppDatabase.getInstance(context) return database.overTimeDao() &#125; fun provideViewModelFactory(context: Context): ViewModelFactory &#123; val dataSource = provideUserDataSource(context) return ViewModelFactory(dataSource) &#125;&#125;// 获取ViewModel实例private lateinit var viewModelFactory: ViewModelFactoryprivate val model : OverTimeViewModel by activityViewModels&#123; viewModelFactory &#125;// 在特定的生命函数中实例化ViewModelFactoryviewModelFactory = Injection.provideViewModelFactory(activity!!)]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager2]]></title>
    <url>%2Fblog%2F2022%2F02%2FViewPager2.html</url>
    <content type="text"><![CDATA[参考指南地址：https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2 需要对比 ViewPager2 与 ViewPager 的差异、优劣]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jetpack-Navigation]]></title>
    <url>%2Fblog%2F2022%2F02%2Fjetpack-Navigation.html</url>
    <content type="text"><![CDATA[具体参考指南地址：https://developer.android.google.cn/guide/navigation/navigation-getting-started 弊端Navigation 其实是对 Fragment 跳转的管理，而不是 Activity，需要配置到某个 Activity 中。其实是单 Activity 模式]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jetpack Room]]></title>
    <url>%2Fblog%2F2021%2F12%2Fjetpack-Room.html</url>
    <content type="text"><![CDATA[处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的使用场景是缓存相关的数据，这样一来，当设备无法访问网络时，用户仍然可以在离线状态下浏览该内容。 Room 持久性库在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。具体来说，Room 具有以下优势： 针对 SQL 查询的编译时验证 可最大限度减少重复和容易出错的样板代码的方便注解。 简化了数据库迁移路径。 出于这些方面的考虑，我们强烈建议您使用 Room，而不是直接使用 SQLite API。 添加依赖在build.gradle中添加 kapt plugin12345plugins &#123; id 'com.android.application' id 'kotlin-android' id 'kotlin-kapt' // 新增&#125; 添加room依赖 1234567dependencies &#123; // Room def room_version = "2.4.1" implementation "androidx.room:room-runtime:$room_version" kapt "androidx.room:room-compiler:$room_version" implementation "androidx.room:room-rxjava2:$room_version"&#125; 主要组件Room 包含三个主要组件： 数据库类，用于保存数据库并作为应用持久性数据底层连接的主要访问点。 数据实体，用于表示应用的数据库中的表。 数据访问对象 (DAO)，提供您的应用可用于查询、更新、插入和删除数据库中的数据的方法。 数据库类为应用提供与该数据库关联的 DAO 的实例。反过来，应用可以使用 DAO 从数据库中检索数据，作为关联的数据实体对象的实例。此外，应用还可以使用定义的数据实体更新相应表中的行，或者创建新行供插入。 实现示例本部分介绍了具有单个数据实体和单个 DAO 的 Room 数据库实现示例。 创建实体使用 Room 时，每个表都由一个类表示。在 Room 等 ORM（对象关系映射）库中，这些类通常称为模型类或实体。 1、创建一个名为 Schedule.kt 的新文件，并定义一个名为 Schedule 的数据类。12@Daodata class Schedule () 注意要使用注解@Dao,标注这是数据库实体类 2、添加主键 据表应该有一个用于唯一标识每行的主键。您要添加到 Schedule 类中的第一个属性是用于表示唯一 ID 的一个整数。添加一个新属性，并使用 @PrimaryKey 注解对其进行标记。此注解会告知 Room 在插入新行时将此属性视为主键。 12345@Daodata class Schedule ( @PrimaryKey val id: Int, ) 3、添加其他信息列 对于新列，您需要添加 @ColumnInfo 注解，用于为该列指定名称。通常，SQL 列名称使用以下划线分隔的单词，而 Kotlin 属性采用小驼峰命名法。对于此列，我们还希望其值为非 null 值，因此您应该使用 @NonNull 注解对其进行标记。 123456@Daodata class Schedule ( @PrimaryKey val id: Int, @NonNull @ColumnInfo(name = "stop_name") val stopName: String, @NonNull @ColumnInfo(name = "arrival_time") val arrivalTime: Int) 定义DAO为了集成 Room 而需要添加的下一个类是 DAO。DAO 代表数据访问对象，是一个提供数据访问的 Kotlin 类。具体而言，您会在 DAO 中包含用于读取和操作数据的函数。对 DAO 调用函数相当于对数据库执行 SQL 命令。实际上，像您要在此应用中定义的函数这样的 DAO 函数通常会指定一个 SQL 命令，以便您可以精确地指定您希望该函数执行什么操作。在定义 DAO 时，您从上一个 Codelab 中学到的 SQL 知识将派上用场。 为 Schedule 实体添加一个 DAO 类。 1234@Daointerface ScheduleDao &#123;&#125; 添加一条查询语句 根据到达时间升序查询所有车次 12@Query("SELECT * FROM schedule ORDER BY arrival_time ASC")fun getAll(): List&lt;Schedule&gt; 在增加一条条件查询语句指定stop_name的查询 12@Query("SELECT * FROM schedule WHERE stop_name = :stopName ORDER BY arrival_time ASC")fun getByStopName(stopName: String): List&lt;Schedule&gt; 异常情况记录 Room AppDatabase_Impl does not exist 使用了 kotlin 构建了项目,并且使用 kotlin 编写 room 创建数据库,在 build.gradle 文件里做如下修改 1234567891011plugins &#123; id 'com.android.library' id 'kotlin-android' id 'kotlin-android-extensions' id 'kotlin-kapt'&#125;//略...dependencies &#123; api"android.arch.persistence.room:runtime:$rootProject.room_version" kapt"android.arch.persistence.room:compiler:$rootProject.room_version"&#125; 将 annotationProcessor 替换成 kapt,请注意需要导入 id ‘kotlin-kapt’ 才能使用 kapt 参考地址：https://www.cnblogs.com/guanxinjing/p/14990401.html 样例代码地址]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jetpack DataSource]]></title>
    <url>%2Fblog%2F2021%2F12%2Fjetpack-DataSource.html</url>
    <content type="text"><![CDATA[Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。 DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。 Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。 Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jetpack lifecycle]]></title>
    <url>%2Fblog%2F2021%2F12%2Fjetpack-lifecycle.html</url>
    <content type="text"><![CDATA[Lifecycle 是 Jetpack 库中用来感知生命周期的组件 使用生命周期感知型组件处理生命周期生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。 一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。 androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。 LifecycleLifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。 Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态： 事件从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。状态由 Lifecycle 对象跟踪的组件的当前状态 example使用： 123456789101112131415161718192021222324252627class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) lifecycle.addObserver(MainLifecycleObserver()) &#125;&#125;class MainLifecycleObserver() : LifecycleObserver &#123; private var TAG: String = "MainLifecycleObserver"; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun onActivityCreated() &#123; Log.d(TAG, "onActivityCreated: ") &#125; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun onActivityResume() &#123; Log.d(TAG, "onActivityResume: ") &#125; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun onActivityStopped() &#123; Log.d(TAG, "onActivityStopped: ") &#125;&#125; 如上所示，就可以實現在 Activity 之外獲取到生命週期的變化，避免在 Activity/Fragment 中的生命週期中寫大量業務代碼 LifecycleOwnerLifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。 此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。 实现 DefaultLifecycleObserver 的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。 自定義 LifecycleOwner我們不只是可以綁定視圖的生命週期，可以通過 LifecycleOwner 自定義對應色生命週期如當處於 Activity 的 onCreate、onStart 中都需執行 onStart 12345678910111213141516171819class MainActivity : AppCompatActivity(), LifecycleOwner &#123; lateinit var lifecycleRegistry: LifecycleRegistry; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) lifecycleRegistry = LifecycleRegistry(this) lifecycleRegistry.markState(Lifecycle.State.STARTED) &#125; override fun onStart() &#123; super.onStart(); lifecycleRegistry.markState(Lifecycle.State.STARTED) &#125; override fun getLifecycle(): Lifecycle&#123; return lifecycleRegistry &#125;&#125; 总结LifeCycle 组件实际上并没有带来什么新的功能，他通过观察者模式+注解来让我们更方便的监听 Activity 和 Fragment 的生命周期变化。]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin学习指南一]]></title>
    <url>%2Fblog%2F2021%2F12%2Fkotlin%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80.html</url>
    <content type="text"><![CDATA[kotlin 是 google 推出的一門新語言，也是基於 JVM 的。 kotlin 基础hello world新建一个 kt 文件， 1234fun main(args:Array&lt;String&gt;) &#123; println(&quot;Hello world!&quot;);&#125; 程序主入口 main 方法， 无需新建类即可运行，函数声明用 fun 123fun sum(a:Int, b:Int):Int&#123; return a + b;&#125; 返回值写在参数之后 表达式可以作为函数体，返回值类型自动推断 1fun sun(a:Int, b:Int) = a+b; 返回无意义的值用 Unit 表示 fun test():Unit {println(“test”);} 变量赋值变量赋值声明关键字：var、valvar：声明变量val：声明常量 var i:Int = 1;val PI:Double = 3.14; 当声明并赋值时，数据类型可以省略, 会自动推断数据类型var i = 1;val PI = 3.14 当声明但不赋值时，不能省略数据类型var i:Int;val PI:Double; 字符串模板123var s = &quot;aaaaa&quot;;var b = &quot;str = $s&quot;;var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot; 条件表达式1234fun testIf(a:Int, b:Int):Int &#123; if(a &gt; b) return a; return b;&#125; 在 kotlin 中，if 还可以用作表达式 1fun max(a:Int, b:Int) = if(a &gt; b) a else b 空值与 null 检测当某个值可以为空时，需要在类型后添加?表示可以为空此时，声明时不能省略类型 12345var obj:Objects ? = null;// 表示返回值可以为nullfun parseInt(str:String):Int?&#123; ...&#125; 类型检测与自动类型转换is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换 123456789fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125; 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 for 循环12345678910var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);// 根据元素遍历for (item in items) &#123; println(item);&#125;// 根据下标便利for (item in items.indices) &#123; println(items[item]);&#125; while 循环12345var index = 0;while (index &lt; items.size) &#123; println(items[index]); index ++;&#125; when 表达式123456789101112private fun testWhen(s: Any?) &#123; when(s) &#123; &quot;a&quot; -&gt; 1; &quot;b&quot; -&gt; 2; is String -&gt; 3; 1 -&gt; &quot;n&quot;; 2 -&gt; &#123; println(&quot;222&quot;); &#125;; else -&gt; &quot;else&quot;; &#125; &#125; 有点类似 java 中的 switch 区间 range12345var x = 6;var y = 9;if(x in 0..y) &#123; println(&quot;x in 0 - y&quot;);&#125; 注意：区间只用于数字 集合集合的迭代可以用的上面的 for in 循环 1234var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);for(item in items) &#123; println(item);&#125; 判断集合中是否包含某元素 用 while in || when 12345678while (&quot;a&quot; in items) &#123; println(&quot;items include a&quot;);&#125;when &#123; &quot;a&quot; in items -&gt; println(&quot;aaa&quot;); &quot;d&quot; in items -&gt; println(&quot;ddd);&#125; 用 lambda 来过滤和映射集合 ，与 java8 lambda stream 大致 1234items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125; .sortBy&#123; it &#125; .map&#123; it.toUpperCase() &#125; .forEach&#123; println(it) &#125; 协程什么是协程？官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。 协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。CPU 调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。 协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。 build.gralde 中引入依赖implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1” runBlocking123456789101112131415class MainActivity4 : AppCompatActivity() &#123; val TAG = &quot;MainActivity4&quot; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main2) test() Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;) &#125; fun test() = runBlocking &#123; repeat(8) &#123; Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;) delay(1000) &#125; &#125;&#125; 打印结果如下：协程执行 0 线程 id：1协程执行 1 线程 id：1协程执行 2 线程 id：1协程执行 3 线程 id：1协程执行 4 线程 id：1协程执行 5 线程 id：1协程执行 6 线程 id：1协程执行 7 线程 id：1线程 main ：1 我们可以得出结论：runBlocking 会阻塞线程，但允许还是在当前线程 launch:Job12345678fun testJob() &#123; val job = GlobalScope.launch &#123; repeat(8) &#123; delay(2000) Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, ) &#125; &#125; &#125; 打印结果如下：testJob: 线程 main：2testJob: 线程 id:6809testJob: 线程 id:6807testJob: 线程 id:6807testJob: 线程 id:6815testJob: 线程 id:6807testJob: 线程 id:6808testJob: 线程 id:6818testJob: 线程 id:6809 说明使用 GlobalScope.launch 并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务 是非阻塞、异步执行，相当于开启了子线程 async123456789101112131415161718192021222324fun testAsync()&#123; GlobalScope.launch &#123; var result1 = GlobalScope.async &#123; getResult1() &#125; var result2 = GlobalScope.async &#123; getResult2() &#125; val result = result1.await() + result2.await() Log.e(TAG, &quot;testAsync: ThreadId = $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;) &#125;&#125;private suspend fun getResult1():Int &#123; delay(3000) Log.e(TAG, &quot;getResult1: ThreadId = $&#123;Thread.currentThread().id&#125;&quot;) return 4&#125;private suspend fun getResult2():Int &#123; delay(5000) Log.e(TAG, &quot;getResult2: ThreadId = $&#123;Thread.currentThread().id&#125;&quot;) return 5&#125; 输出结果：E/MainActivity4: 线程 main ：2E/MainActivity4: getResult1: ThreadId = 7870E/MainActivity4: getResult2: ThreadId = 7870E/MainActivity4: testAsync: ThreadId = 7870 result = 9 其中当打印 getResult2 后就打印了 testAsync: result = 9阻塞时间为 5 秒，而不是 8 秒，说明 getResult1、getResult2 是并行的。 而且发现 threadId 都一样，说明处于同一个线程。但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。 协程并不等于线程，协程内部会根据任务情况自动调度线程。 launch()有三个入参： 1.协程下上文；2.协程启动模式；3.协程体：block 是一个带接收者的函数字面量，接收者是 CoroutineScope 我们在线程中执行的代码就是第三个参数 协程上下文上下文可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，Kotlin 协程使用调度器来确定哪些线程用于协程执行，Kotlin 提供了调度器给我们使用： Dispatchers.Main：使用这个调度器在 Android 主线程上运行一个协程。可以用来更新 UI 。在 UI 线程中执行 Dispatchers.IO：这个调度器被优化在主线程之外执行磁盘或网络 I/O。在线程池中执行 Dispatchers.Default：这个调度器经过优化，可以在主线程之外执行 cpu 密集型的工作。例如对列表进行排序和解析 JSON。在线程池中执行。 Dispatchers.Unconfined：在调用的线程直接执行。 调度器实现了 CoroutineContext 接口。 我们还可以自己自定义调度器 123456var dis = Executors.newCachedThreadPool().asCoroutineDispatcher()runBlocking &#123; launch(dis) &#123; println(&quot;dis 线程id：$&#123;Thread.currentThread().id&#125;&quot;) &#125;&#125; 启动模式在 Kotlin 协程当中，启动模式定义在一个枚举类中： public enum class CoroutineStart {DEFAULT,LAZY,@ExperimentalCoroutinesApiATOMIC,@ExperimentalCoroutinesApiUNDISPATCHED;}一共定义了 4 种启动模式，DEFAULT: 默认的模式，立即执行协程体LAZY: 只有在需要的情况下运行ATOMIC: 立即执行协程体，但在开始运行之前无法取消UNDISPATCHED :立即在当前线程执行协程体，直到第一个 suspend 调用 协程体协程体是一个用 suspend 关键字修饰的一个无参，无返回值的函数类型。被 suspend 修饰的函数称为挂起函数,与之对应的是关键字 resume（恢复）注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。 关键字Kotlin 的硬关键宇包括: as 一一 用于做类型转换或为 import 语句指定别名as?一一类型安全 的类型转换运算符。break 一一中断循环class 一一声明类。continue 一忽略本次循环剩下的语句，重新开始下一次循环。do 一一用于 do while 循环else 一一在 if 分支中使用false 一一在 Boolean 类型中表示假 的直接量。for 一一用于 for 循环fun 一一声 明函数if－在 if 分支中使用in 一一在 for 循环中使用； in 还可作为双目运算符，检查 一个值是否处于区间或集合 内；in 也可 在 when 表达式中使用； in 还可用于修饰泛型参数，表明该泛型参数支持逆变!in 一一可作为双目运算符 的反义词：！in 也可在 when 表达式中使用is 一一用于做类型检查（类 Java instanceof) 或在 when 表达式中使用!is 一一 用于做类型检查（ is 的反义词〉或在 when 表达式中使用null 一一 代表空的直接量。object ——用于声明对象表达式或定义命名对象package 一一用于为当 前文件指定包return 一一声明函数的返回super 一－用于引用父类实现的方法或属性，或者在子类构造器中调用父类构造器this 一一 代表当前类的对象或在构造器中调用当前类的其他构造器throw 一一用于抛出异常true 一一在 Boolean 类型中表示真的直接量。try 一一开始异常处理typealias 一一用于定义类型别名。val 一声明只读属性或变量。var 一一声明可变属性或变量。when 一一用于 when 表达式。while 一一－用于 while 循环或 do while 循环 Kotlin 的软关键宇包括： by 一一用于将接口或祖先类的实现代理给其他对象。catch 一一在异常处理中用于捕捉异常constructor 一一用于声明构造器。delegate 一用于指定该注解修饰委托属性存储其委托实例的字段dynamic 一一主要用于在 Kotlin/JavaScript 中引用 一个动态类型field 一一用于指定该注解修饰属性的幕后字段。file 一一用于指定该注解修饰该源文件本身finally 一一异常处理中的 finallyget 一一用于声明属性的 getter 方法，或者用于指定该注解修饰属性的 getter 方法import 一一用于导包。init 一一用于声明初始化块param 一一用于指定该注解修饰构造器参数property 一一用于指定该注解修饰整个属性（这种目标的注解对 Java 不可见，因为 Java并没有真正的属性）。receiveris 一一用于指定该注解修饰扩展方法或扩展属性的接收者set 一一用于声明属性的 setter 方法，或者用于指定该注解修饰属性的 setter 方法setparam 一一用于指定该注解修饰 setter 方法的参数where 一一用于为泛型参数增加限制。 Kotlin 的修饰符关键宇包括： abstract 一一用于修饰抽象类或抽象成员annotation 一一用于修饰一个注解类。companion 一一用于声明一个伴生对象const 一一用于声明编译时常量crossinline 一一用于禁止在传给内联函数的 Lambd 表达式中执行非局部返回data 一一用于声明数据类。enum 一一用于声明枚举external 一一用于声明某个方法不由 Kotlin 实现（与 Java 的 native 相似〉。final 一一用于禁止被重写infix 一一声明该函数能以双目运算符的格式执行inline 一一用于声明内联函数， Lambda 表达式可在内联函数中执行局部返回。inner 一一用于声明内部类，内部类可以访问外部类的实例internal 一一用于表示被修饰的声明只能在当前模块内可见lateinit——-用于修饰 non-null 属性，用于指定该属性可在构造器以外的地方初始化noinline 一一用于禁止内联函数中个别 Lambda 表达式被内联化open 一一用于修饰类，表示该类可派生子类；或者用于修饰成员，表示该成员可以被重写。out 一一用于修饰泛型参数，表明该泛型参数支持协变。override 一一用于声明重写父类的成员private ——private 访问权限protected ——–protected 访问权限public——-public 访问权限。reified 一一用于修饰内联函数中的泛型形参，接下来在该函数中就可像使用普通类型一样使用该类型参数。sealed 一一用于声明一个密封类。suspend 一一用于标识一个函数后 Lambda 表达式可作为暂停。tailrec 一一用于修饰一个函数可作为尾随递归函数使用。vararg 一一用于修饰形参，表明该参数是个数可变的形参。]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fblog%2F2021%2F12%2Fjava%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[数据类型再java中，数据类型可分为两种：集合（Collection）、图（Map）而这两大类中又可以细分，常用的子类为：ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 集合（Collection）集合可以细分为三类：List、Set、Queue ListList接口扩展自Collection，它可以定义一个允许重复的有序集合 List中常用的子类有：ArrayList、LinkerList、CopyOnWriteArrayList ArrayListArrayList内部的数据结构为数组，当增加元素数量大于初始容量，会触发扩容，即新建一个之前容量两位的数组，并将之前的元素拷贝过来。查询快，增删慢非线程安全 LinkedListLinkedList内部的数据结构为链表，双向链表。查询慢，增删快非线程安全 CopyOnWriteArrayList是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。线程安全，通过ReentrantLock实现 SetSet接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。Set接口有三个具体实现类：散列集HashSet、链式散列集LinkedHashSet、树形集TreeSet Set判断是否重复的原理是，先判断Hash，如果Hash相同再判断equals HashSet散列集HashSet是一个用于实现Set接口的具体类，有两个名词需要关注，初始容量和客座率。客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，就会触发扩容。 非线程安全 LinkedHashSet内部数据是链表，是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。非线程安全 TreeSet内部数据结构为树，扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。非线程安全 Queue数据结构为队列，特点是先进先出，后进后出而关于队列的实现又有多个：优先级队列、异步队列、同步队列、阻塞队列等。 MapMap中常用的子类有: HashMap、HashTable、LinkedHashMap、TreeMap、ConcurrentHashMap HashMapHashMap在jdk1.8时发生了变更在JDK1.7及以前的版本中：内部数据结构为：数组+链表，并且链表插入数据的方式为 头插法在jdk1.8以及之后的版本中：内部的数据结构为：数组+链表+红黑树，并且链表插入数据的方式为 尾插法 数据存放方式为 key value，一一对应，key不允许重复大致原理：根据key得出hash值，根据hash值对数组长度取模得出存放数组的下标，每个数组下标对于的为一个链表，将数据放入到链表，当链表长度大于阈值时，则链表转换为红黑树，红黑树节点数减少小于阈值时，则又转换回链表取值大致过程相同：根据key获取hash，然后得出下标，然后再去链表或者红黑树中根据key对比取值 非线程安全 LinkedHashMapLinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，也可以按它们最后一次被访问的顺序排非线程安全 TreeMapTreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。 在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。非线程安全 ConcurrentHashMapConcurrentHashMap 是并发包concurrent下针对HashMap的一种实现，线程安全同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高 线程安全]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fblog%2F2021%2F12%2FNDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html</url>
    <content type="text"><![CDATA[浅拷贝与深拷贝浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据 浅拷贝在之前讲过的拷贝构造函数，其实就是一种 浅拷贝但是在浅拷贝中，无法拷贝堆内存中的数据 12345678910111213141516171819202122232425262728class Student1&#123;public: int age; char * name; Student1() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125; Student1(char * name) :Student1(name, 99) &#123; cout &lt;&lt; &quot;一个入参 构造函数&quot; &lt;&lt; endl; &#125; Student1(char * name, int age) &#123; cout &lt;&lt; &quot;两个入参构造函数&quot; &lt;&lt; endl; this-&gt;name = (char *) malloc(sizeof(char * ) * 10); strcpy(this-&gt;name, name); this-&gt;age = age; &#125; ~Student1() &#123; cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl; free(this-&gt;name); this-&gt;name = NULL; &#125;&#125;; 如上所示，Student 类中，在构造函数中，name 是动态开辟在堆内存上的，在析构函数中，会使用free释放 name 在堆内存的内存空间 123456789void main() &#123; Student1 s1; Student1 s2 = s1; cout &lt;&lt; &amp;s1 &lt;&lt; endl; cout &lt;&lt; &amp;s2 &lt;&lt; endl;&#125; 当我们执行完上述代码时，会运行异常，Student1 s2 = s1; 会执行 拷贝构造函数，将 s2 的值都复制给 s1但是之前说过 拷贝构造函数是 浅拷贝 浅拷贝 是不会拷贝堆内存中的数据的， 所以其实 s2 与 s1 中的 name 指向的同一块堆内存空间，当main函数执行完毕，出栈时，会调用 s2、s1的析构函数，当指向s1的析构函数时，会释放 name 中的堆内存空间。等到执行 s2 的析构函数时，又会执行 free(this-&gt;name); 但此时 this-&gt;name已经是一块指向NULL的指针了，此时就会抛出异常。 深拷贝上面讲了深拷贝与浅拷贝的区别，以及默认的拷贝构造函数是一次浅拷贝，接下来手动实现一下 深拷贝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Student&#123;public: int age; char * name; Student() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125; Student(char * name) :Student(name, 99) &#123; cout &lt;&lt; &quot;一个参数构造函数 this:&quot; &lt;&lt; (int)this &lt;&lt; endl; &#125; Student(char * name, int age) &#123; this-&gt;name = (char *)malloc(sizeof(char *)* 10); strcpy(this-&gt;name, name); this-&gt;age = age; &#125; ~Student() &#123; cout &lt;&lt; &quot;析构函数 &amp;this-&gt;name:&quot; &lt;&lt; (int)this-&gt;name &lt;&lt; endl; free(this-&gt;name); this-&gt;name = NULL; &#125; Student(const Student &amp; stu) &#123; cout &lt;&lt; &quot;stu的地址 &amp;stu:&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot; this:&quot; &lt;&lt; (int)this &lt;&lt; endl; // 重新开辟一个堆内存存放新的 stu对象中的 name this-&gt;name = (char *)malloc(sizeof(char *)* 10); // 复制name中的值 strcpy(this-&gt;name, name); this-&gt;age = stu.age; &#125;&#125;;void showStudent(Student stu) &#123; cout &lt;&lt; &quot;showStudent的内存地址&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot; &quot; &lt;&lt; stu.name &lt;&lt; &quot;,&quot; &lt;&lt; stu.age&lt;&lt; endl;&#125;void main() &#123; Student stu(&quot;justin&quot;, 31); showStudent(stu); showStudent(stu); showStudent(stu); showStudent(stu); showStudent(stu); getchar();&#125; 如上所述，在函数 showStudent 中会调用拷贝构造函数 然后执行完毕出栈，调用 析构函数，但上述代码不会出现异常，因为在我们自定义的拷贝构造函数中，我们手动实现了堆内存的拷贝。并每次执行析构函数时，又会释放掉name的堆内存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java 类加载机制]]></title>
    <url>%2Fblog%2F2021%2F11%2Fjava-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[类加载 了解 java 类加载机制 理解类加载器 ClassLoader 类加载时机 隐式加载 new 创建类的实例, 显式加载：loaderClass,forName 等 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式创建某个类或者接口对象的 Class 对象。 初始化某个类的子类 直接使用 java.exe 命令来运行某个主类 类加载过程类加载有五步：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 加载类加载过程的一个阶段，ClassLoader 通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个 class 对象 验证目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证 准备为类变量（static 修饰的字段变量）分配内存并且设置该类变量的初始值，（如 static int i = 5 这里只是将 i 赋值为 0，在初始化的阶段再把 i 赋值为 5)，这里不包含 final 修饰的 static ，因为 final 在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到 Java 堆中 解析这里主要的任务是把常量池中的符号引用替换成直接引用 初始化这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对 static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化） forName 和 loaderClass 区别 Class.forName()得到的 class 是已经初始化完成的 ClassLoader.loaderClass 得到的 class 是还没有链接（验证，准备，解析三个过程被称为链接）的。 双亲委派机制双亲委派模式要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，但是在双亲委派模式中父子关系采取的并不是继承的关系，而是采用组合关系来复用父类加载器的相关代码。 12345678910111213141516171819202122232425protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; return c; &#125; 工作原理通过 loadClass 加载类时，会先通过 findLoadClass 查找该类是否已加载，如果未加载，会先通过父加载期加载，依次向上递归，到最上级父加载器加载，如果此时还未加载，再依次向下递归调用 findClass 就是每个儿子都很懒，遇到类加载的活都给它爸爸干，直到爸爸说我也做不来的时候，儿子才会想办法自己去加载。 优势采用双亲委派模式的好处就是 Java 类随着它的类加载器一起具备一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类的时候，就没有必要子类加载器（ClassLoader）再加载一次。其次是考虑到安全因素，Java 核心 API 中定义类型不会被随意替换，假设通过网路传递一个名为 java.lang.Integer 的类，通过双亲委派的的模式传递到启动类加载器，而启动类加载器在核心 Java API 发现这个名字类，发现该类已经被加载，并不会重新加载网络传递过来的 java.lang.Integer.而之际返回已经加载过的 Integer.class，这样便可以防止核心 API 库被随意篡改。可能你会想，如果我们在 calsspath 路径下自定义一个名为 java.lang.SingInteger?该类并不存在 java.lang 中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器，最终会通过系统类加载器加载该类，但是这样做是不允许的，因为 java.lang 是核心的 API 包，需要访问权限，强制加载将会报出如下异常。 1java.lang.SecurityException:Prohibited package name: java.lang 类与加载器在 JVM 中标识两个 Class 对象，是否是同一个对象存在的两个必要条件： 类的完整类名必须一致，包括包名。 加载这个 ClassLoader（指 ClassLoader 实例对象）必须相同。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fblog%2F2021%2F11%2Fjava-%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8Eclass.html</url>
    <content type="text"><![CDATA[反射 JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 * 类名 用途Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口Field 类 代表类的成员变量（成员变量也称为类的属性）Method 类 代表类的方法Constructor 类 代表类的构造方法 获得类相关的方法方法 用途asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象Cast 把对象转换成代表类或是接口的对象getClassLoader() 获得类的加载器getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象forName(String className) 根据类名返回类的对象getName() 获得类的完整路径名字newInstance() 创建类的实例getPackage() 获得类的包getSimpleName() 获得类的名字getSuperclass() 获得当前类继承的父类的名字getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法方法 用途getField(String name) 获得某个公有的属性对象getFields() 获得所有公有的属性对象getDeclaredField(String name) 获得某个属性对象getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法方法 用途getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象getAnnotations() 返回该类所有的公有注解对象getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法方法 用途getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法getConstructors() 获得该类的所有公有构造方法getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法方法 用途getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法getMethods() 获得该类所有公有的方法getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数getDeclaredMethods() 获得该类所有方法 类中其他重要的方法方法 用途isAnnotation() 如果是注解类型则返回 trueisAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 trueisAnonymousClass() 如果是匿名类则返回 trueisArray() 如果是一个数组类则返回 trueisEnum() 如果是枚举类则返回 trueisInstance(Object obj) 如果 obj 是该类的实例则返回 trueisInterface() 如果是接口类则返回 trueisLocalClass() 如果是局部类则返回 trueisMemberClass() 如果是内部类则返回 true Field 类Field 代表类的成员变量（成员变量也称为类的属性）。 方法 用途equals(Object obj) 属性与 obj 相等则返回 trueget(Object obj) 获得 obj 中对应的属性值set(Object obj, Object value) 设置 obj 中对应属性值 Method 类Method 代表类的方法。 方法 用途invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法 Constructor 类Constructor 代表类的构造方法。 方法 用途newInstance(Object… initargs) 根据传递的参数创建类的对象 example先写一个被反射调用的基础类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class ExampleReflex &#123; private static final String TAG = ExampleReflex.class.getSimpleName(); private static int A = 2021; public static String LOG = "LOG"; private String privateName = "privateName"; public String publicName = "publicName"; private String name = "defaultName"; private final String FINAL_NAME = "FINAL_NAME"; private static final String STATIC_FINAL_NAME = "STATIC_FINAL_NAME"; public ExampleReflex() &#123; &#125; private ExampleReflex(String name) &#123; this.name = name; &#125; public void publicMethodNoParams() &#123; Log.d(TAG, "publicMethodNoParams: "); &#125; public void publicMethodHasParams(String name) &#123; Log.d(TAG, "publicMethodHasParams: " + name); &#125; private String getName() &#123; Log.d(TAG, "Private No Params getName: "); return name; &#125; private String privateMethodHasParams(int size) &#123; Log.d(TAG, "privateMethodHasParams: " + size); return "size:" + size; &#125; public static String staticMethodNoParams() &#123; Log.d(TAG, "staticMethodNoParams: "); return "staticMethodNoParams"; &#125; public static String staticMethodHasParams(String name) &#123; Log.d(TAG, "staticMethodHasParams: " + name); return name + "_____" + name; &#125; private static void privateStaticMethod() &#123; Log.d(TAG, "privateStaticMethod: "); &#125; public void logPrivateName() &#123; Log.d(TAG, "logPrivateName: " + privateName); &#125; public void logPublicName() &#123; Log.d(TAG, "logPublicName: " + publicName); &#125; public void logStatic() &#123; Log.d(TAG, "logStatic: A: " + A + " LOG: " + LOG); &#125; public void logFinal() &#123; Log.d(TAG, "logFinal: finalName: " + FINAL_NAME + " STATIC_FINAL_NAME: "+ STATIC_FINAL_NAME); &#125;&#125; 如上，其中包含 public、private、static、final 修饰的属性、以及函数 返回调用函数调用 public 函数12345678910111213// 先获取classClass clazz = Class.forName("weightmeasure.justin.test.ExampleReflex");// 根据class 获取一个对象Object obj = clazz.newInstance();// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象Method method1 = clazz.getMethod("publicMethodNoParams", null);// 执行函数method1.invoke(obj, null);// 获取公有有参函数 第二个参数是入参参数签名Method method2 = clazz.getMethod("publicMethodHasParams", String.class);method2.invoke(obj, "TEST"); 调用 private 函数12345678910111213// 获取私有函数Method method3 = clazz.getDeclaredMethod("getName", null);// 私有函数需要设置允许访问 否则会报错method3.setAccessible(true);// 获取返回值String name = (String) method3.invoke(obj, null);Log.d(tag, "privateMethod Result: " + name);// 获取私有有参函数Method method4 = clazz.getDeclaredMethod("privateMethodHasParams", int.class);method4.setAccessible(true);String size = (String) method4.invoke(obj, 22);Log.d(tag, "privateMethodHasParams Result: " + size); 可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数 调用 static 函数123456789101112131415// 获取静态无参函数Method method5 = clazz.getDeclaredMethod("staticMethodNoParams", null);method5.setAccessible(true);method5.invoke(obj, null);// 获取静态有参函数Method method6 = clazz.getDeclaredMethod("staticMethodHasParams", String.class);method6.setAccessible(true);String result_str6 = (String) method6.invoke(obj, "public static method");Log.d(tag, "staticMethodHasParams Result: " + result_str6);// 私有静态函数Method method7 = clazz.getDeclaredMethod("privateStaticMethod", null);method7.setAccessible(true);method7.invoke(obj, null); 反射调用静态函数与调用私有函数其实没有不同 调用反射修改属性修改 public、private、static 变量1234567891011121314151617181920212223// 修改public变量，并输出// 获取属性Field publicField = clazz.getDeclaredField("publicName");// 在obj实例对象上设置属性新值publicField.set(obj, "publicName_New");Method method8 = clazz.getDeclaredMethod("logPublicName");method8.invoke(obj, null);// 修改private变量Field privateField = clazz.getDeclaredField("privateName");// 私有属性需要设置可访问privateField.setAccessible(true);privateField.set(obj, "privateName_New");Method method9 = clazz.getDeclaredMethod("logPrivateName", null);method9.invoke(obj, null);// 修改静态属性Field field1 = clazz.getDeclaredField("A");field1.setAccessible(true);field1.set(obj, 2222);Method method10 = clazz.getDeclaredMethod("logStatic", null);method10.setAccessible(true);method10.invoke(obj, null); 注意，私有变量时需要调用 setAccessible，不然会报错 修改 final 修饰的常量在 java 中，使用 final 修饰的代表常量，不允许修改。当我们通过反射修改时 1234567// 修改final常量Field field2 = clazz.getDeclaredField("FINAL_NAME");field2.setAccessible(true);field2.set(obj, "FINAL_NAME_NEW");Method method11 = clazz.getDeclaredMethod("logFinal", null);method11.setAccessible(true);method11.invoke(obj, null); 采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。 针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改 123456789// 正确的修改final常量方式Field field3 = clazz.getDeclaredField("FINAL_NAME");field3.setAccessible(true);Field modifiers = Field.class.getDeclaredField("modifiers");modifiers.setAccessible(true);modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);field3.set(obj, "FINAL_NAME_NEW");Method method12 = clazz.getDeclaredMethod("logFinal", null);method12.invoke(obj, null); 反射构造函数在上面调用生成实例中：Object obj = clazz.newInstance(); 其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。修改 ExampleReflex.java 中的构造函数 1234567private ExampleReflex(int a) &#123; Log.d(TAG, "Constructor ExampleReflex: " + a);&#125;public ExampleReflex(String name) &#123; this.name = name;&#125; 直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例 通过 public 有参构造函数生成实例 12345678Class clazz = Class.forName("weightmeasure.justin.test.ExampleReflex");// 获取public 有参的构造函数Constructor constructor1 = clazz.getConstructor(String.class);// 通过构造函数生成对象 参数为入参类型classObject obj = constructor1.newInstance("NNNNN");Method method81 = clazz.getDeclaredMethod("getName", null);method81.setAccessible(true);method81.invoke(obj, null); 通过 private 有参构造函数生成实例 1234// 获取private 有参构造函数Constructor constructor2 = clazz.getDeclaredConstructor(int.class);// 生成实例Object obj2 = constructor2.newInstance(222);]]></content>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2Fblog%2F2021%2F10%2F%E5%8F%8D%E5%B0%84.html</url>
    <content type="text"><![CDATA[反射 JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 * 类名 用途Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口Field 类 代表类的成员变量（成员变量也称为类的属性）Method 类 代表类的方法Constructor 类 代表类的构造方法 获得类相关的方法方法 用途asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象Cast 把对象转换成代表类或是接口的对象getClassLoader() 获得类的加载器getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象forName(String className) 根据类名返回类的对象getName() 获得类的完整路径名字newInstance() 创建类的实例getPackage() 获得类的包getSimpleName() 获得类的名字getSuperclass() 获得当前类继承的父类的名字getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法方法 用途getField(String name) 获得某个公有的属性对象getFields() 获得所有公有的属性对象getDeclaredField(String name) 获得某个属性对象getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法方法 用途getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象getAnnotations() 返回该类所有的公有注解对象getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法方法 用途getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法getConstructors() 获得该类的所有公有构造方法getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法方法 用途getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法getMethods() 获得该类所有公有的方法getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数getDeclaredMethods() 获得该类所有方法 类中其他重要的方法方法 用途isAnnotation() 如果是注解类型则返回 trueisAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 trueisAnonymousClass() 如果是匿名类则返回 trueisArray() 如果是一个数组类则返回 trueisEnum() 如果是枚举类则返回 trueisInstance(Object obj) 如果 obj 是该类的实例则返回 trueisInterface() 如果是接口类则返回 trueisLocalClass() 如果是局部类则返回 trueisMemberClass() 如果是内部类则返回 true Field 类Field 代表类的成员变量（成员变量也称为类的属性）。 方法 用途equals(Object obj) 属性与 obj 相等则返回 trueget(Object obj) 获得 obj 中对应的属性值set(Object obj, Object value) 设置 obj 中对应属性值 Method 类Method 代表类的方法。 方法 用途invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法 Constructor 类Constructor 代表类的构造方法。 方法 用途newInstance(Object… initargs) 根据传递的参数创建类的对象 example先写一个被反射调用的基础类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class ExampleReflex &#123; private static final String TAG = ExampleReflex.class.getSimpleName(); private static int A = 2021; public static String LOG = "LOG"; private String privateName = "privateName"; public String publicName = "publicName"; private String name = "defaultName"; private final String FINAL_NAME = "FINAL_NAME"; private static final String STATIC_FINAL_NAME = "STATIC_FINAL_NAME"; public ExampleReflex() &#123; &#125; private ExampleReflex(String name) &#123; this.name = name; &#125; public void publicMethodNoParams() &#123; Log.d(TAG, "publicMethodNoParams: "); &#125; public void publicMethodHasParams(String name) &#123; Log.d(TAG, "publicMethodHasParams: " + name); &#125; private String getName() &#123; Log.d(TAG, "Private No Params getName: "); return name; &#125; private String privateMethodHasParams(int size) &#123; Log.d(TAG, "privateMethodHasParams: " + size); return "size:" + size; &#125; public static String staticMethodNoParams() &#123; Log.d(TAG, "staticMethodNoParams: "); return "staticMethodNoParams"; &#125; public static String staticMethodHasParams(String name) &#123; Log.d(TAG, "staticMethodHasParams: " + name); return name + "_____" + name; &#125; private static void privateStaticMethod() &#123; Log.d(TAG, "privateStaticMethod: "); &#125; public void logPrivateName() &#123; Log.d(TAG, "logPrivateName: " + privateName); &#125; public void logPublicName() &#123; Log.d(TAG, "logPublicName: " + publicName); &#125; public void logStatic() &#123; Log.d(TAG, "logStatic: A: " + A + " LOG: " + LOG); &#125; public void logFinal() &#123; Log.d(TAG, "logFinal: finalName: " + FINAL_NAME + " STATIC_FINAL_NAME: "+ STATIC_FINAL_NAME); &#125;&#125; 如上，其中包含 public、private、static、final 修饰的属性、以及函数 返回调用函数调用 public 函数12345678910111213// 先获取classClass clazz = Class.forName("weightmeasure.justin.test.ExampleReflex");// 根据class 获取一个对象Object obj = clazz.newInstance();// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象Method method1 = clazz.getMethod("publicMethodNoParams", null);// 执行函数method1.invoke(obj, null);// 获取公有有参函数 第二个参数是入参参数签名Method method2 = clazz.getMethod("publicMethodHasParams", String.class);method2.invoke(obj, "TEST"); 调用 private 函数12345678910111213// 获取私有函数Method method3 = clazz.getDeclaredMethod("getName", null);// 私有函数需要设置允许访问 否则会报错method3.setAccessible(true);// 获取返回值String name = (String) method3.invoke(obj, null);Log.d(tag, "privateMethod Result: " + name);// 获取私有有参函数Method method4 = clazz.getDeclaredMethod("privateMethodHasParams", int.class);method4.setAccessible(true);String size = (String) method4.invoke(obj, 22);Log.d(tag, "privateMethodHasParams Result: " + size); 可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数 调用 static 函数123456789101112131415// 获取静态无参函数Method method5 = clazz.getDeclaredMethod("staticMethodNoParams", null);method5.setAccessible(true);method5.invoke(obj, null);// 获取静态有参函数Method method6 = clazz.getDeclaredMethod("staticMethodHasParams", String.class);method6.setAccessible(true);String result_str6 = (String) method6.invoke(obj, "public static method");Log.d(tag, "staticMethodHasParams Result: " + result_str6);// 私有静态函数Method method7 = clazz.getDeclaredMethod("privateStaticMethod", null);method7.setAccessible(true);method7.invoke(obj, null); 反射调用静态函数与调用私有函数其实没有不同 调用反射修改属性修改 public、private、static 变量1234567891011121314151617181920212223// 修改public变量，并输出// 获取属性Field publicField = clazz.getDeclaredField("publicName");// 在obj实例对象上设置属性新值publicField.set(obj, "publicName_New");Method method8 = clazz.getDeclaredMethod("logPublicName");method8.invoke(obj, null);// 修改private变量Field privateField = clazz.getDeclaredField("privateName");// 私有属性需要设置可访问privateField.setAccessible(true);privateField.set(obj, "privateName_New");Method method9 = clazz.getDeclaredMethod("logPrivateName", null);method9.invoke(obj, null);// 修改静态属性Field field1 = clazz.getDeclaredField("A");field1.setAccessible(true);field1.set(obj, 2222);Method method10 = clazz.getDeclaredMethod("logStatic", null);method10.setAccessible(true);method10.invoke(obj, null); 注意，私有变量时需要调用 setAccessible，不然会报错 修改 final 修饰的常量在 java 中，使用 final 修饰的代表常量，不允许修改。当我们通过反射修改时 1234567// 修改final常量Field field2 = clazz.getDeclaredField("FINAL_NAME");field2.setAccessible(true);field2.set(obj, "FINAL_NAME_NEW");Method method11 = clazz.getDeclaredMethod("logFinal", null);method11.setAccessible(true);method11.invoke(obj, null); 采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。 针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改 123456789// 正确的修改final常量方式Field field3 = clazz.getDeclaredField("FINAL_NAME");field3.setAccessible(true);Field modifiers = Field.class.getDeclaredField("modifiers");modifiers.setAccessible(true);modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);field3.set(obj, "FINAL_NAME_NEW");Method method12 = clazz.getDeclaredMethod("logFinal", null);method12.invoke(obj, null); 反射构造函数在上面调用生成实例中：Object obj = clazz.newInstance(); 其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。修改 ExampleReflex.java 中的构造函数 1234567private ExampleReflex(int a) &#123; Log.d(TAG, "Constructor ExampleReflex: " + a);&#125;public ExampleReflex(String name) &#123; this.name = name;&#125; 直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例 通过 public 有参构造函数生成实例 12345678Class clazz = Class.forName("weightmeasure.justin.test.ExampleReflex");// 获取public 有参的构造函数Constructor constructor1 = clazz.getConstructor(String.class);// 通过构造函数生成对象 参数为入参类型classObject obj = constructor1.newInstance("NNNNN");Method method81 = clazz.getDeclaredMethod("getName", null);method81.setAccessible(true);method81.invoke(obj, null); 通过 private 有参构造函数生成实例 1234// 获取private 有参构造函数Constructor constructor2 = clazz.getDeclaredConstructor(int.class);// 生成实例Object obj2 = constructor2.newInstance(222); 反射原理在上面其实讲的都是反射的使用，包括函数、属性、构造器等而关于反射能够使用的原理，大概描述：当类被加载时，会将类中的构造器、属性、函数，都缓存到 Class 类的内部类 ReflectionData 中。而反射就是，先判断该类是否加载过，加载过则直接去 ReflectionData 中取，如果没加载过就报错。 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化； 每个类都会有一个与之对应的 Class 实例，从而每个类都可以获取 method 反射方法，并作用到其他实例身上； 反射也是考虑了线程安全的，放心使用； 反射使用软引用 relectionData 缓存 class 信息，避免每次重新从 jvm 获取带来的开销； 反射调用多次生成新代理 Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器； 当找到需要的方法，都会 copy 一份出来，而不是使用原来的实例，从而保证数据隔离； 调度反射方法，最终是由 jvm 执行 invoke0()执行； 參考連結：https://www.cnblogs.com/yougewe/p/10125073.html]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 复习导航]]></title>
    <url>%2Fblog%2F2021%2F10%2Fandroid-%E5%A4%8D%E4%B9%A0%E5%AF%BC%E8%88%AA.html</url>
    <content type="text"><![CDATA[java 篇 类加载机制 双亲委派机制 反射 注解 注入 序列化 范型 集合 Map List LinkedList Set HashMap 内存 内存抖动 内存泄露 内存溢出 GC 算法 JVM 结构 JMM（java 内存模型） 四种引用类型 多线程 线程池 wait/notify 锁 原子类 ThreadLocal 线程的状态、转换 android 篇 四大组件 Activity Service BroadcastReceiver-LocalBroadcastReceiver (為何更高效) Provider 生命周期 Activity 生命周期 Service 生命周期 消息机制 Handler IdleHandler Looper MessageQueue 事件分发机制 View/ViewGroup 滑动冲突 自定义 View onMeasure onLayout onDraw 注入 数据持久化 SharePreferences 跨进城通信 AIDL Binder 设计模式 MVC MVP MVVM 第三方插件 GSON okHttp Rxjava Dagger Dagger2 APT ARouter Glide UI ListView ViewPager Fragment Stub RecyclerView Adapter 其他语言 Kotlin C/C++ 混合开发平台 Cordova react-native Flutter 原理 渲染机制]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm内存说明]]></title>
    <url>%2Fblog%2F2021%2F08%2Fjvm%E5%86%85%E5%AD%98%E8%AF%B4%E6%98%8E.html</url>
    <content type="text"><![CDATA[针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出 内存抖动在一定时间内，频繁的创建对象然后又回收，使内存存在明显的上下波动一般可能发生在循环中大量创建了局部对象 内存抖动的影响，抖动频繁的话会导致回收也频繁，而频繁的 GC 是会造成性能影响的。因为每次 GC 时会挂起线程两次，二次还会产生内存碎片。 要考虑多复用对象，涉及模式：享元模式 内存泄漏在程序运行期间，已经没有被使用的对象，引用却一直被持有，导致该对象无法被回收，此时就会造成内存泄漏 内存泄漏的影响：会造成无用对象无法被回收，使内存空间越来越小，最终可能会造成内存溢出 一般示例：Inflater 的创建需要 Context 对象，传入 Actiivty 时创建完后，需要将 Inflater 的实例对象置空，此时就会消除对 Activity 对象引用的持有，不然就会造成 Activity 的内存泄漏 内存溢出当创建对象时，JVM 无法分配足够的内存，此时就会执行 GC，清理内存已获取足够的空间。但如果 GC 后仍然无法获取足够的空间时，此时就会抛出异常 OOM（内存溢出），中断程序的运行 影响：会抛出异常，中断程序的运行与内存抖动、内存泄漏不同，内存抖动、内存泄漏都不会影响程序的运行，最多只会影响程序运行的性能，内存溢出则会直接报错，中断程序的运行。内存溢出是内存泄漏的持续结果。 解决办法：程序内存溢出后会在特定目录输出 .trace 文件，需要分析文件确定造成内存溢出的代码块。 常见的内存溢出：流使用完后未关闭、Cursor 使用完后未关闭、短时间创建大量的大内存对象]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习导航]]></title>
    <url>%2Fblog%2F2021%2F08%2Fandroid%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA.html</url>
    <content type="text"><![CDATA[android 学习思维导图 123456789101112graph LRJVM知识点 --&gt; A(内存问题)A --&gt; 内存抖动A --&gt; 内存泄漏A --&gt; 内存溢出JVM知识点 --&gt; B(JVM结构)B --&gt; JVM结构B --&gt; GC回收算法B --&gt; JMM内存模型JVM知识点 --&gt; C(四种引用类型)]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android应用启动过程]]></title>
    <url>%2Fblog%2F2021%2F07%2Fandroid%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[android 应用启动过程 首先，手机中的主页面、以及显示各个应用图标的页面本身就是一个 Activityandroid 应用启动就是我们点击应用图标后的过程 以下以 API28 为例 应用启动涉及 L：三个进程、六个大类 三个进程：Launcher 进程：整个 App 启动流程的起点，负责接收用户点击屏幕事件，它其实就是一个 Activity，里面实现了点击事件，长按事件，触摸等事件，可以这么理解，把 Launcher 想象成一个总的 Activity，屏幕上各种 App 的 Icon 就是这个 Activity 的 button，当点击 Icon 时，会从 Launcher 跳转到其他页面。 SystemServer 进程：这个进程在整个的 Android 进程中是非常重要的一个，地位和 Zygote 等同，它是属于 Application Framework 层的，Android 中的所有服务，例如 AMS, WindowsManager, PackageManagerService 等等都是由这个 SystemServer fork 出来的。 App 进程：你要启动的 App 所运行的进程。 六个大类：ActivityManagerService：（AMS）AMS 是 Android 中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要，它本身也是一个 Binder 的实现类。 Instrumentation：监控应用程序和系统的交互。 ActivityThread：应用的入口类，通过调用 main 方法，开启消息循环队列。ActivityThread 所在的线程被称为主线程。 ApplicationThread：ApplicationThread 提供 Binder 通讯接口，AMS 则通过代理调用此 App 进程的本地方法。 ActivityManagerProxy：AMS 服务在当前进程的代理类，负责与 AMS 通信。 ApplicationThreadProxy：ApplicationThread 在 AMS 服务中的代理类，负责与 ApplicationThread 通信。 可以说，启动的流程就是通过这六个大类在这三个进程之间不断通信的过程。 LauncherActivitypackage android.app; LauncherActivity 既是显示所有应用图标的系统页面LauncherActivity 布局是一个 ListView listView 的数据集就是 所有应用的数据集合，每个应用信息为 ListItem ListItem123456789101112131415161718192021222324public static class ListItem &#123; public ResolveInfo resolveInfo; public CharSequence label; public Drawable icon; // 图标 public String packageName; // 应用包名 public String className; // 启动Activity的类名 public Bundle extras; ListItem(PackageManager pm, ResolveInfo resolveInfo, IconResizer resizer) &#123; this.resolveInfo = resolveInfo; label = resolveInfo.loadLabel(pm); ComponentInfo ci = resolveInfo.activityInfo; if (ci == null) ci = resolveInfo.serviceInfo; if (label == null &amp;&amp; ci != null) &#123; label = resolveInfo.activityInfo.name; &#125; if (resizer != null) &#123; icon = resizer.createIconThumbnail(resolveInfo.loadIcon(pm)); &#125; packageName = ci.applicationInfo.packageName; className = ci.name; &#125;&#125; 而 ListView 涉及的所有信息信息是在 Adapter 的构造函数中获取的，也就是说其实在启动 LauncherActivity 时，已经获取到所有应用信息 接下来查看 Item 的点击事件，即启动应用的逻辑。 12345@Overrideprotected void onListItemClick(ListView l, View v, int position, long id) &#123; Intent intent = intentForPosition(position); startActivity(intent);&#125; 此时就会进入到 Activity 的 startActivity，最后会进入 Activity 的下列方法中：requestCode: -1 options: null是在系统页面开启另一个应用，所以 mParent = null 123456789101112131415161718192021222324252627282930313233343536public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; &#125; 此时会进入 Instrumentation.java 中的 execStartActivity 函数（7 个参数的）然后又会调用到 1234int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, 0, null, options); 又会调用到 ActivityManagerService 中的 startActivity然后会调用到 ActivityManagerService 中的 startActivityAsUser 123456789101112131415161718192021222324public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; enforceNotIsolatedCaller("startActivity"); userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser"); // TODO: Switch to user app stacks here. return mActivityStartController.obtainStarter(intent, "startActivityAsUser") .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute(); &#125; 此处使用构建者模式，execute 执行的是 ActivityStarter.java 中的 execute 函数 而最终会调用到 1193 行的 startActivity 12345678910111213141516171819202122private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; ... result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); ... return result; &#125;private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; ... mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); ... return START_SUCCESS;&#125; 会执行 ActivityStackSupervisor 中的 resumeFocusedStackTopActivityLocked 12345678910boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; ... if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; ...&#125; 然后又会执行到 ActivityStack 中的 resumeTopActivityUncheckedLocked 1234567891011121314boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ... result = resumeTopActivityInnerLocked(prev, options); ... return result;&#125;private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... mStackSupervisor.startSpecificActivityLocked(next, true, false); if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; 又会回到 ActivityStackSupervisor 中的 startSpecificActivityLocked 函数 123456789101112131415161718192021222324252627282930313233void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); getLaunchTimeTracker().setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !"android".equals(r.info.packageName)) &#123; // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode, mService.mProcessStats); &#125; realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; 此时会通过 AMS 获取进程信息，判断进程是否存在，应用进程存在时会调用 realStartActivityLocked应用进程不存在时会调用 AMS 中的 startProcessLocked 去开启新进程 暂时先看 应用进程不存在的情景： AMS startProcessLocked 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@GuardedBy("this")private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */);&#125;@GuardedBy("this")private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride) &#123; return startProcessLocked(app, hostingType, hostingNameStr, false /* disableHiddenApiChecks */, abiOverride);&#125;private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, boolean disableHiddenApiChecks, String abiOverride) &#123; ... return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime);&#125;@GuardedBy("this")private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint, app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo, requiredAbi, instructionSet, invokeWith, app.startTime); ...&#125; private ProcessStartResult startProcess(String hostingType, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; try &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName); checkTime(startTime, "startProcess: asking zygote to start proc"); final ProcessStartResult startResult; if (hostingType.equals("webview_service")) &#123; startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; else &#123; startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, new String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; checkTime(startTime, "startProcess: returned from zygote!"); return startResult; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125; 然后会调用 Process 中 start 去开启进程同时注意，此处会判断进程类型， webview 123456789101112131415public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) &#123; return zygoteProcess.start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs); &#125; 然后又会调用到 ZygoteStartFailedEx 中的 start 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 public final Process.ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) &#123; ... return startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */, zygoteArgs);&#125;private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean startChildZygote, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(mLock) &#123; return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125;@GuardedBy("mLock")private static Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; // Throw early if any of the arguments are malformed. This means we can // avoid writing a partial response to the zygote. int sz = args.size(); for (int i = 0; i &lt; sz; i++) &#123; if (args.get(i).indexOf('\n') &gt;= 0) &#123; throw new ZygoteStartFailedEx("embedded newlines not allowed"); &#125; &#125; /** * See com.android.internal.os.SystemZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; writer.flush(); // Should there be a timeout on this? Process.ProcessStartResult result = new Process.ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx("fork() failed"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125;&#125; 最终执行 zygoteSendArgsAndGetResult 函数来完成进程的创建。注意：Android 中有一个重要的进程 Zygote，翻译为受精卵进程，所有的应用程序进程都是通过 Zygote 进程 fork 得来的。 简单来说就是通过 Binder 请求 AMS 进程，然后 AMS 再发送 Socket 消息给 Zygote 进程，最后统一由 Zygote 进程 fork 出应用进程。 当进程创建完成后，会执行 ActivityThread 中的 main 方法 在 ActivityThread 中就会启动 消息分发 、 Application 的创建、Activity 的创建]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++高级]]></title>
    <url>%2Fblog%2F2021%2F05%2Fc-%E9%AB%98%E7%BA%A7.html</url>
    <content type="text"><![CDATA[c++ 高级部分 STL 容器STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。 STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。 从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。 Vector 数组数组的特征：只能保存相同类型的数据、内存连续，数据具备索引，根据索引查找快，增、删慢 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int main() &#123; cout &lt;&lt; "STL 标准模版库 容器学习1 Vector" &lt;&lt; endl; vector&lt;int&gt;vector1; // 创建数组 vector&lt;int&gt;vector2(8); // 创建8个容量的数组 vector&lt;int&gt;vector3(10, -1); // 创建10个容量的数组，且默认值都是 -1 // 遍历 int i = 0; for(i = 0; i &lt; vector3.size(); i ++) &#123; // 修改值 vector3[i] = i; cout &lt;&lt; "i:" &lt;&lt; i &lt;&lt; " value:" &lt;&lt; vector3[i] &lt;&lt; endl; &#125; // 插入值 // 从头部插入 vector1.insert(vector1.begin(), 40); vector1.insert(vector1.begin(), 30); vector1.insert(vector1.begin(), 20); vector1.insert(vector1.begin(), 10); // 从尾部插入 vector1.insert(vector1.end(), 99); // 使用迭代器遍历 for(vector&lt;int&gt;::iterator ite = vector1.begin(); ite != vector1.end(); ite ++) &#123; // 迭代器获取的是地址 cout &lt;&lt; "迭代器遍历" &lt;&lt; *ite &lt;&lt; endl; &#125; // 因为vector2在构造函数中申明了容量为8，此时不能进行插入或者删除操作。会报错// vector2.insert(vector2.begin(), 22);// vector2.insert(vector2.end(), 33);// vector2.insert(vector2.begin(), 44);// vector2.insert(vector2.begin(), 44);// vector2.insert(vector2.begin(), 22);// vector2.insert(vector2.end(), 33);// vector2.insert(vector2.begin(), 44);// vector2.insert(vector2.begin(), 44); // 删除尾部// vector2.erase(vector2.end());// // 删除头部// vector2.erase(vector2.begin()); // 迭代器自动推导类型 类似于kotlin for(auto iter = vector2.begin(); iter != vector2.end(); iter++) &#123; *iter = 88; cout &lt;&lt; "自动推导迭代器遍历" &lt;&lt; *iter &lt;&lt; endl; &#125; return 0;&#125; stack 栈栈的数据特点：先进后出、后进先出，类似于方法栈进栈、出栈12345678910111213141516171819int main() &#123; cout &lt;&lt; "STL stack 栈的学习" &lt;&lt;endl; // 初始化 stack&lt;int&gt; stack1; // 压栈 stack1.push(1); stack1.push(2); stack1.push(20); stack1.push(22); // 弹栈 stack1.pop(); cout &lt;&lt; "栈顶元素:" &lt;&lt; stack1.top() &lt;&lt; endl; // 栈没有迭代器，也没有索引 这样遍历的话，会将栈内元素都弹出。 while (!stack1.empty()) &#123; cout &lt;&lt; "遍历栈元素：" &lt;&lt; stack1.top() &lt;&lt; endl; stack1.pop(); &#125; return 0;&#125; 压栈、弹栈函数都是没有返回值的，top函数获取栈顶元素 queue 队列队列的数据特点： FIFO 先进先出，后进后出。与栈不同队列内部可以使用数组实现、也可以使用链表实现 12345678910111213141516int main() &#123; cout &lt;&lt; "STL 三 队列queue学习" &lt;&lt; endl; queue&lt;int&gt; que; que.push(1); que.push(2); que.push(3); cout &lt;&lt; "队列队头元素：" &lt;&lt; que.front() &lt;&lt; endl; cout &lt;&lt; "队列队尾元素" &lt;&lt; que.back() &lt;&lt; endl; // 队列也是没有迭代器的，只能采用与栈相同的方式遍历数据 while (!que.empty()) &#123; cout &lt;&lt; "遍历 队列队头元素：" &lt;&lt; que.front() &lt;&lt; endl; que.pop(); &#125; return 0;&#125; 优先级队列优先级队列是队列的一个子集，内部数据结构通过数组实现，而且是数据有序排练，默认是降序。不论数据push的顺序，直接给你降序处理，可以设置成升序排列 1234567891011121314151617181920int main() &#123; cout &lt;&lt; "STL 三 优先级队列priority_queue学习" &lt;&lt; endl; // 默认是降序排列// priority_queue&lt;int&gt; que; // 设置成升序排列 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;que; que.push(20); que.push(50); que.push(60); que.push(30); que.push(10); que.push(70); while (!que.empty()) &#123; cout &lt;&lt; "遍历 优先级队列队头元素：" &lt;&lt; que.top() &lt;&lt; endl; que.pop(); &#125; return 0;&#125; list 链表链表的数据特点，内存非连续，每个节点有下一个节点的指针，增删快，但查询慢，增加、删除都只能在表头操作 1234567891011121314151617181920212223242526272829int main()&#123; cout &lt;&lt; "STL 四 链表list学习" &lt;&lt; endl; list&lt;int&gt; listArr; // push listArr.push_front(11); // 从链头添加一个值 listArr.push_back(80); // 从链尾添加一个值 // 插入 listArr.insert(listArr.end(), 99); // 插入一个值到链尾 listArr.insert(listArr.end(), 98); // 插入一个值到链尾 listArr.insert(listArr.begin(), 20); // 插入一个值到链头 listArr.insert(listArr.begin(), 22); // 插入一个值到链头 // 删除 listArr.erase(listArr.begin());// listArr.erase(listArr.end()); // 这一句在运行时报错，不知道为何 // 使用迭代器遍历 for(list&lt;int&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123; cout &lt;&lt; "链表迭代器遍历：" &lt;&lt; *it &lt;&lt; endl; &#125; // 清除所有元素 listArr.clear(); cout &lt;&lt; "clear" &lt;&lt; endl; for(list&lt;int&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123; cout &lt;&lt; "链表迭代器遍历：" &lt;&lt; *it &lt;&lt; endl; &#125; return 0;&#125; set 红黑树内部结构 红黑树 会对你存入的数据进行排序，但是绝对不允许元素相同 默认会升序排列，123456789101112131415161718192021222324252627282930int main() &#123; cout &lt;&lt; "STL 五 set 学习" &lt;&lt; endl; set&lt;int&gt;setV; // 插入值 // 默认会升序排列 setV.insert(80); setV.insert(70); setV.insert(50); setV.insert(90); // 当插入已经存在的值时，会失败，因为不允许重复 pair&lt;set&lt;int, less&lt;int&gt;&gt;::iterator, bool&gt; result = setV.insert(60); // 注意set的insert函数是有返回值的，first是迭代器 second是插入的结果 if(result.second) &#123; // 插入成功 cout &lt;&lt; "插入成功" &lt;&lt; endl; // 注意此处取得的迭代器不是从begin开始，而是从插入的值60处开始的。 for(; result.first != setV.end(); result.first ++) &#123; cout &lt;&lt; "插入结果迭代器遍历的值:" &lt;&lt; * result.first &lt;&lt; endl; &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; // 迭代器遍历 for(set&lt;int&gt;::iterator it = setV.begin(); it != setV.end(); it ++) &#123; cout &lt;&lt; "迭代器遍历的值:" &lt;&lt; * it &lt;&lt; endl; &#125; return 0;&#125; 谓词转自：https://www.cnblogs.com/xym4869/p/12250174.html 1.函数(function)谓词通过传递函数名, 匹配二元谓词(binary predicates), 根据函数提供的策略, 输出值; 12345/*Function Predicate*/bool isLarger (const std::string &amp;s1, const std::string &amp;s2) &#123; return s1.size() &gt; s2.size();&#125;std::stable_sort(sv.begin(), sv.end(), isLarger); 2.函数指针(function pointer)谓词建立一个函数指针, 传入算法, 使用指针代替函数名, 用法类似函数谓词. 123bool (*pf) (const std::string &amp;s1, const std::string &amp;s2);pf = &amp;isLarger;std::stable_sort(sv.begin(), sv.end(), *pf); 3.Lambda表达式(lambda expression)谓词Lambda表达式格式: [capture list] (parameter list) -&gt; return type { function body }需要匹配谓词数, 一元(unary) 或 二元(binary), 也可以通过[capture list]传递函数的变量; 12std::stable_sort(sv.begin(), sv.end(), [](const std::string&amp; s1, const std::string&amp; s2)&#123; return s1.size()&gt;s2.size(); &#125;); 4.函数对象(Function Object)谓词类中重载函数的调用”()”, 使类可以被调用, 并且传入算法谓词中, 进行使用. 123456789/*Function Object*/class LargerString &#123;public: bool operator() (const std::string&amp; a, const std::string&amp; b) &#123; return a.size() &gt; b.size(); &#125;&#125;;......std::stable_sort(sv.begin(), sv.end(), LargerString()); 5、结构体谓词 12345678910111213// 真正的谓词struct doCompareAction2 &#123;public: bool operator() (const Person&amp; __x, const Person&amp; __y) &#123; return __x.id &lt; __y.id; &#125;&#125;;int main() &#123; set&lt;Person, doCompareAction2&gt; setVar; return 0;&#125; mapmap: key value键值对容器，默认会对key进行排序，所以不能存在重复的key，会添加失败 value可以重复1234567891011121314151617181920212223242526272829303132int main()&#123; cout &lt;&lt; "STL 六 map学习" &lt;&lt; endl; map&lt;int, string&gt;mapVar; // 插入值 需要借助 std::pair mapVar.insert(pair&lt;int, string&gt;(1, "justin")); mapVar.insert(pair&lt;int, string&gt;(5, "justinA")); mapVar.insert(pair&lt;int, string&gt;(3, "justin")); // 使用迭代器遍历 for(map&lt;int, string&gt;::iterator it = mapVar.begin(); it != mapVar.end(); it++) &#123; cout &lt;&lt; "key:" &lt;&lt; it-&gt;first &lt;&lt; " value:" &lt;&lt; it-&gt;second &lt;&lt;endl; &#125; // 获取插入值的结果 pair&lt;map&lt;int,string&gt;::iterator, bool&gt; result = mapVar.insert(pair&lt;int, string&gt;(4, "novia")); if(result.second) &#123; cout &lt;&lt; "插入值成功" &lt;&lt; endl; // 因为有排序，只会遍历从4以及4以后的元素 for(; result.first != mapVar.end(); result.first ++) &#123; cout &lt;&lt; "key:" &lt;&lt; result.first-&gt;first &lt;&lt; " value:" &lt;&lt; result.first-&gt;second &lt;&lt;endl; &#125; &#125; else &#123; cout &lt;&lt; "插入值失败" &lt;&lt; endl; &#125; // 查询 是根据key查询的 map&lt;int, string&gt;::iterator findResult = mapVar.find(3); if(findResult != mapVar.end()) &#123; cout &lt;&lt; "已找到" &lt;&lt; findResult -&gt; first &lt;&lt; ", " &lt;&lt; findResult-&gt;second.c_str() &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "查找key失败" &lt;&lt; endl; &#125; return 0;&#125; multimapmultimap 属于 map下的子集// 1.key可以重复， 2.key重复的数据可以分组, 3.key会排序， 4.value不会排序1234567891011121314151617181920212223242526272829303132333435363738394041int main()&#123; cout &lt;&lt; "STL 七 multimap学习" &lt;&lt; endl; multimap&lt;int, string&gt;multimapVar; multimapVar.insert(make_pair(10, "justin")); multimapVar.insert(make_pair(10, "novia")); multimapVar.insert(make_pair(10, "justin")); multimapVar.insert(make_pair(20, "justin")); multimapVar.insert(make_pair(20, "novia")); multimapVar.insert(make_pair(20, "coco")); multimapVar.insert(make_pair(30, "justin1")); multimapVar.insert(make_pair(30, "justin2")); multimapVar.insert(make_pair(30, "justin3")); for(multimap&lt;int, string&gt;::iterator it = multimapVar.begin(); it != multimapVar.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it -&gt; second &lt;&lt; endl; &#125; // TODO 核心功能是分组 int result; cout &lt;&lt; "请输入你要查询的key，为int类型:" &lt;&lt; endl; cin &gt;&gt; result; multimap&lt;int, string&gt;::iterator iteratorVar = multimapVar.find(result); while (iteratorVar != multimapVar.end()) &#123; cout &lt;&lt; iteratorVar-&gt;first &lt;&lt; "," &lt;&lt; iteratorVar-&gt;second &lt;&lt; endl; // 需要自己做逻辑控制，不然有问题 iteratorVar++; if (iteratorVar-&gt;first != result) &#123; break;; // 循环结束 &#125; // 严谨性 if (iteratorVar == multimapVar.end()) &#123; break;; // 循环结束 &#125; &#125; return 0;&#125; 防函数12345678910111213141516171819202122232425262728293031323334353637class TestForEach&#123;public: int size = 0; void _size() &#123; cout &lt;&lt; "size：" &lt;&lt; size &lt;&lt; endl; &#125; void operator()(int content) &#123; cout &lt;&lt; "自定义防函数" &lt;&lt; content &lt;&lt; endl; size++; &#125;&#125;;void fake(int content) &#123; cout &lt;&lt; "自定义函数" &lt;&lt; content &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; "防函数学习" &lt;&lt; endl; TestForEach forEach; set&lt;int&gt;setVar; setVar.insert(10); setVar.insert(20); setVar.insert(500); setVar.insert(40); setVar.insert(30); setVar.insert(50); setVar.insert(60); // set 红黑树本身没有没有记录size，我们可以通过防函数记录 // for_each是有返回值的，返回值是 防函数本身 for_each(setVar.begin(), setVar.end(), fake); forEach = for_each(setVar.begin(), setVar.end(), forEach); forEach._size(); return 0;&#125; 在源码中有很多防函数的使用，其实我们自己可以手动实现一个防函数，并替换源码中的 1234567891011121314151617181920212223242526// 自定义加法template&lt;typename T&gt;struct plus_d&#123; T operator() (const T &amp; x, const T &amp; y)&#123; return x + y; &#125;&#125;;int main()&#123; cout &lt;&lt; "自定义实现算法" &lt;&lt; endl; // 使用系统自带的加法 plus&lt;int&gt;sum_int; cout &lt;&lt; "int相加" &lt;&lt; sum_int(1,2) &lt;&lt; endl; plus&lt;string&gt;sum_str; cout &lt;&lt; "字符相加" &lt;&lt; sum_str("AAA","BBB") &lt;&lt; endl; // 接下来自己实现加法 plus_d&lt;float&gt;sum_flo; cout &lt;&lt; "自定义 float相加" &lt;&lt; sum_flo(1.78f, 2.56f) &lt;&lt; endl; plus_d&lt;string&gt;sum_s; cout &lt;&lt; "自定义 字符相加" &lt;&lt; sum_s("justin ", "and novia") &lt;&lt; endl; return 0;&#125; 关于模版函数 1234567// 定义模版 Params1 第一个参数类型 Params2 第二个参数类型 ReturnType 返回值类型template&lt;typename Params1, typename Params2, typename ReturnType&gt;struct binary_function&#123; typedef Params1 first_argument_type; // 第一个参数的别名 typedef Params2 second_argument_type; // 第二个参数的别名 typedef ReturnType result_type; // 返回值别名&#125;;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础 五]]></title>
    <url>%2Fblog%2F2021%2F04%2Fc-%E5%9F%BA%E7%A1%80-%E4%BA%94.html</url>
    <content type="text"><![CDATA[c++基础 五继承与kotlin中一样，类的继承使用 : 表示。不同的是，c++继承分为私有继承、公开继承，默认为私有继承 1.默认是 隐式代码： : private Person 2.私有继承：在子类里面是可以访问父类的成员，但是在类的外面不行 3.必须公开继承，才可以访问父类的成员 1234567891011121314151617181920212223242526272829303132333435363738394041class Father &#123; private: int age;public: char * name;&#125;;class Son : Father &#123; // 默认私有 private 继承public: void setName() &#123;// this-&gt;age = 19;// 'age' is a private member of 'Father' this-&gt;name = "son"; &#125; char * getName()&#123; return this-&gt;name; &#125;&#125;;class Daugther : public Father &#123; // 公开继承public: void setName() &#123;// this-&gt;age = 19; // 'age' is a private member of 'Father' this-&gt;name = "dauther"; &#125; char * getName()&#123; return this-&gt;name; &#125;&#125;;int main()&#123; cout &lt;&lt; "HELLO WORLD!" &lt;&lt; endl; Son son; son.setName();// son.name; //报错 'name' is a private member of 'Father' Daugther daugther; daugther.setName(); cout &lt;&lt; "daugther.name : " &lt;&lt; daugther.name &lt;&lt; endl; return 0;&#125; 总结： 子类不能访问父类的私有属性 子类直接继承为私有继承 私有继承的子类对象不能访问父类的属性，只能在类中访问 公开继承的子类对象可以访问父类的属性，在类中同样可以 多继承 C++ 是允许多继承的 Java语言不允许多继承，多继承有歧义，如果Java语言多继承 就会导致代码不健壮，（二义性） Java多实现：做的非常棒，严格避免出现 二义性问题（歧义） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Mother&#123;public: void raisChild() &#123; cout &lt;&lt; "Mother raisChild" &lt;&lt; endl; &#125; void work() &#123; cout &lt;&lt; "Mother work" &lt;&lt; endl; &#125; void play() &#123; cout &lt;&lt; "Mother play" &lt;&lt; endl; &#125; void playWithChild() &#123; cout &lt;&lt; "Mother playWithChild" &lt;&lt; endl; &#125; &#125;;class Father &#123;public: void smoking() &#123; cout &lt;&lt; "Father smoking" &lt;&lt; endl; &#125; void work() &#123; cout &lt;&lt; "Father work" &lt;&lt; endl; &#125; void play() &#123; cout &lt;&lt; "Father play" &lt;&lt; endl; &#125; void playWithChild() &#123; cout &lt;&lt; "Father playWithChild" &lt;&lt; endl; &#125;&#125;;class Son: public Mother, public Father &#123;public: void work() &#123; cout &lt;&lt; "Son work" &lt;&lt; endl; &#125; void play() &#123; cout &lt;&lt; "Father play" &lt;&lt; endl; &#125;&#125;;int main() &#123; cout &lt;&lt; "HELLO WORLD!" &lt;&lt; endl; Son son; // 这个是优先寻找子类的函数，因为特别明确，没有问题，还没有产生歧义（二义性） son.work(); son.play(); son.raisChild(); son.playWithChild(); // 报错 Member 'playWithChild' found in multiple base classes of different types return 0;&#125; 如上述代码所示，Son类同时继承自Father、Mother类，这两个类有一些相同的函数work、play、playWithChild但子类Son也实现了work、play时，执行这些函数不会报错，但调用playWithChild则会报错，因为两个父类都有该函数、但子类未实现，此时就存在二义性问题。解决这样的问题，存在两个办法： 1、指定调用哪个父类的该函数 使用 ::父类.函数名son.Father::playWithChild(); 2、在子类也实现该函数 在Son类中添加playWithChild函数。 总结： 1、c++可以多继承 2、多继承时，如果多个父类间存在同名同参函数，子类指针使用时，会存在二义性问题，需要子类也实现该函数，或者指定父类调用 3、真实开发时，一般时子类也会定义同名成员，覆盖掉多个父类同名成员。 虚继承二义性问题出现在菱形继承。关于二义性问题，还有一种解决办法，就是虚继承。第三种解决方案： 【虚基类】 属于 虚继承的范畴真实C++开始，是很少出现，二义性（歧义） 如果出现， 系统源码（系统用 第三种解决方案） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 祖父类class Object&#123;public: int number; void show() &#123; cout &lt;&lt; &quot;Object show run...&quot; &lt;&lt; endl; &#125;&#125;;// 等下讲 virtual 的原理是什么 ...// 父类1class BaseActivity1 : virtual public Object &#123;// public:int number; // 人为制作二义性 error: request for member &apos;number&apos; is ambiguous&#125;;// 父类2class BaseActivity2 : virtual public Object &#123;// public:int number;&#125;;// 子类class Son : public BaseActivity1, public BaseActivity2 &#123;&#125;;int main() &#123; cout &lt;&lt; &quot;HELLO WORLD!!!!&quot; &lt;&lt; endl; Object object; BaseActivity1 baseActivity1; BaseActivity2 baseActivity2; Son son; object.number = 100; baseActivity1.number = 200; baseActivity2.number = 300; son.number = 400; object.show(); baseActivity1.show(); baseActivity2.show(); son.show(); cout &lt;&lt; object.number &lt;&lt; endl; cout &lt;&lt; baseActivity1.number &lt;&lt; endl; cout &lt;&lt; baseActivity2.number &lt;&lt; endl; cout &lt;&lt; son.number &lt;&lt; endl; return 0;&#125; 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class） 上面的例子中：Object就是虚基类，BaseActivity1、BaseActivity2都是虚继承于Object，然后Son都公开继承于BaseActivity1、BaseActivity2在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 虚函数多态（虚函数）。 动态多态（程序的角度上：程序在运行期间才能确定调用哪个类的函数 == 动态多态的范畴）Java语言默认支持多态C++默认关闭多态，怎么开启多态？ 虚函数 在父类上给函数增加 virtual关键字 1234567891011121314151617181920212223242526272829303132333435363738394041424344class BaseActivity &#123; public: virtual void onStart()&#123; cout &lt;&lt; "BaseActivity onStart" &lt;&lt; endl; &#125;&#125;;class HomeActivity : public BaseActivity &#123; public: void onStart() &#123; cout &lt;&lt; "HomeActivity onStart" &lt;&lt; endl; &#125;&#125;;class MyActivity : public BaseActivity &#123;public: void onStart() &#123; cout &lt;&lt; "MyActivity onStart" &lt;&lt; endl; &#125;&#125;;void onActivityStart(BaseActivity * baseActivity) &#123; baseActivity-&gt;onStart();&#125;int main() &#123; cout &lt;&lt; "HELLO WORLD!!" &lt;&lt; endl; HomeActivity * homeActivity = new HomeActivity(); MyActivity * myActivity = new MyActivity(); onActivityStart(homeActivity); onActivityStart(myActivity); if(myActivity &amp;&amp; homeActivity) &#123; delete homeActivity; homeActivity = NULL; delete myActivity; myActivity = NULL; &#125; return 0;&#125; 多态的定义 *父类的引用指向之类的对象，同一个方法有不同的实现，重写（动态多态）和 重载(静态多态) 函数重载函数重载即为 静态多态重载：函数名相同，但入参不同 12345678910111213141516171819202122int add (int a, int b) &#123; cout &lt;&lt; "int: " &lt;&lt; a + b &lt;&lt; endl; return a + b;&#125;float add (float a, float b) &#123; cout &lt;&lt; "float: " &lt;&lt; a + b &lt;&lt; endl; return a + b;&#125;double add (double a, double b) &#123; cout &lt;&lt; "double: " &lt;&lt; a + b &lt;&lt; endl; return a + b;&#125;int main() &#123; cout &lt;&lt; "HELLO WORLD!!" &lt;&lt; endl; add(1, 2); add(1.3f, 4.5f); add(1.45, 1.67); return 0;&#125; 纯虚函数c++纯虚函数类似于java中的抽象类 12345678910111213141516171819202122232425262728293031323334353637383940414243class BaseActivity &#123; private: void setContentView(int layoutId)&#123; cout &lt;&lt; "XmlResourceParser解析布局文件信息... 反射" &lt;&lt; endl; &#125; public: void onCreate()&#123; setContentView(getLayoutId()); initData(); initView(); &#125;// virtual int getLayoutId(); // 虚函数 virtual int getLayoutId() = 0; // 纯虚函数 virtual void initData() = 0; virtual void initView() = 0;&#125;;class HomeActivity : public BaseActivity &#123;public: int getLayoutId() &#123; return 100; &#125; void initData() &#123; cout &lt;&lt; "HomeActivity initData" &lt;&lt; endl; &#125; void initView()&#123; cout &lt;&lt; "HomeActivity initView" &lt;&lt; endl; &#125;&#125;;int main() &#123; cout &lt;&lt; "Hello world!" &lt;&lt; endl; // 错误：抽象类型 BaseActivity 绝对不能实例化 // BaseActivity ba; // 報錯 Variable type 'BaseActivity' is an abstract class HomeActivity home; home.onCreate(); return 0;&#125; 注意纯虚函数记得在函数后面写 = 0如果不写 = 0 则会运行报错 全纯虚函数如果类中的函数都是虚函数，则这个类可以被成为全纯虚函数， 相当于java中的接口 回调与java中的函数回调类似123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class User &#123; public: int id; string name; string mobile; User(int id, string name, string mobile): id(id), name(name), mobile(mobile)&#123; this -&gt; toString(); &#125; void toString()&#123; cout &lt;&lt; "用户名:" &lt;&lt; this-&gt;name &lt;&lt; " 用户id：" &lt;&lt; this-&gt;id &lt;&lt; " 用户手机号:" &lt;&lt; this-&gt;mobile &lt;&lt; endl; &#125;&#125;;class ILognResult &#123;public: virtual void success(int code, User user) = 0; virtual void fail(int code, string message) = 0;&#125;;void loginAction(string userName, string password, ILognResult &amp; loginResult) &#123; if(userName.empty() || password.empty()) &#123; cout&lt;&lt; "登录的账号与用户名都不能为空" &lt;&lt; endl; return; &#125; if("justin" == userName &amp;&amp; "123321qQ" == password) &#123; loginResult.success(200, User(1121, "justin", "13163396276")); &#125; else &#123; loginResult.fail(404, "用户名或密码错误"); &#125;&#125;class LoginResultImpl : public ILognResult &#123;public: void success(int code, User user)&#123; cout &lt;&lt; "登录成功：userName:" &lt;&lt; user.name &lt;&lt; " mobile: " &lt;&lt; user.mobile &lt;&lt; endl; &#125; void fail(int code, string message) &#123; cout &lt;&lt; "登录失败：错误状态码:" &lt;&lt; code &lt;&lt; " 错误信息: " &lt;&lt; message &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; "HELLO WORLD!" &lt;&lt; endl; string userName; cout &lt;&lt; "请输入用户名" &lt;&lt; endl; cin &gt;&gt; userName; string password; cout &lt;&lt; "请输入密码" &lt;&lt; endl; cin &gt;&gt; password; LoginResultImpl loginResult; loginAction(userName, password, loginResult); return 0;&#125; 如上代码就是一个登录操作的回调 其实是非常类似于 java中的接口回调的 模版函数c++ 中没有范型概念，但是有模版函数，与java中的范型类似 像我们在之前的 静态多态中对于重载时的举例，加法当我们针对不同的数据类型都需要进行一次重载，但当我们使用函数模版时，写一次即可。 123456789101112131415161718template &lt;typename T&gt;T add(T a, T b) &#123; cout &lt;&lt; "result:" &lt;&lt; a + b &lt;&lt; endl; return a + b;&#125;int main()&#123; cout &lt;&lt; "HELLO WORLD!" &lt;&lt; endl; int a = add(1, 3); float f = add(1.4f, 66.8f); double d = add(3.6, 88.99); cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "f:" &lt;&lt; f &lt;&lt; endl; cout &lt;&lt; "d:" &lt;&lt; d &lt;&lt; endl; return 0;&#125; 如上所示，使用模版函数完成了各个类型的加法计算，使用也与java中的范型及其类似]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NDK C++基础 四]]></title>
    <url>%2Fblog%2F2021%2F04%2FNDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html</url>
    <content type="text"><![CDATA[c++可变参数在java中，可变参数使用 int … 需要声明类型在c++中，可变参数直接使用 … 表示，不限制类型，而是在取值时，申明类型在c++，获取可变参数使用 va_list va_start va_arg va_end 12345678910111213141516171819202122232425void sum(int count, ...) &#123; va_list vp; // 可变参数的动作 va_start(vp, count); // 第二个参数：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息 int num1 = va_arg(vp, int); // 取值 cout &lt;&lt; "num1： " &lt;&lt; num1 &lt;&lt; endl; num1 = va_arg(vp, int); // 取值 cout &lt;&lt; num1 &lt;&lt; endl; num1 = va_arg(vp, int); // 取值 cout &lt;&lt; num1 &lt;&lt; endl; num1 = va_arg(vp, int); // 取值 cout &lt;&lt; num1 &lt;&lt; endl; // 关闭 va_end(vp);&#125;int main() &#123; cout &lt;&lt; "Hello, World!" &lt;&lt; endl; sum(666, 8, 19, 20); return 0;&#125; 关于 va_start 中第二个参数的解释： 可变参数获取其实是根据内存地址来获取的，将函数传入的可变参数前的一个参数作为 va_start 的第二个参数，就是获取到前一个参数的地址，就可以获取到可变参数的首地址，然后再根据取值的类型，既可获取存储需要的size，就可以获取到每一个可变参数的值 * 注意事项： 取值可变参数多个值时，需要用同一个变量接收，即使用同一个内存地址接收 当取的值超出了可变参数的长度时，并不会报错，而是取到一个系统内存地址的值，随机 当取值完毕要调用 va_end 来结束可变参数的获取 我们在使用可变参数时，必须传递一个具体的参数，用于确定可变参数的内存地址， 同时为了方便使用，我们可以传递可变参数的长度。这样也就不会存在可变参数越界取到随机值的问题 123456789101112void sum(int count, ...) &#123; va_list vp; va_start(vp, count); int num = 0; int i = 0; for(i = 0; i &lt; count; i ++) &#123; num = va_arg(vp, int); cout &lt;&lt; num &lt;&lt; endl; &#125; va_end(vp);&#125;sum(3, 8, 19, 20); static 关键字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person &#123; public: int age; static int id; // statin int id = 99; 会报错 Non-const static data member must be initialized out of line Person()&#123; id = 99; // 编译不通过 &#125; static void update()&#123; id = 9; // 编译不通过 &#125; void change()&#123; id = 87; // 编译不通过 &#125;&#125;;int Person::id= 88; // 加上这一句，这样就可以了。 int main() &#123; cout &lt;&lt; "Hello, World!" &lt;&lt; endl; Person person; person.change(); Person::update(); // 类名::可以调用静态函数 cout &lt;&lt; person.id &lt;&lt; endl; // id没实现也会报错 return 0;&#125;```c++静态的总结：* 1.可以直接通过类名::静态成员（字段/函数）* 2.静态的属性必须要初始化，然后再实现（规则）* 3.静态的函数只能取操作静态的属性和方法（Java）## thisthis 指当前的对象** const修饰函数的this意义何在。 **之前讲过常量指针、指针常量、常量指针常量使用const 修饰的函数其实就是对该函数 内部隐式的 this 进行const 修饰，使当前this变为一个 常量指针常量* 常量指针 常量是修饰值的，不能修改指，可以修改地址* 指针常量，不可修改指向的地址，但可以修改指针指向的值* 常量指针常量 既不能修改指向的地址，也不能修改指针指向的数据，即完全只读也就是说使用const修饰的函数，既不能修改 当前对象 中属性的值，也不能修改地址```c++void test() const &#123; this-&gt;age = 19; // 报错 Cannot assign to non-static data member within const member function 'test' int num = 88; &amp;this = NULL; // 报错 Cannot take the address of an rvalue of type 'const Person *'&#125; 友元函数常规来说，private的变量在类之外，都是无法访问的，即使是在外部生成的变量或者子类都是无法修改的。但是在c++中，存在友元函数，可以在友元函数中，类对象可以访问对象的私有属性 123456789101112131415161718192021222324252627class Person &#123;private: int age;public: void setAge(int age) &#123; this -&gt; age = age; &#125; int getAge() &#123; return this-&gt;age; &#125; // 申明友元函数 friend void updateAge(Person *person, int age);&#125;;// 友元函数的实现void updateAge(Person *person, int age) &#123; person-&gt;age = age;&#125;int main() &#123; cout &lt;&lt; "HELLO WoRLD!" &lt;&lt; endl; Person person;// person.age = 10; // 会报错 'age' is a private member of 'Person' person.setAge(19); updateAge(&amp;person, 88); cout &lt;&lt; "age: " &lt;&lt; person.getAge() &lt;&lt; endl; return 0;&#125; 友元类除了友元函数，还存在友元类，和友元类类似，在友元类中，类对象可以访问私有属性与私有函数 1234567891011121314151617181920class Student &#123;private: int age; friend class Class; // 友元类 &#125;;class Class &#123;public: Student student; void setStudentAge(int age) &#123; student.age = age; &#125;; int getStudentAge() &#123; return student.age; &#125;;&#125;;Class cla;cla.setStudentAge(18);cout &lt;&lt; "友元类中输出私有属性：" &lt;&lt; cla.getStudentAge() &lt;&lt; endl; 运算符重载重写运算符的逻辑，使用关键字 operator123456789101112131415161718192021222324252627282930313233343536373839404142class Point&#123;private: int x,y;public: Point(int x, int y) : x(x), y(y) &#123; &#125; int getX()&#123; return this-&gt;x; &#125; int getY()&#123; return this-&gt;y; &#125; void setX(int x)&#123; this-&gt;x = x; &#125; void setY(int y)&#123; this-&gt;y = y; &#125;&#125;;// 对+号做运算符重载Point operator + (Point point1, Point point2) &#123; int x = point1.getX() + point2.getX(); int y = point1.getY() + point2.getY(); Point point(x, y); return point;&#125;// 对象1 + 对象2 C++默认不支持的， Java也不支持，Kotlin也不支持// C++/Kotlin 运算符重载 + 把+重载掉int main() &#123; cout &lt;&lt; "HELLO WORLD!" &lt;&lt; endl; Point point1(100, 100); Point point2(200, 200); Point point = point1 + point2; cout &lt;&lt; "运算符+重载 point x:" &lt;&lt; point.getX() &lt;&lt; " y: " &lt;&lt; point.getY() &lt;&lt; endl; // 这里的加号还是可以正常运算 int a = 1 + 2; cout &lt;&lt; "1 + 2 = " &lt;&lt; a &lt;&lt; endl; return 0;&#125; 上面是将 运算符重载函数写在类外，还可以将重载函数写在类的内部 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Point&#123;private: int x,y;public: Point(int x, int y) : x(x), y(y) &#123; &#125; int getX()&#123; return this-&gt;x; &#125; int getY()&#123; return this-&gt;y; &#125; void setX(int x)&#123; this-&gt;x = x; &#125; void setY(int y)&#123; this-&gt;y = y; &#125; // 对+号重载 // 系统是这样写的 常量引用：不允许修改，只读模式 // const 关键字的解释 // &amp; 性能的提高，如果没有&amp; 运行+ 构建新的副本，会浪费性能 // 如果增加了&amp; 引用是给这块内存空间取一个别名而已 Point operator + (const Point &amp; point) &#123; int x = this-&gt;x + point.x; int y = this-&gt;y + point.y; return Point(x, y); &#125; // 对-号重载 Point operator -(const Point &amp; point) &#123; int x = this-&gt;x - point.x; int y = this-&gt;y - point.y; return Point(x, y); &#125; // 对 ++对象 进行重载 void operator ++ () &#123; cout &lt;&lt; "++对象" &lt;&lt; endl; this-&gt;x = this-&gt;x + 1; this-&gt;y = this-&gt;y + 1; &#125; // 对 对象++ 进行重载 void operator ++(int) &#123; cout &lt;&lt; "对象++" &lt;&lt; endl; this-&gt;x = this-&gt;x + 1; this-&gt;y = this-&gt;y + 1; &#125;&#125;;int main() &#123; cout &lt;&lt; "HELLO WORLD!" &lt;&lt; endl; Point point1(100, 100); Point point2(200, 200); Point point = point1 + point2; cout &lt;&lt; "运算符+重载 point x:" &lt;&lt; point.getX() &lt;&lt; " y: " &lt;&lt; point.getY() &lt;&lt; endl; point1++; ++point1; cout &lt;&lt; "运算符++重载 point1 x:" &lt;&lt; point1.getX() &lt;&lt; " y: " &lt;&lt; point1.getY() &lt;&lt; endl; return 0;&#125; 注意 ++对象 与 对象++ 的区别]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android aidl]]></title>
    <url>%2Fblog%2F2021%2F03%2Fandroid-aidl.html</url>
    <content type="text"><![CDATA[AIDL: Android Interface Definition Language （android 接口定义语言）可以使用 AIDL 定于跨进程的客户端与服务端通信(IPC)的编程接口. 主要流程是在项目中新建一个 aidl 文件，此时会自动在 src 目录下生成 aidl 目录，并创建包名路径，并在路径下生成命名的 aidl 文件。 12345678910111213141516package com.justin.ipc.application;// Declare any non-default types here with import statementsinterface IMyAidlInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); void setName(String name); void getName();&#125; 然后 rebuild project，会在 app/build/generated/aidl_source_doutput_dir/denug/out/包名/下生成对应的 IMyAidlInterface.java 文件 会生成大量代码，首先是接口基本代码： 1234567891011121314151617181920212223242526272829public interface IMyAidlInterface extends android.os.IInterface&#123; /** Default implementation for IMyAidlInterface. */ public static class Default implements com.justin.ipc.application.IMyAidlInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException &#123; &#125; @Override public void setName(java.lang.String name) throws android.os.RemoteException &#123; &#125; @Override public void getName() throws android.os.RemoteException &#123; &#125; @Override public android.os.IBinder asBinder() &#123; return null; &#125; &#125; .... public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException; public void setName(java.lang.String name) throws android.os.RemoteException; public void getName() throws android.os.RemoteException;&#125; 如上代码， 是 IMyAidlInterface.java 文件中代码主体部分，IMyAidlInterface 继承 android.os.IInterface 接口然后有一个默认的静态内部类 Default 实现 IMyAidlInterface 接口，具体的函数实现都是空，没有具体逻辑。注意其中的 asBinder 函数，这是 android.os.IInterface 中的方法 Stub然后在 IMyAidlInterface 接口类中，还有一个静态内部抽象类 Stub 继承自 android.os.Binder 实现 IMyAidlInterface 接口而 android.os.Binder 又实现于 IBinder 接口介于 Binder 对象在系统底层的支持下，Stub 对象就具有了远程传输数据的能力，在生成 Stub 对象的时候会调用 asInterface 方法。 123456789101112public static com.justin.ipc.application.IMyAidlInterface asInterface(android.os.IBinder obj)&#123; if ((obj==null)) &#123; return null; &#125; // 检索 Binder 对象是否是本地接口的实现 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof com.justin.ipc.application.IMyAidlInterface))) &#123; return ((com.justin.ipc.application.IMyAidlInterface)iin); &#125; return new com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);&#125; Binder 为什么具有远程通信的能力，因为如上面所说 Stub 继承了 Binder 类下面是官网对 IBinder 接口的描述：远程对象的基础接口，轻量级远程过程调用机制的核心部分，专为执行进程内和跨进程调用时的高性能而设计。该接口描述了与可远程对象交互的抽象协议。不要直接实现这个接口，而是从Binder扩展。这里我们知道 Binder 实现了 IBinder 接口，也就是说 Binder 具备了远程通信的能力，当不同进程之间（远程）之间通信时，显然使用的是 Stub 的代理对象 Proxy ，而在 Proxy 中的具体函数中，只是将数据序列号，然后在系统跨进程支持下最终调用 onTransact() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123; java.lang.String descriptor = DESCRIPTOR; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(descriptor); return true; &#125; case TRANSACTION_basicTypes: &#123; data.enforceInterface(descriptor); int _arg0; _arg0 = data.readInt(); long _arg1; _arg1 = data.readLong(); boolean _arg2; _arg2 = (0!=data.readInt()); float _arg3; _arg3 = data.readFloat(); double _arg4; _arg4 = data.readDouble(); java.lang.String _arg5; _arg5 = data.readString(); this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); reply.writeNoException(); return true; &#125; case TRANSACTION_setName: &#123; data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); this.setName(_arg0); reply.writeNoException(); return true; &#125; case TRANSACTION_getName: &#123; data.enforceInterface(descriptor); this.getName(); reply.writeNoException(); return true; &#125; default: &#123; return super.onTransact(code, data, reply, flags); &#125; &#125;&#125; 显然，这个方法在当系统回调给开发者的时候，传递回来的 code 是一个常量，在跨进程时，每个具体的服务（方法）都会对应一个编号，然后根据这个编号来执行相应的服务（业务），这里说到了最后要执行的具体业务，那么这个业务要体现在什么地方呢，从上面可知 Stub 是一个抽象类，那么它所提供的具体业务必然需要一个具体的实现类来完成，而这个类就是需要我们自己手动根据需要来实现 ProxyProxy 是 Stub 中的一个 静态内部类，实现 IMyAidlInterface 接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private static class Proxy implements com.justin.ipc.application.IMyAidlInterface&#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(anInt); _data.writeLong(aLong); _data.writeInt(((aBoolean)?(1):(0))); _data.writeFloat(aFloat); _data.writeDouble(aDouble); _data.writeString(aString); boolean _status = mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; getDefaultImpl().basicTypes(anInt, aLong, aBoolean, aFloat, aDouble, aString); return; &#125; _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; @Override public void setName(java.lang.String name) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(name); boolean _status = mRemote.transact(Stub.TRANSACTION_setName, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; getDefaultImpl().setName(name); return; &#125; _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; @Override public void getName() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; getDefaultImpl().getName(); return; &#125; _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; public static com.justin.ipc.application.IMyAidlInterface sDefaultImpl;&#125; 可以看到在 Proxy 中的几个具体方法，主要是对数据做序列化处理，然后调用 mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0); mRemote 在 Proxy 的构造函数内被赋值，而 Proxy 是在 Stub 中的 asInterface 函数， 所以又回到了 上面的逻辑。 手动实现进程通信Service创建一个 Service，并运行在其他进程，模拟跨进程调用 Service 123456789public class MyTestAIDLService extends Service &#123; public MyTestAIDLService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return new MyAIDLTestImp(); &#125;&#125; 在 AndroidManifest.xml 文件中，配置 Service 1234567&lt;service android:name=".MyTestAIDLService" android:enabled="true" android:exported="true" android:process=":remote" &gt;&lt;/service&gt; 其中 process=”:remote” 表示运行在另一进程，进程号为： 主进程 + ‘:remote’ MainActivity写三个按钮，一个绑定服务，一个解绑服务，一个调用服务中的 Binder 获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends AppCompatActivity &#123; private final String TAG = MainActivity.class.getName() + "MYTEST："; private Button btn_bind, btn_unbind, btn_get; private IMyAidlInterface interfaces; private boolean isConnected = false; private WebView webView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn_bind = findViewById(R.id.bind_server); btn_unbind = findViewById(R.id.unbind_server); btn_get = findViewById(R.id.btn_getInfo); btn_bind.setOnClickListener((View view) -&gt; &#123; bindService(); &#125;); btn_unbind.setOnClickListener((View view) -&gt; &#123; unbindService(); &#125;); btn_get.setOnClickListener((View view) -&gt; &#123; getInfo(); &#125;); &#125; private void bindService() &#123; isConnected = true; Intent intent = new Intent(this, MyTestAIDLService.class); bindService(intent, connection, Context.BIND_AUTO_CREATE); &#125; private void unbindService() &#123; if(!isConnected) &#123; Log.d(TAG, "unbindService: 已解绑，请勿重复提交"); return; &#125; isConnected = false; unbindService(connection); Log.d(TAG, "unbindService: "); &#125; private void getInfo() &#123; try &#123; interfaces.setName("name"); String result = interfaces.getName(); Log.d(TAG, "getInfo: " + result); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; private ServiceConnection connection = new ServiceConnection()&#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, "onServiceConnected: "); interfaces = IMyAidlInterface.Stub.asInterface(service); System.out.println(TAG + "具体的业务对象："+interfaces); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, "onServiceDisconnected: "); &#125; @Override public void onBindingDied(ComponentName name) &#123; Log.d(TAG, "onBindingDied: "); &#125; &#125;;&#125; 当我们依次点击绑定服务、获取信息，输出如下：onServiceConnected:具体的业务对象：com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157getInfo: name 当我们在 AndroidManifest.xml 中去除 Service 的 process 配置，即让 service 与 MainActivity 处于同一进程时，输出如下：onServiceConnected:具体的业务对象：com.justin.ipc.application.MyAIDLTestImp@da080agetInfo: name 对比发现，输出的 interfaces 对象不同原因是在 Stub 中 asInterface 函数中 1234567891011public static com.justin.ipc.application.IMyAidlInterface asInterface(android.os.IBinder obj)&#123; if ((obj==null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof com.justin.ipc.application.IMyAidlInterface))) &#123; return ((com.justin.ipc.application.IMyAidlInterface)iin); &#125; return new com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);&#125; 当在同一进程中，queryLocalInterface 返回的 iin 不为空，此时获取的就是 om.justin.ipc.application.MyAIDLTestImp@da080a 而处于跨进程通信时，queryLocalInterface 返回的 iin 为空，此时会返回 new com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);一个新的 Proxy 对象，也就是上面的 com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157 跨进程通信的身份认证在跨进程通信时，可能需要对通信双方进行安全认证认证方式一般包括：自定义权限、数据认证 自定义权限自定义权限，一般适用于需要提供功能给第三方应用使用时，做一个权限认证。需要我们先在自己应用中申明我们的自定义权限 申明自定义权限1234567891011121314&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.justin.ipc.application"&gt; ... &lt;permission android:name="com.justin.custom.permission.PERSONAL" android:description="自定义权限描述" android:permissionGroup="MINE_CUSTOM_PERMISSION_GROUP" android:protectionLevel="normal" /&gt; ...&lt;/manifest&gt; 解释下各个属性： name，该标签就是权限的名字。 您需要为权限提供标签和说明。这些是用户在查看权限列表 (android:label) 或有关单个权限的详细信息 (android:description) 时能够看到的字符串资源。标签应当简短，用几个词描述该权限所保护的关键功能。说明应该用几个句子描述权限允许权限获得者执行哪些操作。我们通常会使用包含两个句子的说明：第一句描述权限；第二句提醒用户在向应用授予权限后可能会出现哪类错误。 android:permissionGroup 属性为可选项，仅用于帮助系统向用户显示权限。在大多数情况下，您应将其设置为标准系统组（在 android.Manifest.permission_group 中列出），但您也可以自行定义组。最好使用现有的组，因为这可以简化用户看到的权限界面。 protectionLevel 属性为必需项，用于指示系统如何向用户告知哪些应用正在请求权限或者谁可以获得该权限 Android 将权限分为若干个保护级别:normal, dangerous, signature 等。normal 就是正常权限，该权限并不会给用户或者设备的隐私带来风险； 在 6.0 后不需要动态申请dangerous 就是危险权限，该级别的权限通常会给用户的数据或设备的隐私带来风险； 在 6.0 后需要动态申请signature 指的是，只有相同签名的应用才能使用该权限。 在 6.0 后需要动态申请 使用当我们申明了自定义权限后，在其他应用中使用时，就与系统的权限使用是一样的配置。 而我们也会对权限进行校验]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[andorid MVC]]></title>
    <url>%2Fblog%2F2021%2F03%2Fandorid-MVC.html</url>
    <content type="text"><![CDATA[MVC 模式： 1）Model (模型层) 在 MVC 中 Model 一般用来保存数据的状态，比如数据存储，网络请求。同时还与View 存在一定的耦合，通过某种事件机制（比如观察者模式） 通知 View 状态的改变来让view 更新。 2）View (视图层)一般由一些GUI 组建组成，同时响应用户的交互行为并触发 Controller 的逻辑，View 还有可能修改Model 的状态 以使其与 Model 同步，View 还会在model 中注册 model 事件的改变。以此来刷新自己并展示给用户。 3）Control （控制层）控制器由View 根据用户行为触发并响应来自view 的用户交互，然后根据view 的事件逻辑来修改对应的Model, Control 并不关心 View 如何展示 相关数据或状态，而是通过修改 Model 来实现view 的数据的刷新。 view 层即指 xml文件]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fblog%2F2021%2F03%2Fandroid-%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画属性动画android 动画分为补间动画、属性动画。补间动画的原理是在draw绘制时，一直改变draw绘制的图形，但在layout时的坐标都没有变化， 所以对视图的响应还是在原来的坐标。属性动画，是通过改变视图的属性来达到动画的效果，在设置属性动画时，就需要针对被更改的属性提供get/set方法。所以对视图的响应就在动画那一刻视图显示的位置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[NDK-c++基础 三]]></title>
    <url>%2Fblog%2F2021%2F03%2FNDK-c-%E5%9F%BA%E7%A1%80-%E4%B8%89.html</url>
    <content type="text"><![CDATA[c++语言基础，c++中能运行c语言，但c语言不能运行c++ C++语言面向对象 + 标准特性C语言面向过程，函数+结构体C++里面可以运行C语言，可以调用C语言，反之 就不行C语言无法运行C++以后我们85%以上 都是 用C++去写功能 在c语言中基本运行需要引入#include &lt;stdio.h&gt;在c++中需要引入#include &lt;iostream&gt; 打印语句 cout *1234567cout &lt;&lt; "HELLO WORLD!" &lt;&lt; endl; cout &lt;&lt; "YYYYYY\n";cout &lt;&lt; "Line1\n" &lt;&lt; "Line2\n" &lt;&lt; "line3\n"; 需要引入using namespace std;namespace 命名空间 &lt;&lt; 是一个操作重载符，cout 更正确的写法是： std::cout因为我们已经引入 命名空间，所以可以省略为： cout 常量在c或者c++中，常量使用 const 声明，但是在c语言中，常量是个伪命题，因为c中可以直接修改指针 123const int i = 90;int * p = &amp;i; // c++ Cannot initialize a variable of type 'int *' with an rvalue of type 'const int *'*p = 10; i 已经被定义成常量上面这段代码在c语言中可以运行，并能修改i地址处的值为10，达到了修改常量值的目的。但是在c++中会报错，ide工具就会直接报错：Cannot initialize a variable of type ‘int ‘ with an rvalue of type ‘const int ‘ 引用 &amp; * c++中 &amp; 标示引用类型。 123456int i = 0;int &amp; a = i;cout &lt;&lt; "a地址:" &lt;&lt; &amp;a &lt;&lt; "\ni地址:" &lt;&lt; &amp;i &lt;&lt; endl;int c = 9;int d = 9;cout &lt;&lt; "c地址:" &lt;&lt; &amp;c &lt;&lt; "\nd地址:" &lt;&lt; &amp;d &lt;&lt; endl; 打印结果：a地址:0x7ffeefbff4c8i地址:0x7ffeefbff4c8c地址:0x7ffeefbff4bcd地址:0x7ffeefbff4b8 因为 a 是 i 的引用。 a 指向 i， 所以 a 与 i 的地址一致。而c 与 d 不同，c、d都是一个新的对于9的引用。 类c++ 申明类使用关键字 class1234567891011121314151617181920class Person &#123;private: int age; char * name;public: void setAge(int age) &#123; this-&gt;age = age; &#125; void setName(char * name) &#123; this-&gt;name = name; &#125; int getAge()&#123; return this-&gt;age; &#125; char * getName()&#123; return this-&gt;name; &#125;&#125;; 如此一个基本类就定义完成，成员变量使用private修饰，在外部不可访问，提供public修饰的set、get函数来操作成员变量。 构造函数12345678910111213141516public: Person()&#123; cout &lt;&lt; "空构造函数" &lt;&lt; endl; &#125; Person(int age): age(age) &#123; // 2 cout &lt;&lt; "一个参数的构造函数： age" &lt;&lt; endl; &#125; Person(char * name) &#123; // 3 this-&gt;name = name; cout &lt;&lt; "一个参数的构造函数： name" &lt;&lt; endl; &#125; Person(int age, char * name)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; "两个参数的构造函数： name" &lt;&lt; endl; &#125; 如上所示，第2个与第三个其实效果是一样的，都是对成员变量直接赋值。还有构造函数的相互调用问题:1234Person(int age, char * name): Person(age)&#123; this-&gt;name = name; cout &lt;&lt; "两个参数的构造函数： name" &lt;&lt; endl; &#125; 调用两个参数的构造函数时，会调用到一个参数的构造函数， 而且打印会先打印一个参数的构造函数的日志，然后再打印两个参数构造函数的日志 * 类的引用我们在上面申明了一个类，然后我们可以根据类申明引用 12345678cout &lt;&lt; "HELLO TESTCLASS" &lt;&lt; endl;Person person;person.setAge(29);person.setName("justin");cout &lt;&lt; "age:" &lt;&lt; person.getAge() &lt;&lt; ", name:" &lt;&lt; person.getName() &lt;&lt; endl;Person person1(24, "novia");cout &lt;&lt; "age:" &lt;&lt; person1.getAge() &lt;&lt; ", name:" &lt;&lt; person1.getName() &lt;&lt; endl; 打印结果如下：HELLO TESTCLASS 空构造函数 age:29, name:justin 一个参数的构造函数： age 两个参数的构造函数： name age:24, name:novia 在上述代码中，生成的person都是普通的引用，数据内存都是在栈区。接下来看一下在C++中如何使用堆区内存 堆内存与c语言不同，c++中使用 new 生成的对象都存放在堆内存中，而存放在堆内存中的数据，需要自己手动c++使用 delete 释放内存。 12345Person * person = new Person(29, "justin");cout &lt;&lt; "age:" &lt;&lt; person-&gt;getAge() &lt;&lt; ", name:" &lt;&lt; person-&gt;getName() &lt;&lt; endl;delete person;person = NULL; QA: 为何栈区内存不需要释放内存我们都知道函数在出栈时，会释放栈区内存，那为何不需要使用delete释放。其实函数并不是没有调用delete来释放，在函数出栈时，有静默的调用了delete，来释放栈区的内存 QA：为何调用了delete后，还能调用指针并获取到值因为delete的原理并不是直接清空数据，而是标记该块内存地址为可用，当应用有向堆内存重新申请内存时，就可能申请到这块内存，此时数据才会被修改，如果此块内存一直没有被申请到时，调用该指针后，还是能访问到之前的数据的。当调用 delete 时，该指针即成为悬空指针，继续调用就有可能出现异常，规范用法时指向NULL； 析构函数当对象内存被回收时，会执行对象的析构函数，类似与java对象的finalize函数但与finalize函数不同的是，java对象可以在finalize中实现自我拯救，c++析构函数中，不能实现自我拯救，主要是用于一些数据清除、销毁工作，如解绑、释放堆内存空间，是的，对象中如果也有开辟堆内存时，就需要在此处释放，不然该内存会被一直占用。析构函数的格式： 123~Person()&#123; cout &lt;&lt; "析构函数" &lt;&lt; endl;&#125; 拷贝构造函数123456// 拷贝构造函数Person(const Person &amp; person)&#123; this-&gt;name = person.name; this-&gt;age = person.age; cout &lt;&lt; "拷贝构造函数" &lt;&lt; endl;&#125; 当执行复制拷贝时，就会执行复制拷贝函数，系统默认的复制拷贝函数会自动完成复制值，手动重写复制拷贝函数时，我们也需要手动赋值 此时传入的person就是旧对象，this即是拷贝后生成的新对象 拷贝的场景 person1 = person2 12Person person1(24, "novia");Person person2 = person1; 当执行 Person person2 = person1; 即会执行 拷贝构造函数 来对person2赋值， 参数传递 12345678910111213void test(Person person) &#123; cout &lt;&lt; "test函数中,参数person的地址: " &lt;&lt; &amp;person &lt;&lt; endl;&#125;int main() &#123; Person person1(24, "novia"); Person person2 = person1; cout &lt;&lt; "Person1.age:" &lt;&lt; person1.getAge() &lt;&lt; ", Person1.name:" &lt;&lt; person1.getName() &lt;&lt; endl; cout &lt;&lt; "Person2.age:" &lt;&lt; person2.getAge() &lt;&lt; ", Person2.name:" &lt;&lt; person2.getName() &lt;&lt; endl; cout &lt;&lt; "person1地址---" &lt;&lt; &amp;person1 &lt;&lt; " ,person2地址---" &lt;&lt; &amp;person2 &lt;&lt; endl; test(person2); return 0;&#125; 打印结果： 一个参数的构造函数： age两个参数的构造函数： name拷贝构造函数Person1.age:24, Person1.name:noviaPerson2.age:24, Person2.name:noviaperson1地址—0x7ffeefbff4b8 ,person2地址—0x7ffeefbff4a8拷贝构造函数test函数中,参数person的地址: 0x7ffeefbff488析构函数析构函数析构函数 可以看到test函数中打印的person地址 与我们调用 test 函数传递的 person2 地址并不相同。这被叫做 行参 像避免上面的操作，避免产生大量的副本对象，占用内存，有几个办法， 1、使用引用在上面就讲过引用，引用也是直接执行地址的，所以当我们使用引用时，就不会重新拷贝赋值了。修改一下test函数的入参 123void test(Person &amp; person) &#123; cout &lt;&lt; "test函数中,参数person的地址: " &lt;&lt; &amp;person &lt;&lt; endl;&#125; 2、运算符重载重写 = 运算符，使之返回之前的地址。 注意事项 *123Person person2 = person1; // 1Person person2;person2 = person1; // 2 方式2是不会调用 拷贝构造函数， 方式1 才会。为什么？ 因为person2其实已经调用了无参构造函数，Person person2; 这一句已经调用了无参构造函数，person2 = person1; 只是重新赋值而已。 常量指针 常量引用 指针常量 常量指针常量之前讲过常量，代表不可更改值 常量下还有 常量指针 常量引用 指针常量 常量指针常量 注意常量修饰的位置 常量指针12345 int number = 10;int number2 = 100;const int * a_p = &amp;number;*a_p = 100; // 修改值 会报错，a_p = &amp;number2; // 修改地址 不会报错 const 用来修饰类型，这个指针即为常量指针声明了常量指针 a_p，*a_p = 100; 会提示错误：Read-only variable is not assignable常量代表只读, 常量指针 常量是修饰值的，不可以直接修改指针指向的数据，只能通过修改指针指向的地址来修改值 常量引用1const int &amp; a = 18; const 用来修饰引用，这个引用即为 常量引用常量引用指向的数据也是不能直接修改的。拷贝构造函数 重的参数就是一个常量引用。 指针常量1234int * const b_p = &amp;number;// b_p = &amp;number2; // 会报错 Cannot assign to variable 'b_p' with const-qualified type 'int *const'*b_p = 190; // 不报错cout &lt;&lt; "*bp指向的值为" &lt;&lt; *b_p &lt;&lt; endl; const 用来修饰指针，这个指针即是 指针常量上面的输出结果：*bp指向的值为190 指针常量，不可修改指向的地址，但可以修改指针指向的值 常量指针常量常量指针常量 其实相当于 常量指针 与 指针常量 两个的合并。123const int * const c_p = &amp;number;c_p = &amp;number2; // 报错*c_p = 99; // 报错 常量指针常量 既不能修改指向的地址，也不能修改指针指向的数据，即完全只读]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android SharedPreferences]]></title>
    <url>%2Fblog%2F2021%2F03%2Fandroid-SharedPreferences.html</url>
    <content type="text"><![CDATA[原理SharedPreferences 存取值原理，其实还是将数据写入到xml文件 以及 缓存中。Context.getSharedPreferences 都是在ContextImpl中实现，但是在API23之前、23之后实现方式却不同 API 231234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic SharedPreferences getSharedPreferences(String name, int mode) &#123; SharedPreferencesImpl sp; synchronized (ContextImpl.class) &#123; // 第一次为空时，初始化值 if (sSharedPrefs == null) &#123; sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;(); &#125; // 获取对应packageName下的 sp实例集合 也是当前应用第一次使用时初始化 final String packageName = getPackageName(); ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName); if (packagePrefs == null) &#123; packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;(); sSharedPrefs.put(packageName, packagePrefs); &#125; if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; if (name == null) &#123; name = &quot;null&quot;; &#125; &#125; // 根据传入的name获取对应的sp实例，第一次初始化 获取对应的文件 sp = packagePrefs.get(name); if (sp == null) &#123; File prefsFile = getSharedPrefsFile(name); sp = new SharedPreferencesImpl(prefsFile, mode); packagePrefs.put(name, sp); return sp; &#125; &#125; if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123; sp.startReloadIfChangedUnexpectedly(); &#125; return sp;&#125;@Overridepublic File getSharedPrefsFile(String name) &#123; return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);&#125; ContextImpl 中 维护有一个 静态集合 sSharedPrefs = ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;sSharedPrefs 全局唯一 该map中 key为 应用包名，value 为一个 packagePrefs ArrayMap&lt;String, SharedPreferencesImpl&gt;, SharedPreferencesImpl 是单个sp实例信息， 文件、数据map缓存 packagePrefs 存有一个应用中所有的 sp实例 SharedPreferencesImpl sSharedPrefs 存有所有应用关于sp的实例信息 存取值其实就是在集合sSharedPrefs中通过包名packageName获取到 packagePrefs，再根据 初入的name获取到指定的 SharedPreferencesImpl实例，然后再通过实例来读写数据 getSharedPrefsFile 就是返回 应用data文件夹/shared_prefs/ name.xml API 24及以上ContextImp 中存在两个 getSharedPreferences函数，public SharedPreferences getSharedPreferences(String name, int mode);public SharedPreferences getSharedPreferences(File file, int mode); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;@Overridepublic SharedPreferences getSharedPreferences(String name, int mode) &#123; if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; if (name == null) &#123; name = &quot;null&quot;; &#125; &#125; File file; synchronized (ContextImpl.class) &#123; // 获取name 对应的文件 if (mSharedPrefsPaths == null) &#123; mSharedPrefsPaths = new ArrayMap&lt;&gt;(); &#125; file = mSharedPrefsPaths.get(name); if (file == null) &#123; file = getSharedPreferencesPath(name); mSharedPrefsPaths.put(name, file); &#125; &#125; return getSharedPreferences(file, mode);&#125;@Overridepublic SharedPreferences getSharedPreferences(File file, int mode) &#123; SharedPreferencesImpl sp; synchronized (ContextImpl.class) &#123; // 获取当前运行应用的 sp集合 final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) &#123; checkMode(mode); if (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123; if (isCredentialProtectedStorage() &amp;&amp; !getSystemService(UserManager.class) .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123; throw new IllegalStateException(&quot;SharedPreferences in credential encrypted &quot; + &quot;storage are not available until after user is unlocked&quot;); &#125; &#125; // 新建 SharedPreferencesImpl 对象 sp = new SharedPreferencesImpl(file, mode); cache.put(file, sp); return sp; &#125; &#125; if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123; // If somebody else (some other process) changed the prefs // file behind our back, we reload it. This has been the // historical (if undocumented) behavior. sp.startReloadIfChangedUnexpectedly(); &#125; return sp;&#125;private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123; if (sSharedPrefsCache == null) &#123; sSharedPrefsCache = new ArrayMap&lt;&gt;(); &#125; final String packageName = getPackageName(); ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName); if (packagePrefs == null) &#123; packagePrefs = new ArrayMap&lt;&gt;(); sSharedPrefsCache.put(packageName, packagePrefs); &#125; return packagePrefs;&#125; 在api24以后，ContextImpl中不再维护有静态的sSharedPrefs集合，而是维护有一个ArrayMap mSharedPrefsPaths ，以及一个静态集合ArrayMap sSharedPrefsCachesSharedPrefs key为name，value为文件sSharedPrefsCache ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; key为包名packageName， value 为集合ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferences(String name, int mode)函数中，先通过name获取到对应的文件，再调用public SharedPreferences getSharedPreferences(File file, int mode); API 23 与 24 的差异从上面来看，API23与24差异很小，其实就是将内部的集合的key从 string 改成了 file，在API24中，增多一个mSharedPrefsPaths集合，在集合中就有 name 与 file的映射关系。对于需要频繁获取的sp实例来说，可能略有优化，但是也增加了内存消耗。 ## 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@UnsupportedAppUsageSharedPreferencesImpl(File file, int mode) &#123; mFile = file; mBackupFile = makeBackupFile(file); mMode = mode; mLoaded = false; mMap = null; mThrowable = null; startLoadFromDisk();&#125;@UnsupportedAppUsageprivate void startLoadFromDisk() &#123; synchronized (mLock) &#123; mLoaded = false; &#125; new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123; public void run() &#123; loadFromDisk(); &#125; &#125;.start();&#125;private void loadFromDisk() &#123; synchronized (mLock) &#123; if (mLoaded) &#123; return; &#125; if (mBackupFile.exists()) &#123; mFile.delete(); mBackupFile.renameTo(mFile); &#125; &#125; // Debugging if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123; Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;); &#125; Map&lt;String, Object&gt; map = null; StructStat stat = null; Throwable thrown = null; try &#123; stat = Os.stat(mFile.getPath()); if (mFile.canRead()) &#123; BufferedInputStream str = null; try &#123; str = new BufferedInputStream( new FileInputStream(mFile), 16 * 1024); map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str); &#125; catch (Exception e) &#123; Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e); &#125; finally &#123; IoUtils.closeQuietly(str); &#125; &#125; &#125; catch (ErrnoException e) &#123; // An errno exception means the stat failed. Treat as empty/non-existing by // ignoring. &#125; catch (Throwable t) &#123; thrown = t; &#125; synchronized (mLock) &#123; mLoaded = true; mThrowable = thrown; // It&apos;s important that we always signal waiters, even if we&apos;ll make // them fail with an exception. The try-finally is pretty wide, but // better safe than sorry. try &#123; if (thrown == null) &#123; if (map != null) &#123; mMap = map; mStatTimestamp = stat.st_mtim; mStatSize = stat.st_size; &#125; else &#123; mMap = new HashMap&lt;&gt;(); &#125; &#125; // In case of a thrown exception, we retain the old map. That allows // any open editors to commit and store updates. &#125; catch (Throwable t) &#123; mThrowable = t; &#125; finally &#123; mLock.notifyAll(); &#125; &#125;&#125; 当新建 SharedPreferencesImpl 时，会初始化一些变量，并且执行startLoadFromDisk在startLoadFromDisk 中会新开线程执行 loadFromDisk在loadFromDisk 中，会删除原文件，然后将 备份文件重命名 然后就是通过文件流读取 文件信息，将读取到的信息赋值给 SharedPreferencesImpl中的 map对象。同时对文件的读取都是加锁操作的。当文件读取完成了，执行mLock.notifyAll();唤醒所有操作线程。 loadFromDisk 需要新开线程也是互斥的问题，必须保证load 与读写不在同一线程，才能让不会一直await，在加载完能够唤醒读写的操作继续。 getValue()内部有针对不同类型的get方法，基本都一致，看一个就可以了。1234567public String getString(String key, @Nullable String defValue) &#123; synchronized (mLock) &#123; awaitLoadedLocked(); String v = (String)mMap.get(key); return v != null ? v : defValue; &#125;&#125; 读操作也是加锁的，防止读、写同时，导致数据异常，同时也跟上面的 loadFromDisk 中加锁呼应，防止问价还未加载完就进行读写操作 putput操作需要通过内部类EditorImpl来完成。 123456789 @Overridepublic Editor edit() &#123; // 当文件未加载完，即loadFromDisk未执行完时，会一直等待。 synchronized (mLock) &#123; awaitLoadedLocked(); &#125; // 每次获取edit时都是重新创建一个对象。 return new EditorImpl();&#125; 每次获取Edit对象时都是返回一个新的对象，所以尽量将数据操作合并，不要频繁去重新获取edit对象。在看一下put数据的方法 12345678private final Map&lt;String, Object&gt; mModified = new HashMap&lt;&gt;();@Overridepublic Editor putString(String key, @Nullable String value) &#123; synchronized (mEditorLock) &#123; mModified.put(key, value); return this; &#125;&#125; 执行put方法时，只是将数据提交到 EditorImpl 中的一个HashMap中，只有在commit 或者 apply时，才会将数据合并、写入到文件中。 QA：为何要设计一个mModified，来保存数据，而不是直接提交合并到文件？这样可以避免频繁操作文件，只有在执行commit、apply时才去操作文件，提高效率，是一种优化手段。 commit12345678910111213141516171819202122232425262728@Overridepublic boolean commit() &#123; long startTime = 0; if (DEBUG) &#123; startTime = System.currentTimeMillis(); &#125; // 合并mModified数据到一个新的集合，并清除mModified数据，并记录哪些key的value发生更改，最后将合并的数据包装成一个MemoryCommitResult对象 MemoryCommitResult mcr = commitToMemory(); // 将mcr加入文件写入队列，注意第二个参数为null，标示 直接写入，不需等待 SharedPreferencesImpl.this.enqueueDiskWrite( mcr, null /* sync write on this thread okay */); try &#123; // 等待写入结果 mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException e) &#123; return false; &#125; finally &#123; if (DEBUG) &#123; Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration + &quot; committed after &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); &#125; &#125; // 唤醒监听器，发送消息，数据更改操作结束 notifyListeners(mcr); return mcr.writeToDiskResult;&#125; apply12345678910111213141516171819202122232425262728293031323334@Overridepublic void apply() &#123; final long startTime = System.currentTimeMillis(); final MemoryCommitResult mcr = commitToMemory(); final Runnable awaitCommit = new Runnable() &#123; @Override public void run() &#123; try &#123; mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException ignored) &#123; &#125; if (DEBUG &amp;&amp; mcr.wasWritten) &#123; Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration + &quot; applied after &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); &#125; &#125; &#125;; QueuedWork.addFinisher(awaitCommit); Runnable postWriteRunnable = new Runnable() &#123; @Override public void run() &#123; awaitCommit.run(); QueuedWork.removeFinisher(awaitCommit); &#125; &#125;; SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); notifyListeners(mcr);&#125; 可以看到 apply、commit两个函数基本相同，主要时在 enqueueDiskWrite 函数执行时，传入的第二个参数不同 enqueueDiskWrite1234567891011121314151617181920212223242526272829303132333435private void enqueueDiskWrite(final MemoryCommitResult mcr, final Runnable postWriteRunnable) &#123; // commit时,传入的postWriteRunnable为null， isFromSyncCommit 为true， // apply时 postWriteRunnable != null isFromSyncCommit = false final boolean isFromSyncCommit = (postWriteRunnable == null); final Runnable writeToDiskRunnable = new Runnable() &#123; @Override public void run() &#123; synchronized (mWritingToDiskLock) &#123; writeToFile(mcr, isFromSyncCommit); &#125; synchronized (mLock) &#123; mDiskWritesInFlight--; &#125; if (postWriteRunnable != null) &#123; postWriteRunnable.run(); &#125; &#125; &#125;; // commit 才会进入这个判断，并最终执行writeToDiskRunnable 然后return if (isFromSyncCommit) &#123; boolean wasEmpty = false; synchronized (mLock) &#123; wasEmpty = mDiskWritesInFlight == 1; &#125; if (wasEmpty) &#123; writeToDiskRunnable.run(); return; &#125; &#125; // apply 会执行此处 QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);&#125; commit、apply差异从上面的注释也可以看出: commit会直接在当前线程执行 writeToDiskRunnable.run(); 而 apply 会将 writeToDiskRunnable 加入队列 QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);等待线程池执行任务。 总结SP是线程安全的，通过锁、await、notifyAll，保证并行时不会读写异常。 SP通过全局静态ArrayMap维护一个集合，通过packageName、name找到对应的读写文件file、SPImpl实例。 读操作是加载file完之后，直接在缓存的一个集合Map中根据key读取即可。 写操作是先将需要写入的数据都缓存到一个HashMap中，再在commit或者apply时与file中的数据合并，并标示哪些key发生改变，包装成一个MemoryCommitResult对象。 写操作只是修改缓存的HashMap，修改持久化的数据还需要执行commit或者apply。 commit 是当前线程直接执行，而 apply是添加到任务队列等待线程池执行。 优化建议 不要存放大的key和value在SharedPreferences中，否则会一直存储在内存中得不到释放，内存使用过高会频发引发GC，导致界面丢帧甚至ANR。 不相关的配置选项最好不要放在一起，单个文件越大读取速度则越慢。 读取频繁的key和不频繁的key尽量不要放在一起（如果整个文件本身就较小则忽略，为了这点性能添加维护得不偿失）。 不要每次都edit，因为每次都会创建一个新的EditorImpl对象，最好是批量处理统一提交。否则edit().commit每次创建一个EditorImpl对象并且进行一次IO操作，严重影响性能。 commit发生在UI线程中，apply发生在工作线程中，对于数据的提交最好是批量操作统一提交。虽然apply发生在工作线程（不会因为IO阻塞UI线程）但是如果添加任务较多也有可能带来其他严重后果 （参照ActivityThread源码中handleStopActivity方法实现） 尽量不要存放json和html，这种可以直接文件缓存。 不要指望它能够跨进程通信 Context.PROCESS 最好提前初始化SharedPreferences，避免SharedPreferences第一次创建时读取文件线程未结束而出现等待情况。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 应用启动流程]]></title>
    <url>%2Fblog%2F2021%2F03%2Fandroid-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[android 应用启动过程分为冷启动、热启动 我们从应用入口开始分析 ActivityThreadandroid 应用的主入口，在 main 函数中，会启动消息机制。 在 performLaunchActivity 函数中，会构建 Activity 对象，然后调用 activity 中的 attach 函数。 而在 attach 函数中，会构建 Activity 的 PhoneWindow 以及 decorView 在 ActivityThread 中的 handleResumeActivity 函数中，会将 decorView 添加到 windowManager 中 12345678r.window = r.activity.getWindow();View decor = r.window.getDecorView();decor.setVisibility(View.INVISIBLE);ViewManager wm = a.getWindowManager();if (!a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l);&#125;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NDK c语言基础 二]]></title>
    <url>%2Fblog%2F2021%2F03%2FNDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C.html</url>
    <content type="text"><![CDATA[结构体申明关键字 struct 123456struct Person &#123; char * name; int age; &#125;; 类似与java中的bean类，kotlin中的data class 1234567891011121314struct Person &#123; char * name; int age;&#125;;int main() &#123; printf(&quot;HELLO WORLD!\n&quot;); struct Person * person; person-&gt;name = &quot;justin&quot;; // xcode可以这样写，其他工具可能需要使用 strcpy 函数来对字符串复制来进行赋值 person-&gt;age = 29; printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age); return 0;&#125; 还可以直接在结构体后实例化对象 12345struct Person &#123; char * name; int age;&#125; ppp1 = &#123;&quot;9999&quot;, 21&#125;; 类型定义在不同的ide工具中，c语言的语法可能略有不同，为了统一，推出一个类型定义，如此保证在不同的ide工具，使用一样的代码运行 在源码中也是大量使用 关键字 typedef 123456789101112131415161718struct Person &#123; char * name; int age;&#125; ppp1 = &#123;&quot;9999&quot;, 21&#125;;typedef struct Person Person; // 为结构体定义一个类型，后续申明结构体对象就不需要使用struct关键字typedef Person * Person_; // 为结构体指针定一个类型int main() &#123; printf(&quot;HELLO WORLD!\n&quot;); Person_ person; person-&gt;name = &quot;justin&quot;; person-&gt;age = 29; printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age); return 0;&#125; 文件操作file]]></content>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMM java内存模型]]></title>
    <url>%2Fblog%2F2021%2F03%2FJMM-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[一、现代计算机内存模型早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问内存地址的。而在现代计算机中，CPU指令的运行速度远远超过了内存数据的读写速度，为了降低这两者间这高达几个数量级的差距，所以在CPU与主内存之间加入了CPU高速缓存。 高速缓存可以很好地解决CPU与主内存之间的速度差距，但CPU缓存并不是所有CPU共享的，因此产生了一个新的问题：数据一致性问题。 二、缓存一致性协议（MESI）MESI四种状态因为存在多个cpu，也就存在多个cpu缓存，CPU缓存的一致性问题会导致并发处理的不同步。 所以引入一种解决办法：缓存一致性协议（MESI） MESI 这个名称本身是由：Modified（修改）、Exclusive（独享）、Shared（共享）、Invalid（无效）。这个四个单词也代表了缓存协议中对缓存行（即Cache Line，缓存存储数据的单元）声明的四种状态，用2 bit表示，它们所代表的含义如下所示 状态 ｜ 描述 ｜ 监听任务 Modified（修改 ｜ 这行数据有效，数据被修改了，和内存种的数据不一致，数据只存在于本Cache中 ｜ 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 Exclusive（独享）｜ 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中 ｜ 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 S共享（Shared ｜ 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中 ｜ 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 I无效（Invalid） ｜ 这行数据无效 ｜ 无 理解： 某数据如果多个缓存读取，则处于S共享状态，如果只是单个则处于E独享状态。 某个CPU2对CPU2缓存中某数据作出修改，则CPU2缓存该数据处于Modified状态，如果该数据是S共享状态，则其他缓存该行数据变成I无效状态。 如何保证缓存一致性在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议， 每个处理器通过嗅探在总线上传播的数据来检查自己缓存中的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改， 就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 三、JMM java 内存模型 线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地工作内存（Local Memory），工作内存中存储了线程以读/写共享变量的副本。（本地工作内存是 JMM 的一个抽象概念，并不真实存在，线程中所谓工作内存其实还是存在于主内存中的。） Java内存模型与现代计算机内存模型区分Java内存模型和现代计算机内存模型都需要解决一致性问题，但是这个一致性问题在现代计算机内存模型中指代的是缓存一致性问题，MESI协议所设计的目的也是为了解决这个问题。而在Java内存模型中，这个一致性问题则是指代内存一致性问题。两者之间有一定区别。 缓存一致性 计算机数据需要经过内存、计算机缓存再到寄存器，计算机缓存一致性是指硬件层面的问题，指的是由于多核计算机中有多套缓存，各个缓存之间的数据不一致问题。缓存一致性协议（如MESI）就是用来解决多个缓存副本之间的数据一致性问题。 内存一致性 线程的数据则是放在内存中，共享副本也是，内存一致性保证的是多线程程序并发时的数据一致性问题。我们常见的volatile、synchronized关键字就是用来解决内存一致性问题。这里屏蔽了计算机硬件问题，主要解决原子性、可见性和有序性问题。 至于内存一致性与缓存一致性问题之间的关系，就是实现内存一致性时需要利用到底层的缓存一致性（之后的volatile关键字会涉及）。 四、并发编程的特性首先我们要先了解并发编程的三大特性：原子性，可见性，有序性； 原子性原子性是指一个操作是不可间断的，即使是多个线程同时执行，该操作也不会被其他线程所干扰。既操作的连续性1int x = 10; // 具有原子性，赋值 i++;不具备原子性因为i++juyou多部操作 1、读取 i 的值到内存空间 2、i + 1 3、刷新结果到内存 多个具备原子性操作放在一起并不具备原子性y=x 先读取x的值到内存空间 x = 10； 这一步具备原子性在给y赋值 y = 10; 也一步也具备原子性但y=x不具备原子性 可见性 内存可见性（Memory visibility）是指当某个线程正在使用对象状态而同时另一个线程正在修改该状态，此时需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。 每个线程都有一个私有的本地工作内存并存储了线程间读/写的共享副本。 如果某个线程对这个副本中值进行修改，却没有对主内存进行同步，则会导致其他线程访问过时的数据。 使用volatile关键字就可以保证数据在不同线程副本的可见性，当有线程在副本中进行修改，就会强制修改主内存中值，同步到其他线程的副本中。保证所有线程访问到值都为最新值 有序性 有序性即程序按照我们代码所书写的那样，按其先后顺序执行。第一次接触这个特性可能会有所疑惑，所以在了解有序性之前我们需要来了解执行重排序以及相关概念。 指令重排序为了提高性能，编译器和处理器会对程序的指令做重排序操作，重排序分为3种类型： 编译器优化的重排序：属于编译器重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； 指令级并行的重排序：属于处理器重排序，现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序； 内存系统的重排序：处于处理器重排序由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行 指令重排序对于程序执行有利有弊，我们并不是要去完全禁止它。对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型个的内存屏障指令，通过内存屏障指令来禁止特定的处理器重排序。 as-if-serial不管如何重排序，要保证程序运行的结果保持不变，编译器、runtime和处理器都必须遵循as-if-serial语义。 为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。 例如123int x = 10; // 1int y = 20; // 2int a = x + y; // 3 明显第3行依赖于第2行、第1行，所以第三行不会重排序，而第1行、第2行可能会被重排序。 happens-before如果说 as-if-serial 是 JMM 提供用来解决单线程间的内存可见性问题的话，那么 happens-before 就是JMM向程序员提供的可跨越线程的内存可见性保证。具体表现为：如果线程A的写操作a与线程B的读操作b之间具有 happens-before 关系，那么JMM将保证这个操作a对操作b可见。此外，happens-before 还有传递关系，表现为：a happens-before b，b happens-before c，那么a happens-before c。 注意：两个操作之间存在happens-before关系，并不意味着一个操作必须要在后一个操作之前执行，只要求前一个操作执行的结果对后一个操作可见。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不违法（也就是说，JMM允许这种重排序）。 比对 happens-before 与 as-if-serial。 1、as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。 2、as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。 3、as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NDK c语言基础 (一)]]></title>
    <url>%2Fblog%2F2021%2F03%2FNDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%80.html</url>
    <content type="text"><![CDATA[c语言基础创建C语言程序xcode -&gt; create new xcode project -&gt; macos -&gt; command line tools在macos系统即可创建一个c语言程序 基本数据类型int 整型，占4个字节double 双精度小数 占8个字节float 单精度小数 占4个字节char 字符 占1个字节 12345678int i = 2;printf(&quot;i的值:%d,所占字节%d\n&quot;, i, sizeof(i));double db = 1.34;printf(&quot;db的值:%lf,所占字节%d\n&quot;, db, sizeof(db));float fl = 1.12;printf(&quot;fl的值:%f,所占字节%d\n&quot;, fl, sizeof(fl));char ch = &apos;A&apos;;printf(&quot;ch的值:%c,所占字节%d\n&quot;, ch, sizeof(ch)); 打印结果：i的值:2,所占字节4db的值:1.340000,所占字节8fl的值:1.120000,所占字节4ch的值:A,所占字节1 内存地址使用 &amp; 变量 即可获取到变量的内存地址12int i = 2;printf(&quot;i的值:%d,所占字节%d， 内存地址为%p\n&quot;, i, sizeof(i), &amp;i); i的值:2,所占字节4， 内存地址为0x7ffeefbff4c8 指针&amp;i 既是取出i的内存地址，也是i的指针。或者换个说法：12int i = 10;int * i_p = &amp;i; 取出指针的值使用 * i_p 既可取出值 i = 10； 1234int i = 22;int * i_p = &amp;i;printf(&quot;i 的值：%d, i_p指针指向的值: %d \n&quot;, i, *i_p);printf(&quot;i的地址：%p, i_p的地址%p \n&quot;, i_p, &amp;i_p); 打印： i 的值：22, i_p指针指向的值: 22 i的地址：0x7ffeefbff4c8, i_p的地址0x7ffeefbff4c0可以是 &amp; 对指针再次取内存地址 数组12int a[5];printf(&quot;a的值：%p， a的内存地址：%p, a[0]的地址%p\n&quot;, a, &amp;a, &amp;a[0]); 打印结果：a的值：0x7ffeefbff4b0， a的内存地址：0x7ffeefbff4b0, a[0]的地址0x7ffeefbff4b0 可以看到 打印 a、&amp;a、&amp;a[0]出现的结果都一样。 1、为何a与&amp;a一样 因为a是数组，除基本数据类型外的其他变量，变量本身就是指向内存地址的。所以 a == &amp;a 2、为何&amp;a与&amp;a[0]一样 因为a是数组，数组内存连续，所以数组下标为0的内存地址就是数组本身的内存地址。 1234int j = 0;for (j = 0; j &lt; 5; j ++) &#123; printf(&quot;当前下标为%d,下标内存地址为%p\n&quot;, j, &amp;a[j]);&#125; 打印结果如下： 当前下标为0,下标内存地址为0x7ffeefbff4b0 当前下标为1,下标内存地址为0x7ffeefbff4b4 当前下标为2,下标内存地址为0x7ffeefbff4b8 当前下标为3,下标内存地址为0x7ffeefbff4bc 当前下标为4,下标内存地址为0x7ffeefbff4c0可以看到内存地址以每次为4增加，因为这是int数组，int占4个字节，所以每次增加4 指针偏移123int * p = &amp;a[j] + 1;printf(&quot;p的值为:%p\n&quot;, p);*(&amp;a[j] + 0) = j; &amp;a[j] 是取出下标j处的地址。&amp;a[j] + 1 是指针在a[j]处偏移1位，既指向a[j + 1];*(&amp;a[j] + 0) = j; + 0 其实相当于未偏移，就是对a[j]赋值 函数指针首先函数指针的申明格式：函数返回值类型 (* 指针变量名) (函数参数列表);12345678910111213void add(int a, int b)&#123; printf(&quot;sum = %d\n&quot;, a+b);&#125;void test(void (*method)(int, int), int a, int b) &#123; method(a, b);&#125;int main() &#123; printf(&quot;Hello \n&quot;); test(add, 3, 4); return 0;&#125; 在test函数入参中，有一个函数指针，在main函数中，调用test函数，并将add函数作为入参传递到test函数中。 多级指针指向指针的指针就是多级指针 1234567891011int main() &#123; printf(&quot;HELLO WORLD!\n&quot;); int a = 0; int * b = &amp;a; int **c = &amp;b; int *** d = &amp;c; printf(&quot;d的地址%p \n&quot;, d); return 0;&#125; 还可以用来表示多维数组 静态分配内存在c语言中，内存区域分为栈区、堆区 函数被调用时，就会进栈，函数执行完毕则会出栈，而在函数中默认方式申明生成的数据都是系统静态分配内存的，当函数执行完毕，出栈后，在该函数中静态分配的内存会被回收，系统会自己执行，无需手动处理。静态分配内存都是在栈区 栈区总容量较小，大约是2M，各个系统、设备可能不一致，超出会抛出异常 动态分配内存动态分配内存需要手动调用API才可，动态分配的内存不会自动回收，动态分配的内存都是在堆区。堆区总容量较大，至少超过40M，各个系统、设备可能不一致， 超出也会抛出异常。 调用动态分配内存：malloc(int size)函数调用回收动态内存：free(void *); 需要额外引入依赖文件：#include &lt;stdlib.h&gt; 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int num; printf(&quot;请输入数字\n&quot;); scanf(&quot;%d&quot;, &amp;num); printf(&quot;num的值为：%d\n&quot;, num); int * arr = (int *)malloc(sizeof(int) * num); int i = 0; for (i = 0; i &lt; num; i ++) &#123; arr[i] = i + 10000; &#125; for (i = 0; i &lt; num; ++i) &#123; printf(&quot;%d对应值为%d\n&quot;, i, arr[i]); &#125; free(arr); return 0;&#125; 重新分配就是将之前动态分配的内存重新分配，使用：realloc(void *ptr, size_t size);第一个参数：原来的内存指针第二个参数：新的内存大小 1234567891011121314int * new_arr = (int *)realloc(arr, sizeof(int) * (num + new_num));if(new_arr) &#123; int j = num; for (; j &lt; (num + new_num); j ++) &#123; new_arr[j] = j + 100000; &#125; int i = 0; for (; i &lt; (num + new_num); i ++) &#123; printf(&quot;新数组第%d个值为%d\n&quot;, i, new_arr[i]); &#125; free(new_arr); new_arr = NULL;&#125; 题目 截取字符串中指定字符char c = “ABCDEFGHIJK”; 截取第3位到第6位 123456789101112131415161718#include &lt;stdio.h&gt;void substring(char * result, char *str, int start, int end) &#123; for (int i = start; i &lt;= end; ++i) &#123; printf(&quot;char:%c\n&quot;, *(str + i)); *(result++) = *(str + i); &#125;&#125;int main()&#123; char * str = &quot;ABCDEFGHIJK&quot;; char * result; substring(result, str, 3, 6); printf(&quot;result:%c\n&quot;,result); return 0;&#125;]]></content>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https详解]]></title>
    <url>%2Fblog%2F2021%2F02%2Fhttps%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[Https详解什么是Https在说HTTPS之前先说说什么是HTTP，HTTP就是我们平时浏览网页时候使用的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，今后TLS将会继承SSL优良血统继续为我们进行加密服务。目前TLS的版本是1.2，定义在RFC 5246中，暂时还没有被广泛的使用 ()]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2Fblog%2F2021%2F02%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[观察者模式的定义与特点：观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 观察者模式是一种对象行为型模式，其主要优点如下： 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 目标与观察者之间建立了一套触发机制。 它的主要缺点如下： 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 屏幕渲染]]></title>
    <url>%2Fblog%2F2021%2F02%2Fandroid-%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93.html</url>
    <content type="text"><![CDATA[渲染机制 CPU负责计算数据，把计算好数据交给GPU, GPU会对图形数据进行渲染，渲染好后放到buffer里存起来 display负责将buffer里的数据显示在屏幕 简单的说就是CPU/GPU准备好数据，存入buffer， display每隔一段时间去buffer里取数据，然后显示出来。 display读取的频率是固定的，比如每个16ms读一次，但是CPU/GPU写数据是完全无规律的 底层每16ms会发送一次VSync，更新界面 CPU：执行应用层的measure、layout、draw等操作，绘制完成后将数据提交给GPUGPU：进一步处理数据，并将数据缓存起来屏幕：由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点 因为display取buffer数据渲染的频率固定，而GPU往buffer写数据却是不固定的，难免存在场景：GPU还在往buffer写数据，但此时display正要显示，此时就会显示异常。 为避免这种现象，引入一种新方案：双缓存机制 双缓存机制android的渲染机制中引入双缓存机制。新增一个缓存 back buffer, back buffer 会定时与 frame buffer交换数据 当你的应用正在往Back Buffer中填充数据时，系统会将Back Buffer锁定。如果到了GPU交换两个Buffer的时间点，你的应用还在往Back Buffer中填充数据，GPU会发现Back Buffer被锁定了，它会放弃这次交换。 这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的丢帧，所以为了避免丢帧的发生，我们就要尽量减少布局层级，减少不必要的View的invalidate调用，减少大量对象的创建（GC也会占用CPU时间）等等 QA Q1：Android 每隔 16.6 ms 刷新一次屏幕到底指的是什么意思？是指每隔 16.6ms 调用 onDraw() 绘制一次么？Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？ 答：我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面，而这个每一帧的画面数据就是我们 app 在接收到屏幕刷新信号之后去执行遍历绘制 View 树工作所计算出来的屏幕数据。而 app 并不是每隔 16.6ms 的屏幕刷新信号都可以接收到，只有当 app 向底层注册监听下一个屏幕刷新信号之后，才能接收到下一个屏幕刷新信号到来的通知。而只有当某个 View 发起了刷新请求时，app 才会去向底层注册监听下一个屏幕刷新信号。 也就是说，只有当界面有刷新的需要时，我们 app 才会在下一个屏幕刷新信号来时，遍历绘制 View 树来重新计算屏幕数据。如果界面没有刷新的需要，一直保持不变时，我们 app 就不会去接收每隔 16.6ms 的屏幕刷新信号事件了，但底层仍然会以这个固定频率来切换每一帧的画面，只是后面这些帧的画面都是相同的而已。 Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？ 答：我们 app 只负责计算屏幕数据而已，接收到屏幕刷新信号就去计算，计算完毕就计算完毕了。至于屏幕的刷新，这些是由底层以固定的频率来切换屏幕每一帧的画面。所以即使屏幕数据都计算完毕，屏幕会不会马上刷新就取决于底层是否到了要切换下一帧画面的时机了。 Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？ 之所以提了这个问题，是因为之前是以为如果某个 View 发起了刷新请求，比如调用了 invalidte()，那么它的重绘工作就马上开始执行了，所以以前在看网上那些介绍屏幕刷新机制的博客时，经常看见下面这张图： 那个时候就是不大理解，为什么每一次 CPU 计算的工作都刚刚好是在每一个信号到来的那个瞬间开始的呢？毕竟代码里发起刷新屏幕的操作是动态的，不可能每次都刚刚好那么巧。 梳理完屏幕刷新机制后就清楚了，代码里调用了某个 View 发起的刷新请求，这个重绘工作并不会马上就开始，而是需要等到下一个屏幕刷新信号来的时候才开始，所以现在回过头来看这些图就清楚多了。 Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？ 答：造成丢帧大体上有两类原因，一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms；二是，主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。 第一个原因就是我们写的布局有问题了，需要进行优化了。而第二个原因则是我们常说的避免在主线程中做耗时的任务。 针对第二个原因，系统已经引入了同步屏障消息的机制，尽可能的保证遍历绘制 View 树的工作能够及时进行，但仍没办法完全避免，所以我们还是得尽可能避免主线程耗时工作。 其实第二个原因，可以拿出来细讲的，比如有这种情况， message 不怎么耗时，但数量太多，这同样可能会造成丢帧。如果有使用一些图片框架的，它内部下载图片都是开线程去下载，但当下载完成后需要把图片加载到绑定的 view 上，这个工作就是发了一个 message 切到主线程来做，如果一个界面这种 view 特别多的话，队列里就会有非常多的 message，虽然每个都 message 并不怎么耗时，但经不起量多啊。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题答案]]></title>
    <url>%2Fblog%2F2021%2F02%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.html</url>
    <content type="text"><![CDATA[1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息 当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage 而在MessageQueue的enqueueMessage中。就会根据when大小插入到链表，when越小就在链表越前，其实相当于根据时间排序，越接近的时间越在链头 Looper中的消息既能同步也能异步，在Handler的构造时传入async = true；即为异步消息]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题合集]]></title>
    <url>%2Fblog%2F2021%2F02%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html</url>
    <content type="text"><![CDATA[android腾讯一面1、Object的方法有哪些？ finilize 2、为什么要有HashCode方法，hash算法的原理，在Java中哪些地方用到，进而问到了HashMap的源码 3、Java有几种锁，synchronized与Lock有什么区别，Lock的实现原理，有没有碰到死锁的情况 synchronized 是 jvm 内置锁 Lock 是 famework 层实现的锁synchronized 是非公平锁 Lock 可以实现公平锁synchronized 是 独占锁，Lock 可以实现共享锁 Lock 基于 AQS 实现，AQS 又是基于 CAS通过AQS中的内部类 Node 实例来维持一个链表，state 记录锁的状态， thread 记录占有锁的线程，链表记录进入阻塞的线程 4、Android源码中用到了哪些设计模式，举例说明 消息机制：享元模式 5、一个Android正常启动有多少个线程?(这里当时是比较懵逼的，第一反应是一个主线程，然后觉得应该不止这么简单，想到应用Activity启动的话，应该还有2个Binder线程，可能一个管理JVM的线程，面试官接着问还有哪些。。果断放弃不知道…) 6、Binder机制的实现思想 Serveice 端向 Binder 层注册Client 端通过 Binder 获取到 Service 的一个副本引用(如果在同一个进程时，直接获取到Service实例) 7、简单描述Https的实现思路 HTTP + SSL/TLS在Http的基础上再加上双向身份认证 在三次牵手建立通信过程中，客户端还会发送本地支持的SSL/TSL版本、算法版本等信息，而服务端会根据对应的版本，向客户端发送服务端证书，客户端验证证书，拿到服务器公钥；利用两个随机数，生成pre-master secret(客户端私钥)，并使用服务器的公钥加密发送给服务器。服务端获取到客户端的私钥，然后使用客户端的私钥加密服务端的私钥再发送给客户端，达到了交换两方私钥的目的 8、描述下快速排序的思想，时间复杂度？什么场景对应着最坏情况？ 选取一个基准值(一般是第一个元素)，将数组分割为两段，比基准值大的元素放一端、比基准值小的元素放另一端。完成后对分割的两段数组再进行操作。直到分割的数组长度为1采用分治的思想，时间复杂度 O(n*logn)最坏的场景：升序数组要排序成降序数组 9、给定无序数组和一个值，找到两个数和为值的元素，不能使用额外空间复杂度（不要使用HashMap） 二面二面是视频面试，还是个周六下午。。。 1、TCP/IP四层模型，网络层和传输层有什么区别？网络层的主要工作是什么 网络层 IP协议 流量控制、拥塞控制、差错控制 &amp; 网际互连 封装数据成分组/包、路由选择 传输层 TCP协议 为端到端的连接提供可靠的传输服务、流量控制、差错控制、数据传输管理服务 2、socket.accept()函数对应着TCP三次握手中哪一次握手，哪个函数代表连接建立完毕，四次挥手的过程？ accept对应第三次握手后，此时服务端会进入阻塞状态，一直等待客户端发送数据 （服务端） connect 代表第一次握手 listen 代表第二次握手 （服务端） 3、有做过哪些优化工作，卡顿优化，内存优化，启动优化，APK体积优化，每个做了哪些工作 4、JNI开发中有碰到什么问题？怎么定位native crash 5、递归非递归反转链表 6、打印回环数组 三面1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息 postDelay 都是延时消息，根据传入的延时时间毫秒数，赋值 msg 的 when 为当前时间戳 + 传入的时间毫秒数通过自己代码传输的消息都是同步消息，只有系统内部源码中，能发送异步消息 2、事件分发机制的源码 3、android的屏幕刷新机制，怎么优化UI卡顿情况 4、有没有使用过插件化框架，实现原理？ 5、你在项目中碰到什么比较棘手的问题？怎么解决的？ 6、找到一个无序数组中第一次出现最多次数的元素 某手机海外部门（offer）上来就是笔试题，其实之前没怎么做过面试题，难道现在都是这个套路了….？20分钟后做完就开始面试了 1、手写线程安全的观察者模式 2、找到一个字符串中出现最多的字母 3、描述Java面对对象六大原则针对项目中谈谈自己的看法 4、android阅读过哪些源码，举例说明 消息机制时间分发机制HashMap 数据结构okHttp 5、项目中的优化工作，内存，卡顿优化，leakcanary的原理实现 6、Tcp/Udp的区别，项目中的C/S端双向认证如何实现 TCP 面向连接，安全性高，不会数据丢失，效率低 UDP 面向报文 不安全，数据可能丢失，但效率高对称+非对称算法 + 证书 （Https思路）C端获取服务端公钥，通过公钥加密C端私钥发送给S端，S端获取到C端私钥，然后将S端私钥通过C端私钥加密，发送给C端。此时C、S端就交换了私钥，并都获取到公钥 7、项目中有碰到过哪些比较难解决的问题。 8、android 8.0，9.0有哪些新特性，有没有了解过 深信服1、HashMap的原理以及android中为什么建议用ArrayMap和SpareArray替代HashMap？ ArrayMap &amp; SpareArray 空间利用率高，线程安全 2、android如何保证进程不被杀死 守护进程 3、Java怎么与C++进行交互，以及native crash如何定位的 jni (java native interface) 4、C/S如何保证双向认证（项目中使用到的，可以理解为Https的原理），用到了哪些加密算法 对称+非对称算法 + 证书 （Https思路） hash算法C端获取服务端公钥，通过公钥加密C端私钥发送给S端，S端获取到C端私钥，然后将S端私钥通过C端私钥加密，发送给C端。此时C、S端就交换了私钥，并都获取到公钥 5、LBS定位如何去除野点（指因为定位偏差过大的点），大数据量如何和后台交互？ 6、设计模式用过哪些，动态代理的原理？ 7、项目中有做过哪些优化，优化成效如何？ TCL（offer）是一个猎头推荐的一个职位，主要应该是做TV上的相关项目，有VR类型类似的项目等等，一面居然是一个妹子和一个男的一起进来的，还是第一次遇到，没问多少基础知识点，更多的是根据自身项目问一些东西 1、TCP/UDP的区别，有看过具体报文的信息吗 TCP 面向连接，安全性高，不会数据丢失，效率低 UDP 面向报文 不安全，数据可能丢失，但效率高 2、你觉得开发一个SDK，需要注意哪些地方，有没有做过SDK性能测试 3、有了解过音视频的编解码吗 4、你觉得你这个项目中比较难的地方在哪里，你是如何解决的 5、开放题：让你加载一个200M左右的GIF，如何实现及优化，不可降低画质 6、如何优化一个列表滑动的流畅性 ui优化：减少试图层级嵌套列表缓存处理]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发]]></title>
    <url>%2Fblog%2F2021%2F02%2F%E5%B9%B6%E5%8F%91.html</url>
    <content type="text"><![CDATA[并发并发指单位时间的访问量并行指同一时刻的访问量 线程池锁synchronizedLockvolatileThreadLocal原子类CAS问题 ABA问题 开销问题 只能保证一个共享变量的原子操作 死锁活锁]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ForkJoinTask]]></title>
    <url>%2Fblog%2F2021%2F01%2FForkJoinTask.html</url>
    <content type="text"><![CDATA[ForkJoinTaskForkJoin 是采用分而治之的思维，将一个大任务分解为若干个相互独立的子任务（异步），达到提高运算效率。我们做一个简单的运算 计算1-100000的累加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class TestJoinTask &#123; public static void main(String[] args) &#123; long currentTime = System.currentTimeMillis(); ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; task = pool.submit(new MyForkJoinTask(1, 100000)); try &#123; int result = task.get(); System.out.println(&quot;result = &quot; + result); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot; 执行完毕&quot; + &quot; time = &quot; + (System.currentTimeMillis() - currentTime)); &#125; /** * 传入的范型Integer是返回结果类型 */ static class MyForkJoinTask extends RecursiveTask&lt;Integer&gt; &#123; private int startValue; private int endValue; private int limitValue = 100; public MyForkJoinTask(int startValue, int endValue) &#123; if(startValue &gt; endValue) &#123; throw new RuntimeException(&quot;startValue &lt; endValue&quot;); &#125; this.startValue = startValue; this.endValue = endValue; &#125; @Override protected Integer compute() &#123; if(endValue - startValue &lt;= limitValue) &#123; System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot; 执行计算&quot;); // 两个值在限制值内 进行计算 int sum = 0; for(int i = startValue; i &lt;= endValue; i ++) &#123; sum += i; &#125; return sum; &#125; MyForkJoinTask task1 = new MyForkJoinTask(startValue, (endValue + startValue) / 2); task1.fork(); MyForkJoinTask task2 = new MyForkJoinTask((endValue + startValue) / 2 + 1, endValue); task2.fork(); return task1.join() + task2.join(); &#125; &#125;&#125; 如上所示，我们将一个从0 - 100000的累加任务分解为500个子任务：每200位数累加 在日志打印中，我们可以看到，有多个线程在执行任务，也就是说，分解的任务其实都是提交到线程池中执行，]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android ViewPager/ViewPager2解析]]></title>
    <url>%2Fblog%2F2021%2F01%2Fandroid-ViewPager-ViewPager2%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android RecyclerView解析]]></title>
    <url>%2Fblog%2F2021%2F01%2Fandroid-RecyclerView%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android ListView解析]]></title>
    <url>%2Fblog%2F2021%2F01%2Fandroid-ListView%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[ListView解析首先是简单使用1234567891011121314151617181920212223242526272829303132class ListViewActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_list_view) var list = arrayListOf(Person("novia", 24), Person("justin", 29), Person("doudou", 1)) var adapter = MyListAdapter(list, this) listView.adapter = adapter &#125; class MyListAdapter(var list: ArrayList&lt;Person&gt;, var context: Context) : BaseAdapter() &#123; override fun getCount(): Int &#123; return list.size &#125; override fun getItem(position: Int): Person &#123; return list.get(position); &#125; override fun getItemId(position: Int): Long &#123; return list.get(position).hashCode().toLong() &#125; override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View &#123; var view = LayoutInflater.from(context).inflate(R.layout.item_listview, parent, false) view.findViewById&lt;TextView&gt;(R.id.item_name).setText(getItem(position).name) view.findViewById&lt;TextView&gt;(R.id.item_age).setText("" + getItem(position).age + "岁") return view; &#125; &#125; data class Person(var name: String, var age: Int)&#125; 但是ListView的特点是会将所有条目都渲染出来，当子条目较多时，会存在性能问题，当加载图片时，甚至会导致OOM]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp(二) 拦截器]]></title>
    <url>%2Fblog%2F2021%2F01%2Fokhttp-%E4%BA%8C-%E6%8B%A6%E6%88%AA%E5%99%A8.html</url>
    <content type="text"><![CDATA[okhttp(二) 拦截器在前文中讲到了okhttp中的分发器 接下来讲okhttp中的拦截器 在上文中讲到，同步执行excuet时，会通过 getResponseWithInterceptorChain 获取response，在异步enqueue后，后面会调用AsyncCall中execute，而里面也是通过getResponseWithInterceptorChain 来获取response。 调用的都是RealCall中的getResponseWithInterceptorChain函数。 getResponseWithInterceptorChain1234567891011121314151617181920Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); //自定义拦截器加入到集合 interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 一个数组，添加各个拦截器，然后初始化一个 Interceptor.Chain 对象，注意第2、3、4个参数都是null，而第5个参数是index：0然后调用proceed函数 RealInterceptorChain.javaRealInterceptorChain 实现 Interceptor接口中的Chain接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors; private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; private final int index; private final Request request; private final Call call; private final EventListener eventListener; private final int connectTimeout; private final int readTimeout; private final int writeTimeout; private int calls; public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call, EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; this.call = call; this.eventListener = eventListener; this.connectTimeout = connectTimeout; this.readTimeout = readTimeout; this.writeTimeout = writeTimeout; &#125; @Override public Connection connection() &#123; return connection; &#125; @Override public int connectTimeoutMillis() &#123; return connectTimeout; &#125; @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, millis, readTimeout, writeTimeout); &#125; @Override public int readTimeoutMillis() &#123; return readTimeout; &#125; @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, millis, writeTimeout); &#125; @Override public int writeTimeoutMillis() &#123; return writeTimeout; &#125; @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, readTimeout, millis); &#125; public StreamAllocation streamAllocation() &#123; return streamAllocation; &#125; public HttpCodec httpStream() &#123; return httpCodec; &#125; @Override public Call call() &#123; return call; &#125; public EventListener eventListener() &#123; return eventListener; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must retain the same host and port&quot;); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must call proceed() exactly once&quot;); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptor + &quot; must call proceed() exactly once&quot;); &#125; // Confirm that the intercepted response isn&apos;t null. if (response == null) &#123; throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;); &#125; if (response.body() == null) &#123; throw new IllegalStateException( &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;); &#125; return response; &#125;&#125; 上面是RealInterceptorChain的全部代码，注意看一段代码 12345678// 最开始index = 0，注意这里构造RealInterceptorChain时，传入的为index+1 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的最前面的，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 RetryAndFollowUpInterceptor 拦截器 Interceptor interceptor = interceptors.get(index); // 然后调用拦截器的 intercept函数 Response response = interceptor.intercept(next); 看注释现在可能又点绕，接着往下看，Interceptor是一个接口，没必要看，可以直接先看RetryAndFollowUpInterceptor RetryAndFollowUpInterceptor 重试以及重定向拦截器RetryAndFollowUpInterceptor 实现 Interceptor 接口 查看其中的intercept函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); /** * todo 管理类，维护了 与服务器的连接、数据流与请求三者的关系。真正使用的拦截器为 Connect */ StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; Response priorResponse = null; // 在这里无限循环，只有抛出异常或者return response才会中断 while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); &#125; Response response; boolean releaseConnection = true; try &#123; //todo 请求出现了异常，那么releaseConnection依旧为true。 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; //todo 路由异常，连接未成功，请求还没发出去 //The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getLastConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接) // HTTP2才会抛出ConnectionShutdownException。所以对于HTTP1 requestSendStarted一定是true //An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We&apos;re throwing an unchecked exception. Release any resources. //todo 不是前两种的失败，那直接关闭清理所有资源 if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; //todo 如果进过重试/重定向才成功的，则在本次响应中记录上次响应的情况 //Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse( priorResponse.newBuilder() .body(null) .build() ) .build(); &#125; //todo 处理3和4xx的一些状态码，如301 302重定向 Request followUp = followUpRequest(response, streamAllocation.route()); if (followUp == null) &#123; if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; closeQuietly(response.body()); //todo 限制最大 followup 次数为20次 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); &#125; if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code()); &#125; //todo 判断是不是可以复用同一份连接 if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;); &#125; request = followUp; priorResponse = response; &#125; &#125; 可以看到此处的主要逻辑，将传入的chain对象转为RealInterceptorChain，无限循环，然后在循环中调用chain.proceed函数，获取response，循环的主要作用为catch异常，并针对RouteException 或者 IOException 做重试操作，其他异常则终止， 而chain.proceed又会回到上面RealInterceptorChain中 123456789// 当从RetryAndFollowUpInterceptor再过来时，index = 1； index + 1 = 2； RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 1，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 BridgeInterceptor 拦截器 Interceptor interceptor = interceptors.get(index); // 然后调用拦截器的 intercept函数 Response response = interceptor.intercept(next); BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应BridgeInterceptor 也是实现 Interceptor 接口 同样直接查看intercept函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(&quot;Content-Type&quot;, contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength)); requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); &#125; else &#123; requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); &#125; &#125; if (userRequest.header(&quot;Host&quot;) == null) &#123; requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(&quot;Connection&quot;) == null) &#123; requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;); &#125; // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also // decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123; transparentGzip = true; requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies)); &#125; if (userRequest.header(&quot;User-Agent&quot;) == null) &#123; requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent()); &#125; Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(&quot;Content-Encoding&quot;) .removeAll(&quot;Content-Length&quot;) .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(&quot;Content-Type&quot;); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; 可以看到，这个函数的逻辑，先对请求头信息进行再处理，然后执行chain.proceed获取networkResponse，然后再对networkResponse进行再包装处理 同RetryAndFollowUpInterceptor一样，又会调用到chain.proceed函数，又会回到上面RealInterceptorChain中 12345678// 当从RetryAndFollowUpInterceptor再过来时，index = 2； index + 1 = 3； RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 2，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CacheInterceptor 拦截器 Interceptor interceptor = interceptors.get(index); // 然后调用拦截器的 intercept函数 Response response = interceptor.intercept(next); 再看CacheInterceptor代码 CacheInterceptor 负责读取缓存以及更新缓存CacheInterceptor 也是实现 Interceptor 接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104@Overridepublic Response intercept(Chain chain) throws IOException &#123; //todo 通过url的md5数据 从文件缓存查找 （GET请求才有缓存） Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //todo 缓存策略:根据各种条件(请求头)组成 请求与缓存 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); // Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it. &#125; //todo 没有网络请求也没有缓存 //If we&apos;re forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; //todo 没有请求，肯定就要使用缓存 //If we don&apos;t need the network, we&apos;re done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; //todo 去发起请求 Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we&apos;re doing a conditional get. if (cacheResponse != null) &#123; //todo 服务器返回304无修改，那就使用缓存的响应修改了时间等数据后作为本次请求的响应 if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //todo 走到这里说明缓存不可用 那就使用网络的响应 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //todo 进行缓存 if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;&#125; 过程就是获取一个networlRequets，以及一个缓存的cacheResponse，如果networlRequets与cacheResponse，则直接报504的网络异常如果networlRequets为空，则只能返回cacheResponse，如果networlRequets不为空，则执行网络请求，获取networkResponse，如果cacheResponse 不为空 且 networkResponse响应码304，代表无更改，则可以返回， 再往下就是对networlRequets进行处理，并加入缓存。 注意：此处获取networkResponse也是调用chain.proceed，于是与上面一直，也会走到 RealInterceptorChain中。 12345678// 当从RetryAndFollowUpInterceptor再过来时，index = 3； index + 1 = 4；RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 3，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 ConnectInterceptor 拦截器Interceptor interceptor = interceptors.get(index);// 然后调用拦截器的 intercept函数Response response = interceptor.intercept(next); 此时会调用到ConnectInterceptor中的intercept函数 ConnectInterceptorConnectInterceptor 也是实现 Interceptor 接口 123456789101112131415161718192021public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; 如上代码就是ConnectInterceptor类中所有源码，intercept函数中，重新获取了几个参数，和上面的几个Interceptor实现类不太一样，最后调用的proceed函数是四个参数的，最后还是会走到 RealInterceptorChain中。 12345678// 当从RetryAndFollowUpInterceptor再过来时，index = 4； index + 1 = 5；RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);// 获取到传入的拦截器数组中的 index = 4，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CallServerInterceptor 拦截器Interceptor interceptor = interceptors.get(index);// 然后调用拦截器的 intercept函数Response response = interceptor.intercept(next); CallServerInterceptorCallServerInterceptor 也是实现 Interceptor 接口，CallServerInterceptor 中 intercept 函数就是直接与服务端通信的，而在这里会获取到真正的response，并返回到上一层，也就是ConnectInterceptor的intercept，同理会依次向上返回。 责任链模式在上面看到的，一层一层拦截器向下调用，Interceptor类实现 调用 Interceptor类实现，每一层的拦截器实现自己的功能，然后交付给下一层拦截器，这种设计模式就是责任链模式。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react Hook]]></title>
    <url>%2Fblog%2F2021%2F01%2Freact-Hook.html</url>
    <content type="text"><![CDATA[Hook技术Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。 useState在这里，useState 就是一个 Hook （等下我们会讲到这是什么意思）。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。 12345678910111213141516171819import React, &#123; useState &#125; from 'react';import &#123; View, Text, TouchableOpacity,&#125; from 'react-native';export default function test() &#123; console.log('------test'); const [count, setCount] = useState(0); return ( &lt;View style=&#123;&#123; marginTop: 100 &#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt; &lt;Text&gt;点击获取次数：&#123;count&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Text onPress=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125; style=&#123;&#123; marginTop: 100, fontSize: 30 &#125;&#125;&gt;test&lt;/Text&gt; &lt;/View&gt; );&#125; 如上图所示，是在react-native中简单使用Hook，使用其中的useStateconst [count, setCount] = useState(0);结构赋值，第一个count为获取的参数，第二个参数setCount是修改第一个参数的函数，useState(0)中，useState是在react中引入，后面的 0 是 count 的默认数据。 useEffectuseEffect 是一个副作用函数，默认在每次渲染之后都会执行。而且保证每次运行effect时，DOM已经渲染完毕。 传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。事实上这正是我们可以在 effect 中获取最新的 useState中 的值，而不用担心其过期的原因。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。 与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。 useEffect提供清除操作，当我们需要在React组件清除时，执行某一些操作，可以在useEffect中，返回清除函数。当React清除时，会执行useEffect中的返回函数。 12345678useEffect(() =&gt; &#123; ... return function remove() &#123; // when react remove &#125;&#125;) 为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。 React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。 还可以对useEffect进行优化，useEffect接受两个参数，第二个参数为比较值，当这个值发生了变化，才会执行useEffect。 123456789const [count, setCount] = useState(0)useEffect(() =&gt; &#123; ... return function remove() &#123; // when react remove &#125;&#125;, [count]) 这样，只有当count发生变化，即我们调用过 setCount来改变count的值，下一次渲染完毕，才会执行useEffect 所以，当我们需要执行一些只需执行一次的逻辑时，可以传入一个定值，一般使用空数组[] 123456789101112useEffect(() =&gt; &#123; ... function request() &#123; &#125; return function remove() &#123; // when react remove &#125;&#125;, []]) 如上所示，request只会在第一次渲染完毕执行一次，remove函数也时只会执行一次 Hook规则Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则 只在最顶层使用 Hook 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。 遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。 只在 React 函数中调用 Hook 不要在普通的 JavaScript 函数中调用 Hook 自定义Hook 自定义一个Hook函数 函数命名以use开始]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC]]></title>
    <url>%2Fblog%2F2021%2F01%2FIOC.html</url>
    <content type="text"><![CDATA[Android 推荐应用架构建议将代码划分为多个类，以从分离关注点这一原则（其中，层次结构的每个类都具有一项已定义的责任）中受益。这就需要将更多更小的类连接在一起，以实现彼此之间的依赖关系。 IOCandroid ioc 技术 源码地址：https://github.com/wangchongwei/ioc.git daggerdagger使用：主要使用了工厂模式、APT技术 利用注解处理器，变异时生成大量代码，完成自动注入 dagger 的使用主要作用：不必编写冗长乏味且容易出错的样板代码。 优势 Dagger 可以执行以下操作，使您无需再编写冗长乏味又容易出错的样板代码： 生成您在手动 DI 部分手动实现的 AppContainer 代码（应用图）。 为应用图中提供的类创建 factory。这就是在内部满足依赖关系的方式。 重复使用依赖项或创建类型的新实例，具体取决于您如何使用作用域配置该类型。 为特定流程创建容器，操作方法与上一部分中使用 Dagger 子组件为登录流程创建容器的方法相同。这样可以释放内存中不再需要的对象，从而提升应用性能。 只要您声明类的依赖项并指定如何使用注释满足它们的依赖关系，Dagger 便会在构建时自动执行以上所有操作。Dagger 生成的代码与您手动编写的代码类似。在内部，Dagger 会创建一个对象图，然后它可以参考该图来找到提供类实例的方式。对于图中的每个类，Dagger 都会生成一个 factory 类型类，它会使用该类在内部获取该类型的实例。 在构建时，Dagger 会走查您的代码，并执行以下操作： 构建并验证依赖关系图，确保： 每个对象的依赖关系都可以得到满足，从而避免出现运行时异常。 不存在任何依赖循环，从而避免出现无限循环。 生成在运行时用于创建实际对象及其依赖项的类。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide框架解析]]></title>
    <url>%2Fblog%2F2020%2F12%2FGlide%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[Glide是android平台中的一个图片加载框架，可以加载本地图片、网络图片、动态图 Glide的使用 1Glide.with(context).load(url).into(imageView); 可以看出分成三部分：with、load、into下面我们也分成三部分针对讲解 withwith函数其实是对生命周期的管理在Glide源码中，可以看到几个with函数,入参类型各不相同 12345678910111213141516171819202122232425262728293031@NonNullpublic static RequestManager with(@NonNull Context context) &#123; return getRetriever(context).get(context);&#125;@NonNullpublic static RequestManager with(@NonNull Activity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment);&#125;@SuppressWarnings(&quot;deprecation&quot;)@Deprecated@NonNullpublic static RequestManager with(@NonNull android.app.Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment);&#125;@NonNullpublic static RequestManager with(@NonNull View view) &#123; return getRetriever(view.getContext()).get(view);&#125; with函数的入参有 Context Activity FragmentActivity androidX.Fragment android.app.Fragment View可以看到，在with函数中都是调用getRetriever返回RequestManager对象，而调用getRetriever的入参有两个类型 1、context 2、activity getRetriever的两种入参类型又是根据上面with函数获取的，针对fragment、fragmentActiivty、Actiivty获取对应的actiivty针对context、view，则获取对应的context 再看一下getRetriever函数 getRetriever12345678910111213@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) &#123; Preconditions.checkNotNull( context, &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot; + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot; + &quot;is attached or after the Fragment is destroyed).&quot;); return Glide.get(context).getRequestManagerRetriever();&#125;@NonNullpublic RequestManagerRetriever getRequestManagerRetriever() &#123; return requestManagerRetriever;&#125; 也就是说，getRetriever返回就是一个 RequestManagerRetriever对象 也就是说 with函数最后调用到了RequestManagerRetriever对象的get函数 RequestManagerRetriever看在Glide.java中的with函数就知道，RequestManagerRetriever中get函数也存在多个1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@NonNull public RequestManager get(@NonNull Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; return getApplicationManager(context); &#125; @NonNull public RequestManager get(@NonNull FragmentActivity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); FragmentManager fm = activity.getSupportFragmentManager(); return supportFragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); &#125; &#125; @NonNull public RequestManager get(@NonNull Fragment fragment) &#123; Preconditions.checkNotNull(fragment.getActivity(), &quot;You cannot start a load on a fragment before it is attached or after it is destroyed&quot;); if (Util.isOnBackgroundThread()) &#123; return get(fragment.getActivity().getApplicationContext()); &#125; else &#123; FragmentManager fm = fragment.getChildFragmentManager(); return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible()); &#125; &#125; @SuppressWarnings(&quot;deprecation&quot;) @NonNull public RequestManager get(@NonNull Activity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); &#125; &#125;@SuppressWarnings(&quot;deprecation&quot;)@NonNullpublic RequestManager get(@NonNull View view) &#123; if (Util.isOnBackgroundThread()) &#123; return get(view.getContext().getApplicationContext()); &#125; Preconditions.checkNotNull(view); Preconditions.checkNotNull(view.getContext(), &quot;Unable to obtain a request manager for a view without a Context&quot;); Activity activity = findActivity(view.getContext()); if (activity == null) &#123; return get(view.getContext().getApplicationContext()); &#125; if (activity instanceof FragmentActivity) &#123; Fragment fragment = findSupportFragment(view, (FragmentActivity) activity); return fragment != null ? get(fragment) : get(activity); &#125; android.app.Fragment fragment = findFragment(view, activity); if (fragment == null) &#123; return get(activity); &#125; return get(fragment);&#125; 第一个get函数，传入context对象，对context做分发，其他的get函数，都是判断当前执行线程是否在main线程，如果不是 则都会走到1return getApplicationManager(context) 在main线程时，会根据传入的参数获取对应的activity，activity为null，则也会执行1return getApplicationManager(context) 如果activity不为空，则执行123android.app.FragmentManager fm = activity.getFragmentManager();return supportFragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); 其中android.app.Fragment会略有差异，因为该Fragment为android包下，已被遗弃，但执行逻辑其实大同小异 接下来我们再看supportFragmentGet函数 supportFragmentGet()跟随Fragment的生命周期1234567891011121314151617181920@NonNullprivate RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) &#123; SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint, isParentVisible); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); current.setRequestManager(requestManager); &#125; return requestManager;&#125; getApplicationManager跟随应用的生命周期 12345678910111213141516171819202122232425@NonNull private RequestManager getApplicationManager(@NonNull Context context) &#123; // Either an application context or we&apos;re on a background thread. if (applicationManager == null) &#123; synchronized (this) &#123; if (applicationManager == null) &#123; // Normally pause/resume is taken care of by the fragment we add to the fragment or // activity. However, in this case since the manager attached to the application will not // receive lifecycle events, we must force the manager to start resumed using // ApplicationLifecycle. // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context.getApplicationContext()); applicationManager = factory.build( glide, new ApplicationLifecycle(), new EmptyRequestManagerTreeNode(), context.getApplicationContext()); &#125; &#125; &#125; return applicationManager; &#125; 这样的话，就可以看得出调用with函数时，会绑定到一个requestManaget对象，但是分两种： 1、子线程，或出入的Context为ApplicationContext —》 applicationManager —— 跟随应用的生命周期 2、main线程 &amp; 非ApplicationContext —-》 requestManager —- 跟随当前Fragment/Activity的生命周期 接着看RequestManager RequestManager查看RequestManager的构造函数1234567891011121314151617181920212223242526272829303132333435363738public RequestManager( @NonNull Glide glide, @NonNull Lifecycle lifecycle, @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) &#123; this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory(), context);&#125;@SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)RequestManager( Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode, RequestTracker requestTracker, ConnectivityMonitorFactory factory, Context context) &#123; this.glide = glide; this.lifecycle = lifecycle; this.treeNode = treeNode; this.requestTracker = requestTracker; this.context = context; connectivityMonitor = factory.build( context.getApplicationContext(), new RequestManagerConnectivityListener(requestTracker)); if (Util.isOnBackgroundThread()) &#123; mainHandler.post(addSelfToLifecycle); &#125; else &#123; lifecycle.addListener(this); &#125; lifecycle.addListener(connectivityMonitor); defaultRequestListeners = new CopyOnWriteArrayList&lt;&gt;(glide.getGlideContext().getDefaultRequestListeners()); setRequestOptions(glide.getGlideContext().getDefaultRequestOptions()); glide.registerRequestManager(this);&#125; 两个构造函数，上面的构造函数会调用到下面的构造函数，只有上面的函数才对外暴露。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[okhttp解析(一) 执行与分发]]></title>
    <url>%2Fblog%2F2020%2F12%2Fokhttp%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[okhttp解析okhttp 是一个网络框架，是当下android使用最频繁的网络请求框架，由Square公司开源。 google在Android4.4后开始将源码中的HttpUrlConnection底层实现替换为okhttp，现在流程的Retrofit框架底层同样是使用okhttp的。 优点 支持http1、http2、Quic以及WebSocket 连接池复用底层TCP(Socket),减少请求延时 无缝支持GZIP减少通信数据流量 缓存相应数据减少重复请求次数 请求失败自动重试主机其他ip，自动重定向 使用方法okhttp具体使用可以查看： Call在client执行request时，会调用newCall方法。 1234@Overridepublic Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125; 会返回一个RealCall对象，而RealCall是Call接口的一个实现。 client调用newCall时，只是返回一个RealCall对象，请求还没有发送出去。需要执行RealCall的execute()或者enqueue() 这两个方法由什么区别呢，现在看一下。 execute这是一个同步方法，即会直接执行 123456789101112131415161718192021@Overridepublic Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this); // 发起请求 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 此处会调用client.dispatcher().executed(this); 其实是将当前RealCall对象加入到Dispatch的同步执行队列在最后执行完毕会调用 client.dispatcher().finished(this); 其实是将当前RealCall对象从Dispatch的同步执行队列移除，因为当前RealCall对象的任务已执行完毕 会获取到response，并直接return enqueue这是一个异步方法 12345678910@Overridepublic void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 在上面的两个方法中，最后都会调用到dispatcher的对应函数，Dispatch是一个分发器 注意调用dispatch的enqueue函数时，会将responseCallback包装成一个AsyncCall对象，AsyncCall为RealCall的一个内部类 AsyncCall1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super(&quot;OkHttp %s&quot;, redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //执行请求 （拦截器） Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;&#125; AysncCall实质上实现的是Runnable，execute执行的是获取response过程，请求成功则执行responseCallback.onResponse，否则执行responseCallback.onFailure 最后执行client.dispatcher().finished(this); 注意最后传入的this指向是AsyncCall实例对象， DispatchDispatch是okHttp内一个任务分发器，用于管理任务、管理线程池。我们可以自定义Dispatch，如果没有传入自定义的，okHttp内部也有默认的，okhttp3.Dispatcher 123456789101112131415161718192021222324252627282930313233public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private @Nullable Runnable idleCallback; /** * Executes calls. Created lazily. * 内部的线程池 */ private @Nullable ExecutorService executorService; /** * Ready async calls in the order they&apos;ll be run. * 等待执行的异步队列 */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** * Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. * 正在执行的异步队列 */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** * Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. * 正在执行的同步队列 */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); ....&#125; 可以看到在Dispatch内部有一个线程池，有三个队列，这三个队列下面会用的，会根据不同的任务添加到不同的队列 看一下Dispatch内部的executed以及enqueue函数 线程池12345678public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); &#125; return executorService;&#125; 关于线程池的详细解析可以查看之前的文章：线程池第4个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小 当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。 所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。 LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定 当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的integer.MAX_VALUE,此时添加任务会一直成功。 最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。 SynchronousQueue: 无容量的队列 使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。 唯一制约就是配置的最大线程数，如果使用Integer.MAX_VALUE就实现了真正的无等待。 而在okhttp中就采用的SynchronousQueue，但进程内存是有限制的，不能无限添加，所以在Okhttp内部又有maxRequests限制，保证不超过64个。 executed123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 可以看到在同步函数中，会将call 添加到同步执行队列 enqueue12345678910synchronized void enqueue(AsyncCall call) &#123; //todo : 1、如果正在执行的请求小于64 // 2、相同host的请求不能超过5个 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); //正在执行的请求 executorService().execute(call); //线程池跑任务 &#125; else &#123; readyAsyncCalls.add(call); &#125;&#125; 在异步执行时，会判断当前正在执行异步队列大大小是否小于64 &amp;&amp; 传入的call的Host在正在执行队列中数量是否小于，如果都满足，则会被放入正在执行异步队列，并且调用线程池执行该任务如果不满足，则会被放入待执行异步队列 注意：此处的call为一个AsyncCall实例， 上面在AsyncCall中讲过了，当AsyncCall执行完毕会调用finished（AsyncCall）函数来移除正在执行异步队列中的这个AsyncCall对象 finished123456789101112131415161718192021222324// 异步执行队列移除AsyncCall对象void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true);&#125;// 同步队列移除RealCall对象void finished(RealCall call) &#123; finished(runningSyncCalls, call, false);&#125;private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 当异步执行队列移除AsyncCall对象时，会执行promoteCalls()；而且当this.idleCallback不为空，而且异步执行队列为空时,会执行this.idleCallback.run(); promoteCalls12345678910111213141516171819/** * 从异步等待队列中取任务执行 */private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); // 同一Host请求只能同时有5个 if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125;&#125; promoteCalls函数主题其实就是从等待异步队列中取任务放入到执行异步任务队列中，并执行。 先判断异步执行队列大小是否大于64，是则不向下执行 再判断待执行异步队列是否没有数据，是则不向下执行 然后遍历readyAsyncCalls队列，判断当前AsyncCall的Host是否在异步执行队列中&lt;5,小于5时，将该任务从待执行异步队列移除，并将该任务添加到执行异步队列，并放入线程池判断异步执行队列大小是否大于64，是的话，终止遍历 到这里，okHttp的任务执行基本就看完了。 当然还有任务的取消 Cancel12345678910111213public synchronized void cancelAll() &#123; for (AsyncCall call : readyAsyncCalls) &#123; call.get().cancel(); &#125; for (AsyncCall call : runningAsyncCalls) &#123; call.get().cancel(); &#125; for (RealCall call : runningSyncCalls) &#123; call.cancel(); &#125; &#125; 就是遍历三个队列，调用Call对象的cancel方法。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-自定义View-继承Drawable]]></title>
    <url>%2Fblog%2F2020%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFDrawable.html</url>
    <content type="text"><![CDATA[源码地址 最后实现效果如下图： 思路：1、将正个鱼分成几个部分，鱼头圆，鱼身二阶贝塞尔曲线，鱼尾，鱼鳍2、因为鱼会摆动，需要考虑一个角度问题，需要定义一个点，来确定整个的角度3、以鱼的重心点作为基准点，即鱼身的中心点4、根据鱼的中心点以及每条线的长度获取其他点的坐标，就可以绘制整个图形5、鱼的摆动根据属性动画来绘制，但要考虑鱼头与鱼尾的摆动频率不一致，可以使用三角函数，0-360，鱼头设置一倍，鱼尾设置多倍，此时就能鱼头与鱼尾摆动频率不一致了。6、鱼尾分两段，摆动的方向不一致，一段带动另一段，一个采用正旋sin，一个采用余旋cos 进阶：鱼能游动7、点击时的水波纹8、鱼回头问题]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 嵌套滑动]]></title>
    <url>%2Fblog%2F2020%2F12%2FAndroid-%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android View的事件分发]]></title>
    <url>%2Fblog%2F2020%2F12%2FAndroid-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html</url>
    <content type="text"><![CDATA[View的事件分发首先用户的交互事件都是先交给Actiivty，然后再来向下分发事件 Activity我们可以查看 Activity 的 dispatchTouchEvent 123456789101112public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 事件的起点时，调用一次 onUserInteraction if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; // 将事件先分发给 window.superDispatchTouchEvent 如果返回为true 则直接终止 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; // 当通过事件分发 依然返回为false，代表没有被消费时，则执行 Activity 的 onTouchEvent return onTouchEvent(ev);&#125; 首先需要明确一点，ACTION_DOWN是一次完整的交互事件的起点，onUserInteraction是一个空函数可以不要管， 会将事件分发到 window 的 superDispatchTouchEvent，而 window 指的是PhoneWindow，在andorid源码中，只有一个window的实现类，就是PhoneWindow，如果 window 的 dispatch 返回为 true 则不向下执行，否则会执行到 Activity 的 onTouchEvent， PhoneWindow1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 在PhoneWindow.java中 superDispatchTouchEvent函数又代理给DecorView的superDispatchTouchEvent DecorView123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; DecorView 继承自 FrameLayout，FrameLayout 继承自 ViewGroupDecorView中的 superDispatchTouchEvent 直接调用父类的 dispatchTouchEvent，而在FrameLayout 中没有重写 dispatchTouchEvent 函数，所以会直接调用到 ViewGroup 的 dispatchTouchEvent 函数 ViewGroup首先，所有的View都是继承自View的，ViewGroup也是继承自View 在ViewGroup的dispatchTouchEvent函数中，代码太长，先将部分代码收缩起来 123456789101112131415161718192021222324252627@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; // mInputEventConsistencyVerifier是View中的一个变量，这里是对事件的一些校验 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. // 此处是对一些无障碍功能的设置 if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; // 局部变量，每一个事件分发时，都会重置为false boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; ... &#125; // 重新校验 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 其实主要逻辑还是在 if (onFilterTouchEventForSecurity(ev)) { 这个代码区域里 123456789public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123; //noinspection RedundantIfStatement if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123; // Window is obscured, drop this touch. return false; &#125; return true;&#125; 对事件安全过滤的函数，正常情况都能通过。接着看dispatchTouchEvent函数 1234567891011final int action = ev.getAction();final int actionMasked = action &amp; MotionEvent.ACTION_MASK;// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();&#125; 判断是ACTION_DOWN就清除、重置touch事件，因为在上面讲过，ACTION_DOWN是一次交互的起点，在这里将上一次交互的状态都清除掉 判断事件是否拦截1234567891011121314151617181920212223// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; // 当是事件的起点，获取此连续事件已经获取到对应的 target时 // 先获取子视图中是否设置了 外部拦截， final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 如果子视图允许外部拦截 即 disallowIntercept = false，默认为false // 进行内部拦截判断，看 viewgroup 的拦截逻辑 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; // 子视图禁止外部拦截，则事件必须尝试向下分发，不能在当前 viewgroup 拦截 intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. // 当 不是连续事件的起点，且 mFirstTouchTarget = null， 说明无视图处理了 ACTION_DOWN 事件，则没必要再向下分发该连续事件，直接拦截 intercepted = true;&#125; 这里是判断是否开启拦截，注意这里的判断逻辑，intercepted 是是否拦截标志位disallowIntercept： 是否允许拦截，此处是一个外部拦截，在子视图中设置的，子视图设置是否让父容器拦截事件如果 disallowIntercept = false，再取执行内部拦截, onInterceptTouchEvent ,查看 ViewGroup 是否拦截，为内部拦截disallowIntercept 为true时，代表子视图不允许父容器拦截，则 intercepted = false; 此处 else 的逻辑， 走到 else 说明： actionMasked 不是 ACTION_DOWN ，说明是一个后续事件，而且 mFirstTouchTarget = null说明 在这一个连续事件中，没有视图消费 ACTION_DOWN 事件，所以后续的事件也不再向下分发。 1234567891011121314151617181920212223242526272829303132 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false);&#125;// Check for cancelation.final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;// Update list of touch targets for pointer down, if needed.final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;TouchTarget newTouchTarget = null;boolean alreadyDispatchedToNewTouchTarget = false;``` 当被拦截时，或者 touchTarget 不为空时，设置事件的 TargetAccessibilityFocus 为false然后判断事件是否是取消事件初始化一个变量 alreadyDispatchedToNewTouchTarget=false , 是否已经将事件绑定到一个targetView```javaif (!canceled &amp;&amp; !intercepted) &#123; // 当不是取消、没有被拦截时 // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. // 获取到该事件绑定的view View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; ......&#125; 在上述代码段中，其实只是执行了一个操作，即遍历子 View ，获取该事件对应的处理的 View 。注意这里有一个函数调用 dispatchTransformedTouchEvent 当遍历找到需要处理这个事件的 View 或者 确定不存在该 View 时，即执行这个函数，对这个事件进行重新分发12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; // 为空，将事件交给View.dispatchTouchEvent处理 handled = super.dispatchTouchEvent(event); &#125; else &#123; // 子View处理 handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; // If the number of pointers is the same and we don't need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled;&#125; 上述函数总结其实就是判断 childView 是否为空，如果为空的话，就再将事件转交给 View.dispatchTouchEvent 来处理，super.dispatchTouchEvent，因为 ViewGroup 继承自 View，此时会调用到 View.dispatchTouchEvent如果 childView 存在，则执行 childView.dispatchTouchEvent，如果 childView 还是 ViewGroup ，还会再次执行这个过程，遍历-找寻子View-分发，注意在分发过程中，如果已经返回为true了，则不会再向下分发。 接下来看 View 的 dispatchTouchEvent View12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture // 当手指触碰时，停止滚动 stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement // 当onTouch事件返回了true时，此处返回true ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; // 当onTouch事件返回了true时，此处返回true if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. // 当手指抬起、取消时，结束滚动 if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 再看一下 onTouchEvent 事件，onTouchEvent是对事件的处理 123456789if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable;&#125; 如果View是不可点击的，如：ImageView,直接return false View里因为设置了 onClickListener(), 这样就导致 View是 clickable (或者可以直接在xml里加上android:clickable=”true”)，即可点击， 那么View.onTouchEvent就会永远返回 True, 代表View consume了该事件。 注意：只要View consume了该事件，那么该事件既不会往下传(不会传给子view)，也不会往上传(后面Activity/ViewGroup 的 onTouchEvent将不会再调用)。 View中不存在拦截，只有ViewGroup才有拦截 总结： 事件 Event 从 Activity 分发到 PhoneWindow 再到 DecorView 再到自己写的视图中，每一步都会先判断是否拦截，如果拦截，则不继续向下分发，而是执行当前拦截层的 onTouchEvent事件 当事件分发到了自己写的视图中时，因为所有的视图都是View的子集，包括ViewGroup，所有事件其实是在View、ViewGroup中一层一层向下分发。 在 ViewGroup 分发中，会先判断内部子View是否允许外部拦截，默认允许，此时会执行 ViewGroup 的 onTouchEvent 事件 如果ViewGroup未拦截事件，则ViewGroup会遍历子View，继续分发过程，直到找到消费该事件的targetView 如果该事件无子View消费，则该事件又会向上传递，一直到Activity 的 onTouchEvent 事件 关于可点击View的click事件与touch事件监听：dispatchTouchEvent&gt;onInterceptTouchEvent(ViewGroup才有)&gt;onTouch&gt;onTouchEvent&gt;onClick。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信]]></title>
    <url>%2Fblog%2F2020%2F12%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html</url>
    <content type="text"><![CDATA[网络通信计算机网络发展概史计算机的发展大致分为以下四个阶段1、诞生阶段，单个计算机为中心的远程联机系统2、ARPANET，多个主机通过通信线路互联起来3、开放性的标准化体系结构，OSI诞生4、Internet互联网 OSI模型分为7层，tcp/ip模型分为4层，并存在对应关系osi：物理层、链路层、 网络层、 传输层、 会话层、表示层、应用层tcp/ip：链路层、 网络层、 传输层、 应用层 ip -&gt; 网络层 tcp｜udp -&gt; 传输层 http | https -&gt; 应用层 像我们日常中所说的4G、5G网络，是作用在链路层 TCP协议的基本特性：面向链接、可靠性、RTT和RTO、数据排序、流量控制、全双工 数据流通在构造一个请求包时，从上往下，依次添加各个层级信息在解析一个请求包时，从下往上，依次解析出各个层级的信息 Tcp协议 优势： 面向连接 可靠性 RTT和RTO 数据排序 流量控制 全双工 tcp协议位于传输层 三次握手TCP协议中，Client与Server端建立链接会经历三次握手过程 1、Client 向 Server端发送报文， 含有SYN = 1； seq(序列号)=1234(系统决定，1234是举例)，Client端进入SYN_SENT状态2、Server 接收到 Client端报文，向Client端发送一个确认报文， 含有 SYN = 1；ACK = 1; ack=1235(1234 + 1);seq(序列号)=2637(系统决定，2637是举例) Server端进入SYN_SYN_RCND状态3、Client端接收到Server的确认报文，向Server端也发送一次确认报文， 含有 ACK = 1；ack=2638(2637+1); Client与Server端都进入ESTABLISHED状态，通信建立，开始会话 以上就是三次握手的过程 问题：为何tcp协议需要三次握手，而不是两次 因为三次是保证连接可靠、效率最高的次数。第一次：客户端询问服务端能否建立通信第二次：服务端向客户端确认可以通信第三次：客户端向服务端确认可以通信然后建立通信。 洪泛攻击黑客伪造大量虚假ip向服务端发送第一次握手报文，使server端大量通信进入SYN_SYN_RCND状态，消耗server资源，使服务端无法响应其他的请求，甚至宕机。 处理方案：防火墙、 四次挥手当要断开连接时，客户端与服务端之间将进行四次挥手，来确保数据传输都完毕，确保连接断开。 1、client向server端发送FIN报文， 含有FIN = 1，seq(序列号)=J(系统决定，J是举例)，Client进入FIN_WAITING2、server收到客户端发送的报文，同时向Server发送一个FIN ACK 确认报文 含有ACK = 1； ack = J + 1; Server进入CLOSE_WAITING3、server向client发送一个FIN报文， 含有FIN = 1； seq = K；Server进入 CLOSE状态4、client收到上述两个server端报文，Client进入TIME_WAITING状态,同时client向server发送一个ACK报文， 含有FIN = 1； ACK = 1； ack = K + 1; server接收到此报文后，进入CLOSED状态， 而client，在经过2 * MSL的时间段后，client进入CLOSED状态。 注意：四次挥手设计到四次报文的传输，但在实际中，可能会存在报文合并的现象，就是报文发送的次数可能只有3次甚至两次。MSL理论上是2分钟，可实际一般会被重写为30s，所以最后等待时间为1min-4min。 为什么需要四次挥手因为tcp是全双工(即客户端和服务器端可以相互发送和接收请求)，所以需要双方都确认关闭连接。 为什么需要TIME-WAIT状态？在第三次报文发送，client接收到时，client会进入TIME_WAIT状态，而且是需要经过经过2 * MSL，才会进入CLOSED状态，为何这么设计呢，因为要考虑最后一个报文的接收，要考虑到Server未接收到时，需要重新发送，还要考虑，如果Client即时进入CLOSED，连接断开，端口可能会有一个新的程序使用，可能存在报文被发送到这个新启动的程序。 wireshark使用wireshark可以抓包，查看到连接过程中的每一次数据包的传递 使用过滤器查看 tcp udp 可以指定协议 tcp.port==80 端口 ip.src==192.168.101.130 ip连接符使用and tcp and tcp.port==3306 and ip.src==192.168.101.130 HttpHttp（Hyper Text Transfer Protocol）超文本传输协议 服务器传输超文本到本地浏览器的传送协议 一次完整的Http请求过程1、首先进行DNS域名解析（本地缓存、操作系统缓存或DNS服务器）2、三次握手建立TCP连接3、客户端发起Http请求4、服务端响应Http请求5、客户端解析http代码，并请求http代码中的资源6、客户端渲染展示内容7、四次挥手关闭tcp连接 questtion1、DNS 劫持 2、http劫持 UDP 协议UDP是非面向连接的，所以优点是快，缺点就是不安全、可能数据丢失 要构造一个UDP请求时，需要使用DatagramSocket]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity一键换肤]]></title>
    <url>%2Fblog%2F2020%2F12%2FActivity%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4.html</url>
    <content type="text"><![CDATA[Activity一键换肤Activity绘制过程ActivityThread查看ActivityThread代码源码，performLaunchActivity函数123456789101112131415161718192021222324Activity activity = null;try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125;......activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); Activity我们在看Activity类中的attach函数中的部分12345mWindow = new PhoneWindow(this, window, activityConfigCallback);mWindow.setWindowControllerCallback(this);mWindow.setCallback(this);mWindow.setOnWindowDismissedCallback(this);mWindow.getLayoutInflater().setPrivateFactory(this); 再看我们在Activity中设置布局的setContentView函数在Activity中的实现1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; 这里可以看出我们传入的layout布局是设置到window对象上的，继续往里看Window类中的setContentView是一个抽象方法，而getWindow()返回的是我们上面的PhoneWindow对象，我们看PhoneWindow中的setContentView方法 PhoneWindowPhoneWindow.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125;@Overridepublic void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 当初次运行时，肯定会走到installDecor 函数，在此函数中，又会新建一个DecorView绑定到window上。 也就是说我们的window上还有挂载一个DecorView 而在installDecor中，会对mContentParent判断，当为空时，会初始化mContentParent = (DecorContentParent) mDecor.findViewById(R.id.decor_content_parent); 所以其实我们的view的层级其实是：Window -&gt; DecorView -&gt; mContentParent + 我们自己的布局而我们自己的View最后都是调用到LayoutInflater.inflate来加载的。 LayoutInflater最后所有View的加载会走到tryCreateView函数LayoutInflater 中的 tryCreateView函数 12345678910111213141516171819202122232425@UnsupportedAppUsage(trackingBug = 122360734)@Nullablepublic final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; if (name.equals(TAG_1995)) &#123; // Let&apos;s party like it&apos;s 1995! return new BlinkLayout(context, attrs); &#125; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; return view;&#125; 可以看得出先判断mFactory2是否存在，存在的话，会通过mFactory2.onCreateView来创建View再判断mFactory是否存在，存在的话，会通过mFactory.onCreateView来创建View如果上面两个都不存在，则会调用mPrivateFactory来创建 实践设计思路根据上面的描述，我们知道所有的View创建都会走到LayoutInflater.tryCreateView函数，而且这里有一个工厂类mFactory2，如果我们能创建一个mFactory2对象，并设置上去，那所有的view创建就都会走到我们自己的代码，则我们可以获取到所有的view 换肤：是替换所有可以替换的颜色、背景，包括背景颜色、背景图片，因为我们替换了背景颜色，所以文本颜色也是需要替换。我们明确了换肤的目标，原理呢就是：换肤插件module中具有的资源名与宿主app的资源名都一致，只是资源值不同，如在宿主app中res/value/colors.xml中1234567891011121314&lt;!--宿主app--&gt;&lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt; &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#ffce3d3a&lt;/color&gt;&lt;/resources&gt;&lt;!--插件module--&gt;&lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#1F1F1F&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#373935&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#ffffff&lt;/color&gt; &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#FFA500&lt;/color&gt;&lt;/resources&gt; 如上所示，所有的资源名称都是一致，只是资源内容不同，图片也是如此。当需要换肤时，通过获取宿主app的资源名称，到插件module中获取该名称的对应资源，然后替换]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2Fblog%2F2020%2F12%2F%E6%B3%A8%E8%A7%A3.html</url>
    <content type="text"><![CDATA[注解Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。 注解作用可以在源码、编译、运行时起作用， 自定义注解新建一个 @interface与java类或接口大致相同的格式要求，但使用关键字 @interface 可以在自定义注解上使用其他注解 1234public @interface CustomAnnotation &#123;&#125;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android消息机制]]></title>
    <url>%2Fblog%2F2020%2F11%2Fandroid%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[android 消息机制在 andorid 中，系统的行为、用户的输入等事件都会被包装为一个消息，进行消息发送、处理 关于消息的处理，就离不开 Handler、Message、Loop在平时使用时，Handler 多用于多线程之间通信。 那么 Handler 如何实现多线程通信？ 多线程之间为何不会互相干扰？ 为什么不使用用 wait/notify？ Handler 多线程通信先看一下普通使用案例 12345678910111213141516171819202122232425public class MyActiivty extends Activity &#123; private Handler myHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if(msg.what=100) &#123; // TODO &#125; &#125; &#125;; &#125; static class MyThread extends Thread &#123; @Overtide public void run() &#123; super.run(); Message message = Message.obtain(); message.what = 100; myHandler.sendMessage(); &#125; &#125;&#125; 上面就是一个简单的在子线程发送消息，回到主线程处理消息的过程， 通过在子线程构造一个 message 对象，在主线程中获取到该 message 对象，来处理消息。 所以其实 Handler 处理多线程通信是通过共享 Message 对象内存来实现的。内存是不区分线程的，这种通信原理就是在子线程与主线程共享 message 内存 所以 那么 Handler 如何实现多线程通信？通过 内存共享 实现。 在多线程时，Handler 又是如何保证消息如何在正确的线程发送的呢，或者说是如何保证执行的线程是正确的了。这就要引入我们的 Loop、消息队列概念了。 handler 处理消息模型: handler 负责发送、处理消息looper 负责一直轮询消息messageQueue 消息队列，负责存放、取出消息 以下以API 31为例 Handler消息的发送、处理 消息的发送几个public的发送消息的函数 sendMessage sendMessageDelayed sendMessageAtTime sendMessageAtFrontOfQueue sendEmptyMessage*** 函数不进行额外讲解， 123456789101112131415161718192021222324252627282930313233public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; // 设置message的target为当前的handler实例 msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 通过 sendMessage 发送消息时，调用链如下，此时 uptimeMillis = 0sendMessage -&gt; sendMessageDelayed -&gt; sendMessageAtTime -&gt; enqueueMessage -&gt; queue.enqueueMessage 通过 sendMessageDelayed 发送消息时，可以指定消息延迟的时间 (delayMillis)，单位为毫秒， 此时 uptimeMillis = 当前时间戳 + delayMillissendMessageDelayed -&gt; sendMessageAtTime -&gt; enqueueMessage -&gt; queue.enqueueMessage 通过sendMessageAtTime，与 sendMessageDelayed 类似，不过不会自动加当前时间戳，需要自己处理。一般是使用某个时间的时间戳 sendMessageAtFrontOfQueue 12345678910public final boolean sendMessageAtFrontOfQueue(@NonNull Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125; 看函数字面意思，发送消息到消息队列的队头上面的函数可以看出，与 sendMessageAtTime 函数逻辑一致，只是将 uptimeMillis = 0后面会讲为何 uptimeMillis = 0时，可以将消息置为队头 消息的处理会执行 dispatchMessage1234567891011121314151617public void dispatchMessage(@NonNull Message msg) &#123; // 如果message设置了callback，则会让message的callback处理该消息 if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; // 如果hangdler设置了callback，并且经过callback函数处理该消息返回true，则不继续执行 // 像我们自己实例话handler，参数里传入的就是callback匿名内部类 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // hangdler的handleMess函数处理，一般只有在自定义自己的Handler，继承Handler，重写handler函数才会用到 handleMessage(msg); &#125;&#125; 不经过MessageQueue直接处理消息 executeOrSendMessage1234567public final boolean executeOrSendMessage(@NonNull Message msg) &#123; if (mLooper == Looper.myLooper()) &#123; dispatchMessage(msg); return true; &#125; return sendMessage(msg);&#125; 当handler绑定的looper是当前运行线程的looper时，则会直接处理该消息，否则还是会发送消息到 MessageQueue 异步Handler在Handler中的构造函数中，有两个构造函数 Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) Handler(@Nullable Callback callback, boolean async) 传入的 async 即是标识该handler发送的消息是同步还是异步。 但这两个构造函数都适用 @UnsupportedAppUsage 标识，不能被外部调用。 所以在我们自己的代码中，Handler都是同步的，只有在 framework 中，存在异步 Message上面讲了消息机制中的 Handler现在我们再讲一下消息的本体 Message Message作为消息数据的载体，本身的数据结构为链表，而且是只有 next 指针，所以是个单链表。 异步消息Handler中有一个同异步的标识，但最终其实作用与Message身上，异步的Handler中发送的消息message也都为异步消息，同步的Handler发送的消息message也都为同步消息 Message中有一个属性，flag，标识消息是属于同步消息还是异步消息 通过以下函数也能设置消息为同步或异步： setAsynchronous 设置消息 isAsynchronous 获取消息是同步还是异步 享元模式Message 中没有什么复杂操作，都是一些赋值函数有两个地方可以注意下 12345678910111213141516171819202122232425262728293031323334public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); &#125; return; &#125; recycleUnchecked();&#125;void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; Message 的回收函数不是将对象置为空，而是将 Message 中的变量都还原为默认值。 12345678910111213public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; Message 还提供 obtain 函数，不会直接 new 一个 Message 对象，而是共享之前的对象，改变对象的内部属性。 所以我们在实际使用中都是使用 Message.obtain()来构建 message 对象，而不是一直使用 new ，这样可以避免频繁的生成、回收，避免内存抖动。 这种设计被成为 _ 享元设计模式 _ Looper讲到 looper 负责一直轮询消息，但是好像在上面的代码中，都没有使用到 looper。 其实是在主线程中，系统已经默认为我们创建了 looper，在 ActivityThread.java 的 main 方法中（ActivityThread 即为主线程） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format "seq=114" long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125; 我们可以看到，调用了 Loop.prepareMainLooper()、Looper.loop()函数，而且在 Looper.loop()后面就抛出异常，也就是说主线程中 loop 一旦停止轮询，则会抛出异常闪退。正常情况时，loop 就是一直在轮询。 查看 Looper 的这两个函数 prepareMainLooper12345678910public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; prepareMainLooper 其实也是一个 prepare 的过程，只是这个是针对主线程而已 在 prepareMainLooper 中可以看到，不允许调用两次，否则会抛出异常。 prepare我们看一下 myLooper 函数 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 说明 looper 是存放在 ThreadLocal 中的。这样保证了 looper 的线程唯一性关于 ThreadLocal，在之前已经大致讲过了。ThreadLocal 讲解（https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）在每一个线程，都存在一个对应且唯一的值 我们可以看一下 prepare 函数 123456789101112131415public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 可以看到与 prepareMainLooper 的不同，因为 prepareMainLooper 是在主线程调用，而主线程只有一个，所以直接使用 sMainLooper 来保存主线程的 looper，而且主线程中 prepare(false)；标示不允许 looper 退出。 而在子线程时，就是将 looper 对象保存到 sThreadLocal 中，sThreadLocal.get()不为 null 时，会抛出异常。也就是说子线程中 prepare 只允许调用一次，保证了每个线程中的 looper 对象唯一性 然后看到子线程和主线程的另一个差异 prepare(false) &amp;&amp; prepare(true)因为 andorid，所有事件如：用户的操作、ui 的渲染等都是作为消息发送的，而这些都是在主线程操作的，所以在主线程中是不允许退出 loop 循环，否则抛出异常。 而在子线程中 prepare(true)，允许退出，其实在子线程中新建 handler、looper 时，当我们不需要再使用，需要终止 loop 循环。此时需要调用： 123public void quitSafely() &#123; mQueue.quit(true);&#125; loop123456789101112131415161718192021222324252627282930313233public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; if (me.mInLoop) &#123; Slog.w(TAG, "Loop again would have the queued messages be executed" + " before this one completed."); &#125; me.mInLoop = true; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0); me.mSlowDeliveryDetected = false; for (;;) &#123; if (!loopOnce(me, ident, thresholdOverride)) &#123; return; &#125; &#125;&#125; loop 函数中，首先获取通过 myLooper()函数获取 looper 对象，如果 looper 对象为空，则抛出异常，提示必须在当前线程先执行 Looper.prepare()然后获取 looper 对象持有的 messageQueue， 在API 31中，与之前的源码略有改动，新增了函数 loopOnce 然后就是 for(;;)无限循环，调用 loopOnce 函数 loopOnce12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) &#123; // 调用 me.mQueue.next() 获取到下一条消息，可能会阻塞 Message msg = me.mQueue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return false; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; // Make sure the observer won't change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; // 调用handler的dispatchMessage msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (me.mSlowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, "Drained"); me.mSlowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery", msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. me.mSlowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg); &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); return true; &#125; 这里面注意两句： Message msg = me.mQueue.next(); // might block 通过 mQueue 取出下一条 message， 这个过程可能会阻塞 msg.target.dispatchMessage(msg); 将取出的消息发送给 handler.dispatchMessage 进行处理 最后执行 msg.recycleUnchecked()，相当于一个回收利用。 MessageQueue在上面中已经讲过 Looper，looper 中持有一个 messageQueuefinal MessageQueue queue = me.mQueue;mQueue 在 Looper 的私有构造函数中被初始化 接下来我们看一下 MessageQueue 直面翻译为 消息队列，队列是一种数据结构，FIFO，先进先出但这里的其实不是一个队列，只是对 Message 的管理，处理存、取 消息，起到一个类似队列的功能，对消息主体进行管理 之前说了，MessageQueue 主要用于存放、取出消息。在 Looper 中主要用到了 messagequeue 的 next 函数，用于取出下一条消息 我们先看一下存放消息 enqueueMessage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; // 消息不能重复入队 throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; // 将消息置为使用 msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; // 通过 handler.sendMessage 发送的消息主体，when = 0 // 此时该消息会被放置到链表的表头位置 // 这里也就是为何 sendMessageAtFrontOfQueue 传入的 when 是0，会被放置在链表的头部位置 // when &lt; p.when 时， msg -&gt; p , 时间是升序 if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. // 当前被阻塞，且当前的消息未绑定target(handler), 且 传入的msg为异步消息时，需要唤起线程 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; // 取到链表中链尾或者p.when比当前when要大的消息 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; // 如果需要唤起线程，且 现有（不包括最新的msg）的消息链表中存在异步消息。则不唤起线程 needWake = false; &#125; &#125; // 跳出循环之后 // 将传入的 msg 插入到 prev 、p之间。 // prev -&gt; msg -&gt; p （按照when降序排序） 此处有一个疑问🤔️，此处时间是降序，上面的时间为何是升序 // 此处传入的msg 肯定是异步消息 msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 如果当前线程已经退出，mQuitting 为 true，则抛出异常。 注意这段代码123456789msg.when = when;Message p = mMessages;boolean needWake;if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked;&#125; 当全局变量 mMessages 为空，即代表消息队列中不存在消息了或者当前传入的 when 为 0， 通过handler.sendMessage 发送的消息 传入的when都为0或者当前 when 小于全局变量 mMessages.when, 即时间在前其实判断的是两种状态，1:messageQueue 队列为空 2:添加的消息执行时间在前此时将该消息置于链头，needWake = mBlocked；如果 mBlocked 为 true，needWake 也为 true，就是如果之前阻塞则唤醒，反之无需唤醒 再看不满足上面情况下时,即消息队列中已添加过消息，而且要添加的消息.when 在上一次添加的消息之后 12345678910111213141516171819else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;&#125; for 循环，遍历链表，当找到节点为 null 即遍历完 || 传入的 when 小于遍历节点的 when（即传入消息的时间在遍历节点时间之前时）终止循环，将 msg.next -&gt; p原来prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; p -&gt; …现在prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; msg.next -&gt; p -&gt; … 也就是说，message 链表是按照 when 排序的，when 越小，在越靠近链头为何要根据 when 排序了，其实是因为 message 执行时间是要按时间排序，要执行时间越小，代表时间越早，所以放在链头 以上是消息队列，入队函数，再看一下出队函数 next123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112@UnsupportedAppUsageMessage next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 这里代表同步屏障 取出异步消息 msg // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 消息的执行时间还未到，需要休眠此时间差，阻塞 // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 在链表中删除 msg 节点，并返回 msg // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // msg == null 无需休眠 // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. // message 链表为空，无消息，此时可以执行 idleHandler 任务 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; // idleHandler 执行一个则移除一个 mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 接下来一段段代码分析 1234567if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125; 这一块设计到消息的同步屏障，放到下面再将，我们先只看出队时的逻辑next 函数就是取出下一条消息。开启 for 循环 123if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands();&#125; 如果 nextPollTimeoutMillis 不等于 0 时，会阻塞。 1234567891011121314151617181920212223242526272829303132333435final long now = SystemClock.uptimeMillis();Message prevMsg = null;Message msg = mMessages;if (msg != null &amp;&amp; msg.target == null) &#123; // 这里代表同步屏障 取出异步消息 msg // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125;if (msg != null) &#123; if (now &lt; msg.when) &#123; // 消息的执行时间还未到，需要休眠此时间差，阻塞 // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 在链表中删除 msg 节点，并返回 msg // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125;&#125; else &#123; // msg == null 无需休眠 // No more messages. nextPollTimeoutMillis = -1;&#125; 当当前 message 不为空时：如果当前时间小于 msg.when，即没到执行时间，则阻塞线程到 msg.when 时间将 msg.next 赋值给全局变量 mMessages，再将 msg.next 指向 null然后返回 msg 这一个节点，如此不会返回一个链表 如果 msg 为空，说明队列为空，没有消息，此时赋值 nextPollTimeoutMillis = -1;下一次循环时，就会阻塞。 MessageQueue 添加消息、取出消息是线程安全的吗？是，是线程安全的。 如何保证线程安全的？通过锁，存放消息以及取出消息时都有设置 synchronized (this)，synchronized 后面修饰的是 this，同一个对象在多线程环境调用函数时，只会有一个线程获取到锁，进行操作。synchronized 是内置锁，JVM 已经内置处理了锁的获取以及释放 为什么不使用用 wait/notify？在上述代码可以看到使用了阻塞、锁，阻塞是直接调用 native 函数来阻塞，其实在内部已经使用了 wait/notify。 Message 同步屏障上面讲的消息 message 链表是根据 when 时间排序，那如果有紧急的消息必须马上处理呢，这个时候不可能等其他先执行而必须是马上执行的事件时，怎么办？ 这个时候就可以用到 同步屏障。 在 MessageQueue 中具备两个函数：postSyncBarrier、removeSyncBarrier设置与移除同步屏障，注意这两个方法都是 hide，供系统内部使用，想自己调用只能通过反射，而且在新版本反射使用会报错。 postSyncBarrier12345678910111213141516171819202122232425262728private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125; &#125; 构建一个 Message 对象 msg，遍历当前 message 链表，将该 msg 插入到一个 when 大于传入 when 的节点后，并注意 msg 的 target 为 null；然后就与上面讲到的 next 函数中代码呼应。 1234567 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());&#125; 此时会遍历获取到最后一条异步消息，msg， &amp;&amp; prevMsg.next = msg; 123456789101112131415161718if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125;&#125; 此处就是在链表中移除 msg 节点，并 return msg 对象。也就是说，当设置消息屏障时，会在 Message 链表中从后向前取出异步消息，直至移除同步屏障 removeSyncBarrier移除同步屏障 IdleHandler在上面讲到的 MessageQueue 中的 next 函数中，我们看到了一段代码 1234567891011121314151617for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125;&#125; 当队列 MessageQueue 为空或者 未到消息的执行时间时，此时会从 mPendingIdleHandlers 数组中，取出 IdleHandler 对象，进行执行 queueIdle 函数。如果 queueIdle 返回结果为 true，代表可以重复执行，返回为 false，则执行一次会将该任务移除。 IdleHandler 相当于闲时任务，只有在空闲时才会执行。 常见面试提问： 如何在页面绘制完成后执行一个任务此时就可以使用 IdleHandler，因为调用到 IdleHandler 中的 queueIdle 函数时，保证消息队列中的 Message 都被消费了。 总结handler 消息机制大概流程：生成 Looper 对象，生成 Handler 对象，Lopper.looper 循环在 Handler 构造函数内，获取到上面生成的 looper 对象，通过 ThreadLocal 保存到对应的线程，与 MessageQueue 绑定在需要发送消息的地方调用 handler.sendMessage(),在 sendMessage 时，将 message 与 handler 绑定，将 message.target 赋值为当前 handler同时，sendMessage 时，调用 messageQueue.enqueueMessage 将 message 放入消息队列。同时，Looper.loop()在循环一直取出消息 message，然后通过 message.target 获取到 handler 对象，最终回调到 handler.handlerMessage 函数。 这样消息从产生到处理流程就走完了。 总结提问： Looper.loop()一直在循环，为什么不会导致应用卡死(ANR)? 答：loop()循环与 ANR 是两个不相关的事情，loop 只是循环事件，ANR 是处理事件耗时，导致无法响应用户的下一次输入。系统的 ANR 弹窗都是通过消息机制发送，并弹出提示窗的。 fragment 生命周期 Handler 内存泄漏原理： postDelay 的 Message 怎么处理 其实是设置了handler的callback回调 当调用 Handler 的 sendMessageDelayed 时，会调用 sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage 而在 MessageQueue 的 enqueueMessage 中。 汇总总结调用 Looper.prepare 会往 ThreadLocal 中存放一个新的 Looper 对象，新建 Handler 时，会获取当前线程的 looper 对象，如果无则报错。获取到 looper 就将当前的 handler 与当前线程的 looper 关联。而 looper 中有一个 MessageQueue 消息队列实例 mQueue handler 与 mQueue 就通过 Looper 关联起来 Handler —-&gt; Looper &lt;——- MessageQueue handler 的 sendMessage 调用链如下： handler.sendMessage —&gt; sendMessageDelayed —&gt; sendMessageAtTime —&gt; enqueueMessage —&gt; MessageQueue.enqueueMessage 在 enqueueMessage 中，传入的 when 是在 sendMessageAtTime 传入的系统当前时间，此时会遍历链表，以时间排序，将新来的 message 放入链表。 Message 的数据结构是链表 target 就是处理 message 的 handler、when 就是消息发送的时间，正常情况链表就是根据 when 排列的， 越小在链头，时间戳越大的越靠近当前时间。也就是说 Message 中的链表，正常情况是按时间先后顺序来的 以前—-&gt;现在 消息机制就是一个完整的生产者、消费者模式，上述的部分就是生产者部分，往消息队列中放入消息。 再到消费者部分，Loop.loop() 无限循环，往 messageQueue 队列中取数据，Looper.loop —&gt; MessageQueue.next在 Message.next 函数中，会去判断是否存在消息屏障，如果有，则取出里面的同步消息，优先处理该消息]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APT注解处理器]]></title>
    <url>%2Fblog%2F2020%2F11%2FAPT%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8.html</url>
    <content type="text"><![CDATA[APTAPT(Annotation Processing Tool) 是一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，根据注解自动生成代码，如果想要自定义的注解处理器能够正常运行，必须要通过APT工具来进行处理。 也可以这样理解，只有通过声明APT工具后，程序在编译期间自定义注解解释器才能执行。 通俗理解：根据规则，帮我们生成代码、生成类文件 在使用APT在项目编译时期动态生成我们需要的java文件时，有两种方式，传统方式、javapoet 项目源码(https://github.com/wangchongwei/apt) javapoet以面向对象(OOP)思维，在编译时，动态生成java文件 优点：OOP思维，不需要导包缺点：倒序写法，从函数-&gt;类-&gt;包 这种方式和写作思维不同，从调用链尾部到头部。开源组件butterknife、ARouter都是使用javapoet方式 example: 新建一个工程，并在工程新建一个javaLib，在此工程新建一个注解类123456789@Target(ElementType.TYPE) // 表明注解是添加在类上@Retention(RetentionPolicy.CLASS) // 表明在编译器执行public @interface ARouter &#123; String path(); // 声明注解时 必须参数 String group() default &quot;&quot;; // 因为已经设置了default值，所以这个是选填参数&#125; 此时我们就完成了一个注解的定义然后再新建一个javaLib，在此工程新建一个处理注解的类，而这个类就是我们在编译时生成java类的主要代码部分在此工程build.gradle中添加依赖123456789101112dependencies &#123; // 背后的服务 能够监听 你是否在编译中..... // AS3.4.1 + Gradle 5.1.1 + auto-service:1.0-rc4 compileOnly&apos;com.google.auto.service:auto-service:1.0-rc4&apos; annotationProcessor&apos;com.google.auto.service:auto-service:1.0-rc4&apos; // 帮助我们通过类调用的形式来生成Java代码 [JavaPoet] implementation &quot;com.squareup:javapoet:1.9.0&quot; // 依赖注解module implementation project(&quot;:annotations&quot;)&#125; 然后我们开始写监听到注解时需要生成java类的部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@AutoService(Processor.class) // 启用服务 google 自动服务，一直监控@SupportedAnnotationTypes(&#123;&quot;com.justin.annotationprocessor.ARouter&quot;&#125;) // 注解 包名.类名@SupportedSourceVersion(SourceVersion.RELEASE_8) // 环境的版本@SupportedOptions(&quot;student&quot;) // 接收在app/build.gradle中声明的参数public class ARouterProcessor extends AbstractProcessor &#123; private Elements elements; private Messager messager; private Filer filer; private Types typeTool; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); elements = processingEnvironment.getElementUtils(); messager = processingEnvironment.getMessager(); filer = processingEnvironment.getFiler(); typeTool = processingEnvironment.getTypeUtils(); // 获取在app/build.gradle中申明的参数 String value = processingEnvironment.getOptions().get(&quot;student&quot;); messager.printMessage(Diagnostic.Kind.NOTE, &quot;=========&gt;&quot; + value); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; // 此时会运行两次，一次执行，一次检查 messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; compiler is running&quot;); if(set.isEmpty()) &#123; // 使用注解的类集合为空 return false; &#125; // 获取被 ARouter注解的 &quot;类节点信息&quot; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class); for(Element element : elements) &#123; /** 举例我们需要生成这样一个类 package com.example.helloworld; public final class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, JavaPoet!&quot;); &#125; public int add(int a, int b)&#123; return 5; &#125; &#125; */ // javapoet生成java文件的方式时，OOP思维，先生成函数，再生成类，最后生成包 // 1 生成函数 MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;main&quot;) // 构造一个函数， 函数名 .addModifiers(Modifier.PUBLIC, Modifier.STATIC) // public 、static .returns(void.class) // 返回值类型 .addParameter(String[].class, &quot;args&quot;) // 入参类型 .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)// 函数执行语句 不需要添加分号 .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, agent!&quot;) .build(); // 多个函数 MethodSpec methodSpec1 = MethodSpec.methodBuilder(&quot;add&quot;) .addModifiers(Modifier.PUBLIC) .returns(int.class) .addParameter(int.class, &quot;a&quot;) .addParameter(int.class, &quot;b&quot;) // 可以添加多个入参 .addStatement(&quot;return 5&quot;) .build(); // 2 生成类 TypeSpec myClass = TypeSpec.classBuilder(&quot;HelloWorld&quot;) // 构造一个类，类名 .addModifiers(Modifier.PUBLIC, Modifier.FINAL) // 添加申明 public、final .addMethod(methodSpec) // 绑定函数 .addMethod(methodSpec1) // 绑定多个函数 .build(); // 3、生成包 JavaFile myPackage = JavaFile.builder(&quot;com.example.helloworld&quot;, myClass).build(); try &#123; myPackage.writeTo(filer); &#125; catch (IOException e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; 创建HelloWorld类失败,异常原因：&quot; + e.getMessage()); &#125; &#125; return false; &#125;&#125; 最后使用@ARouter注解在MainActivity中使用123456789@ARouter(path = &quot;main/MainActivity&quot;)public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 点击build项目，即会在app/build/ap_generated_sources/debug下生成对应的包以及java文件 在上述方式中，我们只是写成了一个固定的java文件，还没有体现动态生成概念。下面我们就要改造，动态接收参数来生成代码只显示动态生成代码部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取被 ARouter注解的 &quot;类节点信息&quot; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class); for(Element element : elements) &#123; // 动态生成java代码 // 获取组件class的包路径 String packageName = elementTool.getPackageOf(element).getQualifiedName().toString(); // 获取注解的类名 String className = element.getSimpleName().toString(); // 获取到注解以及注解时的参数 ARouter aRouter = element.getAnnotation(ARouter.class); String path = aRouter.path(); /** 模板： public class MainActivity3$$$$$$$$$ARouter &#123; public static Class findTargetClass(String path) &#123; return path.equals(&quot;/app/MainActivity3&quot;) ? MainActivity3.class : null; &#125; &#125; */ // 1、方法 MethodSpec method = MethodSpec.methodBuilder(&quot;findTargetClass&quot;) .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .returns(Class.class) .addParameter(String.class, &quot;path&quot;) .addStatement(&quot;return path.equals($S) ? $T.class : null&quot;, path, ClassName.get((TypeElement) element) // 获取注解类的class对象 ) .build(); // 2 类 TypeSpec mineClass = TypeSpec.classBuilder(className + &quot;$$$$$$$$$ARouter&quot;) .addModifiers(Modifier.PUBLIC) .addMethod(method) .build(); // 3 包 JavaFile minePackage = JavaFile .builder(packageName, mineClass) .build(); try &#123; minePackage.writeTo(filer); &#125; catch (IOException e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + className + &quot;类失败&quot;); &#125; &#125; 此时我们就完成了自动获取注解类的包名、类名、注解时的path自动生成的类也在相同包名下，获取注解时的path，可以做一些操作 传统方式生成java文件在编译时，一行一行，从头到尾，以写文本的方式写一个java文件 优点：套版格式，思路清晰缺点：所有代码都需要写，包括导包，如果有任一一个字符错误、分号缺失，都会导致报错。 这种方式需要及其细心开源组建EventBus就是采用的这种方式 example：首先自定义注解类：123456@Target(TYPE) @Retention(CLASS) // 编译期 XUtil==运行期public @interface Binding &#123; String router();&#125; 然后写注解处理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@SupportedSourceVersion(SourceVersion.RELEASE_7) // 环境的版本@AutoService(Processor.class) // 启用服务@SupportedAnnotationTypes(&#123;&quot;com.derry.arouter_annotations.Binding&quot;&#125;) // 注解public class BindingProcessor extends AbstractProcessor &#123; private Elements elementTool; private Messager messager; private Filer filer; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); elementTool = processingEnvironment.getElementUtils(); messager = processingEnvironment.getMessager(); filer = processingEnvironment.getFiler(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; if(set.isEmpty()) &#123; return false; &#125; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Binding.class); for (Element element : elements) &#123; // 获取包名 String packageName = elementTool.getPackageOf(element).getQualifiedName().toString(); String className = element.getSimpleName().toString(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;被@ARetuer注解的类有：&quot; + className); String findClassName = className + &quot;$$$$$$$Binding&quot;; Binding binding = element.getAnnotation(Binding.class); try &#123; JavaFileObject javaFileObject = filer.createSourceFile(packageName + &apos;.&apos; + findClassName, element.getEnclosingElement()); Writer writer = javaFileObject.openWriter(); StringBuilder sb = new StringBuilder(); sb.append(&quot;package &quot;).append(packageName).append(&quot;;\n\n&quot;); sb.append(&quot;public class &quot;).append(findClassName).append(&quot;&#123;\n&quot;); sb.append(&quot;public String findTargetRouter()&#123;\n&quot;);// sb.append(&quot;return &quot; + binding.router().toString()).append(&quot;;\n&quot;); sb.append(&quot;return \&quot;test\&quot;;\n&quot;); sb.append(&quot;&#125;\n&quot;); sb.append(&quot;&#125;\n&quot;); writer.write(sb.toString()); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + findClassName + &quot;类失败&quot;); &#125; &#125; return false; &#125;&#125;]]></content>
      <tags>
        <tag>andorid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 性能优化]]></title>
    <url>%2Fblog%2F2020%2F11%2Fandroid-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[android性能优化性能优化分为几个方向： 内存优化 电量优化 渲染优化 size大小优化 异常捕获 apk瘦身针对与apk大小优化而言，首先需要知道apk中主要结构，了解其中是哪些部分比较大。然后来针对性优化。 一般而言比较占用的是：资源文件、架构文件(.so) 资源文件优化针对资源文件，首先我们去除没有被使用的资源，然后就是降低所用资源的大小。 在app/build.gradle文件中设置shrinkResources true 12345release &#123; shrinkResources true proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot; &#125; 则会在Gradle打包release apk时，自动忽略未使用的资源文件，包括：图片、xml 但要注意此时也会忽略隐式调用的资源文件，如通过反射调用，或者react-native中在js调用drawable木土图片，在这两种场景时，都会被忽略。针对这种场景，可以通过keep文件，保持这些资源文件不会被忽略。 在res目录下新建xml目录，在xml目录下新建文件keep.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resourcesxmlns:tools=&quot;http://schemas.android.com/tools&quot;tools:keep=&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;tools:discard=&quot;@layout/unused2&quot; /&gt; 其中tools:keep是强制不忽略，tools:discard是强制忽略 上面讲述的是去除无用资源，还有我们可以去除无用的代码，如未被调用的函数，未被使用的变量 minifyEnabled设置为true，设置在与shrinkResources一起的地方。注意shrinkResources需要与minifyEnabled一起使用才会生效123456release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot; &#125; 针对架构.so优化在大型项目，特别时继承第三方过多时，此时.so文件才是占用最多的部分。 异常捕获开发时怕的不是出现问题，而是问题无法重现。因为android碎片化严重 生产上的问题肯定要比开发时问题多。而且很多都是在开发端未必能重现的。此时需要我们记录发生在用户手机上的异常。 针对异常可以分类，java异常、native异常。native异常即是native函数c++代码异常 java异常捕获在andorid app中捕获java异常，只需要实现Thread.UncaughtExceptionHandler native异常]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程与进程]]></title>
    <url>%2Fblog%2F2020%2F10%2F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[进程是操作系统资源分配的基本单位， 线程是处理器（CPU）任务调度和执行的基本单位线程依赖于进程，一个进程可能对应多个线程。 并发与并行 1、并发（Concurrent）：指两个或多个事件在同一时间间隔内发生，即交替做不同事的能力，多线程是并发的一种形式。例如垃圾回收时，用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。 2、并行（Parallel）：指两个或者多个事件在同一时刻发生，即同时做不同事的能力。例如垃圾回收时，多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 同时能处理的最大线程数取决于CPU内核数量，有些机器还有逻辑处理器， 能同时处理任务的线程最大数量为CPU内核与逻辑处理器的较大值。 如内核：4，逻辑处理器：8那么CPU正在能同时处理的任务数量为8。 但为何我们写代码的时候，设置多线程运行时为何感觉可以同时设置很多个线程数量呢。 这个就跟CPU的时间轮转片调度算法有关了 在早期的时间片轮转法中,系统将所有的就绪进程按先来先服务的原则,排成一个队列,每次调度时,把CPU分配给队首进程,并令其执行一个时间片.时间片的大小从几ms到几百ms.当执行的时间片用完时,由一个计时器发出时钟中断请求,调度程序便据此信号来停止该进程的执行,并将它送往就绪队列的末尾;然后,再把处理机分配给就绪队列中新的队首进程,同时也让它执行一个时间片.这样就可以保证就绪队列中的所有进程,在一给定的时间内,均能获得一时间片的处理机执行时间. 所以我们在多线程运行时，超过内核数量的线程任务在执行时，其实是在切换运行的。只是因为CPU的时间片粒度很小，所以在切换时，很多都是无感的 线程的启动java中的程序天生的多线程的，启动线程有两种方式。 继承Thread类 实现Runnable接口 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[]args) &#123; MyThread thread = new MyThread(); thread.start(); MyThread2 thread2 = new MyThread2(); new Thread(thread2).start(); &#125; static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); System.out.println(&quot;extends Thread&quot;); &#125; &#125; static class MyThread2 implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;implements Runnable&quot;); &#125; &#125;&#125; 线程的终止线程启动了，如何终止呢？Thread类中提供了stop、suspend、resume等函数，但都是已经遗弃的，不提倡使用，在API29时，调用内部就是直接抛出异常UnsupportedOperationException。 为何遗弃，因为suspend函数，只会终止当前线程，而不会释放线程已经占有的资源(比如锁)，而是占有资源进入睡眠状态，这样容易引发死锁问题。而stop函数也是同理，在终止线程时，不会保证线程资源能够正常释放所以这些函数都已经被遗弃，不提倡使用。 正确的中断线程的方法，是调用Thread中的interrupt().interrupt()函数不会强制中断线程，而只是改变了一个线程的标志位，线程通过检测自身的标志位是否被置为true来判断是否需要继续执行。 可以调用isInterrupted()来获取该标志位，判断线程任务是否应该中断，还可以调用Thread中的静态函数interrupted()来判断，但是interrupted()函数调用时，会将标志位重新置于false。 1234567891011121314151617181920212223242526class Test &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); try &#123; Thread.sleep(300); thread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); while (!currentThread().isInterrupted()) &#123; System.out.println(&quot;线程正常运行&quot;); &#125;// while (!Thread.interrupted()) &#123;// System.out.println(&quot;线程正常运行&quot;);// &#125; System.out.println(&quot;线程已经被终止 flag ---&quot; + currentThread().isInterrupted()); &#125; &#125;&#125; 打印结果可以看得出isInterrupted()与interrupted()的区别。 run() start()我们new一个Thread实例对象，只是创建了一个对象，并没有与操作系统的真正的线程挂钩，只有在执行start函数时，才是真正启动了一个线程，执行了其中的run方法 start()的调用，让线程进入就绪队列等待分配cpu，分到cpu后执行run()方法，start方法不能重复调用，否则抛出异常 123456789101112131415161718192021222324252627282930313233343536373839public synchronized void start() &#123; /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ // Android-changed: Replace unused threadStatus field with started field. // The threadStatus field is unused on Android. if (started) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group&apos;s list of threads * and the group&apos;s unstarted count can be decremented. */ group.add(this); // Android-changed: Use field instead of local variable. // It is necessary to remember the state of this across calls to this method so that it // can throw an IllegalThreadStateException if this method is called on an already // started thread. started = false; try &#123; // Android-changed: Use Android specific nativeCreate() method to create/start thread. // start0(); nativeCreate(this, stackSize, daemon); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; 主要逻辑在这个native函数中nativeCreate() Thread中其他函数yieldyield(): 使当前让出cpu占有权，但让出时间不可限定，也不会让出锁资源，而且执行yield()的线程也不一定持有锁，我们可以在释放锁后执行这个方法。执行yield()后让出cpu，但也可能在下一个时间片重新获取cpu。 joinjoin() ：将指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行，比如在线程B中执行了A线程的join函数，直到A线程执行完毕，才会执行B线程。 1234567891011121314151617181920212223242526272829303132class Test &#123; public static void main(String[] args) &#123; Thread a = new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(&quot;这是a线程在执行&quot;); try &#123; Thread.sleep(100); System.out.println(&quot;这是a线程在休眠结束&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread b = new Thread()&#123; @Override public void run() &#123; super.run(); try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;这是b线程在执行&quot;); &#125; &#125;; a.start(); b.start(); &#125;&#125; 线程的同步synchronized锁，内置锁，具体详情可以查看：https://wangchongwei.github.io/blog/2020/09/Synchronized%E8%AF%A6%E8%A7%A3.html volatile只保证可见性，不能保证原子性 ThreadLocal在每个线程存在副本，各个线程数据互不干扰。具体详情可以查看： https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html ForkJoinForkJoin 是采用分而治之的思维，将一个大任务分解为若干个相互独立的子任务（异步），达到提高运算效率。我们做一个简单的运算 计算1-100000的累加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class TestJoinTask &#123; public static void main(String[] args) &#123; long currentTime = System.currentTimeMillis(); ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; task = pool.submit(new MyForkJoinTask(1, 100000)); try &#123; int result = task.get(); System.out.println(&quot;result = &quot; + result); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot; 执行完毕&quot; + &quot; time = &quot; + (System.currentTimeMillis() - currentTime)); &#125; /** * 传入的范型Integer是返回结果类型 */ static class MyForkJoinTask extends RecursiveTask&lt;Integer&gt; &#123; private int startValue; private int endValue; private int limitValue = 100; public MyForkJoinTask(int startValue, int endValue) &#123; if(startValue &gt; endValue) &#123; throw new RuntimeException(&quot;startValue &lt; endValue&quot;); &#125; this.startValue = startValue; this.endValue = endValue; &#125; @Override protected Integer compute() &#123; if(endValue - startValue &lt;= limitValue) &#123; System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot; 执行计算&quot;); // 两个值在限制值内 进行计算 int sum = 0; for(int i = startValue; i &lt;= endValue; i ++) &#123; sum += i; &#125; return sum; &#125; MyForkJoinTask task1 = new MyForkJoinTask(startValue, (endValue + startValue) / 2); task1.fork(); MyForkJoinTask task2 = new MyForkJoinTask((endValue + startValue) / 2 + 1, endValue); task2.fork(); return task1.join() + task2.join(); &#125; &#125;&#125; 如上所示，我们将一个从0 - 100000的累加任务分解为500个子任务：每200位数累加 在日志打印中，我们可以看到，有多个线程在执行任务，也就是说，分解的任务其实都是提交到线程池中执行， 守护线程守护线程依附与其他线程，当其他线程结束时，守护线程自动退出 在守护线程中的 finally 中代码可能不会执行]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 8.0屏幕朝向]]></title>
    <url>%2Fblog%2F2020%2F10%2Fandroid-8-0%E5%B1%8F%E5%B9%95%E6%9C%9D%E5%90%91.html</url>
    <content type="text"><![CDATA[在android8.0设备发现一个问题，在androidManifest.xml中已配置了固定的屏幕方向，但是在应用中，点击设备menu键，选择应用时，此时应用仍然可以旋转。 在MainActivity中通过代码设置 setRequestedOrientation时会报错：Only fullscreen activities can request orientation 原因是在android8.0 的Activity.java 的代码中 1234567891011121314151617protected void onCreate(@Nullable Bundle savedInstanceState) &#123; if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (getApplicationInfo().targetSdkVersion &gt;= O &amp;&amp; mActivityInfo.isFixedOrientation()) &#123; final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window); final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta); ta.recycle(); if (isTranslucentOrFloating) &#123; throw new IllegalStateException( &quot;Only fullscreen opaque activities can request orientation&quot;); &#125; &#125; .......&#125; 如果sdk版本&gt;O &amp;&amp; 当前Activity的屏幕方向固定时，判断当前主题样式，如果包含透明样式，则会抛出该异常。 很明显这段代码存在问题，sdk&gt;=O其实就是android8.0(26)及以上。而后面两个要求，固定屏幕方向在特定应用时很常见的，而透明样式页比较常见，我们常用透明背景做一个简单的启动优化，避免其他样式导致的闪屏现象。 而这段代码也在8.0之后的版本修复，但是现在市面存在的手机在andorid8.0的时候基本都存在该问题。 修复方式时只能去除透明背景，但为了修复26存在的问题，修改应用整个的表现有些得不偿失。 所以我们可以针对特定版本修改资源。 首先去掉AndroidManifest.xml中的 android:screenOrientation 配置， 在res新增values-v26文件夹，这样在sdk26的手机就会在这个文件夹下寻找对应的资源，如果没有才会有主目录values中去找。 在values-v26中修改styles.xml，去掉此处的透明背景。 再在代码中调用setRequestedOrientation来固定屏幕 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);&#125; 此时则不会再报错，也不存在之前所说的点击menu键，回到应用会旋转问题。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android内存优化]]></title>
    <url>%2Fblog%2F2020%2F10%2Fandroid%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[内存优化内存检测工具 MATandroid studio profile 内存抖动内存泄漏内存溢出 JMM 内存结果模型 GC算法 对象的生命周期：内存分配初始化、不可见、不可达、收集、终结、内存重新分配 四种引用类型 incomegoing: 持有该对象的对象outgoing: 该对象持有的对象 12345678910111213141516171819class A &#123; C c = new C()&#125;class B &#123; C c = new C()&#125;class C &#123; public C() &#123; &#125; C instance = new C() public C getInstance() &#123; return c &#125; D d = new D() E e = new E()&#125; C 的incomegoing为 A、B、CC 的outgoing为 C、D、E]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider]]></title>
    <url>%2Fblog%2F2020%2F10%2FContentProvider.html</url>
    <content type="text"><![CDATA[ContentProviderContentProvider 内容提供者 是android四大组件之一，为不同应用、进程之间数据共享，制定统一的接口]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service、IntentService]]></title>
    <url>%2Fblog%2F2020%2F10%2FService%E3%80%81IntentService.html</url>
    <content type="text"><![CDATA[Service、IntentServiceService是android中四大组件之一，用于处理后台任务，不能处理耗时任务，否则会造成ANR而IntentService继承自Service，但是可以处理耗时任务，因为在内部开启了一个子线程。 Service生命周期Service的生命周期分为两种情形，一种是通过startService启动，另一种是通过bindService启动。在这两种情况下时，Service的生命周期是有差异的。 startService通过startService去启动一个Service，如果该Service未被创建，则会走onCreate、onStartCommand、onStart生命周期如果该Service已被创建，则不会执行onCreate，只会执行onStartCommand、onStart onStart为正常运行时的生命周期 而且startService可以被多次调用被重复调用后会执行下面的生命周期 通过startService启动的Service存活不依赖与Activity，即使启动该Service的Activity已经被销毁，但该Service仍然可以存活。通过startService启动的Service需要调用stopService来销毁该Service,此时会执行onDestroy周期函数 bindServicebindService时，Service是依赖Activity的，当当前Activity被销毁、或者调用unBindService时，Service都会被销毁。 所以每一次调用bindService时，Service都会被重新创建所以通过bindService去启动一个Service，会走onCreate、onBind生命周期 12345678910111213class ServiceConnect() : ServiceConnection &#123; override fun onServiceDisconnected(name: ComponentName?) &#123; Log.d(TAG, &quot;onServiceDisconnected: &quot;) &#125; override fun onServiceConnected(name: ComponentName?, service: IBinder?) &#123; Log.d(TAG, &quot;onServiceConnected: &quot;) &#125;&#125;btn_bindService.setOnClickListener &#123; var conn = ServiceConnect() bindService(Intent(this, MyService::class.java), conn, Context.BIND_AUTO_CREATE) hasBind = true&#125; 当执行到onBind时，还会执行onServiceConnected 在Service中，不能执行耗时操作，超过5秒，则会造成程序不响应ANR当我们需要执行耗时操作时，则必须开启子线程，或者使用IntentService IntentServiceIntentService有与Service一样的生命周期，只是在内部开启了一个子线程，暴露onHandleIntent来执行耗时任务，当子线程执行完就会终止当前Service IntentService中的部分源码123456789101112131415161718192021222324252627282930private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125;@Overridepublic void onCreate() &#123; super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125;@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; Servicehandler是IntentService的一个内部类，当收到消息时调用onHandleIntent,当执行完，则调用stopSelf，终止当前服务 在OnCreate中，新建了一个HandleThread，并运行。创建一个Servicehandler，而该ServiceHandler的Looper对象为HandleThread线程中创建的， 当执行到onStart生命周期时，handler发送一条消息，此时就会走到ServiceHandler中的handlerMessage中，也就会执行onHandleIntent中。因为mServiceLooper = thread.getLooper();所以onHandleIntent是运行在HandlerThread中的。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment的懒加载实现，参数传递与保存]]></title>
    <url>%2Fblog%2F2020%2F09%2FFragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%9D%E5%AD%98.html</url>
    <content type="text"><![CDATA[Fragment懒加载关于Fragment的懒加载，针对ViewPager、ViewPager2又有不同， ViewPager针对ViewPager，其实是使用Fragment中的setUserVisibleHint函数以及onHiddenChanged函数，通过getUserVisibleHint()获取当前的Fragment是否可见，当不可见时，则不加载，当可见时再创建视图并缓存。这样可以只加载一次，大致原理就是如此。 ViewPager2ViewPager是androidX下的包，之前使用的setUserVisibleHint、getUserVisibleHint等都已被申明遗弃，而在ViewPager2时通过FragmentTransaction.setMaxLifecycle() 来实现懒加载]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Application生命周期]]></title>
    <url>%2Fblog%2F2020%2F09%2FApplication%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[ApplicationApplication是指代一个应用，默认我们在android应用中可以不指定，也可以写一个类，继承Application，在AndroidManifest.xml中指定applictaion类即可 Application是应用的入口。 Application的生命周期就是应用的生命周期。 生命周期生命周期函数有：onCreate、onLowMemory、onTrimMemory、onTerminate、onConfigurationChanged 各个生命周期函数解释 onCreate: 应用被创建时调用，是程序的主入口，在此处做一些初始化操作，不要做耗时操作。 onLowMemory： 当系统整体内存可用量较少时触发，可以在这里做一些不重要数据的清除、释放资源，避免因内存不足导致App被系统杀掉 onTrimMemory(int level)： andorid4.0后出的API，用来取代onLowMemory函数的，其中这个函数还有一个入参，来表示等级。 onTerminate： 当Application结束时，又系统决定调用时机。常规手动kill app进程没有触发此函数 onTrimMemory此函数是在android4.0后引入的，能实现的组件不止Application，还有Activity、Fragment、Service、ContentProvider作用是指导应用程序在不同情况下进行自身的内存释放，以避免被系统杀掉，提高用户体验 根据不同的情况，在函数中的提现就是 onTrimMemory函数中的 level这个入参。level有7个值， TRIM_MEMORY_UI_HIDDEN：表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键、Pause键导致应用的UI界面不可见．这时候应该释放一些资源． 当app运行在前台时，会回调下面这三个值，内存余量从高到低排列 TRIM_MEMORY_MODERATE：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。 TRIM_MEMORY_RUNNING_CRITICAL：表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。 TRIM_MEMORY_RUNNING_LOW：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。 当app缓存在后台时，会回调一下三个值，内存余量从高到低排列 TRIM_MEMORY_BACKGROUND：表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。 TRIM_MEMORY_RUNNING_MODERATE： 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。 TRIM_MEMORY_COMPLETE：表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。 onTrimMemory 主要是在考虑内存优化时需要考虑。在此处做数据清除、资源释放]]></content>
      <tags>
        <tag>andorid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的启动模式]]></title>
    <url>%2Fblog%2F2020%2F09%2FActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[Activity启动模式首先，Activity有四大启动模式：standard、singleTask、singleTop、singleInstance 如何设置Activity的启动模式： 静态设置，在AndoridManifest.xml文件中，对Activity设置launchMode 123&lt;activity android:name=&quot;.MainActivity3&quot; android:launchMode=&quot;singleInstance&quot; /&gt; 动态设置，在Activity跳转时，intent设置FLAG 123var intent = Intent(this, MainActivity::class.java);intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)startActivity(intent) 并且注意，同时设置了两种方式时，动态设置会覆盖静态设置 launchModestandardstandard: 标准模式，默认模式，当设置为此模式时，每一次跳入都会重新创建实例每次会新创建一个实例，并加入到启动它的Activity的任务栈中。 singleTasksingleTask: 栈内复用模式，当设置此模式时，如果栈内没有该Activity就会重新创建，如果已经有了，则会复用栈内已存在的该Activity，而不会重新创建，并会移除之前在栈中处于该Activity上部的所有的Activity。ex：A的启动模式是standard， B的启动模式为singleTask A -&gt; B -&gt; A -&gt; B A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以不会重新创建b的实例，而是复用之前B的实例，同时会调用onNewIntent生命周期函数，而且会销毁之前处于栈顶的A。最后栈内就是： A、B，B位于栈顶 singleTopsingleTop：栈顶复用，与singleTask有部分相似，singleTask是只要在栈内就会复用，而singleTop是只有在栈顶才会复用，如果栈内存在实例，但不处于栈顶，则表现与standard一致，如果站内存在实例，且处于栈顶，则表现与singleTask一致， ex：A的启动模式是standard、B的启动模式是singleTopA -&gt; B -&gt; A -&gt; BA -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，但之前的B不在栈顶，所以会重新创建一个B的实例 singleInstancesingleInstance: 独立运行在一个单独的task中，而且只会存在一个实例在Activity跳转时，注意查看，普通的Activity跳转和Activity Task跳转，两者的动画效果是不同的。 ex: A的启动模式是standard、B的启动模式是singleInstanceA -&gt; B -&gt; A -&gt; BA -&gt; B 时，因为当前Activity栈task A中只有A，会重新创建一个task B并新建一个B的实例放入task BA -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例，并放入到task A中A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以会将task B置顶，最后的栈情况为： A -&gt; A -&gt; B，如下图所示： 我们可以通过指令：adb shell dumpsys activity查看Activity栈中的Activity task情况 通过关键字：ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)即可搜索到上述截图情况 任务栈我们一直提到一个栈，那什么是Activity所需要的任务栈呢，这需要提到一个参数：TaskAffinity TaskAffinity可以翻译为任务相关性，这个参数主要标识了一个Activity所需要的任务栈的名字默认情况下，所有activity所需的任务栈的名字为应用包名。当然我们也可以为每个Activity单独指定TaskAffinity，但是我们指定的必须不能与包名相同，否则就相当于没指定。 相同TaskAffinity的Activity会运行在同一个任务栈中 TaskAffinity一般与启动模式或allowTaskReparenting搭配使用 allowTaskReparenting当应用A调用应用B的Activity C，如果Activity C的allowTaskReparenting设置为true，当应用B被启动后，则会将应用A的任务栈转移到应用B的任务栈。 当应用A调用应用B的Activity C，然后按Home键回到桌面，此时会显示被应用A启动的Activity C，而不是应用B的默认Activity]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android生命周期]]></title>
    <url>%2Fblog%2F2020%2F09%2Fandroid%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[准备对andorid基础性的东西都进行整理，梳理一下。 android的生命周期单个Actiivty正常的生命周期 onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory 这就是一个Activity从被创建到被销毁过程。 其中正常运行状态为onResume 当Activity从前台被置于后台，onResume -&gt; onPause -&gt; onStop 当从后台重新置于前台onStop -&gt; onPause -&gt; onResatrt -&gt; onStart-&gt; onResume 其中可以发现，只要Activity置于前台都会执行onStart函数，所以我们可以考虑在这里做一下需要在前台就处理的逻辑 各个生命周期函数：onCreate: Activity被创建，此时Activity处于不可见、不可交互onStart: 此时Activity 部分可见不可交互onRestart: Activity从后台重新回到前台，部分可见不可交互onResume: 完全可见可交互，为Activity正常运行状态onPause: Activity处于暂停，从前台被置于后台 部分可见部分不可见，不可交互onStop: 完全置于后台，完全不可见，onDestroy: Activity被销毁 上面就是一个正常的Activity的生命周期， 屏幕旋转在Activity生命周期中，还设计一些其他：Activity旋转：onCreate -&gt; onStart -&gt; onResume此时被旋转-&gt; onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume 可以发现当Activity被旋转时，整个Activity是被销毁然后重新创建的。其中新增调用了两个生命周期函数onSaveInstanceState: 当Activity被系统异常销毁时被调用，用于存储数据，用于系统恢复Activity时恢复数据onRestoreInstanceState: 当Actiivty被系统异常销毁并重新创建时，取出在onSaveInstanceState时存储的数据 注意，在onCreate函数中，其实也是有参数的12345override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) Log.d(TAG, &quot;onCreate: &quot;) setContentView(R.layout.activity_main) &#125; 此处的savedInstanceState也是在onSaveInstanceState时存储的数据，但此处可能为nll，因为在正常的Activity时，此处就是null，只有在Activity被异常销毁然后被系统重新创建时，此处才有值。如果要在此处使用，切记要判空。 onNewIntentonNewIntent与Activity的启动模式有关 当Activity未设置启动模式时，则不会触发该生命周期函数 当Activity已经处于应用的Activity栈中 如果Actiivty的LaunchMode为Standard时，即默认模式，此时不会触发该生命周期函数。 如果Activity的LaunchMode为SignleTop，如果ActivityA已经处于栈顶，再通过StartActivityForResult调用该Activity，此时会触发的生命周期函数为： onPause -&gt; onNewIntent -&gt; onResume 如果Activity的LainchMode为SingleInstance,SingleTask时，并且ActivityA已经处于Activity栈中，再次通过StartActivityForResult调用该Activity，此时生命周期函数：onNewIntent—&gt;onRestart—&gt;onStart—&gt;onResume onNewIntent只会在Activity设置了启动模式，并且Activity被复用时才会调起。 注意：只对startActivityForResult调起的Activity起作用，statActivity本质调用的也是startActivityForResult，Activity正常的切换前后台时不会触发的。 Activity交互A -&gt; B:A正常运行处于 onResume，打开B A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop点击跳入B页面， 首先A进入暂停，B开始创建，到onResume完全可见可交互，于是A被完全遮挡，变成完全不可见、处于后台，进入onStop A -&gt; B -&gt;goBack-&gt; A 在B页再执行返回 B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B Stop -&gt; B onDestory和A进入B类似，B返回A时，B进入暂停，A变得重新可见到A完全可见，进入onResume，然后B进入停止，并销毁 B启动模式设置为 SingleTop，B -&gt; BB onPause -&gt; B onNewIntent -&gt; B onResume因为 B已经处于栈顶，启动模式为 SingleTop 则不会重新创建B的实例 将A的启动模式设置为SingleTask 可以通过在andorid studio的终端 Terminal中输入：adb shell dumpsys activity查看当前应用的Activity task栈 onSaveInstanceState关于onSaveInstanceState，在api28以前，实在onPause之后、onStop之前调用，在api28以后，是在onStop之后调用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 适配androidX]]></title>
    <url>%2Fblog%2F2020%2F09%2Freact-native-%E9%80%82%E9%85%8DandroidX.html</url>
    <content type="text"><![CDATA[androidX在API28后，android新增androidX依赖，用于解决以前的android.support.v*依赖混乱问题。对v1-v9做了合并处理。 然后很多使用的第三方依赖中在新版本都适配了androidX，当你需要使用这些插件的较新版本时，只能去适配androidX。 最近使用react-native-firebase时，被提示必须使用17.0.0+的 Firebase Crashlytics SDK，否则2020年11月15日之后，将不再向firebase发送错误日志。 适配androidX点击andorid studio上方导航栏Refactor/Migrate to AndroidX这时会提示你，gradle tool version 最低3.2.0项目中每一个project的build.gradle都需要修改 classpath(“com.android.tools.build:gradle:3.2.0”)其中3.2.0为最低版本。 注意，选择的版本可能maven仓库找不到。如在第三方插件中，设置的maven仓库可能不存在该版本。如： 我使用的是版本：3.4.0123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:3.4.0&apos; &#125;&#125; 此时会报错，404，找不到。因为在jcenter远程仓库中不存在该版本。 3.4.0的版本只有google的maven仓库中有，所以需要修改 1234repositories &#123; google() jcenter() &#125; 查看maven插件地址：https://maven.aliyun.com/mvn/search 同时需要修改每个project的targetSdkVersion 将所有project的版本都修改为3.4.0之后，在点即Migrate to AndroidX,此时会提示你需要修改的地方， java文件，去除一些v*的引入 build.gradle 去除一些v*的依赖 manifest.xml 需要修改一些属性，如配置的FileProvider,修改name属性android:name=&quot;androidx.core.content.FileProvider&quot; 修改完后，无报错时直接运行。 会有一些java文件报错，就是引入的之前的v*的包，需要手动修改，哪里报错改哪里。 最后运行，运行成功]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin 在android老项目中引入kotlin]]></title>
    <url>%2Fblog%2F2020%2F09%2Fkotlin-%E5%9C%A8android%E8%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5kotlin.html</url>
    <content type="text"><![CDATA[在android项目中引入kotlin存在两种方法 1、手动修改，在module/build.gradle中添加kotlin依赖 2、使用android studio 等ide工具在项目引入kotlin依赖 修改项目的build.gradle 文件中 buildscript { ext { kotlin_version = &quot;1.3.10&quot; } dependencies { classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; } } 在app/build.gradle中 1234apply plugin: &quot;com.android.application&quot;// 在顶行下添加apply plugin: &apos;kotlin-android&apos;apply plugin: &apos;kotlin-android-extensions&apos; 然后同步一下即可 在andorid studio操作点击 android studio工具栏的 Tools -&gt; Kotlin -&gt; Configure Kotlin in Project 此时会弹窗选择需要添加kotlin依赖的module，可以选择某个modulw，也可以选择项目 android studio 一键转换java代码为kotlin代码选中某个java文件，需要该文件聚焦，然后点击android studio工具栏 Code -&gt; Convert Java File to Kotlin File]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google play 提交要求]]></title>
    <url>%2Fblog%2F2020%2F09%2Fgoogle-play-%E6%8F%90%E4%BA%A4%E8%A6%81%E6%B1%82.html</url>
    <content type="text"><![CDATA[google play 提交要求本文于2020/09/09日起记录在google play提交版本时，google play提出的提交要求 targetSdkVersion在2020/08/05日，提交版本发现多了一个警告 新提交的应用在8月开始，必须设定targetSdkVersion为29或以上，已存在的应用提交新版本时，必须设定targetSdkVersion为29或以上 关于targetSdkVersion的原理targetSdkVersion相当于在编写代码时设定一个假想的运行手机版本，打包后，再运行到真实设备。最终的运行表现取决与targetSdkVersion与真实运行设备版本中的低值。 targetSdkVersion的预设就相当于预设一个代码运行环境，我们所写的代码功能如果是只有部分版本才有的API，我们需要先判断真实的运行版本是否符合。如在android6.0后引入权限请求，在每次请求权限时，我们需要判断SDK版本是否大于等于23. 12345private void request() &#123; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; requestPermissions(new String[]&#123;Manifest.permission.CAMERA&#125;, 101); &#125;&#125; 当然，是否需要判断版本其实和minSdkVersion也是有关的，如上面的代码，因为权限请求是23以后的，如果我们直接将minSdkVersion设置为23，则此时就不需要判断版本了，因为肯定是运行在23之后的手机，因为23以前的手机此时会无法安装该应用。 ex:当我们设定targetSdkVersion=29，即android10，而用户手机为API=23，即android6.0，此时app的表现会是6.0。 当我们设定targetSdkVersion=23，即android6，而用户手机为API=29，即android10，此时app的表现也会是6.0。 64位框架在去年时，google play要求提及的应用必须支持64位的框架，也就是.so文件必须支持64位架构，在提交审核的apk中，有armeabi-v7a则必须也要有arm64-v8a，如果有x86，则必须也要有x86_64。react-native 原本只有armeabi-v7a，在之后的版本0.59.10中就开始内部源码中支持64位含有arm64-v8a下的.so文件 API 31在2022年10月以前，google play要求提交的应用必须设定 targetSdkVersion 为31 或以上]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2Fblog%2F2020%2F09%2Fgit%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[gitgit是一款分布式代码版本控制工具 初始化使用：当我们在gitlab、github初始化一个项目路径后，需要将本地仓库的代码提交到新建好的远端仓库 12345git initgit remote add origin &lt;remoteurl&gt; // 链接远端仓库 &lt;remoteurl&gt;为远端仓库地址git add .git commit -m &quot;commit info&quot;git push 设置全局用户信息12git config --global user.name &quot;userName&quot;git config --global user.email &quot;useremail&quot; git fetch 拉取代码git merge 合并代码git pull 拉取并合并代码git push 将本地仓库的commit提交到远端仓库 git checkout 切换分支git checkout -b 新建分支并切换 git branch -d 删除分支 不能删除有未提交commit的分支git branch -D 强制删除分支 git push -u origin 将本地分支推送到远端，如果远端没有此分支则会创建 git reset –hard 代码回滚到某个commit commitId可以通过git log查看 git log 可以查看每一个的commit，显示的信息有 commit date，commit person，commitId，commit info git merge A 将A分支合并到当前分支 git rebase A 将A分支合并并且将A分支节点置于当前分支之后 git mv 修改文件名，因为git默认忽略文件大小写，如修改文件名 File.js 到 file.js此时是无法检测到更改，需要使用命令：git mv File.js file.js update在github中已修改默认分支为main 而不再是master 此时针对命令为git initgit remote add origin // 链接远端仓库 为远端仓库地址git branch -M maingit push -u origin main git checkoutcheckout 有多个使用场景。 切换分支 git checkout -b branchName 新建分支并切换到该分支 git checkout branchName 切换到分支 舍弃代码 (未提交到暂存区) git checkout filePath 舍弃指定文件的修改 git checkout . 舍弃所有的修改 git cherry-pick （合并单次commit）当我们需要从其他的分支获取某次提交，但又不想直接合并该分支的全部代码此时可以使用 git cherry-pick commitid 来获取其他分支的某次提交 git reset –hard (还原到历史版本)当需要还原仓库代码时，可以使用 git reset –hard commitid 来回滚本地代码但是因为此时本地仓库落后于远端仓库，此时是无法 push 的。 需要在远端仓库删除该分支，然后执行 git push localBranchName:remoteBranchName localBranchName 本地仓库的该分支名 remoteBranchName 远端仓库的分支名 git rebase异常解决有时git -refusing to merge unrelated histories当执行git push时提示先执行git pull而执行git pull时报错如标题，此时需执行：1git pull origin master --allow-unrelated-histories]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock详解]]></title>
    <url>%2Fblog%2F2020%2F09%2FLock%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[LockLock 是java中的一个锁接口，在jdk1.5新增 synchronized 是内置锁，不需要手动释放 与synchronized不同，Lock需要手动获取锁，手动释放锁而且Lock可以被设置为公平锁 而且Lock可以设置获取锁的超时时间 Lock的实现类 ReentrantLockReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性;ReentrantLock提供公平锁、非公平锁 继承关系图 非公平锁ReentrantLock 默认为非公平锁NonfairSync1234567891011121314151617181920static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ // Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android. // @ReservedStackAccess final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 在NonfairSync 获取锁时，先判断执行CAS操作是否能够成功， 如果成功将1设置到state上，那么此时锁没有被线程占用， 则会调用到AbstractOwnableSynchronizer中的setExclusiveOwnerThread函数 123protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread;&#125; 也就是把当前线程设为此锁的拥有者 如果执行CAS操作失败，就会执行 acquire(1); 会调用AbstractQueuedSynchronizer中的acquire 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquire会执行两个判断： tryAcquire acquireQueued当两个判断都返回true时，则会调用selfInterrupt();自己中断自己 tryAcquire在NonfairSync中，tryAcquire(1)会调用nonfairTryAcquire，nonfairTryAcquire是Sync类中的函数1234567891011121314151617181920final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; // 此处会尝试重新执行CAS操作 如果成功，则回到上面的操作 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 判断当前线程是否已经获取锁 可重入锁 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 如上所示，tryAcquire其实就是再次判断state是否没有被占用 返回true，以及当前线程是否已经占有此锁 返回true，否则就返回false。 acquireQueuedacquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 此处arg = 1； 先查看addWaiter函数 addWaiter12345678910111213141516private Node addWaiter(Node mode) &#123; Node node = new Node(mode); for (;;) &#123; Node oldTail = tail; if (oldTail != null) &#123; U.putObject(node, Node.PREV, oldTail); if (compareAndSetTail(oldTail, node)) &#123; oldTail.next = node; return node; &#125; &#125; else &#123; initializeSyncQueue(); &#125; &#125;&#125; addWaiter 方法采用了自旋非阻塞的方式进行了入队操作 在看一下完整的acquireQueued函数12345678910111213141516171819202122final boolean acquireQueued(final Node node, int arg) &#123; try &#123; boolean interrupted = false; for (;;) &#123; //获取当前节点的前驱节点 final Node p = node.predecessor(); //当前节点为第二个节点时,尝试获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC return interrupted; &#125; //判断是否可以挂起 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; catch (Throwable t) &#123; cancelAcquire(node); throw t; &#125;&#125; 公平锁当构造ReentrantLock实例时传入true，则为公平锁 FairSync 123456789101112131415161718192021222324252627282930313233static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don&apos;t grant access unless * recursive call or no waiters or is first. */ // Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android. // @ReservedStackAccess protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; &#125; 而看公平锁FairSync中的tryAcquire函数，多了一个判断 !hasQueuedPredecessors() 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 总结公平锁的lock方法在进行cas判断时多了一个hasQueuedPredecessors()方法，它会在AQS队列中没有中没有线程的情况下才会申请锁，而不像非公平锁一样，非公平锁一来不管AQS里是否有排队的线程就直接申请锁]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized详解]]></title>
    <url>%2Fblog%2F2020%2F09%2FSynchronized%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[Synchronized详解Synchronized是内置锁，锁的是对象，Synchronized 有几个使用方式，但其实都是作用于对象。 1、作用于方法块 2、作用于obj 3、作用于this 4、作用于class 1234567891011121314151617181920212223public synchronized void lockFun() &#123; try &#123; Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName()); Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName() + &quot;结束&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;public void lockThis() &#123; synchronized (this) &#123; try &#123; Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName()); Thread.sleep(10); System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName() + &quot;结束&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面的示例代码中，lockFun是作用于方法块，lockThis是作用于this，但实际上这两个函数都是作用于当前的类的实例对象上的 123456789public void lockClass() &#123; synchronized (Test.class) &#123; &#125;&#125;public static synchronized void lockStatic() &#123; &#125; 而在lockClass与lockStatic中，lockStatic作用与static静态函数，lockClass作用与Test.class对象，但实际都是作用与Test的所有实例对象 12345public void lockObj(Object o) &#123; synchronized (o)&#123; &#125;&#125; lockObj就是直接作用于Object对象。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 设计模式]]></title>
    <url>%2Fblog%2F2020%2F09%2Fjava-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[java IO]]></title>
    <url>%2Fblog%2F2020%2F09%2Fjava-IO.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2Fblog%2F2020%2F09%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2Fblog%2F2020%2F09%2F%E6%B3%A8%E8%A7%A3.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据传输与序列化]]></title>
    <url>%2Fblog%2F2020%2F09%2F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    <content type="text"><![CDATA[序列化方式 Serializable java自带 Parcelable android中]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Callback Future]]></title>
    <url>%2Fblog%2F2020%2F09%2FCallback-Future.html</url>
    <content type="text"><![CDATA[Future Future代表一个异步计算的结果，并且它提供一些方法来让调用者检测异步过程是否完成，或者取得异步计算的结果，或者取消正在执行的异步任务。 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; private static ExecutorService executorService = Executors.newSingleThreadExecutor(); public static void main(String[]args)&#123; System.out.println(&quot;hello world&quot;); Future&lt;Integer&gt;future = calcute(9); while (!future.isDone())&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;正在执行&quot;); &#125; &#125; try &#123; int result = future.get(); System.out.println(&quot;result = &quot; + result); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static Future&lt;Integer&gt;calcute(Integer i) &#123; return executorService.submit(() -&gt; &#123; Thread.sleep(1000); System.out.println(&quot;return future for &quot; + i); return i *i; &#125;); &#125;&#125; 一个简单Future使用用例写完，使用线程池+Callback+Future，完成了一个简单的计算操作。 Future是一个接口，先看一下内部方法： 1234567891011public interface Future&lt;V&gt; &#123; boolean cancel(boolean var1); boolean isCancelled(); boolean isDone(); V get() throws ExecutionException, InterruptedException; V get(long var1, TimeUnit var3) throws ExecutionException, InterruptedException, TimeoutException;&#125; get()函数是返回计算结果，注意get会同步操作，每天返回结果前，会阻塞线程。get还有一个重载函数get(long var1, TimeUnit var3)，第一个参数是时长，第二个是单位。表示在多少时长内获取结果，如果仍未返回，则抛出异常TimeoutException。12345try&#123; int result2 = future2.get(1000, TimeUnit.MILLISECONDS);&#125; catch(TimeoutException e) &#123; e.printStackTrace();&#125; cancel(boolean) 表示是否取消该future， 不能在调用cancel(true)/cancel(false)后，调用get()函数，否则会抛出异常CancellationException isCancelled()函数是判断该future是否已取消 isDone()函数是判断该future是否已完成 isDone()函数是实时状态读取，不会阻塞线程。 CallbackCallback 是一个接口，内部只有一个函数 1234@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; Callback 可以理解为一个执行任务，如上面例子中的计算 FutureTask介绍Future是一个接口，RunnableFuture也是一个接口，继承Future、Runnable两个接口1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; 而FutureTask是对RunnableFuture的基本实现 FutureTask 有一个状态值12345678910111213141516/** 状态值存在如下几种变化：* Possible state transitions:* NEW -&gt; COMPLETING -&gt; NORMAL* NEW -&gt; COMPLETING -&gt; EXCEPTIONAL* NEW -&gt; CANCELLED* NEW -&gt; INTERRUPTING -&gt; INTERRUPTED*/private volatile int state;private static final int NEW = 0;private static final int COMPLETING = 1;private static final int NORMAL = 2;private static final int EXCEPTIONAL = 3;private static final int CANCELLED = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED = 6;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android AsyncTask]]></title>
    <url>%2Fblog%2F2020%2F09%2Fandroid-AsyncTask.html</url>
    <content type="text"><![CDATA[AsyncTask 顾名思义 即是异步任务。在内部实现了线程的切换，并会一直回调任务进度。适用于耗时任务、网络请求，并需要与主线程进行交互。 AsyncTask 内部有一个线程池，使用线程池执行任务，并通过Handler 来发送消息、回调状态，任务执行完毕使用Handler与主线程交互，使用Handler一直回调任务进度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class AsyncTask&lt;Params, Progress, Result&gt;// Params Progress Result 分别时三个范性，代指参数、任务执行进度、返回结果体// API 29 与 API 28略有不同private static final int CORE_POOL_SIZE = 1; // 核心线程数private static final int MAXIMUM_POOL_SIZE = 20; // 最大线程数private static final int BACKUP_POOL_SIZE = 5; // 备份线程数private static final int KEEP_ALIVE_SECONDS = 3; // 空闲线程空闲存活时间// 线程工厂private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; // 线程数原子类 保证原子操作 private final AtomicInteger mCount = new AtomicInteger(1); // 重写该方法是为了对线程加 别名 AsyncTask # public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); &#125;&#125;;// 当任务超出时的拒绝策略。private static final RejectedExecutionHandler sRunOnSerialPolicy = new RejectedExecutionHandler() &#123; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; android.util.Log.w(LOG_TAG, &quot;Exceeded ThreadPoolExecutor pool size&quot;); // As a last ditch fallback, run it on an executor with an unbounded queue. // Create this executor lazily, hopefully almost never. synchronized (this) &#123; if (sBackupExecutor == null) &#123; // 当任务添加到队列失败，并且最大线程数已满，此时会新建一个备份线程池去执行任务 sBackupExecutorQueue = new LinkedBlockingQueue&lt;Runnable&gt;(); sBackupExecutor = new ThreadPoolExecutor( BACKUP_POOL_SIZE, BACKUP_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sBackupExecutorQueue, sThreadFactory); sBackupExecutor.allowCoreThreadTimeOut(true); &#125; &#125; sBackupExecutor.execute(r); &#125;&#125;;public static final Executor THREAD_POOL_EXECUTOR;// 类加载时就会执行 初始化线程池 注意初入的队列参数为 new SynchronousQueue&lt;Runnable&gt;() 任务添加都会失败，都会开启新线程执行直到最大线程数满static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), sThreadFactory); threadPoolExecutor.setRejectedExecutionHandler(sRunOnSerialPolicy); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 直接查看 execute 执行任务函数 executeexecute函数存在重载 123456789@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic static void execute(Runnable runnable) &#123; sDefaultExecutor.execute(runnable);&#125; 当执行execute时，并传入Runnabe时，执行sDefaultExecutor.execute(runnable);sDefaultExecutor 是 Async 的一个内部类 SerialExecutor 的一个实例对象 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 如上代码所示，就是在数组队列mTasks队尾添加一个runnable，scheduleNext函数就是弹出队首任务并通过THREAD_POOL_EXECUTOR执行。 再看一下 execute(Params… params) 函数 execute(Params… params)1234567891011121314151617181920212223242526272829303132333435363738394041// 此处传入的 exec 也是 一个 SerialExecutor 对象。@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; // 当一个任务状态不是处于 等待执行 而又执行了这个函数时，会抛出异常。 if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; // 改变状态为正在执行 mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; // 此处传入的时一个FutureTask 对象 mFuture exec.execute(mFuture); return this;&#125;public enum Status &#123; /** * 任务等待执行 */ PENDING, /** * 任务正在执行 */ RUNNING, /** * 任务已经完成 */ FINISHED, &#125; FutureTask 实现 Runnable 接口，但是功能更加丰富，能获取任务执行的结果Result，能主动取消Runnableexec.execute(mFuture) 最后也会执行到 SerialExecutor 的 execute 函数，也会被添加到 队列队尾， InternalHandler123456789101112131415161718192021222324252627282930313233private static InternalHandler sHandler;private static Handler getMainHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(Looper.getMainLooper()); &#125; return sHandler; &#125;&#125;private Handler getHandler() &#123; return mHandler;&#125;private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 全局的mHandler是InternalHandler实例，而且传入的looper对象是 getMainLooper();所以finish，与 onProgressUpdate 一定会走到main线程 如果通过直接执行AsyncTask中的静态方法execute(Runnable runnable) 来执行runnable时，是不会触发回调， 并且是没有返回的。 因为只有在AsyncTask构造函数内，对mWorker、mFuture、mHandler都做了包装处理。 12345678910111213141516171819202122232425262728293031323334353637383940 public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 这是AsyncTask其中一个构造函数，而其他构造函数都会调用到此处，最后都会执行此处逻辑。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2Fblog%2F2020%2F09%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content type="text"><![CDATA[java 线程池线程池是用来管理以及调度线程的容器。 线程池的优势 复用线程，避免大量线程重复创建、销毁，降低消耗 提升效率，当线程池内未饱和时，无需等待线程的重新创建和初始化，便能立即执行 方便线程并发管理，避免线程无限制的创建，可能造成的 OOM、cpu 过高等问题，规定了最大并发数 延时定时执行任务 创建线程池创建线程池的几种方法： 1234567ExecutorService pool = Executors.newCachedThreadPool();ExecutorService pool1 = Executors.newFixedThreadPool(1);ExecutorService pool2 = Executors.newScheduledThreadPool(1);ExecutorService pool3 = Executors.newSingleThreadScheduledExecutor();ExecutorService pool4 = new ThreadPoolExecutor(0, 10, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); 最后都会执行到 ThreadPoolExecutor 的构造函数中 线程池参数1234567891011121314151617181920212223242526public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 即时是 ThreadPoolExecutor 的其他几个构造函数，最后也会调用到这个 7 参的构造函数 corePoolSize: 核心线程数量，当向线程池提交一个任务时，如果线程数小于核心线程数，不管是否有线程处于空闲状态，都会创建一个新的线程来执行该任务，直到线程池中的线程数大于等于核心线程数量 maximumPoolSize: 最大线程数，线程池中线程数量最大值，当向线程池提交任务，核心线程都已创建完毕，且核心线程都处于工作状态，此时会先将该任务提交到阻塞队列，如果阻塞队列已满， 并线程池中线程数量小于最大线程数时，此时会新创建一个线程执行该任务。如果阻塞队列已满，且线程数也达到最大值，此时会执行线程饱和策略。 keepAliveTime：非核心线程可空闲时长，非核心线程处于空闲时，且空闲时长超过 keepAliveTime，则该线程会被回收，但不会回收核心线程 unit： keepAliveTime 的时长单位 workQueue： 阻塞队列，用于保存和运输待执行任务的阻塞队列 threadFactory：线程工厂，用于创建工作线程，threadFactory 也是采用 new Thread()形式创建一个新线程，但命名线程名称，格式为：pool-m-thread-n（m 为线程池的编号，n 为线程池内的线程编号）。 defaultHandler： 线程饱和策略，当线程池和阻塞队列都满了，再添加任务时，会执行此策略 线程池第 5 个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。 LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的 integer.MAX_VALUE,此时添加任务会一直成功。最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。 SynchronousQueue: 无容量的队列使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。唯一制约就是配置的最大线程数，如果使用 Integer.MAX_VALUE 就实现了真正的无等待。 运行流程; execute 提交任务123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; ctl 是一个原子 Integer 对象，存储的是正在运行的线程数看英文注释也写的很清楚了，分三部，1、判断正在运行的线程是否小于核心线程数，是的话则 调用 addWorker(command, true)；并不再向下执行2、判断队列能否添加 command 以及 线程池是否还在运行，而且双重检测，成功将加任务加入到阻塞队列，再进行第二次判断，如果线程池没有再运行 &amp;&amp; 移除这个任务，执行拒绝或者工作线程数 == 0， 则直接 addWorker(null, false);3、尝试添加失败，执行 reject(command) addWorker查看添加任务的函数 12345678910111213141516171819202122232425retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; 外层 for 循环： 当线程池已经 SHUTDOWN 时，不能添加任务内层 for 循环：当前线程数大于总容量 ｜｜ 为添加核心线程时，&gt; 核心线程数 当为非核心线程时，&gt; 最大线程数，不能添加任务如果能添加时，终止外层 for 循环 compareAndIncrementWorkerCount 函数是将当前的正在运行的线程数 + 1； 12345678910111213141516171819202122232425262728293031323334353637boolean workerStarted = false;boolean workerAdded = false;Worker w = null;try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125;&#125; finally &#123; if (! workerStarted) addWorkerFailed(w);&#125; Worker 是 ThreadPoolExecutor 中的内部类，implements Runnable此处就是在构建一个 Worker，并启动线程执行。 流程总结当提交一个任务时， 1、查询核心线程是否已满，如果未满则新创建核心线程执行该任务 2、当核心线程已满，判断阻塞队列是否已满，如果阻塞队列未满则将该任务加入到阻塞队列中 3、当阻塞队列已满时，判断线程池是否已满，如果未满，则新创建线程执行该任务 4、当线程池已满时，则执行饱和策略， 线程池为何需要使用阻塞队列1、因为线程池是管理并调度线程、以完成任务，肯定不可能无限制的创建线程， 2、提高核心线程的使用效率 线程的阻塞、挂起、睡眠 线程是靠cpu来运行的，cpu要运行一个线程，（不说别的）最起码就是要占用cpu时间，像Windows这样的多任务操作系统，可以允许多个线程同时运行，所谓的同时运行并不是真正的同时运行，而是轮流运行不同的线程，因为cpu速度很快，如果线程不是很多，就会给用户有所有线程在同时运行的错觉。 cpu的调度都是内核来做的，表面上用户进程自己执行自己的，其实内核很忙的。他会不断的挂起某个线程，去执行另一个线程，回头再恢复那个线程 阻塞：阻塞就是内核突然让cpu去干别的事情了（比如获取资源失败等），用户要等待内核返回消息。 是一种被动行为 挂起：挂起其实是用户主动行为，一旦挂起，线程就不再需要cpu，内核也不需要再考虑它用不用cpu，直到用户恢复线程的状态。 睡眠：它表示用户线程放弃当前的cpu时间片，n秒后参与cpu使用。sleep(0)是有特殊含义的，它表示此时此刻我放弃cpu时间片，别人可以执行，然后马上参与cpu竞争。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 强、软、弱、虚四种引用类型]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[引用类型在jdk 1.2之前，一个对象只有 “已被引用” 和 “未被引用”两种概念，在jdk1.8之后，引用类型分为4类：强引用：Strong Reference软引用：Soft Reference弱饮用：Weak Reference虚引用：Phantom Reference这4中引用的强度依次减弱 强引用java中默认的引用类型，只要引用存在，永远不会回收，哪怕内存不足，系统会抛出OOM异常，也不会回收。 软引用只有当内存不足时，才会回收，回收后如果还是内存不足才会抛出OOM 123456789101112131415private static void testSoftReference() &#123; for (int i = 0; i &lt; 10; i++) &#123; byte[] buff = new byte[1024 * 1024]; SoftReference&lt;byte[]&gt; sr = new SoftReference&lt;&gt;(buff); list.add(sr); &#125; System.gc(); //主动通知垃圾回收 for(int i=0; i &lt; list.size(); i++)&#123; Object obj = ((SoftReference) list.get(i)).get(); System.out.println(obj); &#125; &#125; 弱引用// 无论内存是否足够，只要JVN开始回收，弱饮用都会被回收很多文章都说，只要执行GC就会回收软引用，这种结论是错误的。 当一个对象只被弱引用实例引用（持有）时，这个对象就会被GC回收 被回收的对象弱饮用实例引用的对象，而不是弱饮用本身 如果显式地声明了一个变量E e，并使之指向一个对象：e = new E()，这时变量e就是对对象的一个强引用。如果变量e所引用的这个对象同时又被WeakReference的一个实例持有，则由于存在对对象的一个强引用e，对象并不符合上述回收规则，因此对象至少在变量e的作用域范围内都不会被回收。 12345678910111213141516171819class TestWeakReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); &#125; private static void testWeakReference() &#123; byte[]buff = new byte[1024 * 1024]; for (int i = 0; i &lt; 10; i++) &#123; WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff); list.add(weakReference); &#125; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 在上述情况下，buff是一个强引用类型，在它的作用域时是不可回收的，即使除了弱饮用持有没有其他的引用。 将上述代码改一下，将buff与gc作用域修改 12345678910111213141516171819202122232425class TestSoftReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); private static List&lt;Object&gt; lists = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); gc(); &#125; static WeakReference&lt;byte[]&gt; softReference; private static void testWeakReference() &#123; byte[]buff = new byte[1024 * 1024]; for (int i = 0; i &lt; 10; i++) &#123; softReference = new WeakReference&lt;&gt;(buff); list.add(softReference); &#125; &#125; public static void gc() &#123; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 在上面这种情况下，gc执行的作用域与buff的作用域是同级的另一个作用域，且buff无其他引用，则可以回收 将上述代码再修改一下12345678910111213141516171819class TestWeakReference &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testWeakReference(); &#125; private static void testWeakReference() &#123; for (int i = 0; i &lt; 10; i++) &#123; byte[]buff = new byte[1024 * 1024]; WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff); list.add(weakReference); &#125; System.gc(); for (int i =0; i &lt; list.size(); i ++) &#123; Object o = ((WeakReference)list.get(i)).get(); System.out.println(o); &#125; &#125;&#125; 此时buff的作用域只在for循环内，此时是可以被回收的，因为输出的结果均为null 虚引用虚引用是最弱的引用类型，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。 引用队列（ReferenceQueue）引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。 与软引用、弱引用不同，虚引用必须和引用队列一起使用。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java ThreadLocal解析]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-ThreadLocal%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[ThreadLocalThreadLocal 是一个线程的内部存储类，对于被存储的对象，在不同的线程读取的变量是独立的。 实现原理是：对每一个线程都有一个 ThreadLocalMap，ThreadLocal 维护每个 ThreadLocalMap 中的值ThreadLocalMap 内部是一个[]Enter, 不同的 ThreadLocal 都是存储在线程的同一个 ThreadLocalMap 中的，只是下标位置不同，同一个 ThreadLocal 在不同线程的 ThreadLocalMap 中的下标值即索引值是相同的。 ThreadLocal 方法解析ThreadLocal 最常用的示例： 123ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;();threadLocal.set(&quot;1&quot;);String name = threadLocal.get(); 在主线程初始化 ThreadLocal 实例，在各个线程调用 set、get，设置、获取存储在各个线程中的值 查看源码 set12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 当调用 set 函数时，会去获取当前线程的 ThreadLocalMap 对象，该对象是在 Thread.java 中申明，默认值为 null。当 map 为 null 时，则调用 createMap,为 threadLocals 对象赋值，不为 null，在调用 ThreadLocalMap 中的 set 函数，将值保存到数组中 get12345678910111213141516171819202122232425 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 当调用 get 方法时，获取当前线程的 ThreadLocalMap 对象，如果 map 不为 null，则获取 map 持有的 Entry 对象，再返回该 Entry 对象持有的 value 值。如果 map 为 null 或者获取的 Enter 对象为 null，则会调用 setInitialValue，而 initialValue 的返回值是 null。当 map 为 null 时，会调用 createMap 方法，实例化 ThreadLocalMap 上面的 set、get 都会调用 getMap 方法，来获取当前线程的 ThreadLocalMap 实例 getMap123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; threadLocals 是在 Thread.java 中声明的，默认值为 null，也就是说每个线程中都有这个对象，只是默认是 null。 createMap在 set、get 中都会对当前线程的 ThreadLocalMap 对象判断，当为 null 时，会调用 createMap 对 ThreadLocalMap 对象 threadLocals 赋值， 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; ThreadLocalMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static class ThreadLocalMap &#123; // 必须为2的次方 private static final int INITIAL_CAPACITY = 16; // 最终存储数据的数组 private Entry[] table; // table 有值的长度 private int size = 0; // resize后的大小 private int threshold; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; ......&#125; getEntry 函数就是获取 key 对应的节点 Entry在 getEntry、set 函数中可以看到 value 存储在[]Entry 中的下标位置是由 key.threadLocalHashCode &amp; (len-1)计算得出的。就是 ThreadLocal 中的 threadLocalHashCode 对[]Entry 长度取模getEntry，通过下标获取 e，如果不为 null 而且再次校验 key 相等，则返回 eset 时，e 不为 null，而且 key 相等，代表已存在，则替换 e.value，key 不相等，代表不存在，而添加 1234567891011121314151617181920212223242526272829303132333435 private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize(); &#125;private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; 当 Entry[] 中存入的值数量已达到数组长度的 3/4；则会调用 resize 函数，调整 Entry[]的长度，将新数组长度*2，遍历老数组，重新获取下标 h，判断 h 处是否有值，无值填充，有值则重新获取 h，再填充 EntryThreadLocalMap 的内部类 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; value 是调用 ThreadLocal 保存的值， ThreadLocal 内存泄漏首先要知道 ThreadLocal 的结构： Thread 持有 ThreadLocalMapThreadLocalMap 持有 Entry 数组Entry 持有 ThreadLocal 和 value Enry 是弱引用，但是 value data 是强引用，而这就是内存泄漏的点 Entry 虽然是继承自弱引用，但是存储的 value 是强引用，所以在 ThreadLocal 仍然存在内存泄漏可能，即使在 set 时会调用 replaceStaleEntry 来清理数据 最好是在确定线程中不再使用 ThreadLocal 中线程副本时，调用 remove 函数，清除线程副本 ThreadLocal 线程不安全12345678910111213141516171819202122232425262728293031323334353637383940class TestThreadLocal &#123; private static Person person = new Person(20); private static ThreadLocal&lt;Person&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; person.setAge(person.age + 1); threadLocal.set(person); System.out.println("age = " + threadLocal.get().getAge()); for (int i = 0; i &lt; 5; i ++) &#123; new MyThread().start(); &#125; &#125; static class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); person.setAge(person.age + 1); threadLocal.set(person);// try &#123;// sleep(1);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println("age = " + threadLocal.get().getAge()); &#125; &#125; static class Person &#123; int age; public Person(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125;&#125; 打印结果如下：age = 21age = 22age = 23age = 24age = 25age = 26 如果将注释的 sleep 代码放开，打印结果：age = 21age = 26age = 26age = 26age = 26age = 26 我们在主线程与 5 个子线程中改变了 person 的 age 值，使加 1，并打印了 person 的 age 值ThreadLocal 在每个线程存有一个线程副本，按照理解打印结果应该都是 21 才对，因为每个线程副本取 age 应该都是 20，加 1 就是 21但从我们执行的情况来看，线程与线程之间的变量值在相互干扰。导致 age 值在不同线程之间也在累加。 这是因为我们在 ThreadLocal 中存有的 person 对象是静态对象的引用，而静态对象全局唯一，导致在不同线程之间的引用，指向了同一个对象。 汇总ThreadLocalMap 為 ThreadLocal 的一個静态内部类，在 Thread 中有一个变量 ThreadLocalMap threadLocals;ThreadLocalMap 中又有一個静态内部类：Enter，Enter 是继承至弱引用：WeakReference，Enter 是一个 key、value 结构，key 为 ThreadLocal 对象，value 为 Object 强引用对象，而这就是内存泄露点。 ThreadLocalMap 中有一个 Enter 数组 table，用于存放我们放进区的数据每次存放數據時，根據使用的 threadLocal 的 hash 值對 table 的長度取余，即为该要存放的数据要在 table 中的下标，如果该处下标的 value 不为 null，则下标向后移一位，如果到最后一位了，则移到 0 处。存放数据时。现根据传入的 key 获取 hash，再取余获取对应 index，从下标处还是后移遍历 enter， 取到 key 为 enter 的 k 相等，则说明为替换。修改 enter 的 value 即可，并结束操作 enter 的 k 为 null，代表此处的 key 已被回收遍历完后，说明是添加，直接插入到该下标处一个新 Enter 对象 当存放的数据条数大于等于总长度 3/4 时，触发扩容 resize每次 resize 的长度时上一次的两倍。resize 时会遍历旧数组，如果 Enter 不为 null 但 key 为 null，代表弱引用被回收，此时直接将 value 置为 null，便于 GC。使用 key 的 hash 对新数组长度取余，hash 碰撞则后移，与上面的一致。 threadLocal 获取数据 get 时，会调用 threadLocalMap 的 getEntry 函数，先计算下标，获取到的 e 不为 null，而且 key 相同，则返回 e否则调用 getEntryAfterMiss ，getEntryAfterMiss 会尝试再次获取 e，包括会尝试后移下标来匹配 key 是否相等。如果下标 key 为 null，会将该处 value 置为 null，便于 gc ThreadLocal 调用 remove 函数时，会调用到 ThreadLocalMap 的 remove 函数，会遍历 table，先回收弱引用 key，在调用 expungeStaleEntry 将 value 置空]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java volatile 关键字]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-volatile%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[参考： https://www.jianshu.com/p/157279e6efdb https://www.jianshu.com/p/e79bdd15a08b valotile 可见性 任意一个线程修改了 volatile 修饰的变量，其他线程可以马上识别到最新值。实现可见性的原理如下。 步骤 1：修改本地内存，强制刷回主内存 步骤 2：强制让其他线程的工作内存失效过期。 步骤 3：其他线程重新从主内存加载最新值。 1、修改 volatile 变量时会强制将修改后的值刷新的主内存中。 2、修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 1234567891011121314151617181920212223242526272829class TestThread &#123; public static void main(String[] args)&#123; Work work = new Work(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::shutdown).start(); new Thread(work::work).start(); new Thread(work::work).start(); new Thread(work::work).start(); &#125; static class Work&#123; volatile boolean isShutdown = false; void shutdown() &#123; System.out.println(&quot;shutdown -----&quot;); isShutdown = true; System.out.println(&quot;shutdown ---- down&quot;); &#125; void work() &#123; while (!isShutdown) &#123; System.out.println(&quot;work ----&quot;); &#125; &#125; &#125;&#125; 上面的代码运行后输出的结果如下：work —-work —-work —-work —-work —-work —-work —-work —-work —-work —-work —-shutdown —–work —-shutdown —- downwork —-work —- 说明一个问题：volatile 的可见性，volatile变量时会强制将修改后的值刷新的主内存修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。将主内存的值刷新，其他线程去读取主内存的值是需要一定时间的， 底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存（缓存行锁定）并回写到主内存。其中lock前缀指令在多核处理器下会引发两件事情： 会将当前处理器缓存行的数据立即回写到系统内存。这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效（通过MESI缓存一致性协议）。 单个读/写具有原子性 单个 volatile 变量的读/写（比如 vl=l）具有原子性，复合操作（比如 i++）不具有原子性 互斥性 同一时刻只允许一个线程操作 volatile 变量，volatile 修饰的变量在不加锁的场景下也能实现有锁的效果，类似于互斥锁。 部分有序性 为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序 JVM 是使用内存屏障来禁止指令重排，从而达到部分有序性效果 针对 volatile 变量 在每个volatile写操作的前面插入一个StoreStore屏障； 在每个volatile写操作的后面插入一个StoreLoad屏障； 在每个volatile读操作的后面插入一个LoadLoad屏障； 在每个volatile读操作的后面插入一个LoadStore屏障。 StoreStore屏障：禁止上面的普通写和下面的volatile写重排序； StoreLoad屏障：防止上面的volatile写与下面可能有的volatile读/写重排序 LoadLoad屏障：禁止下面所有的普通读操作和上面的volatile读重排序 LoadStore屏障：禁止下面所有的普通写操作和上面的volatile读重排序]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java wait方法]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-wait%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[wait()、notify()、notifyAll()wait()、notify()、notifyAll()这三个函数都是Object类中的方法，而Object类是所有类的父类，所以所有对象实例都有该方法. wait():阻塞当前之前直到该对象(调用wait函数的对象)在另一个线程调用了notify()或者notifyAll();notify():唤醒单个线程notifyAll():唤醒所有线程 这三个方法，都是Java语言提供的实现线程间阻塞(Blocking)和控制进程内调度(inter-process communication)的底层机制。在解释如何使用前，先说明一下两点： 正如Java内任何对象都能成为锁(Lock)一样，任何对象也都能成为条件队列(Condition queue)。而这个对象里的wait(), notify()和notifyAll()则是这个条件队列的固有(intrinsic)的方法。 一个对象的固有锁和它的固有条件队列是相关的，为了调用对象X内条件队列的方法，你必须获得对象X的锁。这是因为等待状态条件的机制和保证状态连续性的机制是紧密的结合在一起的。 12345678910111213141516171819202122class TestWait &#123; public static void main(String[]args) &#123; TestWaitBean bean = new TestWaitBean(&quot;bean&quot;); System.out.println(&quot;init bean&quot;); System.out.println(&quot;invoke bean wait&quot;); try &#123; bean.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;wait finished&quot;); &#125; &#125; static class TestWaitBean &#123; String name; public TestWaitBean(String name) &#123; this.name = name; &#125; &#125;&#125; 上述代码运行后会抛出异常java.lang.IllegalMonitorStateException因为未获取对象bean的锁，就去调用bean.wait() 修改一下代码，实现一个简单的阻塞、唤醒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TestWait &#123; public static void main(String[]args) &#123; TestWaitBean bean = new TestWaitBean(&quot;bean&quot;); System.out.println(&quot;init bean&quot;); System.out.println(&quot;invoke bean wait&quot;); WeakUpThread thread = new WeakUpThread(bean); thread.start(); synchronized (bean) &#123; try &#123; bean.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;wait finished&quot;); &#125; &#125; &#125; static class TestWaitBean &#123; String name; public TestWaitBean(String name) &#123; this.name = name; &#125; &#125; static class WeakUpThread extends Thread &#123; Object lock; public WeakUpThread(Object lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; super.run(); synchronized (lock) &#123; try &#123; System.out.println(&quot;Current Thread is sleep 2000ms&quot; ); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot; weakUp!!!&quot;); lock.notify(); &#125; &#125; &#125; &#125;&#125; 注意： 不管是调用wait，还是notify、notifyAll，都要是在同步修饰的代码块或者方法中，即必须先获取对象锁，在调用对象方法 使用wait、notifyAll实现一个多线程的生产者、消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class BlockTest &#123; public static void main(String []args) &#123; List&lt;Object&gt;list = new ArrayList&lt;&gt;(); Block block = new Block(list); list.add(null); Thread thread1 = new Thread(new PutThread(block, new Person(&quot;person1&quot;)), &quot;thread1&quot;); Thread thread2 = new Thread(new PutThread(block, new Person(&quot;person2&quot;)), &quot;thread2&quot;); Thread thread3 = new Thread(new PutThread(block, new Person(&quot;person3&quot;)), &quot;thread3&quot;); Thread thread4 = new Thread(new PutThread(block, new Person(&quot;person4&quot;)), &quot;thread4&quot;); Thread thread5 = new Thread(new OutThread(block), &quot;thread5&quot;); Thread thread6 = new Thread(new OutThread(block), &quot;thread6&quot;); Thread thread7 = new Thread(new OutThread(block), &quot;thread7&quot;); thread1.start(); thread2.start(); thread5.start(); thread6.start(); thread7.start(); thread3.start(); thread4.start(); &#125; static class PutThread implements Runnable &#123; Block block; Person person; public PutThread(Block block, Person person) &#123; this.block = block; this.person = person; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; puting the person name is &quot; + person.getName()); block.put(person); &#125; &#125; static class OutThread implements Runnable &#123; Block block; public OutThread(Block block) &#123; this.block = block; &#125; @Override public void run() &#123; Person person = (Person) block.get(); if(person != null) &#123; System.out.println(Thread.currentThread().getName() + &quot; get the person name is &quot; + person.getName()); &#125; else &#123; System.out.println(Thread.currentThread().getName() + &quot; the person is null&quot;); &#125; &#125; &#125; static class Block&lt;T&gt; &#123; List&lt;T&gt;t; Object lock = new Object(); int currentIndex = 0; volatile boolean isRead = false; public Block(List&lt;T&gt;t)&#123; this.t= t; &#125; public void put(T at) &#123; if(t == null) throw new NullPointerException(&quot;t is null&quot;); synchronized (lock) &#123; try &#123; if(isRead) &#123; lock.wait(); &#125; currentIndex++; t.add(at); lock.notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public T get() &#123; synchronized (lock)&#123; T at = null; try &#123; if(currentIndex == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 当前下标已为0 阻塞 等待写入再取&quot;); lock.wait(); &#125; if(isRead)&#123; System.out.println(Thread.currentThread().getName() + &quot; 当前正在读 阻塞 等待写入再取 index&quot; + currentIndex); lock.wait(); &#125; isRead = true; at = t.remove(currentIndex); if(at == null) &#123; System.out.println(Thread.currentThread().getName() + &quot; index&quot; + currentIndex); return null; &#125; currentIndex --; return at; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.notifyAll(); isRead = false; return at; &#125; &#125; &#125; &#125; static class Person&#123; private String name = &quot;&quot;; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 上述生产者、消费者只能适用于多个线程直接的put、get 因为wait、和notify/notifyAll本身就是互斥的，因为调用wait后，就会阻塞当前调用线程，本身线程的notify/notifyAll也就不会被调用，所以说上述代码只能实现多个线程直接的场景，还有就是上述代码只是简单的实现，而且是读操作加锁，一般而言应该是写操作时堵塞。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java join方法]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-join%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续如在main线程调用t.join(),则会阻塞main线程直到t线程执行完。 而join()函数参数，当调用为t.join(2000),代表阻塞2000毫秒, 当2000毫秒完后，main线程会向下执行，但也有例外，join(millis)如在t线程使用 synchronized时，则必须等到synchronized包裹的代码块执行完并传递的millis毫秒后，t.join()的调用线程才会向下执行。 12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; super.run();// synchronized (currentThread()) &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;休眠&quot; + i); &#125; System.out.println(&quot;线程结束&quot;);// &#125; &#125; &#125;; long start = System.currentTimeMillis(); thread.start(); try &#123; thread.join(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;main线程结束&quot;); System.out.println(System.currentTimeMillis() - start); &#125;&#125; 输出结果： main线程结束1005休眠0休眠1休眠2休眠3休眠4线程结束 将thread.join(1000) 改为2000 时，输出结果如下：休眠0main线程结束2005休眠1休眠2休眠3休眠4线程结束 将上面代码synchronized 注释放开后再运行，输出结果如下：休眠0休眠1休眠2休眠3休眠4线程结束main线程结束5011 查看join方法源码12345678910111213141516171819202122232425262728293031/** * Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever. 当为0时，会一直阻塞调用join函数的线程，直到调用join函数的对象线程执行完毕 */public final synchronized void join(long millis) throws InterruptedException &#123; // 获取当时系统时间 long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; // 当传过来的入参时间小于0，抛出异常 throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (millis == 0) &#123; // 当等于0时，只要线程未执行完毕，则一直阻塞 while (isAlive()) &#123; // 当前线程未执行完一直阻塞 wait(0); &#125; &#125; else &#123; // 当时间大于0 while (isAlive()) &#123; // 当前线程还未执行完，则一直循环获取时间，阻塞调用线程到时间结束 long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 注意：wait()是运行在调用线程的，如在main线程中调用t.join();则join()函数的调用线程是main线程，wait()也是运行在main线程的，所以阻塞main线程，而t才是join()的调用对象线程，isAlive也是判断的t线程是否执行完毕，只有在t线程执行完毕，isAlive才为false]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 指纹验证]]></title>
    <url>%2Fblog%2F2020%2F08%2Fandroid-%E6%8C%87%E7%BA%B9%E9%AA%8C%E8%AF%81.html</url>
    <content type="text"><![CDATA[android 指纹识别android API 23时新增的功能，指纹识别 主要类：FingerpringManager 在API28后，FingerpringManager被遗弃，使用BiometricPrompt，此时授权识别的弹窗不能自定义，只能使用官方统一弹窗，只能设置各个授权文案。各个开发商内部实现可能不一致。 通过只是使用指纹识别，直接使用官方api即可，但出于安全或业务场景需求，很多都需要去检测生物库信息是否变更，如指纹库在重新指纹识别前是否发生变更，这个官方api就没有提供方法，需要我们自己实现。 检测指纹库是否发生变更参考：通过检测密钥查看是否变更(https://www.jianshu.com/p/dbb1a43cfb21) 在API28以前，指纹库信息时可以通过反射获取，获取的信息有指纹id、groupId、指纹名称、指纹个数、设备id等等， 12345678910111213141516if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; Log.d(TAG, &quot;getFingerPrintInfo: &quot;); FingerprintManager fingerprintManager = (FingerprintManager) getCurrentActivity().getSystemService(Context.FINGERPRINT_SERVICE); try&#123; Class clz = Class.forName(&quot;android.hardware.fingerprint.FingerprintManager&quot;); Method method = clz.getDeclaredMethod(&quot;getEnrolledFingerprints&quot;, new Class[]&#123;&#125;); method.setAccessible(true); Object obj = method.invoke(fingerprintManager, null); if (obj != null) &#123; Log.e(TAG, &quot;objStr:&quot; + JsonUtils.toJson(obj)); List&lt;FingerprintBean&gt; list = (List&lt;FingerprintBean&gt;) JsonUtils.fromJson(objStr, new TypeToken&lt;List&lt;FingerprintBean&gt;&gt;()&#123;&#125;.getType()); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 而FingerprintBean是这样的：123456789public class FingerprintBean implements Serializable &#123; private static final long serialVersionUID = 1L; private long mDeviceId; private long mFingerId; private long mGroupId; private String mName;&#125; 最理想的方式是我们反射获取到这些指纹库信息，然后将这些信息保存到本地，每次调用指纹识别时，获取当前指纹库信息与之前的指纹库信息比较，只有不同即可判定指纹库信息变更，但在实际操作中，发现在手机上获取到的指纹id只是简单的1、2、3即指纹库里的排列顺序，而指纹名称是可以随意更改，groupId、deviceId都为0，如果使用这些信息去校验，错误率太高。 还有一种方式即是上面参考链接中的，检测指纹库密钥信息是否变更 但在上面链接那种方法中，有几个问题：1、增加、删除指纹无法检测2、使用修改指纹的手指识别后才能检测出修改 于是将反射、密钥检测两者结合，先反射获取指纹库信息，只是比较指纹库指纹个数，先判断指纹个数是否发生变更，就可知道指纹库信息变更了如果指纹个数没有变更，再来校验密钥是否发生变化]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin (二)]]></title>
    <url>%2Fblog%2F2020%2F07%2Fkotlin-%E4%BA%8C.html</url>
    <content type="text"><![CDATA[可以查看代码示例(https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/Flow) flow 数据流Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库。 Flow只能运行在协程之中 Flow基本使用Flow 能够返回多个异步计算的值，例如下面的 flow builder : 1234567891011121314fun flow1() = runBlocking &#123; val time = measureTimeMillis &#123; flow &#123; for (i in 1..5) &#123; delay(100) emit(i) &#125; &#125;.collect&#123; delay(100) println("flow collect =&gt; $it") &#125; &#125; println("time =&gt; $time")&#125; 注意：flow、collect是同步允许，总共会阻塞1000ms 冷流冷流： 只有当订阅者发起订阅时，事件的发送者才会开始发送事件。 同步非阻塞 热流热流：不管订阅者是否存在，flow本身可以调用emit(或者tryEmit)发送事件，可以有多个观察者，也可在需要的时候发送事件。异步非阻塞 常用的热流有： ChannelFlow StateFlow SharedFlow ChannelFlow1234567891011121314fun channelFlow1() = runBlocking &#123; val time = measureTimeMillis &#123; channelFlow &#123; for (i in 1..5) &#123; delay(100) send(i) &#125; &#125;.collect &#123; delay(100) println("channelFlow collect =&gt; $it") &#125; &#125; println("time =&gt; $time") &#125; channelFlow 与 collect是异步的，当send只会，collect不会阻塞后续的send，所以总共会阻塞600ms StateFlow StateFlow 是一个状态容器式可观察数据流，可以向其收集器发出当前状态更新和新状态更新。 一般用于MVI开发模式中，使用场景、方式都与 LiveData 类似， 查看示例：https://github.com/wangchongwei/JetpackLearn/tree/master/app/src/main/java/com/justin/jetpacklearn/mvi 用法如下所示1234567891011121314151617181920class LoginViewModel @Inject constructor(private var repository: LoginRepository): BaseViewModel() &#123; val userIntent = Channel&lt;LoginIntent&gt;(Channel.UNLIMITED) private val _state = MutableStateFlow&lt;LoginState&gt;(LoginState.Idle) val state: StateFlow&lt;LoginState&gt; get() = _state&#125;class MVIActivity : AppCompatActivity() &#123; lifecycleScope.launch &#123; // 当state状态变更时 viewModel.state.collect &#123; when(it) &#123; ..... &#125; &#125; &#125;&#125; StateFlow 与 LiveData 区别有两点区别 StateFlow 必须有初始值，LiveData 不需要。 当 View 变为 STOPPED 状态时，LiveData.observe() 会自动取消注册使用方，而从 StateFlow 或任何其他数据流收集数据则不会取消注册使用方。 对于 StateFlow 在界面销毁的时仍处于活跃状态，有两种解决方法： 使用 ktx 将 Flow 转换为 LiveData。 在界面销毁的时候，手动取消（这很容易被遗忘）。 使用 lifecycleScope.launchWhenStarted 开启协程 1234567891011121314private var uiStateJob: Job? = nullprivate fun observeViewModelState() &#123; uiStateJob = lifecycleScope.launch &#123; viewModel.state.collect &#123; .... &#125; &#125;&#125;override fun onStop() &#123; uiStateJob?.cancel() super.onStop()&#125; 在stop生命周期中，手动取消，但感觉此中方式麻烦且不优雅，不如直接将 StateFlow 换为 LiveData ，或者使用 lifecycleScope.launchWhenStarted 开启协程避免这个问题 SharedFlow 和 StateFlow 一样，SharedFlow 也是热流，它可以将已发送过的数据发送给新的订阅者，并且具有高的配置性。 SharedFlow 使用场景 发生订阅时，需要将过去已经更新的n个值，同步给新的订阅者。 配置缓存策略。]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 动画]]></title>
    <url>%2Fblog%2F2020%2F07%2Fandroid-%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画alpha在res/anim下新建文件alpha_anime.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; android:duration=&quot;1000&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt; 在Activity中123Animation animation = AnimationUtils.loadAnimation(this.getApplicationContext(), R.anim.alpha_anime);ImageView alphaImage = findViewById(R.id.alphaImageView);alphaImage.startAnimation(animation); 这样就能实现图片渐隐的无限循环效果 scale在res/anim下新建文件scale.xml1234567891011&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt; translate123456789&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromYDelta=&quot;100%p&quot; android:toYDelta=&quot;0%p&quot; android:duration=&quot;1000&quot; android:fromXDelta=&quot;100%&quot; android:toXDelta=&quot;0%&quot; /&gt; rotate1234567891011&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;rotate android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;359&quot; android:duration = &quot;1000&quot; android:drawable = &quot;@mipmap/image1&quot; android:visible = &quot;true&quot;&gt; &lt;/rotate&gt;&lt;/rotate&gt; 属性动画]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android MVP]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-MVP.html</url>
    <content type="text"><![CDATA[MVPandroid MVP是一种开发架构，由MVC演化而来，因为在MVC中，Activity层，糅合逻辑、ui操作，显得臃肿、混乱。 在MVP中， M：model，数据层 V：View，页面操作 P：Present，M、V的桥接，逻辑操作 MVP的优势 1、代码简洁，逻辑清晰 2、解耦，便于维护 因为MVP将逻辑与视图分离，降低了业务耦合，使得整个代码层次分明，所以也就更好维护 下面以登陆做一个示例]]></content>
      <tags>
        <tag>andorid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android MVVM]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-MVVM.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 高级ui]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E9%AB%98%E7%BA%A7ui.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[android 图片加载]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 网络请求框架]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 序列化]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    <content type="text"><![CDATA[android 序列化什么是序列化将 java 对象转化为二进制过程，就是序列化，将二进制转化为 java 对象的过程，就是反序列化 为什么要序列化在下面几种场景下我们需要序列化 永久性保存对象，保存对象的字节序列到本地文件中； 对象在网络中传递； 对象在 IPC 间传递（进程通信） 如何序列化序列化有两种方法，java 中自带的实现 Serializable，android 中特有的 Parcelable SerializableSerializable 接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。新建类实现 Serializable，Serializable 为空接口，没有要实现的方法， 需要 定义一个静态常量 serialVersionUID 1234567891011121314public class SerBean implements Serializable &#123; private static final long serialVersionUID = 263894729013938L; private String name; private int age; public SerBean(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 这样这个类的序列化就完成了。 Serializable 序列化过程其实是将数据写入到文件，而反序列化则是将读取文件中的数据，重新生成对象。 Serializable 原理 序列化：将对象写入到 IO 流中，并保存信息到文件中 反序列化：从文件中读取信息， 然后构建 IO 流中恢复对象。 反序列化过程并没有调用构造函数，而是 JVM 生成 Parcelable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ParBean implements Parcelable &#123; private String name; private int age; // 系统自动添加，给createFromParcel里面用 protected ParBean(Parcel in) &#123; name = in.readString(); age = in.readInt(); &#125; public static final Creator&lt;ParBean&gt; CREATOR = new Creator&lt;ParBean&gt;() &#123; /** * * @param in * @return *createFromParcel()方法中我们要去读取刚才写出的name和age字段， * 并创建一个Person对象进行返回，其中color和size都是调用Parcel的readXxx()方法读取到的， * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。 * 读取的工作我们利用一个构造函数帮我们完成了 * */ @Override public ParBean createFromParcel(Parcel in) &#123; return new ParBean(in); &#125; //供反序列化本类数组时调用的 @Override public ParBean[] newArray(int size) &#123; return new ParBean[size]; &#125; &#125;; // 内容接口描述，默认返回0即可。 @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); // 写出name dest.writeInt(age); // 写出age &#125; // --------下面为自己写的构造函数和get set public ParBean() &#123; &#125; public ParBean(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Parcelable 序列号是在内存空间进行的。 Parcelable 原理Parcelable 是序列话过程是通过 native 函数进行的，属性是通过指针偏移来保存信息，所以反序列化过程读取属性的顺序必须要与写入属性的过程一样，否则会反序列化失败。简单理解就是将 java 中对象的各个属性都保存到 native 空间，然后将各个地址指针存放到 java 引用中，当反序列化时，调用 writeToParcel 写入保存到 native 空间中的属性，然后调用 createFromParcel 生成实例对象，然后就完成了整个反序列化过程。 writeToParcel 中的 write 顺序要与 protected 构造函数中的 read 顺序保持一致，否则会在反序列化时出错。 序列化方案区别上面讲了两个序列化方案，Serializable：是 java 就有的，代码量少，但在序列化时，会产生大量的临时对象，容易造成频繁的 minor GC Parcelable：android 特有的，代码量比 Serializable 要多，但使用效率高，且没那么占内存 因为在选择序列化时，优先使用 Parcelable，但有一种情况特殊，当数据保存在磁盘上时，Parcelable 在外界有变化的情况下，不能很好的保证数据的连续性，因此在此种场景下推荐使用 Serializable； 选择序列化方法的原则 1）在使用内存的时候，Parcelable 比 Serializable 性能高，所以推荐使用 Parcelable。 2）Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。 3）Parcelable 不能使用在要将数据存储在磁盘上的情况，因为 Parcelable 不能很好的保证数据的持续性在外界有变化的情况下。尽管 Serializable 效率低点，但此时还是建议使用 Serializable 。 序列化某种程度来说并不安全 因为序列化的对象数据转换为二进制，并且完全可逆。但是在 RMI 调用时所有 private 字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的 解决方案1、 序列化 Hook 化（移位和复位）2、 序列数据加密和签名3、 利用 transient 的特性解决4、 打包和解包代理 补充 static 和 transient 字段不能被序列化（感兴趣的同学可以深入研究下） 因为 static 修饰的变量不属于对象，而是属于类 PS：如果一个可序列化的类的成员不是基本类型，也不是 String 类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin]]></title>
    <url>%2Fblog%2F2020%2F05%2Fkotlin.html</url>
    <content type="text"><![CDATA[kotlin学习hello world新建一个kt文件， 1234fun main(args:Array&lt;String&gt;) &#123; println(&quot;Hello world!&quot;);&#125; 程序主入口main方法， 无需新建类即可运行，函数声明用fun 123fun sum(a:Int, b:Int):Int&#123; return a + b;&#125; 返回值写在参数之后 表达式可以作为函数体，返回值类型自动推断1fun sun(a:Int, b:Int) = a+b; 返回无意义的值用Unit表示 fun test():Unit { println(“test”);} 变量赋值变量赋值声明关键字：var、valvar：声明变量val：声明常量 var i:Int = 1;val PI:Double = 3.14; 当声明并赋值时，数据类型可以省略, 会自动推断数据类型var i = 1;val PI = 3.14 当声明但不赋值时，不能省略数据类型var i:Int;val PI:Double; 字符串模板123var s = &quot;aaaaa&quot;;var b = &quot;str = $s&quot;;var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot; 条件表达式1234fun testIf(a:Int, b:Int):Int &#123; if(a &gt; b) return a; return b;&#125; 在kotlin中，if还可以用作表达式 1fun max(a:Int, b:Int) = if(a &gt; b) a else b 空值与null检测当某个值可以为空时，需要在类型后添加?表示可以为空此时，声明时不能省略类型12345var obj:Objects ? = null;// 表示返回值可以为nullfun parseInt(str:String):Int?&#123; ...&#125; 类型检测与自动类型转换is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换 123456789fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125; 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 for循环12345678910var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);// 根据元素遍历for (item in items) &#123; println(item);&#125;// 根据下标便利for (item in items.indices) &#123; println(items[item]);&#125; while 循环12345var index = 0;while (index &lt; items.size) &#123; println(items[index]); index ++;&#125; when表达式123456789101112private fun testWhen(s: Any?) &#123; when(s) &#123; &quot;a&quot; -&gt; 1; &quot;b&quot; -&gt; 2; is String -&gt; 3; 1 -&gt; &quot;n&quot;; 2 -&gt; &#123; println(&quot;222&quot;); &#125;; else -&gt; &quot;else&quot;; &#125; &#125; 有点类似java中的 switch 区间 range12345var x = 6;var y = 9;if(x in 0..y) &#123; println(&quot;x in 0 - y&quot;);&#125; 注意：区间只用于数字 集合集合的迭代可以用的上面的 for in 循环1234var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);for(item in items) &#123; println(item);&#125; 判断集合中是否包含某元素 用while in || when12345678while (&quot;a&quot; in items) &#123; println(&quot;items include a&quot;);&#125;when &#123; &quot;a&quot; in items -&gt; println(&quot;aaa&quot;); &quot;d&quot; in items -&gt; println(&quot;ddd);&#125; 用lambda来过滤和映射集合 ，与java8 lambda stream大致 1234items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125; .sortBy&#123; it &#125; .map&#123; it.toUpperCase() &#125; .forEach&#123; println(it) &#125; 协程什么是协程？官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。 协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。CPU调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。 协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。 build.gralde中引入依赖implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1” runBlocking123456789101112131415class MainActivity4 : AppCompatActivity() &#123; val TAG = &quot;MainActivity4&quot; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main2) test() Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;) &#125; fun test() = runBlocking &#123; repeat(8) &#123; Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;) delay(1000) &#125; &#125;&#125; 打印结果如下：协程执行0 线程id：1协程执行1 线程id：1协程执行2 线程id：1协程执行3 线程id：1协程执行4 线程id：1协程执行5 线程id：1协程执行6 线程id：1协程执行7 线程id：1线程main ：1 我们可以得出结论：runBlocking会阻塞线程，但允许还是在当前线程 launch:Job12345678fun testJob() &#123; val job = GlobalScope.launch &#123; repeat(8) &#123; delay(2000) Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, ) &#125; &#125; &#125; 打印结果如下：testJob: 线程main：2testJob: 线程id:6809testJob: 线程id:6807testJob: 线程id:6807testJob: 线程id:6815testJob: 线程id:6807testJob: 线程id:6808testJob: 线程id:6818testJob: 线程id:6809 说明使用GlobalScope.launch 并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务 是非阻塞、异步执行，相当于开启了子线程 async123456789101112131415161718192021222324fun testAsync()&#123; GlobalScope.launch &#123; var result1 = GlobalScope.async &#123; getResult1() &#125; var result2 = GlobalScope.async &#123; getResult2() &#125; val result = result1.await() + result2.await() Log.e(TAG, &quot;testAsync: ThreadId = $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;) &#125;&#125;private suspend fun getResult1():Int &#123; delay(3000) Log.e(TAG, &quot;getResult1: ThreadId = $&#123;Thread.currentThread().id&#125;&quot;) return 4&#125;private suspend fun getResult2():Int &#123; delay(5000) Log.e(TAG, &quot;getResult2: ThreadId = $&#123;Thread.currentThread().id&#125;&quot;) return 5&#125; 输出结果：E/MainActivity4: 线程main ：2E/MainActivity4: getResult1: ThreadId = 7870E/MainActivity4: getResult2: ThreadId = 7870E/MainActivity4: testAsync: ThreadId = 7870 result = 9 其中当打印getResult2后就打印了testAsync: result = 9 阻塞时间为5秒，而不是8秒，说明getResult1、getResult2是并行的。 而且发现 threadId都一样，说明处于同一个线程。但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。 协程并不等于线程，协程内部会根据任务情况自动调度线程。]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 掉起摄像头]]></title>
    <url>%2Fblog%2F2020%2F05%2Freact-%E6%8E%89%E8%B5%B7%E6%91%84%E5%83%8F%E5%A4%B4.html</url>
    <content type="text"><![CDATA[在h5中掉起摄像头，碰到一些问题，无法切换到后置摄像头 —-&gt; 将本地http 改为https就可以了chrome浏览器报错：不支持访问用户媒体 —》 将本地http 改为https就可以了 npm start默认采用的是http协议而npm start其实执行的脚本是react-script/start.js文件查看 79行代码1const protocol = process.env.HTTPS === &apos;true&apos; ? &apos;https&apos; : &apos;http&apos;; 我们只要在环境变量中将HTTPS设置为true即可在macos 执行1234567cd ~code .bash_profile添加一行 HTTPS=truesource .bash_profile// 也可以在终端执行export PORT=8081 在 window 新增环境变量 HTTPS true或者在终端执行 set HTTPS=true 本地掉起的摄像头呈现镜像 —-》css 镜像翻转 transform: ‘rotateY(180deg)’ // 水平镜像翻转180 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import React from &apos;react&apos;;import &#123;StyleSheet,css&#125; from &apos;aphrodite/no-important&apos;import &#123; dpw, dph &#125; from &apos;../../common/tool/ScreenFit&apos;;export default class AliveCheck extends React.PureComponent &#123; componentDidMount() &#123; this.video = document.getElementById(&apos;video&apos;); this.canvas = document.getElementById(&apos;canvas&apos;); this.context = this.canvas.getContext(&apos;2d&apos;); const constraints = &#123; audio: false, video : &#123; width: 480, height: 320, sourceId: &apos;default&apos;, facingMode: &#123; exact: &quot;environment&quot; &#125;, // facingMode: &#123; exact: &quot;user&quot; &#125;, permissions: &#123; &quot;audio-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture audio using getUserMedia()&quot; &#125;, &quot;video-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture video using getUserMedia()&quot; &#125; &#125; &#125; &#125; // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;; &#125; if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123; //调用用户媒体设备, 访问摄像头 this.getUserMedia(constraints, this.success, this.error); &#125; else &#123; alert(&apos;不支持访问用户媒体&apos;); &#125; &#125; //访问用户媒体设备的兼容方法 getUserMedia =(constraints, success, error) =&gt; &#123; if (navigator.mediaDevices.getUserMedia) &#123; //最新的标准API navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error); &#125; else if (navigator.webkitGetUserMedia) &#123; //webkit核心浏览器 navigator.webkitGetUserMedia(constraints,success, error) &#125; else if (navigator.mozGetUserMedia) &#123; //firfox浏览器 navigator.mozGetUserMedia(constraints, success, error); &#125; else if (navigator.getUserMedia) &#123; //旧版API navigator.getUserMedia(constraints, success, error); &#125; &#125; success =(stream) =&gt; &#123; //兼容webkit核心浏览器 let CompatibleURL = window.URL || window.webkitURL; //将视频流设置为video元素的源 console.log(stream); //video.src = CompatibleURL.createObjectURL(stream); this.video.srcObject = stream; this.video.play(); &#125; error =(error)=&gt; &#123; console.log(`访问用户媒体设备失败$&#123;error.name&#125;, $&#123;error.message&#125;`); &#125; takePhoto =() =&gt; &#123; alert(&apos;takePhoto&apos;) this.context.drawImage(this.video, 0, 0, 480, 320); &#125; stopCamera =() =&gt; &#123; if (!this.video.srcObject) return let stream = this.video.srcObject let tracks = stream.getTracks(); tracks.forEach(track =&gt; &#123; track.stop() &#125;) &#125; render() &#123; return( &lt;div className=&#123;css(styles.box)&#125;&gt; &lt;video className=&#123;css(styles.video)&#125; id=&quot;video&quot; width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;/video&gt; &lt;div&gt; &lt;button id=&quot;capture&quot; onClick=&#123;this.takePhoto&#125;&gt;拍照&lt;/button&gt; &lt;/div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; box: &#123; display: &apos;flex&apos;, width: &apos;100%&apos;, height: &apos;100%&apos;, flexDirection: &apos;column&apos;, &#125;, video: &#123; // 水平镜像翻转180 transform: &apos;rotateY(180deg)&apos;, &#125;&#125;)]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常记录]]></title>
    <url>%2Fblog%2F2020%2F05%2F%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[i++++ 在后，先运算完当前结果，再给i赋值 ex：1234567Object [] obj = new Object [16]i = 0；obj[i ++] = &quot;obj&quot;// 会先执行obj[0]=&quot;obj&quot;;// 再执行i = i + 1; –i;– 在前，则先给i赋值，再执行当前运算]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位操作符]]></title>
    <url>%2Fblog%2F2020%2F05%2F%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.html</url>
    <content type="text"><![CDATA[&amp;逻辑 与A &amp; B将A、B都转化为二进制，同为均为1则为1，否则为0 ex：5 &amp; 80000 0101&amp;0000 1000 result ： 0000 0000 结果就是0 逻辑或A | B将A、B都转化为二进制，同为有一位为1则为1，否则为0ex ： 5 &amp; 80000 0101&amp;0000 1000 result ： 0000 1101 结果就是13 逻辑非 逻辑异或 5&gt;&gt;2 0000 0101 &gt;&gt; 2 — 0000 0001 === 1 像右移2左移运算符，&gt;&gt;&gt; &lt;&lt; 5 &lt;&lt; 2像左移20000 0101 &lt;&lt; 2 – 0001 0100 === 20左移运算符， 无符号移动 无符号右移，忽略符号位，空位都以0补齐]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 枚举]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E6%9E%9A%E4%B8%BE.html</url>
    <content type="text"><![CDATA[枚举enum 的全程事 Enumeration 是jdk1.5引进的 被enum 修饰的数据类型就是枚举类型：1enum Test &#123; TEST0, TEST1, TEST2 &#125; 如果枚举不添加任何方法，枚举值默认为从0开始的递增数值，ru上面的： TEST0：0， TEST1：1，TEST2：2 枚举的好处：可以将常量组织起来，便于管理应用场景：状态码：错误码 枚举的本质枚举的本质是一个类，受限制的类 创建enum是，编译器会自动为你生成一个相关的类，这个类继承 java.lang.Enum b编译过后其实是12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; ... &#125; 是一个抽象类，并且继承了Comparable以及Serializable，也就是标记了序列化 而且枚举可以添加自己的方法、变量，但是不能为枚举常量用 “=”赋值，但不能继承其他类，因为已经继承了Enum类，也不能被继承。 枚举可以实现接口，像上面就是内部实现了两个接口，我们也可以自己实现其他接口 枚举添加方法123456789101112131415public enum TestEnum &#123; //此处调用额其实就是下面写的构造函数 TEST(22), TEST1(33), TEST2(44), TEST3(55); private TestEnum(int num) &#123; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 泛型]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E6%B3%9B%E5%9E%8B.html</url>
    <content type="text"><![CDATA[声明中有一个或者多个类型化参数的类或者接口，叫做泛型类或者接口。泛型类和接口统称为泛型。 泛型是一种安全规范，帮助我们在编译前就发现类型安全问题，而不需要等到编译报错。泛型在编译时会被擦除。 关于使用泛型的几个规则： 请不要使用原生态类型如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势 消除非受检的警告 优先考虑泛型 优先考虑泛型方法 通配符无限通配符 ？上界通配符 ？ extends T —&gt; T 以及 T 的子類 （子類的子類不行）下界通配符 ? super T —-&gt; T 以及 T 的父類 （父類的父類不行） 范型的好处 更安全 更规范]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 集合]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[java中的集合包括map、set、list collection 所有的linked 都是链表实现所有的hash 都是hash表，存储的对象都需要重写hashcode、equas函数]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨进程通信 IBinder]]></title>
    <url>%2Fblog%2F2020%2F05%2F%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-IBinder.html</url>
    <content type="text"><![CDATA[参考地址： https://zhuanlan.zhihu.com/p/436246818参考地址： https://blog.csdn.net/qq_30379689/article/details/79451596 手写一个跨进程通信 Binder代码地址 Binder 是基于 C/S模型 先定义实体类定义需要在跨进程中传输的数据的数据格式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Dog implements Parcelable &#123; private int gender; private String name; public Dog()&#123; &#125; public int getGender() &#123; return gender; &#125; public void setGender(int gender) &#123; this.gender = gender; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; protected Dog(Parcel in) &#123; this.gender = in.readInt(); this.name = in.readString(); &#125; public static final Creator&lt;Dog&gt; CREATOR = new Creator&lt;Dog&gt;() &#123; @Override public Dog createFromParcel(Parcel in) &#123; return new Dog(in); &#125; @Override public Dog[] newArray(int size) &#123; return new Dog[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(this.gender); dest.writeString(this.name); &#125;&#125; 此时实体类一定要实现 Parcelable ，即序列化。 定义接口层IInterfaceIInterface 是跨进程通信的中，向外提供的功能接口暴露在这里需要定义Service需要向外暴露的部分 123456789101112131415interface IDogManager : IInterface &#123; companion object&#123; val DESCRIPTOR = "com.example.project.Binder.interfaces.IDogManager" val TRANSACTION_getDogList = IBinder.FIRST_CALL_TRANSACTION + 0 val TRANSACTION_addDog = IBinder.FIRST_CALL_TRANSACTION + 1 &#125; fun getDogList(): List&lt;Dog&gt; fun addDog(dog: Dog?)&#125; 定义了两个函数API，这两个函数会对 client暴露 getDogList 获取数据 addDog 添加数据 定义了三个静态常量： DESCRIPTOR 标识符 TRANSACTION_getDogList 代表调用 getDogList 函数的code TRANSACTION_addDog 代表调用 addDog 函数的code 在跨进程通信中，查看 IInterface 层，就能知道 Service 层对 Client 层暴露的 api。 Binder层 新建类 DogManagerImpl 继承Binder 实现接口层IInterface 新建代理类 Proxy 继承 DogManagerImpl 类 提供 asInterface 函数，对 IBinder 实例对象进行转换 1.新建类 DogManagerImpl1abstract class DogManagerImpl&#123;&#125; 此处新建的是抽象类，也可以不用抽象类，但使用抽象类，可以让Service的逻辑写在自己的代码中，使逻辑更加清晰 2.继承Binder12345678910111213141516171819202122232425262728293031323334353637383940414243444546abstract class DogManagerImpl : Binder() &#123; init &#123; // 相当于注册 attachInterface(this, DESCRIPTOR) &#125; // 将当前对象包装成 IBinder override fun asBinder(): IBinder &#123; return this &#125; override fun onTransact(code: Int, data: Parcel, reply: Parcel?, flags: Int): Boolean &#123; // 根据code匹配调用对应的函数 when(code)&#123; INTERFACE_TRANSACTION -&gt; &#123; reply?.writeString(DESCRIPTOR) return true &#125; TRANSACTION_getDogList -&gt; &#123; // 获取数据时 data.enforceInterface(DESCRIPTOR) var _result = getDogList() reply?.writeNoException() // 输出结果 reply?.writeTypedList(_result) return true &#125; TRANSACTION_addDog -&gt; &#123; data.enforceInterface(DESCRIPTOR) var _arg0: Dog? = null if(data.readInt() != 0) &#123; _arg0 = Dog.CREATOR.createFromParcel(data) &#125; else &#123; _arg0 = null &#125; addDog(_arg0) reply?.writeNoException() return true &#125; &#125; return super.onTransact(code, data, reply, flags) &#125;&#125; 3.实现接口层IInterface1abstract class DogManagerImpl : Binder(), IDogManager&#123;&#125; 因为 DogManagerImpl 被定义成抽象类，所以此处只需写 实现 IDogManager 即可，无需实现具体函数 4. 新建代理类 Proxy 继承 DogManagerImpl 类新建一个静态内部类 Proxy 继承 DogManagerImpl 因为 DogManagerImpl 是抽象类，所以还要实现 getDogList 、 addDog 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455companion object &#123; class Proxy(var remote: IBinder) : DogManagerImpl() &#123; override fun asBinder(): IBinder &#123; return remote &#125; override fun getInterfaceDescriptor(): String &#123; return DESCRIPTOR &#125; override fun getDogList(): List&lt;Dog&gt; &#123; var _data = Parcel.obtain() var _reply = Parcel.obtain() var _result: java.util.ArrayList&lt;Dog&gt;? = null try &#123; _data.writeInterfaceToken(DESCRIPTOR) remote.transact(TRANSACTION_getDogList,_data,_reply,0) _reply.readException() _result = _reply.createTypedArrayList(Dog.CREATOR) println(&quot;proxy getData =&gt; $&#123;_result&#125;&quot;) &#125;catch (e: Exception) &#123; e.printStackTrace() println(&quot;error =&gt; $&#123;e.message&#125;&quot;) &#125;finally &#123; _data.recycle() _reply.recycle() &#125; return _result!!.toList() &#125; override fun addDog(dog: Dog?) &#123; var _data = Parcel.obtain() var _reply = Parcel.obtain() try &#123; _data.writeInterfaceToken(DESCRIPTOR) if(dog != null) &#123; _data.writeInt(1) dog.writeToParcel(_data,0) &#125; else &#123; _data.writeInt(0) &#125; remote.transact(TRANSACTION_addDog, _data, _reply, 0) println(&quot;proxy addDog =&gt; $&#123;_data&#125;&quot;) _reply.readException() &#125;catch (e: Exception) &#123; e.printStackTrace() &#125;finally &#123; _data.recycle() _reply.recycle() &#125; &#125; &#125;&#125; 此处的 Proxy 类其实就是跨进程通信中 会被使用的类 5. 提供 asInterface 函数，对 IBinder 实例对象进行转换 在 companion object 代码块中添加一个 静态函数 asInterface 1234567891011121314companion object &#123; fun asInterface(binder: IBinder):IDogManager? &#123; if(binder == null) return null var iin = binder.queryLocalInterface(DESCRIPTOR) if(iin != null &amp;&amp; iin is IDogManager) &#123; // 在同一进程时，直接返回对象 println("在统一进程时，直接返回对象") return iin &#125; // 不在同一进程，返回代理对象 println("不在同一进程，返回代理对象") return Proxy(binder) &#125;&#125; 这里可以看出 asInterface 函数功能就是通过 IBinder 实例，转换为对应的接口实例 注意此处关于进程的判断当 client 与 service 处于相同进程时，则直接返回该对象当处于不同进程时，返回的是 Proxy 实例 Service层代码 接下来编写 Service 代码 注册一个系统服务Service 12345678910111213141516171819202122class RemoteService: Service() &#123; var dogs = ArrayList&lt;Dog&gt;() val mBinder = object : DogManagerImpl() &#123; override fun getDogList(): List&lt;Dog&gt; &#123; println("RemoteService =&gt; getDogList: $&#123;dogs&#125;") return dogs &#125; override fun addDog(dog: Dog?) &#123; if(dog != null) &#123; dogs.add(dog) &#125; &#125; &#125; override fun onBind(intent: Intent?): IBinder? &#123; return mBinder &#125;&#125; 在 AndroidManifest.xml 中的配置 12345&lt;application&gt; &lt;service android:name=".Binder.RemoteService" android:process=":remote" &gt;&lt;/service&gt;&lt;/application&gt; 注意此处的 android:process=”:remote”, 这是指定 service 运行进程为 包名 + :remote process 用于指定进程名，默认与包名一致]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechat-app]]></title>
    <url>%2Fblog%2F2020%2F05%2Fwechat-app.html</url>
    <content type="text"><![CDATA[微信小程序开发]]></content>
      <tags>
        <tag>wechatApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin 类]]></title>
    <url>%2Fblog%2F2020%2F05%2Fkotlin.html</url>
    <content type="text"><![CDATA[kotlin 类kotlin中使用class申明类 构造函数构造函数分为主构造函数、次构造函数 主构造函数kotlin中可以在申明类时申明一个构造函数，并且次构造函数为 主构造函数 12// 申明了主构造函数class Person constructor(var name: String, var age: Int ) &#123;&#125; 如果主构造函数没有使用任何注解或者修饰符，则可以省略constructor关键字 1class Person (var name: String, var age: Int ) &#123;&#125; 主构造函数不能含有代码块，有需要初始化的代码可以放在以init关键字作为前缀的初始化块中。其中init可以申明多个，会根据代码顺序来执行。 123456789class Person (var name: String, var age: Int ) &#123; var myName = name; init &#123; println(&quot;this person&apos;s name was $&#123;myName&#125;&quot;); &#125; init &#123; println(&quot; test &quot;); &#125;&#125; 如果没有申明主构造函数，系统会自动创建一个无参的主构造函数。 次构造函数次构造函数必须要用constructor申明，如果有主构造函数，必须将次构造函数委托给主构造函数 1234567891011121314class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125; 初始化init代码块实际上会成为主构造函数的一部分。当次级构造函数委托给主构造函数，init代码块会成为次级构造函数的第一句语句。即使该类没有主构造函数，这种委托也会隐式发生，仍会执行初始化代码块。 如果一个非抽象类没有申明任何主、次构造函数，默认会生成一个不带参的主构造函数。函数的可见性为public。如果不想类有一个公有构造函数，需要声明一个private的主构造函数。1class TestClass private constructor () &#123;&#125; 在JVM上，如果主构造函数中的所有参数都有默认值，则会默认生成一个额外的无参构造函数，它将使用默认值。 创建类的实例kotlin 在创建实例时，不需要new 关键字12class MyPerson(str: String, var age: Int) &#123;&#125;var person = MyPerson(&quot;jack&quot;, 11); 类成员 构造函数与初始化代码块 函数 属性 嵌套类、内部类 对象申明 继承在kotlin中，所有类都有一个超类 Any，这对于没有超类型声明的类是默认超类： var oneClass; // 从Any隐式继承 Any 类中有三个方法 equas()、 hashcode()、 toString(), 因此所有kotlin类都定义有这三个方法 默认情况下，kotlin中类都是final 的，不可被继承，如果需要声明该类可以被继承，需要使用关键字 open。 并且kotlin中是使用 : 来表示继承。 12open class TestClassSuper &#123;&#125;class TestClassChild : TestClassSuper &#123;&#125; 如果超类中有声明主构造函数，则子类可以声明主构造函数，则并必须用子类中主构造函数参数初始化超类。如果子类没有声明主构造函数，则必须声明次级构造函数，并且使用super初始化基类12345678910111213141516171819open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall);&#125; 函数的重写正如类的继承需要申明open标识该类开放继承，类中的函数标识可以被重写也是需要使用open申明，如果没有函数没有申明open，则在子类中不允许出现同名并且同参数类型的函数。出现同名但不同参数的函数时允许的，正如java中的重载 12345678910111213141516171819202122232425262728293031323334open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125; open fun testMethod() &#123; &#125; fun test1() &#123; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall); override fun testMethod() &#123; super.testMethod() &#125; fun test1(str:String) &#123; &#125;&#125; 属性的重写同函数的重写，属性的重写也是需要使用open标识，并在子类中使用override1234open var i = 2;// childClassoverride var i = 4; 在属性的重写中，有一点需要注意，可以用var 重写val，却不能用val重写var；这一点是和java不一样的。因为用val申明的属性本质上申明了get方法，而将其重写为var只是在子类新增了一个set方法 派生类的初始化顺序1、进入子类的构造函数2、进入父类的构造函数并完成初始化3、进入父类的init代码块4、父类中属性的初始化5、子类构造函数完成初始化6、子类init代码块7、子类属性初始化 调用父类方法或属性可以使用super关键字1234// 方法super.method();// 属性super.nema; 内部类中调用外部类父类属性或方法，使用super@Outer1super@OutClass.method();]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android dialog]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-dialog.html</url>
    <content type="text"><![CDATA[dialog在日常开发时会经常使用到弹窗dialog 针对自定义视图的弹窗使用方法， 1234567AlertDialog.Builder builder = new AlertDialog.Builder(context);LayoutInflater inflater = context.getLayoutInflater();View view = inflater.inflate(R.layout.view, null);build.setView(view);AlertDialog dialog = build.create();dialog.show(); 上面就是一个AlertDialog实例的创建过程，其中AlertDialog使用了创建者模式。 关于点击弹窗其他部分、点击手机back而不关闭dialog的方法有如下:12dialog.setCancelable(false); // 点击back、其他部位都不关闭弹窗dialog.setCanceledOnTouchOutside(false);// 点击其他部位不关闭、点back关闭 设置dialog弹窗的大小： 12345678910// 在dialog.show() 之后Window window = dialog.getWindow();if(window != null) &#123; WindowManager.LayoutParams attr = window.getAttributes(); if (attr != null) &#123; attr.height = ViewGroup.LayoutParams.MATCH_PARENT; attr.width = ViewGroup.LayoutParams.MATCH_PARENT; window.setAttributes(attr); &#125;&#125; 这样就将dialog窗口大小设置为了最大，但是可以发现我们的弹窗还是没有充满整个屏幕，因为dialog默认的主题theme就是偏距margin的，所以如果我们想要充满整个屏幕的话，需要改变我们dialog的主题， 12// AlertDialog.Builder builder = new AlertDialog.Builder(context);AlertDialog.Builder builder = new AlertDialog.Builder(context, R.style.AppTheme);]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java流]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava%E6%B5%81.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java范型]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava%E8%8C%83%E5%9E%8B.html</url>
    <content type="text"><![CDATA[范型上通配符 ? extends T —&gt; T 以及 T 的子类（子类的子类不行）—-&gt; 集合读取 下通配符 ? super T —-&gt; T 以及 T 的父类（父类的父类不行） —-&gt; 集合存放 通用通配符 ?]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 线程私有区]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjvm-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA.html</url>
    <content type="text"><![CDATA[jvm 线程私有区jvm从多线程角度看，分为线程共享区、线程私有区 而在线程私有区中有：程序计数器、方法栈区（包括虚拟机栈、本地方法栈） 程序计数器较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响 jvm的多线程是通过cpu时间片轮转算法实现的，某个线程在执行过程中会因为时间片耗尽而被挂起，其他线程获得时间片开始执行。当被挂起的线程重新获取到时间片，它要想从之前被挂起的地方开始执行，就需要知道之前执行到了哪里，在jvm中，通过程序计数器来记录字节码执行的位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。 程序计数器的特点1、线程隔离：每个线程都有自己的程序计数器2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。 方法栈区线程在运行时，在执行每一个方法的时候都会打包成一个栈帧，然后将栈帧入栈，当方法执行完时，就会将该栈帧出栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。 栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k 栈帧结构栈帧中含有：局部变量表、操作数据栈、动态链接、返回地址 局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 锁]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E9%94%81.html</url>
    <content type="text"><![CDATA[java中使用锁，主要是用于解决多线程并发问题多个线程对某个对象进行操作，就存在并发问题。 java内存规定了，所有变量都储存在主内存中，每个线程又有自己的工作内存 线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存 线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 注意：锁作用的都是对象，在对象的内存空间中，有标志位标记是有有锁。 并发三要素原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。 可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：程序执行的顺序按照代码的先后顺序执行。 解决并发问题volatile：保证可见性，不保证原子性当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中 这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见 禁止指令重排序指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则 不会对存在依赖关系的指令重排序，例如 a = 1;b = a; a 和b存在依赖关系，不会被重排序 不能影响单线程下的执行结果。比如：a=1;b=2;c=a+b这三个操作,前两个操作可以重排序，但是c=a+b不会被重排序，因为要保证结果是3 使用场景对于一个变量，单个线程写，其他线程读，这个时候就可以使用volatile来修饰这个变量 123456789101112131415161718public class Utils &#123; private static volatile Utils instance; public static Utils getInstance() &#123; // 1 if(instance == null) &#123; // 2 synchronized(Utils.class) &#123; // 3 if(instance == null) &#123; // 4 instance = new Utils(); // 5 &#125; &#125; &#125; return instance; &#125;&#125; 初始化一个对象有如下步骤：分配内存，初始化对象，指向内存 如上代码，如果不使用volatile修饰，这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断instance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。 volatile 原理在jvm底层，volatile是通过内存屏障来实现的，内存屏障会提供三个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将缓存的修改操作立即写到主内存 写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。 valatile局限性volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题 Synchronized多个线程同时写一个变量这个时候使用Synchronized，可以保证同一时刻，只有一个线程可执行某个方法或某个代码块 Synchronized锁升级Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。 偏向锁 ：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。 轻量级锁 ：在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。 重量级锁 ：如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。 Synchromized缺陷不能设置锁超时时间不能通过代码释放锁容易造成死锁 ReentrantLock上面说到Synchronized的缺点，不能设置锁超时时间和不能通过代码释放锁，ReentranLock就可以解决这个问题 在多个条件变量和高度竞争锁的地方 ，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性 原文地址(https://www.jianshu.com/p/4eec21c3338e) JVM内存模型、指令重排、内存屏障概念解析(https://www.cnblogs.com/chenyangyao/p/5269622.html) 在java中有以下锁： 公平锁/非公平锁 可重入锁 互斥锁/读写锁 独享锁/共享锁 分段锁 偏向锁/轻量级锁/重量级锁]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 内存结构]]></title>
    <url>%2Fblog%2F2020%2F01%2Fjava-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[java 内存结构首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。 程序计数器程序计数器： 主要功能是记录当前线程执行程序的位置，通过改变计数值来确定执行下一条指令。每个线程的创建，都会创建一个程序计数器，并且对于每个线程而言是互相独立的。比如我们在debuger模式下运行，for循环的停止，异常的抛出，都是通过改变该线程对应的计数值来确定下一个执行指令。 java虚拟机栈java虚拟机栈：主要功能是临时存储线程执行到的每个方法需要的参数，其内存空间在编译时就已确定。与程序计数器一样，每创建一个线程，则创建一个虚拟机栈，线程每执行到一个方法，对应的栈里就会创建一个栈帧，栈帧会存储局部变量表、动态链接、操作数和方法出口等信息，执行方法，栈帧入栈，方法执行完，栈帧出栈。 本地方法栈本地方法栈与java虚拟机栈一样，只是记录native方法执行。jni native调用的c、c++函数 堆得内存结构分为老年代、新生代，内存比为8:2其中新生代分为: edan、from、to 内存分为8:1:1直接new产生的对象被分配到edan（大对象会被直接分配到老年代），当发生GC时，会通过复制清除算法，清除edan+from区域可被回收的对象，而不可被回收对象会被复制到to区，而在下一次GC时，会清除edan+to区可回收对象，将不可清楚的对象复制到from区，并且每次回收时，会整理碎片内存。如此反复，GC15次后，会将对象放入到老年代。 标记清除算法针对于老年代内存格局内存可达性分析，从GC Root 不可达时，会被第一次标记为清除对象，并执行对象的ﬁnalize()方法，如果这个对象被判定为有必要执行ﬁnalize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它ﬁnalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象在ﬁnalize()中成功拯救自己(只需要重新与引用链上的任何一个对象建立起关联关系即可)，那在第二次标记时它将会被移除出”即将回收”的集合；如果对象这时候还是没有逃脱，那基本上它就是真的被回收了。 注意：对象的finalize()方法只会被系统执行一次。 GCgc分为minor GC、full GCminor 作用区域是新生代内存、算法：复制清除算法。会整理碎片full GC作用区域是老年代内存，算法：标记清除算法，不会整理碎片。 GC时判断是否可回收的依据是：内存可达化：判断堆、方法栈、静态变量、静态方法区中是否有该对象的引用。 每次 gc时会 会stw（stop the world）,线程会被挂起两次 方法区在jdk1.8以前，还存在方法区，方法区同 Java 堆一样是被所有线程共享的区间，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。常量池是方法区的一部分 JDK1.8 使用元空间 MetaSpace 替代方法区，元空间并不在 JVM中，而是使用本地内存。元空间两个参数： MetaSpaceSize：初始化元空间大小，控制发生GC阈值 MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存 内存泄露 不会再被使用的实例对象，因为被其他对象持有引用，导致不能被GC回收。则称为内存泄露 内存泄露的点： 非静态内部类 匿名内部类 hashmap 内部类为何为内存泄露 内部类持有外部类的引用，导致造成外部类内存泄露因为内部类虽然和外部类写在同一个文件中，但是编译后还是会生成不同的class文件，其中内部类的构造函数中会传入外部类的实例，然后就可以通过this$0访问外部类的成员。 内存溢出当申请的内存无法被虚拟机满足，此时就会报错，内存溢出]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法（1）简单算法]]></title>
    <url>%2Fblog%2F2020%2F01%2F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[算法（1）简单算法简单常见算法 二分查找法针对有序的数据集，每次查找时都取中间值，逐步缩小查找范围，最后获取到目标值 复杂度：$O(log_n)$ 选择排序选择排序是针对数组的一种排序算法。过程：遍历数组，计算出最值，新建一个数组，将最值放入新数组, 复杂度：$O(n^2)$ 递归递归指函数在内部调用本身，使用递归注意两个条件：基线条件、递归条件。基线条件：跳出递归的条件递归条件：对递归元素逐步减少的条件，要合理利用这两点，不然容易无限循环。 在数组中取最大值12345678910111213function findMax(arr) &#123; let max = 0; if(arr.length === 0) &#123; return max; &#125; else &#123; max = arr[0] &gt; max ? arr[0] : max; arr.splice(0, 1); return findMax(arr); &#125;&#125;var arr = [1, 2, 3, 4, 5];findMax(arr); 递归算法与数据结构中的 栈 是及其相似的。已上面的算法为例，调用findMax([1,2,3,4,5])时，将findMax([1,2,3,4,5])压入栈顶，而findMax会调用findMax([2,3,4,5]),然后将findMax([2,3,4,5])压入栈,如下图所示： 然后从栈顶依次得出计算结果出栈。 快速排序深度优先、广度优先参考：https://blog.csdn.net/g11d111/article/details/75645970 拉链法参考：https://blog.csdn.net/abm1993/article/details/80886058 拉链法就是把具有相同散列地址的关键字(同义词)值放在同一个单链表中与 HashMap 类似]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 (1)]]></title>
    <url>%2Fblog%2F2020%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.html</url>
    <content type="text"><![CDATA[数据结构 (1) - 简单数据数组数组：有序、内存连续的数据集， 数组是有序的，顺序就是插入的顺序，先插入的值排在前面，内存连续：在内存分配时，数组中的值的内存空间是分配在一起的所以在我们使用数组时，推荐在申明时申明数组的长度，不然在后续插入值时可能会导致之前的数据内存空间不够，需要重新分配整个数据内存空间 数组的索引就是数组中值的下标：从0开始计数。数组的查找通过索引，所以快。而增删、修改时，当插入一个值，则需要将后面的数据都后移，删除也是类似。 数组查询快，增删慢查询：O(1)增删：O(n)修改：O(n) 数组查询原理我们知道通过数组查询快，但是为何快呢。 因为数组是内存连续的，当我们通过下标查询时，其实是通过数组0处内存地址+下标 得出该下标对应的内存地址，然后获取存储的对象。 所以查询会快。 链表链表：无序、内存非连续、每个节点都具有下一个节点的地址 链表是无序的，内存非连续，因为每一个节点都含有下一个节点的地址，相比于数组，内存非连续，则当数据增多，也不会存在内存空间的问题，因为只需随便分配下一个节点的内存，然后将上一个节点的中含有的下一个节点地址指向最新分配的地址即可。 链表数据第一个、最后一个节点的值是明确的。因为链表是无序的。所以查询慢，因为想要获取一个节点的值，需要先获取上一个节点，通过上一个节点获取到下一个节点的地址。 查询：O(n)增删：O(1)修改：O(1) 链表分为：单链表、双链表、循环链表 广义表参考地址： https://blog.csdn.net/calculate23/article/details/108750041 hash表参考地址： https://blog.csdn.net/xqs196301/article/details/123095920 栈栈是一种只允许在一端进行插入或删除的线性表 栈的操作只有两种：出栈、进栈特点：先进后出(FILO:first in last out) 只允许对栈顶的元素操作。最先进入的元素将会被压入栈底 栈可以通过数组实现，也可以通过链表实现 堆参考： https://blog.csdn.net/qq_51086532/article/details/120104501 集合队列FIFO 树参考： https://baijiahao.baidu.com/s?id=1681663951861444437&amp;wfr=spider&amp;for=pc]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 贝塞尔曲线]]></title>
    <url>%2Fblog%2F2020%2F01%2Fandroid-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF.html</url>
    <content type="text"><![CDATA[在自定义view中，绘制连续的曲线时，我们经常会使用到贝塞尔曲线。 贝塞尔曲线又分成几阶贝塞尔曲线，]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-自定义View-继承EditText]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFEditText.html</url>
    <content type="text"><![CDATA[android-自定义View-继承EditText一直觉得flutter中的输入框效果不错。动画，提示标题都有。这次要通过自定义View, 继承重写EditText来实现同样的输入框效果 源码地址 首先确定大致思路两个元素：TextView、EditText，TextView为标题，EditText为输入框展示当未获取焦点时：1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部2、输入框如果没有输入的内容，则输入框展示的提示文本当获取焦点时：不管有无输入内容，提示文本缩小在输入框上部 TextView并非实质组件，只是绘制Text，当作TextView。 1、先写一个类继承AppCompatEditText，并实现构造函数123456789101112131415161718192021public class AnimatedInput extends AppCompatEditText &#123; public AnimatedInput(Context context) &#123; super(context); this.context = context; &#125; public AnimatedInput(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; initView(attrs); &#125; public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initView(attrs); &#125;&#125; 2、重写onFocusChanged函数这样获取到 是否获取焦点的标识位123456@Override protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123; super.onFocusChanged(focused, direction, previouslyFocusedRect); isFocus = focused; postInvalidate(); &#125; 3、重写onTextChanged函数这样获取到输入框的内容value12345@Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; super.onTextChanged(text, start, lengthBefore, lengthAfter); value = text.toString(); &#125; 4、绘制提示文本这时候要分情况，即是否获取焦点、输入框是否有内容1234567891011121314151617181920212223242526272829@Overrideprotected void onDraw(Canvas canvas) &#123; // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸 int width = getMeasuredWidth(); int height = getMeasuredHeight(); top = getPaddingTop(); left = getPaddingLeft(); right = width - left - getPaddingRight(); bottom = height - top; drawTitle(canvas); super.onDraw(canvas);&#125;/** * 绘制标题 * @param canvas */private void drawTitle(Canvas canvas) &#123; if(TextUtils.isEmpty(value)) &#123; if(isFocus) &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125; else &#123; canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint); &#125; &#125; else &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125;&#125; 如此就基本实现了我们的预期目标。这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-自定义View 继承ViewGroup]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFViewGroup.html</url>
    <content type="text"><![CDATA[android 自定义View 继承ViewGroup自定义ViewGroup与自定义View不同.自定义View主要侧重于实现如何绘制，而自定义ViewGroup主要侧重于如何布局。所以自定义ViewGroup时，必须重写onMeasure、onLayout函数。onMeasure测量每个子View的大小，最后得出容器的大小onLayout上根据测量的每个子View，来对每个子View进行布局 自定义FlowLayout这里我们自定义一个自动换行的流式布局。效果图： 设计思路：1、默认横向布局、当横向布局宽度要超出容器宽度时，则自动换行，2、将整个视图分割成多少行，而每行又能分割成多个视图3、使用两个数组，一个记录单行视图，一个记录所有行（也就是前一个数组）4、每次需要换行时，记录这行的高度，当前所有视图的高度，当所有子视图计算完毕，就能知道所有子视图一起需要的宽度与高度5、根据ViewGroup使用时的SpecMode来得出最后实际的宽高,并将宽高设置上去，此处onMeasure函数完成6、处理onLayout，遍历所有行，遍历每一行，得到每个View的left、top、right、bottom，调用View.layout函数，将每个View相对于父容器的位置设置上去，此时就完成了布局，整个FlowLayout的设计基本完成 关于第5点，与自定义View中是一样的 EXACTLY AT_MOST UNSPECIFIED &lt;-MeasureSpec wrap_parnet EXACTLY AT_MOST AT_MOST match_parent EXACTLY AT_MOST AT_MOST 50dp 50dp 50dp 50dp ^LayoutParams onMeasure所以onMeasure函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); recyle(); // 获取各个偏距 int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); // 先获取父容器能给的尺寸大小 int selfWidth = MeasureSpec.getSize(widthMeasureSpec); int selfHeight = MeasureSpec.getSize(heightMeasureSpec); // 获取子视图的数量 int childViewCount = getChildCount(); // 记录每行中的子view List&lt;View&gt;lineViews = new ArrayList&lt;&gt;(); int lineWidthUsed = 0; // 每行已用宽度 int lineHeight = 0; // 行高 int parentNeededWidth = 0; // measure过程中，子View要求的父ViewGroup的宽 int parentNeededHeight = 0; // measure过程中，子View要求的父ViewGroup的高 // 遍历所有的子View for (int i = 0 ; i &lt; childViewCount; i ++) &#123; View childView = getChildAt(i); // 获取子视图的宽、高 LayoutParams lp = childView.getLayoutParams(); // 如果View存在 因为GONE的视图不占位置 if(childView.getVisibility() != GONE) &#123; // 获取子视图的测量规格 int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, paddingLeft + paddingRight, lp.width); int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, paddingTop+paddingTop, lp.height); // 设置子View的尺寸 childView.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 当执行完measure函数后，即可获取到该子view的尺寸 int childViewWidth = childView.getMeasuredWidth(); int childVieeHeight = childView.getMeasuredHeight(); // 当所用宽度 + 宽度间隔 + 当前子视图宽度 &gt; 容器View的宽度，则需要换行 if(lineWidthUsed + mHorizontalSpacing + childViewWidth &gt; selfWidth) &#123; // 记录当前行的视图、高度 allView.add(lineViews); lineHeights.add(lineHeight); // 父容器需要的宽、高 parentNeededHeight = parentNeededHeight + lineHeight + mVerticalSpacing; parentNeededWidth = Math.max(parentNeededWidth, lineWidthUsed + mHorizontalSpacing); // 执行换行、清空当前行数据 lineViews = new ArrayList&lt;&gt;(); lineHeight = 0; lineWidthUsed = 0; &#125; else &#123; lineViews.add(childView); lineHeight = Math.max(lineHeight, childVieeHeight); lineWidthUsed = lineWidthUsed + childViewWidth + mHorizontalSpacing; &#125; //处理最后一行数据 因为最后一行肯定不会触发上面的换行 if (i == childViewCount - 1) &#123; allView.add(lineViews); lineHeights.add(lineHeight); parentNeededHeight = parentNeededHeight + lineHeight + mVerticalSpacing; parentNeededWidth = Math.max(parentNeededWidth, lineWidthUsed + mHorizontalSpacing); &#125; &#125; &#125; // 通过子View的计算得出了需要的最小具体值 再根据spec一起得出最后应该的值 此处需要参考上面提到的第5点 // 根据mode以及lp获取实际值 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int realWidth = widthMode == MeasureSpec.EXACTLY ? selfWidth : parentNeededWidth; int realHeight = heightMode == MeasureSpec.EXACTLY ? selfHeight : parentNeededHeight; // 设置实际尺寸 setMeasuredDimension(realWidth, realHeight); &#125; 这样我们就完成了整个ViewGroup的尺寸测量，ViewGroup的onMeasure过程其实就是遍历子View，测量各个子View的过程。measure方法会调用到onMeasure函数，而在onMeasure中会测量到具体尺寸。 注意一下在onMeasure执行时，我们调用了一个recyle函数，1234 private void recyle() &#123; allView.clear(); lineHeights.clear();&#125; 这个函数作用就是将记录的每行view、行高信息清空。因为onMeasure函数会被调用多次，上面说了，容器的测量就会遍历子View测量，因为上层View视图中，至少存在两层ViewGroup，所以最少会被执行两次。所以每次执行此函数时，我们需要清空一下上一次的数据。 测量函数执行完毕，现在我们知道了每个view的大小，接下来我们就按照记录的View的排列、行高等信息，来对每个子View做布局处理 onLayout在上面的话，我们已经获取到了每个view的行数排列，我们只需再遍历到所有行的View，获取到每个view针对父容器的左偏距、上偏距就能够对view定位，再获取该view的宽高时，就能获取到右偏距、下偏距了。注意在onMeasure执行完毕后，就能调用getMeasuredWidth，获取尺寸信息而在onLayout执行完毕后，就能调用getWidth获取尺寸信息 1234567891011121314151617181920212223242526272829@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; // 获取容器的左、上偏距 int left = getPaddingLeft(); int top = getPaddingTop(); Log.e(TAG, &quot;onLayout: top : &quot; + top); for(int i = 0; i &lt; allView.size(); i ++) &#123; List&lt;View&gt; lineView = allView.get(i); int lineHeight = lineHeights.get(i); // 该行的高度 for(int j = 0; j &lt; lineView.size(); j ++) &#123; View childView = lineView.get(j); // 右偏距等于左偏距加上自身宽度 int right = left + childView.getMeasuredWidth(); // 下偏距等于上偏距加上自身高度 int bottom = top + childView.getMeasuredHeight(); Log.d(TAG, &quot;onLayout: left = &quot; + left + &quot; top = &quot; + top + &quot; bottom = &quot; + bottom); // 设置该view childView.layout(left, top, right, bottom); // 为下一个view准备 left = right + mHorizontalSpacing; &#125; // 为下一行准备 top = lineHeight + mVerticalSpacing + top; left = getPaddingLeft(); &#125;&#125; 这样我们自定义一个ViewGroup就完成了，实现了一个自动换行的ViewGroup 项目源码地址：https://github.com/wangchongwei/customView/blob/master/app/src/main/java/com/justin/customview/customview/FlowLayout.java]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 自定义View 继承View]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFView.html</url>
    <content type="text"><![CDATA[android 自定义View 继承View上篇关于自定义View的介绍接下来将会针对自定义View三种情况一一实现。 源码地址 最后实现效果如下图： 继承View创建一个class MyView 继承View 目标是写一个折线图 现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;LineView&quot;&gt; &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 先新建一个clas 继承View， 并初始化几个构造函数1234567891011121314151617181920212223242526272829303132public class MyView extends View &#123; // 代码生成时，才会调用该构造函数 public MyView(Context context) &#123; super(context); this.context = context; &#125; public MyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; // xml配置时，会调用这个生命周期 public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initData(attrs); &#125; // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。 private void initData(AttributeSet attrs) &#123; Log.d(TAG, &quot;initData: &quot;); // 获取xml中配置的数据 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView); paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black)); // 画笔初始化 paint = new Paint(); paint.setColor(context.getResources().getColor(R.color.black)); paint.setTextSize(40); paint.setStrokeWidth(10); // 线条粗细 &#125;&#125; 在onMeasure函数中对尺寸做约束12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.d(TAG, &quot;onMeasure: &quot;); int height = measuretDimension(defaultHeight, heightMeasureSpec); int width = measuretDimension(0, widthMeasureSpec); top = 0; left = 0; bottom = top + height; right = left + width; setMeasuredDimension(width, height);&#125;/** * 测量实际尺寸 * @param defaultSize: 默认尺寸 * @param measureSpec: 测量规格 * @return */public int measureDimension(int defaultSize, int measureSpec) &#123; int resultSize = defaultSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; // 没有做限制，取默认值 case MeasureSpec.UNSPECIFIED: resultSize = defaultSize; break; // WRAP case MeasureSpec.AT_MOST: // 要取默认值和测量值中较小值 // 当默认值为0时，取最大值, 即宽充满屏幕 resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize); break; // 具体值 或 MATCH case MeasureSpec.EXACTLY: resultSize = specSize; break; default: break; &#125; return resultSize;&#125; 先绘制两个轴线注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。这两个里的坐标不要弄混。 12345678/** 绘制两条轴线 */private void drawXY(Canvas canvas) &#123; Log.d(TAG, &quot;drawXY: &quot;); // 绘制x轴 canvas.drawLine(left + 20, bottom, right, bottom, paint); // 绘制y轴 canvas.drawLine(left + 20, top, left + 20, bottom, paint);&#125; 在MainActivity中配置该视图123456789&lt;com.justin.customview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot; android:layout_marginTop=&quot;20dp&quot; android:padding=&quot;10dp&quot; app:axieColor=&quot;@color/black&quot; android:id=&quot;@+id/myView&quot; /&gt; 我们直接运行,效果如下： x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。新增一个方法初始化这些尺寸数据 123456789101112131415161718192021/** * 尺寸数据初始化 */private void initSize () &#123; // 获取padding尺寸 paddingLeft = getPaddingLeft(); paddingTop = getPaddingTop(); paddingRight = getPaddingRight(); paddingBottom = getPaddingBottom(); StringBuilder sb = new StringBuilder(); sb.append(&quot;paddingLeft =&quot;).append(paddingLeft) .append(&quot;paddingTop =&quot;).append(paddingTop) .append(&quot;paddingRight =&quot;).append(paddingRight) .append(&quot;paddingBottom =&quot;).append(paddingBottom); Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString())); top = paddingTop; left = paddingLeft; bottom = height - top - paddingBottom; right = width - left; setMeasuredDimension(width, height);&#125; 这样我们就对padding做了处理，接下来接着绘制我们需要的图形。我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头 123456789101112131415161718private void drawArrow(Canvas canvas) &#123; Path path = new Path(); // 先绘制x轴三角 //先移动到三角形一个点 path.moveTo(right-20, bottom + 20); path.lineTo(right-20, bottom - 20); // 画线 path.lineTo(right, bottom); // 画线 path.close(); // 图形闭合 canvas.drawPath(path, paint); // 绘制y轴三角 path.moveTo(left - 20, top + 20); path.lineTo(left + 20, top + 20); path.lineTo(left, top); path.close(); canvas.drawPath(path, paint);&#125; 这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。 设置数据并绘制点我们已经完成了绘制两条轴线，现在要开始绘制数据了。首先我们要确认标准线，x轴的标准线肯定就是xValue的值，但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。我们先假设我们的值在0-100以内，取5条标准线，每条间距20. 先设置两个数据1234567891011121314151617// 数据 private float[] yValue; private String[] xValue; private int lineNum = 5; /** 设置数据并刷新 */ public void setData(float[]yValue, String[]xValue) &#123; this.yValue = yValue; this.xValue = xValue; postInvalidate(); &#125; /** 设置标准线数目 */ public void setData(int lineNum) &#123; this.lineNum = lineNum; postInvalidate(); &#125; 然后我们开始绘制标准线、各个点123456789101112131415161718192021/** 绘制各个点 */private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 5, paint); &#125;&#125; 而在MainActivity.kt中，我们可以这样使用 1234567891011// kotlin语法class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;) var yValue = floatArrayOf(70f, 80f, 90f); myView.setData(yValue, xValue); &#125;&#125; 此时的实现效果： 现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些 绘制x、y轴标准线值，将各个点连接起来。123456789101112131415161718192021222324252627282930313233343536/** 绘制各个点 */ private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; int itemValue = yMax / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); // 绘制y轴标准值 canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 10, paint); // 绘制点与点之间的连线 if(lastX &gt; 0f) &#123; canvas.drawLine(lastX, lastY, x, y, paint); &#125; // 绘制x轴标准值 canvas.drawText(xValue[i-1], x, bottom + 50, paint); lastX = x; lastY = y; &#125; &#125; 最后实现效果如下图：]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 自定义View]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View.html</url>
    <content type="text"><![CDATA[Android 自定义View自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。 首页android自定义View有三种类型，1、继承View，多用于实现一些不规则的图形。 2、继承特定的组件，如TextView， 3、继承ViewGroup，用于视图组 在自定义View中有三个关键的方法：onMeasure、onLayout、onDraw onMeasure测量，ViewGroup 会遍历测量子视图的onMeasure方法。一般view 则是在测量自身。 在这个方法中，一般是对视图的尺寸做一些要求。如：处理padding、处理wrap_parent margin是无需处理的，margin其实是在父容器的onMeasure时处理的。 在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。这两个参数都是父容器传递过来。 视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec LayoutParams我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：android:layout_width = “wrap_parent | 50dp | match_parent”存在三种情况，wrap_parent： 自适应大小，50dp: 具体尺寸match_parent: 充满父容器-父容器大小 MeasureSpec测量规格，MeasureSpec由size和mode组成 1.static int getMode(int measureSpec): // 获取mode2.static int getSize(int measureSpec):// 获取size3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec specMode存在三种情况:EXACTLY:具体尺寸、具体值AT_MOST：表示子视图最多只能是specSize中指定的大小UNSPECIFIED：可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。 size：就是LayputParams中指定的大小 而子视图的大小也就是通过size和specMode获取的，具体关系如下图： EXACTLY AT_MOST UNSPECIFIED &lt;-MeasureSpec wrap_parnet EXACTLY AT_MOST AT_MOST match_parent EXACTLY AT_MOST AT_MOST 50dp 50dp 50dp 50dp ^LayoutParams 总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸 下面会讲具体使用 onLayout布局方法 在调用onLayout时，onMeasure已经完成，子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。 onDraw绘制的方法onDraw是在容器的draw方法时调用的。而绘制的顺序为：1.绘制背景2.如果有必要，保存画布的图层，以准备失效3.绘制视图的内容4.绘制子控件5.如果必要，绘制衰落边缘和恢复层6.绘制装饰（比如滚动条） onDraw 有一个参数(Canvas cancas),canvas 就是画布，画布的范围就是onLayout布局后确定的区域Paint 画笔 Paint的常用配置1Paint mPaint = new Paint(); Style画笔的样式分三种类型 Style是个枚举类12345678910111213141516171819202122232425public enum Style &#123; /** * Geometry and text drawn with this style will be filled, ignoring all * stroke-related settings in the paint. */ FILL (0), /** * Geometry and text drawn with this style will be stroked, respecting * the stroke-related fields on the paint. */ STROKE (1), /** * Geometry and text drawn with this style will be both filled and * stroked at the same time, respecting the stroke-related fields on * the paint. This mode can give unexpected results if the geometry * is oriented counter-clockwise. This restriction does not apply to * either FILL or STROKE. */ FILL_AND_STROKE (2); Style(int nativeInt) &#123; this.nativeInt = nativeInt; &#125; final int nativeInt;&#125; canvas的常用函数]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react redux]]></title>
    <url>%2Fblog%2F2019%2F12%2Freact-redux.html</url>
    <content type="text"><![CDATA[在react-native中集成redux对react框架而言，状态树、dom树是它的一大优势。而redux就是对数据、状态进行管理。 集成redux1、执行1234npm install redux --savenpm install react-redux --savenpm install redux-thunk --savenpm i redux-logger --save 以上命令下载关于redux的组件。 2、store的配置1234567891011121314// configStore.jsimport &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import rootReducer from &apos;./reducer&apos;;const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);export default configStore =(initState) =&gt; &#123; const store = createStoreWithMiddleware(rootReducer, initState); return store;&#125; 而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰 123456789101112// rootReducerimport &#123; combineReducers &#125; from &apos;redux&apos;;import &#123; reducer as test &#125; from &apos;../Home/store&apos;;const appReducer = combineReducers(&#123; test,&#125;);const rootReducer =(state, action) =&gt; &#123; return appReducer(state, action);&#125;export default rootReducer; test是一个测试的reducer。 在入口处，绑定store，在入口文件中：1234567891011121314151617181920AppRegistry.registerComponent('projectName', () =&gt; Root);// 指向了root.js，在root.js中：import &#123; Provider &#125; from 'react-redux';import configStore from './store/configStore';const store = configStore();export default class Root extends React.PureComponent &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &#123;...&#125; &lt;/View&gt; &lt;/Provider&gt; ) &#125;&#125; 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142// actionType.jsexport const TEST_REDUCE = &quot;TEST_REDUCE&quot;;// test action.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const test =() =&gt; (&#123; type: TEST_REDUCE,&#125;)export &#123; test,&#125;// test reducer.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const initState = &#123; num: 0,&#125;export default reducer = (state = initState, action) =&gt; &#123; switch(action.type) &#123; case TEST_REDUCE: return &#123; ...state, num: state.num + 1, &#125; default: return &#123; ...initState, &#125; &#125;&#125; 在组件component中使用Test.js 123456789101112131415161718192021222324252627282930313233343536373839import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; action &#125; from &apos;./store&apos;class Test extends Component &#123; testFunction =() =&gt; &#123; this.props.action.test(); &#125; render() &#123; const &#123; num &#125; = this.props; return ( &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;this.testFunction&#125; &gt; &lt;Text&gt; 触发按钮 &lt;/Text&gt; &lt;Text&gt;&#123;num&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; (&#123; num: state.test.num,&#125;)const mapActionToProps = dispatch =&gt; &#123; return &#123; action: bindActionCreators(action, dispatch), &#125;&#125;export default connect(mapStateToProps, mapActionToProps)(Test); 具体的使用方法已在上面，下面再去讲解redux原理 redux原理说明redux状态管理大致流程： component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render reducer中数据改变即store中数据改变为何会导致 component props改变呢？其实就是connect函数。 我们在组件中，export default connect(mapStateToProps, mapActionToProps)(Test);connet是一个柯里化函数。第一组入参两个：第一个mapStateToProps，其实就是将store中的数据绑定到props，第二个mapActionToProps，是将action函数绑定到props，所以我们在使用是，如取store中的值，const { num } = this.props;dispatch action：this.props.action.test(); 第二组入参：当前的Test对象。 再往深考虑connect 函数]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android sqlite的使用]]></title>
    <url>%2Fblog%2F2019%2F11%2Fandroid-sqlite%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[android sqlite的使用1、创建表a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法 onCreate（SQLiteDatabase）在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。 onUpgrade（SQLiteDatabase，int，int）当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。 onOpen（SQLiteDatabase）这是当打开数据库时的回调函数，一般在程序中不是很常使用。 在构造函数中创建数据库12345678910// 数据表名 private static final String TABLE_NAME = &quot;userlog.db&quot;; public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public MyDatabase(Context context, int version) &#123; this(context, TABLE_NAME, null, version); &#125; 在onCreate方法中创建数据表数据库数据类型：NULL：null值INTEGER：整数，1、2、3、4、6、8字节REAL：浮点值，8字节TEXT：字符串BLOB：blob数据DATE：日期 年月日TIME：时刻 时分秒 1234567@Override public void onCreate(SQLiteDatabase db) &#123; Log.d(TAG, &quot;onCreate: onCreate&quot;); String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;; db.execSQL(sql); &#125; 然后在需要建表的实话，初始化一个该java类实例即可 增删改查增加 insert 一条数据1、使用sql语句插入一条数据12String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;db.execSQL(sql); 但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’ 此时应该使用 ? 替代符，如下：1234567891011public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123; SQLiteDatabase db = getWritableDatabase(); StringBuilder sql = new StringBuilder(); sql.append(&quot;insert into &quot;) .append(table_name) .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;); Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;; Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString()))); db.execSQL(sql.toString(), values); db.close();&#125;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ValueAnimator]]></title>
    <url>%2Fblog%2F2019%2F10%2FValueAnimator.html</url>
    <content type="text"><![CDATA[属性动画 ValueAnimator]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas 中的方法]]></title>
    <url>%2Fblog%2F2019%2F10%2Fcanvas-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[canvas 中的一些方法在canvas中一般使用的方法为drawXXX(): 绘制的方法clipXXX(): 裁剪的方法 clipRect裁剪画布，clipRect(int left, top, right, bottom);clipRectF(float left, top, right, bottom) 当执行了该方法，如clipRect(0,0,500,500);则后面都只能在(0,0,500,500)区域绘制 用Rect实现多区域裁剪intersect 交集】12345678Rect rect = new Rect(0, 0, 500, 500); rect.intersect(250, 250, 750, 750); canvas.clipRect(rect);// 取到区域(250, 250, 500, 500) 绘制多个区域相交的区域 union 合集12345678Rect rect = new Rect(0, 0, 500, 500); rect.union(250, 250, 750, 750); canvas.clipRect(rect);// 取到的区域为(0, 0, 750, 750) 绘制多个区域之和 clipPath 取出某个区域12345678910111213// 实例化路径mPath = new Path();// 移动起点至[50,50]mPath.moveTo(50, 50); mPath.lineTo(75, 23); mPath.lineTo(150, 100); mPath.lineTo(80, 110); // 闭合路径mPath.close();// 按照路径进行裁剪canvas.clipPath(mPath); 即是将path区域裁剪出来同样后面在能在该path区域绘制图形 Region.Opcanvas.drawRect]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashMap解析]]></title>
    <url>%2Fblog%2F2019%2F09%2FhashMap%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[HashMap 源码分析Hash 内部类 Node：Node(节点)，链表中的节点，当 HashMap 数据少于 6 条时，为链表结构，Node 为其中的节点。链表数据结构，每一个节点都记录下一个节点的地址。在 Node 的构造函数中，直接包含了下一个节点， 1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; // 将下一个节点作为入参放入构造函数中 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; .... 获取某个节点 12345678910111213141516171819202122232425262728293031 public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 当为树结构的时候 if (first instanceof TreeNode) // 获取树形结构中某个节点 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 遍历链表结构 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; HashMap 底部是数组，数组中存放链表，当链表长度大于 6 时，转为红黑树 put：初始化 table[],使用时再初始化，避免内存。 根据 k 获取 hash，hash &amp; length 获取 index，放入数组指定下标的链表，头插法, 链表超长 6 时，转为红黑树 jdk1.7 及以前采用的头插法，在 jdk1.8 及以后，为避免死锁，采用尾插法。hash &amp; length 使用位运算符，因为位运算符快，cpu 指令就是基于位运算符， 扩容：hashmap 的初识容量是 16，每次扩容 * 2， 为何容量取 2 的次方，因为这样在位运算时，让每一位都能使用到，效率最高，而且这样保证位运算结果与取模结果一致。 加载因子：默认 0.75，因为大量测试表明： 0.6-0.75 最佳，0.75 保证在该范围内存使用率最高。加载因子过大时，会让 hash 碰撞概率增加，降低 hashmap 使用效率。 hashmap 使用缺点：内存使用率最高也只有 75%， hash 碰撞，极端情况退化为单链表。用空间换时间。 HashMap 流程put：12 key -&gt; hashcode -&gt; hash -&gt; index 根据 key 获取 hashcode， 对 hashcode 进行多次位运算获取 hash 值 h，再根据 h 对数组 size - 1 取余 （h &amp; （size - 1）） 这样得出下标，然后遍历该下标对应链表，查询是否存在对应 key，如果存在则替换 e 对应 value，并 return oldValue如果不存在，则在尾部插入一个新节点 tips：jdk1.7 之前是头插法，1.8 之后是尾插法 当 put 数据时，新增的话，size++，会判断是否大于临界值，大于则触发扩容 resize当容量&gt;=75 时，会触发重新排列， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 当原数组长度已为最大值时，直接返回原数组否则为之前数组长度的两倍，然后构建一个新的空数组 newTab，遍历原数组，获取数组下标元素，判断下标元素类型，并会清除原数组中该下标对应值a、原数组元素没有 next 指针，单个元素， 直接放入新数组，放入的下标会根据新数组长度重新计算：newTab[e.hash &amp; (newCap - 1)] = e;b、原数组元素是红黑色节点、即红黑色根结点，调用 split 函数，将红黑树放入到新数组c、原数组又 next 指针，说明是链表，遍历链表组成新链表，并将新链表放入新数组的新位置 最后返回新数组 问题点1、为何 hashmap 是非线程安全的 put 操作未加锁，在多线程时会存在异常另外一个比较明显的线程不安全的问题是 HashMap 的 get 操作可能因为 resize 而引起死循环（cpu100%） 2、HashMap 不保证遍历的顺序和插入的顺序是一致的 为何 插入在不同的 index 时，取出的顺序与插入的顺序就不一致 3、hashmap 的效率 空间使用率最高为 75%，增删查询都是 O(1)，用空间换时间。 可以使用 SparseArray 、 ArrayMap 替代 4、为什么扩容的2的次幂 因为这样可以采用位运算符，提高运行效率 5、为何会死锁 多线程情况时，进行put，触发resize，会导致形成环形链表，造成死锁，在jdk1.8后， 头插法改成尾插法。元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变 数组+链表 结构 改为 数组+链表+红黑树。 但仍然存在死锁问题： 多线程put的时候可能导致元素丢失 put非null元素后get出来的却是null 可以使用其他数据类型替代：SparseArray： 双数组结构，key，value 分别使用数组存储， 但 SparseArray 的 key 只能为 int，有序，通过二分查找来定位元素。用时间换空间。缺点： key 值只能是 int 类型 ArrayMap：sdk 19 引入，双数组结果，key 值可以为任何类型，根据 key 获取 hash，就和 SparseArray 类型一致了。Bundle 内部就是使用 ArrayMap]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级rn版本适配android64]]></title>
    <url>%2Fblog%2F2019%2F08%2F%E5%8D%87%E7%BA%A7rn%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8Dandroid64.html</url>
    <content type="text"><![CDATA[google play在2019/08/01起实施强制支持64位手机的措施。 因为之前的version为0.55.4,到0.59.1版本更新太多，采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava + Retrofit 实现BaseResult]]></title>
    <url>%2Fblog%2F2019%2F07%2FRxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html</url>
    <content type="text"><![CDATA[Rxjava + Retrofit 实现BaseResult最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。答案肯定是可以的。本文只讲使用。 依赖：12345implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos; 普通使用案例首先创建实体数据类Test 1234567891011121314public class Test &#123; private static final String TAG = &quot;=====TEST&quot;; String key = &quot;&quot;; String test = &quot;&quot;; public void log() &#123; Log.d(TAG,&quot;key=&quot; + key); Log.d(TAG, &quot;test=&quot; + test); &#125;&#125; 在写一个接口TestServer，申明请求 1234public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用请求1234567891011121314151617181920212223242526272829303132private void testService() &#123; // 实例化一个Retrofit 对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.1.42:8080/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); TestServer service = retrofit.create(TestService.class); service.getObJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Test&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Test test) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125; 开发考虑我们不可能每个请求都重新创建一个Retrofit对象，而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。 1、写一个result实体类1234567891011121314151617181920212223242526272829303132// 因为每一个接口返回的数据结构都不同，肯定要用泛型。public class Result&lt;T&gt; &#123; private final String TAG = &quot;Result ====&quot;; private String msg; private String code = &quot;0&quot;; private T data; public void logCode() &#123; Log.d(TAG, code); &#125; public long getLongCode() &#123; long resultCode = 0; if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123; resultCode = Long.parseLong(code); &#125; return resultCode; &#125; public void log() &#123; Log.d(TAG, &quot;msg:&quot; +msg + &quot;\n code:&quot; + code + &quot;\n data:&quot; + data); &#125; public T getResultData() &#123; return data; &#125;&#125; 注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论 然后需要写一个BaseObserver观察者基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里还是因为接口返回数据格式问题，使用泛型。public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123; private final String TAG = &quot;====BaseObserver===&quot;; /** * 请求成功 * @param t */ public abstract void onSuccess(T t); /** * 当返回的code值错误时的默认方法 * @param code */ public void onResultCodeErr(long code) &#123; Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code); &#125; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(Result result) &#123; if(result.getLongCode() != 200) &#123; onResultCodeErr(result.getLongCode()); &#125; else &#123; onSuccess((T)result.getResultData()); &#125; result.log(); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); Log.d(TAG, e.getMessage()); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125;&#125; 然后我们的Server类就变成了如下：123456789public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson(); @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用就变成了这样： 1234567891011121314151617BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123; @Override public void onSuccess(Test test) &#123; Log.d(&quot;======&quot;, &quot;onSuccess&quot;); test.log(); &#125; &#125;; /** Retrofit + Rxjav */ private void testRxjavaService() &#123; Retrofit retrofit = RetrofitUtil.getRetrofit(); TestService ts = retrofit.create(TestService.class); ts.getTestRxjavaJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（三）布局组件]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[Flutter入门（三）布局组件之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！ 查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍 ui组件学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。 Text123456789101112131415Text( '要显示的文本', &#123; textAlign: TextAlign.center, // 文本横向对齐方式 居中 overflow: TextOverflow.ellipsis, // 文本溢出处理方式 textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left) softWrap: true, // 是否自动换行 textScaleFactor: 2.0, // 字体显示倍率 maxLines: 1, // 文本最大行数 style: new TextStyle( color: Colors.purple, fontSize: 20.0, ), // 文本样式 &#125;)]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter入门 vscode调试及查看日志]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[flutter入门 vscode调试及查看日志开发肯定需要调试应用，以及查看日志。 在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。 还有一个print()函数，最终发现这个是可以的。 情景再现a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。 b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出 c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出 正确方法print()日志输出函数通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出 ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。 用vscode调试flutetr一个正常的flutter项目用vscode应该是这样的。之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。 点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目 我打了一个断点，当项目运行起来，如下图。 当我点击按钮，进入断点。如下图可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。 添加断点点击代码左侧的红框区域即可（下图）。 在左上角的调试/新建断点 也可以。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用在上一篇中我们利用android studio运行了一个hello word项目。作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。 ###1、配置插件需要在vscode中下载插件找到这两个插件下载好并重新加载vscode就可以了。 ###2、运行flutter项目的运行命令是 flutter run但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。 在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。还有有一些提示信息 当你需要热加载的时候按 r，需要重启应用按R。所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。 ###3、写第一个flutter应用。按照flutter中文网（https://flutterchina.club/get-started/codelab/）写我们第一个flutter应用。其中我个人碰到一个问题。就是在第2步、使用外部package中， 在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。然后重新打开vscode才好，应该是vscode对这个以来的读取问题。 然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。 ###个人体会 flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼 fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。没有对state这个做解释、没有state的使用说明，然后那个路由也是。 ##待续]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（一）环境配置]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Flutter入门（一）环境配置在/flutter/bin目录下执行 flutter doctor命令。 3、android studio插件下载android studio就不说了，打开android studio/file/setting/plugin/输入 flutter查找并install。第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。 在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project hello word按照惯例，接下来我们跑一个hello world。 照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。 项目目录 项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。 运行点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行 第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter数据持久化]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
    <content type="text"><![CDATA[flutter数据持久化shared_preferences本地存储临时数据此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。 添加插件依赖： 123456// 在pubspec.yaml文件中添加依赖dependencies: flutter: sdk: flutter shared_preferences: &quot;&lt;newest version&gt;&quot; 调用： shared_preference 存储方式是根据key-value形式使用便捷，但有限制： a: 只能使用原始类型: int，double，bool，string 和 string list。 b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。 1234567891011import 'package:shared_preferences/shared_preferences.dart';getAsyncData() async &#123; // 获取实例 var prefs = await SharedPreferences.getInstance(); // 获取存储数据 var count = prefs.getInt('count') ?? 0 + 1; // 设置存储数据 await prefs.setInt('count', count);&#125;]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dart语言语法糖]]></title>
    <url>%2Fblog%2F2019%2F07%2Fdart%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
    <content type="text"><![CDATA[dart语言语法糖a、 以 _命名的变量或函数为强制私有 var _num; b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式 1234int getInt() =&gt; 2;int getInt() =&gt; isTrue ? 2 : 0; c、 运算符 aa ?? bb; ?? 为null 时 d、异步 async await then async、await使用与rn中使用方式一致 .then也是异步操作 12345678910111213141516171819202122232425/// 设置需要填写的内容 _setDefaultData(List&lt;dynamic&gt; list) &#123; Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;); List&lt;dynamic&gt; list1 = []; /// 对jsonStr数据做解析 jsonStr.then((value) &#123; var data = json.decode(value); if(list != null || list.length &gt; 0) &#123; data = list; &#125; print(&apos;data ====&apos; + data.toString()); data.forEach((item) &#123; if(item[&apos;type&apos;] == &apos;1&apos;) &#123; list1.add(item); &#125; &#125;); &#125;); print(&apos;list1======&apos; + list1.toString()); this.setState(() &#123; this.saveList = list1; &#125;); &#125; 如图这种代码会先输出list1的信息，然后在输出data的信息说明jsonStr.then 为异步操作]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter android端 原理解析]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter-android%E7%AB%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[flutter android端 原理解析首先看MainActivity， 继承FlutterActivity 再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory 12345678910111213141516private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);private final FlutterActivityEvents eventDelegate;private final Provider viewProvider;private final PluginRegistry pluginRegistry;public FlutterActivity() &#123; this.eventDelegate = this.delegate; this.viewProvider = this.delegate; this.pluginRegistry = this.delegate;&#125;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.eventDelegate.onCreate(savedInstanceState);&#125; 一看delegate就知道代理模式 在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值， FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。 FlutterActivityDelegate 就是FlutterActivityEvents类的实现. 看FlutterActivityDelegate类中的onCreate函数 123456789101112131415161718192021222324252627282930public void onCreate(Bundle savedInstanceState) &#123; if (VERSION.SDK_INT &gt;= 21) &#123; Window window = this.activity.getWindow(); window.addFlags(-2147483648); window.setStatusBarColor(1073741824); window.getDecorView().setSystemUiVisibility(1280); &#125; String[] args = getArgsFromIntent(this.activity.getIntent()); FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args); this.flutterView = this.viewFactory.createFlutterView(this.activity); if (this.flutterView == null) &#123; FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView(); this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView); this.flutterView.setLayoutParams(matchParent); this.activity.setContentView(this.flutterView); this.launchView = this.createLaunchView(); if (this.launchView != null) &#123; this.addLaunchView(); &#125; &#125; if (!this.loadIntent(this.activity.getIntent())) &#123; String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext()); if (appBundlePath != null) &#123; this.runBundle(appBundlePath); &#125; &#125; &#125; 首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。 android端与dart端通信1、dart端调用android端代码1、原生android代码新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。 重写onMethodCall方法，在此处写需要实现的逻辑代码 最后是将插件绑定。 12345678910111213141516171819202122232425262728293031323334public class TestPlugin implements MethodChannel.MethodCallHandler &#123; public static final String CHANNEL = &quot;plugin/test&quot;; static MethodChannel channel; // 上下文 private Activity activity; private TestPlugin(Activity activity) &#123; this.activity = activity; &#125; public static void registerWith(PluginRegistry.Registrar registrar) &#123; channel = new MethodChannel(registrar.messenger(), CHANNEL); TestPlugin plugin = new TestPlugin(registrar.activity()); // 在此通道上接受方法调用的回调 channel.setMethodCallHandler(plugin); &#125; @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123; if(methodCall.method.equals(&quot;test&quot;)) &#123; Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show(); result.success(&quot;调用成功&quot;); &#125; // 当未找到该函数 result.notImplemented(); &#125;&#125; 在MainActivity中绑定 1234567891011121314151617public class MainActivity extends FlutterActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); registerPlugin(this); &#125; private void registerPlugin(PluginRegistry registry) &#123; TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL)); &#125;&#125; 2、在dart中调用该原生方法1234567static const _platform = const MethodChannel(&apos;plugin/test&apos;);_toast() &#123; /// 调用原生的方法 _platform.invokeMethod(&apos;test&apos;); &#125; 一个原生插件调用就完成了。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook推广api 推广主页]]></title>
    <url>%2Fblog%2F2019%2F07%2Ffacebook%E6%8E%A8%E5%B9%BFapi-%E6%8E%A8%E5%B9%BF%E4%B8%BB%E9%A1%B5.html</url>
    <content type="text"><![CDATA[主页推广]]></content>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2Fblog%2F2019%2F07%2Fmaven.html</url>
    <content type="text"><![CDATA[mavenmaven 查看依赖树mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXXcode xxx // 打开xxx文件 // gradle 查看依赖树gradle app:dependency // 查看依赖树关系]]></content>
  </entry>
  <entry>
    <title><![CDATA[react发布到javaweb]]></title>
    <url>%2Fblog%2F2019%2F07%2Freact%E5%8F%91%E5%B8%83%E5%88%B0javaweb.html</url>
    <content type="text"><![CDATA[react项目发布到javaweb中1、打包react直接执行npm run build命令：发现在build目录下生成资源文件，但是打开index.html发现报错，发现在生成的index.html中引入的文件路径有问题：/static /多余，或者说少了. 正确的路径应该是：static 或者 ./static 发现是%PUBLIC_URL%问题，在构建时应该执行 PUBLIC_URL=./ npm run build 2、集成到javaweb中将上一步生成build目录下的文件都复制放在webapp路径下，启动应用就能直接访问到index.html文件]]></content>
      <tags>
        <tag>react+spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook 营销api集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-%E8%90%A5%E9%94%80api%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[facebook 营销api集成营销api需要通过后端服务器与facebook服务器交互 1、下载营销api java代码git clone https://github.com/facebook/facebook-java-business-sdk.git 编辑器：IDEA 123456789101112// 在pom.xml中添加依赖&lt;dependency&gt; &lt;groupId&gt;com.facebook.business.sdk&lt;/groupId&gt; &lt;artifactId&gt;facebook-java-business-sdk&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;插件maven-source-plugin 无法下载因缺失版本号添加&lt;version&gt;3.1.0&lt;/version&gt;// 解决idea报错在&lt;build&gt;&lt;/build&gt;标签内添加&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;在&lt;plugins&gt;&lt;/plugins&gt;标签外套一个标签&lt;pluginManagement&gt;&lt;/pluginManagement&gt; 添加java文件123456789101112131415161718192021222324252627282930import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;import com.facebook.ads.sdk.APIException;public class QuickStartExample &#123; public static final String ACCESS_TOKEN = &quot;[Your access token]&quot;;//Your access token public static final Long ACCOUNT_ID = 123456789L; //Your account ID public static final String APP_SECRET = &quot;[Your app secret]&quot;;//Your app secret public static final APIContext context = new APIContext(ACCESS_TOKEN, APP_SECRET); public static void main(String[] args) &#123; try &#123; System.out.println(&quot;==========&quot;); AdAccount account = new AdAccount(ACCOUNT_ID, context); Campaign campaign = account.createCampaign() .setName(&quot;Java SDK Test Campaign&quot;) .setObjective(Campaign.EnumObjective.VALUE_LINK_CLICKS) .setSpendCap(10000L) .setStatus(Campaign.EnumStatus.VALUE_PAUSED) .execute(); System.out.println(campaign.fetch()); &#125; catch (APIException e) &#123; e.printStackTrace(); &#125; &#125;&#125; or 123456789101112131415161718192021222324import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.APINodeList;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;public class TestFBJavaSDK&#123; public static final APIContext context = new APIContext( &quot;your-access-token&quot;, &quot;your-appsecret&quot; ); public static void main(String[] args) &#123; AdAccount account = new AdAccount(&quot;act_&#123;your-adaccount-id&#125;&quot;, context); try &#123; APINodeList&lt;Campaign&gt; campaigns = account.getCampaigns().requestAllFields().execute(); for(Campaign campaign : campaigns) &#123; System.out.println(campaign.getFieldName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行java文件既可发布请求到facebook服务器， 需要安全上网 1、主页推广根据提示一步一步提交，到 沙盒账号，如果之前没有添加则新建，要推广的主页，如果无则新建 到下载示例代码，点下载，将会获得一个java文件，里面含有accessToken、appid、ad_account_id、app_secret等信息，将该下载的SAMPLE_CODE.java文件放于与上面两个java文件同级目录，直接运行该java文件即可，注意此时电脑需要科学上网，不然会报错Timeout]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook sdk 集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-sdk-%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[Facebook sdk 集成首先需要在facebook注册一个账号，自通过账号进入facebook的开发者平台 创建应用，只需要填写应用名即可，回生成一个appid。 集成事件功能1、配置远端maven仓库地址 在项目android/build.gradle文件123456789101112131415buildscript&#123; repositories&#123; ... mavenCentral(); // 添加这行 &#125;&#125;allprojects&#123; repositories &#123; ... mavenCentral() // 添加这行 &#125;&#125; 2、添加依赖在app/build.gradle文件中添加依赖123456dependencies&#123; ... implementation &apos;com.facebook.android:facebook-android-sdk:[4,5)&apos; // 添加这行 // 最新sdk版本为 implementation &apos;com.facebook.android:facebook-android-sdk:[5,6)&apos; &#125; 3、添加facebook-app-id在res/values/string.xml中1234&lt;string name=&quot;facebook_app_id&quot;&gt;462119014332748&lt;/string&gt; &lt;string name=&quot;fb_login_protocol_scheme&quot;&gt;fb462119014332748&lt;/string&gt;// 462119014332748为你在facebook应用的appid// fb_login_protocol_scheme应该是用于登陆的 在/app/manifest/AndroidManifest.xml中12345678910111213141516&lt;application&gt; &lt;meta-data android:name=&quot;com.facebook.sdk.ApplicationId&quot; android:value=&quot;@string/facebook_app_id&quot;/&gt; &lt;activity android:name=&quot;com.facebook.FacebookActivity&quot; android:configChanges= &quot;keyboard|keyboardHidden|screenLayout|screenSize|orientation&quot; android:label=&quot;@string/app_name&quot; /&gt; &lt;activity android:name=&quot;com.facebook.CustomTabActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;@string/fb_login_protocol_scheme&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 4、在facebook开发者控制台配置analytics sdk在facebook开发者官网，点击「我的应用」即可进入应用控制台，可以创建应用，只需提供应用名，以及邮箱即可， 点击单个应用即可进入应用控制台进行编辑;上图是应用可添加的功能， 点击Analytics即将功能添加进应用，点设置，前几步都是提示，第四步，填入应用id，app/build.gradle中的applicationid，以及应用默认启动的Actiivty， 第五步，填入密钥散列，注意应该要填入两个，一个开发、一个发布，即debug自带的、一个release时通过jks文件签名生成的。获取方法12345// macos debug ，按下enter键需要输入开机密码keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64// release keytool -exportcert -alias YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl base64 5、发送事件 上面的1、2、3都只是基本配置，下面是手动发送事件 在MainApplication.java中FacebookSdk.sdkInitialize 四个初始化方法都已被遗弃， 看到说是不需要初始化了 在MainApplication.java中 12345678910@Override public void onCreate() &#123; super.onCreate(); // facebook 初始化 FacebookSdk.setIsDebugEnabled(true); AppEventsLogger.activateApp(MainApplication.this); FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS); &#125; 注意facebooksdk回自动收集一些事件,如果不需要自动收集功能需要在清单文件中配置 1234&lt;meta-data android:name=&quot;com.facebook.sdk.AutoLogAppEventsEnabled&quot; android:value=&quot;false&quot;/&gt; 在Actiivty中测试发送自定义事件 123456789101112@Overrideprotected void onResume() &#123; super.onResume(); logEvent();&#125;private void logEvent() &#123; Log.d(&quot;========&quot;, &quot;logEvent&quot;); AppEventsLogger logger = AppEventsLogger.newLogger(this); logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP); logger.logEvent(&quot;Test Event&quot;);&#125; 在测试时发现，当打断点调试时发现，发送事件总是会失败，正常运行却可以在facebook分析工具中看得到提交的事件。 后续：在sdk集成后，可以看到之前定义的事件数据。但是在连接商务平台，想要发布广告时。需要通过自己的事件来定义受众、或者定义类似受众时发现，在商务平台无法获取到自定义事件的数据。甚至都无法获取到我们的应用。后来看官方文档，发现出了自定义事件、自动收集的事件，还有一个标准事件。在我添加了一个标准事件后，就在商务平台上能找到在开发平台提交的app了。但是那些自定义受众、类似受众功能貌似只能绑定到 facebook定义的标准事件，而不能是我们自己的自定义事件 注意，运行时手机需要能连接到facebook后台服务器，大陆用户需要科学上网。]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android okHttp3]]></title>
    <url>%2Fblog%2F2019%2F06%2Fandroid-okHttp3.html</url>
    <content type="text"><![CDATA[OkHttp3使用添加依赖，在app/build.gradle中添加依赖1implementation &apos;com.squareup.okhttp3:okhttp:3.10.0&apos; get一个普通的get请求 1234567891011121314151617181920212223242526private void get() &#123; OkHttpClient client = new OkHttpClient.Builder().build(); Request request = new Request.Builder() .addHeader(&quot;header_key&quot;, &quot;header_value&quot;) .url(&quot;https://www.baidu.com&quot;) .get() .build(); try &#123; // 同步执行 client.newCall(request).execute(); // 异步执行 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d(TAG, &quot;onFailure: &quot; + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(TAG, &quot;onResponse: &quot; + response.body().string()); &#125; &#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; post12345678910111213141516171819202122232425262728293031private void post() &#123; OkHttpClient client = new OkHttpClient.Builder().build(); RequestBody body = new FormBody.Builder() .add(&quot;content&quot;, &quot;content&quot;) .build(); Request request = new Request.Builder() .addHeader(&quot;header_key&quot;, &quot;header_value&quot;) .post(body) .url(&quot;https://www.baidu.com&quot;) .build(); try &#123; // 同步执行 client.newCall(request).execute(); // 异步执行 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(TAG, &quot;onResponse: &quot; + response.body().string()); &#125; &#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 上面就是一个简单的post与get请求，区别就是post会多一个RequestBody 而关于okhttp的使用还有很多其他的用户，如自定义分发器Dispatch、拦截器、缓存]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode的常用插件与插件开发]]></title>
    <url>%2Fblog%2F2019%2F04%2Fvscode%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。 nodejs123456curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash. ~/.bashrc#显示有远端的版本nvm ls-remote#安装对应的版本nvm install 对应的版本 安装常用工具： 1234567891011npm install hexo-cli -gnpm install hexo-server -gnpm install hexo-deployer-git -gnpm install yarn -gnpm install http-server -gyarn global add servenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalyarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 常用插件安装以下插件：12345678910111213141516171819202122232425262728293031323334#javascripteslintColor PickernpmDebugger for ChromeEclipse Keymap#reactES7 React/Redux/GraphQL/React-Native snippets#vueVeturVue VSCode Snippets#gitGitLenszerofinance-git#其他公共插件Local HistoryXML ToolsPrettier#https://zhuanlan.zhihu.com/p/54031899koroFileHeaderAutoFileNameImport Cost#javaJava Extension PackSpring Boot Extension PackJava Code GeneratorsDocker#android/ios pluginAndroid iOS EmulatorReact Native Tools#see debug:https://github.com/Microsoft/vscode-react-native/blob/master/doc/debugging.md#debugging-on-ios-device#Install ios-deploy: npm install -g ios-deploy 代码注释koroFileHeader添加注释，在全局的settings.json中添加： 参考： https://code.visualstudio.com/docs/editor/emmet https://www.cnblogs.com/summit7ca/p/6944215.html 12345678910111213141516171819202122232425262728"editor.fontSize": 14,"terminal.integrated.fontSize": 14,"emmet.triggerExpansionOnTab": true,"emmet.includeLanguages": &#123; "javascript": "javascriptreact", "vue-html": "html", "razor": "html", "plaintext": "jade"&#125;,// 注释"fileheader.configObj": &#123; // 将该选项设置为true即可开启 "autoAdd": false&#125;,// 头部注释"fileheader.customMade": &#123; "Author": "dave.zhao", "Date": "Do not edit", "LastEditors": "dave.zhao", "LastEditTime": "Do not edit", "Description": ""&#125;,// 函数注释"fileheader.cursorMode": &#123; "Date": "Do not edit", "description": "", "param": ""&#125; 注意：Author和LastEditors填写自己的名字 文件头注释快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i 函数注释快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t 常用配置可以放在全局的settings.json中，也可以放在各个项目的settings.json中： 1234567891011121314151617181920&#123; "eslint.validate": ["javascript", "javascriptreact"], "javascript.updateImportsOnFileMove.enabled": "always", // 代码缩进修改成4个空格 "editor.detectIndentation": false, "editor.tabSize": 4, "editor.formatOnSave": true, // 每次保存的时候将代码按eslint格式进行修复 "eslint.autoFixOnSave": true, // 让prettier使用eslint的代码格式进行校验 "prettier.eslintIntegration": true, // 去掉代码结尾的分号 "prettier.semi": false, // 使用带引号替代双引号 "prettier.singleQuote": true, "prettier.tabWidth": 4, "prettier.printWidth": 250, // 让函数(名)和后面的括号之间加个空格 "javascript.format.insertSpaceBeforeFunctionParenthesis": true&#125; 插件开发参考代码https://github.com/zhaoxunyong/vs-code-git-plugin 参考 https://segmentfault.com/a/1190000008968904 https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://github.com/steveukx/git-js https://www.jianshu.com/p/2b096d8ad9b8 https://github.com/Microsoft/vscode-extension-samples https://www.jianshu.com/p/520c575e91c3 https://segmentfault.com/a/1190000017279102 https://segmentfault.com/a/1190000014758981 https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
