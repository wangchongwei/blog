<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm 线程私有区]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjvm-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA.html</url>
    <content type="text"><![CDATA[jvm 线程私有区jvm从多线程角度看，分为线程共享区、线程私有区 而在线程私有区中有：程序计数器、方法栈区（包括虚拟机栈、本地方法栈） 程序计数器较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响 jvm的多线程是通过cpu时间片轮转算法实现的，某个线程在执行过程中会因为时间片耗尽而被挂起，其他线程获得时间片开始执行。当被挂起的线程重新获取到时间片，它要想从之前被挂起的地方开始执行，就需要知道之前执行到了哪里，在jvm中，通过程序计数器来记录字节码执行的位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。 程序计数器的特点1、线程隔离：每个线程都有自己的程序计数器2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。 方法栈区线程在运行时，在执行每一个方法的时候都会打包成一个栈帧，然后将栈帧入栈，当方法执行完时，就会将该栈帧出栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。 栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k 栈帧结构栈帧中含有：局部变量表、操作数据栈、动态链接、返回地址 局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 锁]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E9%94%81.html</url>
    <content type="text"><![CDATA[java中使用锁，主要是用于解决多线程并发问题多个线程对某个对象进行操作，就存在并发问题。 java内存规定了，所有变量都储存在主内存中，每个线程又有自己的工作内存 线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存 线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 并发三要素原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。 可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：程序执行的顺序按照代码的先后顺序执行。 解决并发问题volatile：保证可见性，不保证原子性当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中 这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见 禁止指令重排序指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则 不会对存在依赖关系的指令重排序，例如 a = 1;b = a; a 和b存在依赖关系，不会被重排序 不能影响单线程下的执行结果。比如：a=1;b=2;c=a+b这三个操作,前两个操作可以重排序，但是c=a+b不会被重排序，因为要保证结果是3 使用场景对于一个变量，单个线程写，其他线程读，这个时候就可以使用volatile来修饰这个变量 123456789101112131415161718public class Utils &#123; private static volatile Utils instance; public static Utils getInstance() &#123; // 1 if(instance == null) &#123; // 2 synchronized(Utils.class) &#123; // 3 if(instance == null) &#123; // 4 instance = new Utils(); // 5 &#125; &#125; &#125; return instance; &#125;&#125; 初始化一个对象有如下步骤：分配内存，初始化对象，指向内存 如上代码，如果不使用volatile修饰，这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断instance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。 volatile 原理在jvm底层，volatile是通过内存屏障来实现的，内存屏障会提供三个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将缓存的修改操作立即写到主内存 写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。 valatile局限性volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题 Synchronized多个线程同时写一个变量这个时候使用Synchronized，可以保证同一时刻，只有一个线程可执行某个方法或某个代码块 Synchronized锁升级Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。 偏向锁 ：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。 轻量级锁 ：在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。 重量级锁 ：如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。 Synchromized缺陷不能设置锁超时时间不能通过代码释放锁容易造成死锁 ReentrantLock上面说到Synchronized的缺点，不能设置锁超时时间和不能通过代码释放锁，ReentranLock就可以解决这个问题 在多个条件变量和高度竞争锁的地方 ， 用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性 原文地址(https://www.jianshu.com/p/4eec21c3338e) JVM内存模型、指令重排、内存屏障概念解析(https://www.cnblogs.com/chenyangyao/p/5269622.html)]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 内存结构]]></title>
    <url>%2Fblog%2F2020%2F01%2Fjava-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[java 内存结构首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。 程序计数器程序计数器： 主要功能是记录当前线程执行程序的位置，通过改变计数值来确定执行下一条指令。每个线程的创建，都会创建一个程序计数器，并且对于每个线程而言是互相独立的。比如我们在debuger模式下运行，for循环的停止，异常的抛出，都是通过改变该线程对应的计数值来确定下一个执行指令。 java虚拟机栈java虚拟机栈：主要功能是临时存储线程执行到的每个方法需要的参数，其内存空间在编译时就已确定。与程序计数器一样，每创建一个线程，则创建一个虚拟机栈，线程每执行到一个方法，对应的栈里就会创建一个栈帧，栈帧会存储局部变量表、动态链接、操作数和方法出口等信息，执行方法，栈帧入栈，方法执行完，栈帧出栈。 本地方法栈本地方法栈与java虚拟机栈一样，只是记录native方法执行。jni native调用的c、c++函数]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法（1）简单算法]]></title>
    <url>%2Fblog%2F2020%2F01%2F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[算法（1）简单算法简单常见算法 二分查找法针对有序的数据集，每次查找时都取中间值，逐步缩小查找范围，最后获取到目标值 复杂度：$O(log_n)$ 选择排序选择排序是针对数组的一种排序算法。过程：遍历数组，计算出最值，新建一个数组，将最值放入新数组, 复杂度：$O(n^2)$ 递归递归指函数在内部调用本身，使用递归注意两个条件：基线条件、递归条件。基线条件：跳出递归的条件递归条件：对递归元素逐步减少的条件，要合理利用这两点，不然容易无限循环。 在数组中取最大值12345678910111213function findMax(arr) &#123; let max = 0; if(arr.length === 0) &#123; return max; &#125; else &#123; max = arr[0] &gt; max ? arr[0] : max; arr.splice(0, 1); return findMax(arr); &#125;&#125;var arr = [1, 2, 3, 4, 5];findMax(arr); 递归算法与数据结构中的 栈 是及其相似的。已上面的算法为例，调用findMax([1,2,3,4,5])时，将findMax([1,2,3,4,5])压入栈顶，而findMax会调用findMax([2,3,4,5]),然后将findMax([2,3,4,5])压入栈,如下图所示： 然后从栈顶依次得出计算结果出栈。 快速排序]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 (1)]]></title>
    <url>%2Fblog%2F2020%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.html</url>
    <content type="text"><![CDATA[数据结构 (1) - 简单数据数组数组：有序、内存连续的数据集， 数组是有序的，顺序就是插入的顺序，先插入的值排在前面，内存连续：在内存分配时，数组中的值的内存空间是分配在一起的所以在我们使用数组时，推荐在申明时申明数组的长度，不然在后续插入值时可能会导致之前的数据内存空间不够，需要重新分配整个数据内存空间 数组的索引就是数组中值的下标：从0开始计数。数组的查找通过索引，所以快。而增删、修改时，当插入一个值，则需要将后面的数据都后移，删除也是类似。 数组查询快，增删慢查询：O(1)增删：O(n)修改：O(n) 链表链表：无序、内存非连续、每个节点都具有下一个节点的地址 链表是无序的，内存非连续，因为每一个节点都含有下一个节点的地址，相比于数组，内存非连续，则当数据增多，也不会存在内存空间的问题，因为只需随便分配下一个节点的内存，然后将上一个节点的中含有的下一个节点地址指向最新分配的地址即可。 链表数据第一个、最后一个节点的值是明确的。因为链表是无序的。所以查询慢，因为想要获取一个节点的值，需要先获取上一个节点，通过上一个节点获取到下一个节点的地址。 查询：O(n)增删：O(1)修改：O(1) 栈栈是一种只允许在一端进行插入或删除的线性表 栈的操作只有两种：出栈、进栈特点：先进后出(FILO:first in last out) 只允许对栈顶的元素操作。最先进入的元素将会被压入栈底]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 贝塞尔曲线]]></title>
    <url>%2Fblog%2F2020%2F01%2Fandroid-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF.html</url>
    <content type="text"></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-自定义View-继承EditText]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFEditText.html</url>
    <content type="text"><![CDATA[android-自定义View-继承EditText一直觉得flutter中的输入框效果不错。动画，提示标题都有。这次要通过自定义View, 继承重写EditText来实现同样的输入框效果 源码地址 首先确定大致思路两个元素：TextView、EditText，TextView为标题，EditText为输入框展示当未获取焦点时：1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部2、输入框如果没有输入的内容，则输入框展示的提示文本当获取焦点时：不管有无输入内容，提示文本缩小在输入框上部 TextView并非实质组件，只是绘制Text，当作TextView。 1、先写一个类继承AppCompatEditText，并实现构造函数123456789101112131415161718192021public class AnimatedInput extends AppCompatEditText &#123; public AnimatedInput(Context context) &#123; super(context); this.context = context; &#125; public AnimatedInput(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; initView(attrs); &#125; public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initView(attrs); &#125;&#125; 2、重写onFocusChanged函数这样获取到 是否获取焦点的标识位123456@Override protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123; super.onFocusChanged(focused, direction, previouslyFocusedRect); isFocus = focused; postInvalidate(); &#125; 3、重写onTextChanged函数这样获取到输入框的内容value12345@Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; super.onTextChanged(text, start, lengthBefore, lengthAfter); value = text.toString(); &#125; 4、绘制提示文本这时候要分情况，即是否获取焦点、输入框是否有内容1234567891011121314151617181920212223242526272829@Overrideprotected void onDraw(Canvas canvas) &#123; // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸 int width = getMeasuredWidth(); int height = getMeasuredHeight(); top = getPaddingTop(); left = getPaddingLeft(); right = width - left - getPaddingRight(); bottom = height - top; drawTitle(canvas); super.onDraw(canvas);&#125;/** * 绘制标题 * @param canvas */private void drawTitle(Canvas canvas) &#123; if(TextUtils.isEmpty(value)) &#123; if(isFocus) &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125; else &#123; canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint); &#125; &#125; else &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125;&#125; 如此就基本实现了我们的预期目标。这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-自定义View 继承ViewGroup]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFViewGroup.html</url>
    <content type="text"><![CDATA[android 自定义View 继承ViewGroup]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 自定义View 继承View]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFView.html</url>
    <content type="text"><![CDATA[android 自定义View 继承View上篇关于自定义View的介绍接下来将会针对自定义View三种情况一一实现。 源码地址 最后实现效果如下图： 继承View创建一个class MyView 继承View 目标是写一个折线图 现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;LineView&quot;&gt; &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 先新建一个clas 继承View， 并初始化几个构造函数1234567891011121314151617181920212223242526272829303132public class MyView extends View &#123; // 代码生成时，才会调用该构造函数 public MyView(Context context) &#123; super(context); this.context = context; &#125; public MyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; // xml配置时，会调用这个生命周期 public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initData(attrs); &#125; // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。 private void initData(AttributeSet attrs) &#123; Log.d(TAG, &quot;initData: &quot;); // 获取xml中配置的数据 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView); paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black)); // 画笔初始化 paint = new Paint(); paint.setColor(context.getResources().getColor(R.color.black)); paint.setTextSize(40); paint.setStrokeWidth(10); // 线条粗细 &#125;&#125; 在onMeasure函数中对尺寸做约束12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.d(TAG, &quot;onMeasure: &quot;); int height = measuretDimension(defaultHeight, heightMeasureSpec); int width = measuretDimension(0, widthMeasureSpec); top = 0; left = 0; bottom = top + height; right = left + width; setMeasuredDimension(width, height);&#125;/** * 测量实际尺寸 * @param defaultSize: 默认尺寸 * @param measureSpec: 测量规格 * @return */public int measureDimension(int defaultSize, int measureSpec) &#123; int resultSize = defaultSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; // 没有做限制，取默认值 case MeasureSpec.UNSPECIFIED: resultSize = defaultSize; break; // WRAP case MeasureSpec.AT_MOST: // 要取默认值和测量值中较小值 // 当默认值为0时，取最大值, 即宽充满屏幕 resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize); break; // 具体值 或 MATCH case MeasureSpec.EXACTLY: resultSize = specSize; break; default: break; &#125; return resultSize;&#125; 先绘制两个轴线注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。这两个里的坐标不要弄混。 12345678/** 绘制两条轴线 */private void drawXY(Canvas canvas) &#123; Log.d(TAG, &quot;drawXY: &quot;); // 绘制x轴 canvas.drawLine(left + 20, bottom, right, bottom, paint); // 绘制y轴 canvas.drawLine(left + 20, top, left + 20, bottom, paint);&#125; 在MainActivity中配置该视图123456789&lt;com.justin.customview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot; android:layout_marginTop=&quot;20dp&quot; android:padding=&quot;10dp&quot; app:axieColor=&quot;@color/black&quot; android:id=&quot;@+id/myView&quot; /&gt; 我们直接运行,效果如下： x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。新增一个方法初始化这些尺寸数据 123456789101112131415161718192021/** * 尺寸数据初始化 */private void initSize () &#123; // 获取padding尺寸 paddingLeft = getPaddingLeft(); paddingTop = getPaddingTop(); paddingRight = getPaddingRight(); paddingBottom = getPaddingBottom(); StringBuilder sb = new StringBuilder(); sb.append(&quot;paddingLeft =&quot;).append(paddingLeft) .append(&quot;paddingTop =&quot;).append(paddingTop) .append(&quot;paddingRight =&quot;).append(paddingRight) .append(&quot;paddingBottom =&quot;).append(paddingBottom); Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString())); top = paddingTop; left = paddingLeft; bottom = height - top - paddingBottom; right = width - left; setMeasuredDimension(width, height);&#125; 这样我们就对padding做了处理，接下来接着绘制我们需要的图形。我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头 123456789101112131415161718private void drawArrow(Canvas canvas) &#123; Path path = new Path(); // 先绘制x轴三角 //先移动到三角形一个点 path.moveTo(right-20, bottom + 20); path.lineTo(right-20, bottom - 20); // 画线 path.lineTo(right, bottom); // 画线 path.close(); // 图形闭合 canvas.drawPath(path, paint); // 绘制y轴三角 path.moveTo(left - 20, top + 20); path.lineTo(left + 20, top + 20); path.lineTo(left, top); path.close(); canvas.drawPath(path, paint);&#125; 这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。 设置数据并绘制点我们已经完成了绘制两条轴线，现在要开始绘制数据了。首先我们要确认标准线，x轴的标准线肯定就是xValue的值，但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。我们先假设我们的值在0-100以内，取5条标准线，每条间距20. 先设置两个数据1234567891011121314151617// 数据 private float[] yValue; private String[] xValue; private int lineNum = 5; /** 设置数据并刷新 */ public void setData(float[]yValue, String[]xValue) &#123; this.yValue = yValue; this.xValue = xValue; postInvalidate(); &#125; /** 设置标准线数目 */ public void setData(int lineNum) &#123; this.lineNum = lineNum; postInvalidate(); &#125; 然后我们开始绘制标准线、各个点123456789101112131415161718192021/** 绘制各个点 */private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 5, paint); &#125;&#125; 而在MainActivity.kt中，我们可以这样使用 1234567891011// kotlin语法class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;) var yValue = floatArrayOf(70f, 80f, 90f); myView.setData(yValue, xValue); &#125;&#125; 此时的实现效果： 现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些 绘制x、y轴标准线值，将各个点连接起来。123456789101112131415161718192021222324252627282930313233343536/** 绘制各个点 */ private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; int itemValue = yMax / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); // 绘制y轴标准值 canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 10, paint); // 绘制点与点之间的连线 if(lastX &gt; 0f) &#123; canvas.drawLine(lastX, lastY, x, y, paint); &#125; // 绘制x轴标准值 canvas.drawText(xValue[i-1], x, bottom + 50, paint); lastX = x; lastY = y; &#125; &#125; 最后实现效果如下图：]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 自定义View]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View.html</url>
    <content type="text"><![CDATA[Android 自定义View自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。 首页android自定义View有三种类型，1、继承View，多用于实现一些不规则的图形。 2、继承特定的组件，如TextView， 3、继承ViewGroup，用于视图组 在自定义View中有三个关键的方法：onMeasure、onLayout、onDraw onMeasure测量，ViewGroup 会遍历测量子视图的onMeasure方法。一般view 则是在测量自身。 在这个方法中，一般是对视图的尺寸做一些要求。如：处理padding、处理wrap_parent margin是无需处理的，margin其实是在父容器的onMeasure时处理的。 在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。这两个参数都是父容器传递过来。 视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec LayoutParams我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：android:layout_width = “wrap_parent | 50dp | match_parent”存在三种情况，wrap_parent： 自适应大小，50dp: 具体尺寸match_parent: 充满父容器-父容器大小 MeasureSpec测量规格，MeasureSpec由size和mode组成 1.static int getMode(int measureSpec): // 获取mode2.static int getSize(int measureSpec):// 获取size3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec specMode存在三种情况:EXACTLY:具体尺寸、具体值AT_MOST：表示子视图最多只能是specSize中指定的大小UNSPECIFIED：可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。 size：就是LayputParams中指定的大小 而子视图的大小也就是通过size和specMode获取的，具体关系如下图： EXACTLY AT_MOST UNSPECIFIED &lt;-MeasureSpec wrap_parnet EXACTLY AT_MOST AT_MOST match_parent EXACTLY AT_MOST AT_MOST 50dp 50dp 50dp 50dp ^LayoutParams 总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸 下面会讲具体使用 onLayout布局方法 在调用onLayout时，onMeasure已经完成，子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。 onDraw绘制的方法onDraw是在容器的draw方法时调用的。而绘制的顺序为：1.绘制背景2.如果有必要，保存画布的图层，以准备失效3.绘制视图的内容4.绘制子控件5.如果必要，绘制衰落边缘和恢复层6.绘制装饰（比如滚动条） onDraw 有一个参数(Canvas cancas),canvas 就是画布，画布的范围就是onLayout布局后确定的区域]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react redux]]></title>
    <url>%2Fblog%2F2019%2F12%2Freact-redux.html</url>
    <content type="text"><![CDATA[在react-native中集成redux对react框架而言，状态树、dom树是它的一大优势。而redux就是对数据、状态进行管理。 集成redux1、执行1234npm install redux --savenpm install react-redux --savenpm install redux-thunk --savenpm i redux-logger --save 以上命令下载关于redux的组件。 2、store的配置1234567891011121314// configStore.jsimport &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import rootReducer from &apos;./reducer&apos;;const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);export default configStore =(initState) =&gt; &#123; const store = createStoreWithMiddleware(rootReducer, initState); return store;&#125; 而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰 123456789101112// rootReducerimport &#123; combineReducers &#125; from &apos;redux&apos;;import &#123; reducer as test &#125; from &apos;../Home/store&apos;;const appReducer = combineReducers(&#123; test,&#125;);const rootReducer =(state, action) =&gt; &#123; return appReducer(state, action);&#125;export default rootReducer; test是一个测试的reducer。 在入口处，绑定store，在入口文件中：1234567891011121314151617181920AppRegistry.registerComponent(&apos;projectName&apos;, () =&gt; Root);// 指向了root.js，在root.js中：import &#123; Provider &#125; from &apos;react-redux&apos;;import configStore from &apos;./store/configStore&apos;;const store = configStore();export default class Root extends React.PureComponent &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &#123;...&#125; &lt;/View&gt; &lt;/Provider&gt; ) &#125;&#125; 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142// actionType.jsexport const TEST_REDUCE = &quot;TEST_REDUCE&quot;;// test action.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const test =() =&gt; (&#123; type: TEST_REDUCE,&#125;)export &#123; test,&#125;// test reducer.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const initState = &#123; num: 0,&#125;export default reducer = (state = initState, action) =&gt; &#123; switch(action.type) &#123; case TEST_REDUCE: return &#123; ...state, num: state.num + 1, &#125; default: return &#123; ...initState, &#125; &#125;&#125; 在组件component中使用Test.js 123456789101112131415161718192021222324252627282930313233343536373839import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; action &#125; from &apos;./store&apos;class Test extends Component &#123; testFunction =() =&gt; &#123; this.props.action.test(); &#125; render() &#123; const &#123; num &#125; = this.props; return ( &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;this.testFunction&#125; &gt; &lt;Text&gt; 触发按钮 &lt;/Text&gt; &lt;Text&gt;&#123;num&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; (&#123; num: state.test.num,&#125;)const mapActionToProps = dispatch =&gt; &#123; return &#123; action: bindActionCreators(action, dispatch), &#125;&#125;export default connect(mapStateToProps, mapActionToProps)(Test); 具体的使用方法已在上面，下面再去讲解redux原理 redux原理说明redux状态管理大致流程： component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render reducer中数据改变即store中数据改变为何会导致 component props改变呢？其实就是connect函数。 我们在组件中，export default connect(mapStateToProps, mapActionToProps)(Test);connet是一个柯里化函数。第一组入参两个：第一个mapStateToProps，其实就是将store中的数据绑定到props，第二个mapActionToProps，是将action函数绑定到props，所以我们在使用是，如取store中的值，const { num } = this.props;dispatch action：this.props.action.test(); 第二组入参：当前的Test对象。 再往深考虑connect 函数]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android sqlite的使用]]></title>
    <url>%2Fblog%2F2019%2F11%2Fandroid-sqlite%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[android sqlite的使用1、创建表a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法 onCreate（SQLiteDatabase）在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。 onUpgrade（SQLiteDatabase，int，int）当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。 onOpen（SQLiteDatabase）这是当打开数据库时的回调函数，一般在程序中不是很常使用。 在构造函数中创建数据库12345678910// 数据表名 private static final String TABLE_NAME = &quot;userlog.db&quot;; public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public MyDatabase(Context context, int version) &#123; this(context, TABLE_NAME, null, version); &#125; 在onCreate方法中创建数据表数据库数据类型：NULL：null值INTEGER：整数，1、2、3、4、6、8字节REAL：浮点值，8字节TEXT：字符串BLOB：blob数据DATE：日期 年月日TIME：时刻 时分秒 1234567@Override public void onCreate(SQLiteDatabase db) &#123; Log.d(TAG, &quot;onCreate: onCreate&quot;); String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;; db.execSQL(sql); &#125; 然后在需要建表的实话，初始化一个该java类实例即可 增删改查增加 insert 一条数据1、使用sql语句插入一条数据12String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;db.execSQL(sql); 但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’ 此时应该使用 ? 替代符，如下：1234567891011public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123; SQLiteDatabase db = getWritableDatabase(); StringBuilder sql = new StringBuilder(); sql.append(&quot;insert into &quot;) .append(table_name) .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;); Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;; Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString()))); db.execSQL(sql.toString(), values); db.close();&#125;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ValueAnimator]]></title>
    <url>%2Fblog%2F2019%2F10%2FValueAnimator.html</url>
    <content type="text"><![CDATA[属性动画 ValueAnimator]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas 中的方法]]></title>
    <url>%2Fblog%2F2019%2F10%2Fcanvas-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[canvas 中的一些方法在canvas中一般使用的方法为drawXXX(): 绘制的方法clipXXX(): 裁剪的方法 clipRect裁剪画布，clipRect(int left, top, right, bottom);clipRectF(float left, top, right, bottom) 当执行了该方法，如clipRect(0,0,500,500);则后面都只能在(0,0,500,500)区域绘制 用Rect实现多区域裁剪intersect 交集】12345678Rect rect = new Rect(0, 0, 500, 500); rect.intersect(250, 250, 750, 750); canvas.clipRect(rect);// 取到区域(250, 250, 500, 500) 绘制多个区域相交的区域 union 合集12345678Rect rect = new Rect(0, 0, 500, 500); rect.union(250, 250, 750, 750); canvas.clipRect(rect);// 取到的区域为(0, 0, 750, 750) 绘制多个区域之和 clipPath 取出某个区域12345678910111213// 实例化路径mPath = new Path();// 移动起点至[50,50]mPath.moveTo(50, 50); mPath.lineTo(75, 23); mPath.lineTo(150, 100); mPath.lineTo(80, 110); // 闭合路径mPath.close();// 按照路径进行裁剪canvas.clipPath(mPath); 即是将path区域裁剪出来同样后面在能在该path区域绘制图形 Region.Op]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashMap解析]]></title>
    <url>%2Fblog%2F2019%2F09%2FhashMap%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[HashMap源码分析Hash内部类Node：Node(节点)，链表中的节点，当HashMap数据少于6条时，为链表结构，Node为其中的节点。链表数据结构，每一个节点都记录下一个节点的地址。在Node的构造函数中，直接包含了下一个节点，1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; // 将下一个节点作为入参放入构造函数中 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; .... 获取某个节点12345678910111213141516171819202122232425262728293031 public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 当为树结构的时候 if (first instanceof TreeNode) // 获取树形结构中某个节点 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 遍历链表结构 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级rn版本适配android64]]></title>
    <url>%2Fblog%2F2019%2F08%2F%E5%8D%87%E7%BA%A7rn%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8Dandroid64.html</url>
    <content type="text"><![CDATA[google play在2019/08/01起实施强制支持64位手机的措施。 因为之前的version为0.55.4,到0.59.1版本更新太多，采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava + Retrofit 实现BaseResult]]></title>
    <url>%2Fblog%2F2019%2F07%2FRxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html</url>
    <content type="text"><![CDATA[Rxjava + Retrofit 实现BaseResult最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。答案肯定是可以的。本文只讲使用。 依赖：12345implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos; 普通使用案例首先创建实体数据类Test 1234567891011121314public class Test &#123; private static final String TAG = &quot;=====TEST&quot;; String key = &quot;&quot;; String test = &quot;&quot;; public void log() &#123; Log.d(TAG,&quot;key=&quot; + key); Log.d(TAG, &quot;test=&quot; + test); &#125;&#125; 在写一个接口TestServer，申明请求 1234public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用请求1234567891011121314151617181920212223242526272829303132private void testService() &#123; // 实例化一个Retrofit 对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.1.42:8080/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); TestServer service = retrofit.create(TestService.class); service.getObJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Test&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Test test) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125; 开发考虑我们不可能每个请求都重新创建一个Retrofit对象，而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。 1、写一个result实体类1234567891011121314151617181920212223242526272829303132// 因为每一个接口返回的数据结构都不同，肯定要用泛型。public class Result&lt;T&gt; &#123; private final String TAG = &quot;Result ====&quot;; private String msg; private String code = &quot;0&quot;; private T data; public void logCode() &#123; Log.d(TAG, code); &#125; public long getLongCode() &#123; long resultCode = 0; if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123; resultCode = Long.parseLong(code); &#125; return resultCode; &#125; public void log() &#123; Log.d(TAG, &quot;msg:&quot; +msg + &quot;\n code:&quot; + code + &quot;\n data:&quot; + data); &#125; public T getResultData() &#123; return data; &#125;&#125; 注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论 然后需要写一个BaseObserver观察者基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里还是因为接口返回数据格式问题，使用泛型。public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123; private final String TAG = &quot;====BaseObserver===&quot;; /** * 请求成功 * @param t */ public abstract void onSuccess(T t); /** * 当返回的code值错误时的默认方法 * @param code */ public void onResultCodeErr(long code) &#123; Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code); &#125; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(Result result) &#123; if(result.getLongCode() != 200) &#123; onResultCodeErr(result.getLongCode()); &#125; else &#123; onSuccess((T)result.getResultData()); &#125; result.log(); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); Log.d(TAG, e.getMessage()); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125;&#125; 然后我们的Server类就变成了如下：123456789public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson(); @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用就变成了这样： 1234567891011121314151617BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123; @Override public void onSuccess(Test test) &#123; Log.d(&quot;======&quot;, &quot;onSuccess&quot;); test.log(); &#125; &#125;; /** Retrofit + Rxjav */ private void testRxjavaService() &#123; Retrofit retrofit = RetrofitUtil.getRetrofit(); TestService ts = retrofit.create(TestService.class); ts.getTestRxjavaJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（三）布局组件]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[Flutter入门（三）布局组件之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！ 查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍 ui组件学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。 Text123456789101112131415Text( &apos;要显示的文本&apos;, &#123; textAlign: TextAlign.center, // 文本横向对齐方式 居中 overflow: TextOverflow.ellipsis, // 文本溢出处理方式 textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left) softWrap: true, // 是否自动换行 textScaleFactor: 2.0, // 字体显示倍率 maxLines: 1, // 文本最大行数 style: new TextStyle( color: Colors.purple, fontSize: 20.0, ), // 文本样式 &#125;)]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter入门 vscode调试及查看日志]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[flutter入门 vscode调试及查看日志开发肯定需要调试应用，以及查看日志。 在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。 还有一个print()函数，最终发现这个是可以的。 情景再现a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。 b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出 c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出 正确方法print()日志输出函数通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出 ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。 用vscode调试flutetr一个正常的flutter项目用vscode应该是这样的。之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。 点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目 我打了一个断点，当项目运行起来，如下图。 当我点击按钮，进入断点。如下图可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。 添加断点点击代码左侧的红框区域即可（下图）。 在左上角的调试/新建断点 也可以。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用在上一篇中我们利用android studio运行了一个hello word项目。作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。 ###1、配置插件需要在vscode中下载插件找到这两个插件下载好并重新加载vscode就可以了。 ###2、运行flutter项目的运行命令是 flutter run但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。 在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。还有有一些提示信息 当你需要热加载的时候按 r，需要重启应用按R。所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。 ###3、写第一个flutter应用。按照flutter中文网（https://flutterchina.club/get-started/codelab/）写我们第一个flutter应用。其中我个人碰到一个问题。就是在第2步、使用外部package中， 在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。然后重新打开vscode才好，应该是vscode对这个以来的读取问题。 然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。 ###个人体会 flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼 fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。没有对state这个做解释、没有state的使用说明，然后那个路由也是。 ##待续]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（一）环境配置]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Flutter入门（一）环境配置在/flutter/bin目录下执行 flutter doctor命令。 3、android studio插件下载android studio就不说了，打开android studio/file/setting/plugin/输入 flutter查找并install。第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。 在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project hello word按照惯例，接下来我们跑一个hello world。 照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。 项目目录 项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。 运行点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行 第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter数据持久化]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
    <content type="text"><![CDATA[flutter数据持久化shared_preferences本地存储临时数据此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。 添加插件依赖： 123456// 在pubspec.yaml文件中添加依赖dependencies: flutter: sdk: flutter shared_preferences: &quot;&lt;newest version&gt;&quot; 调用： shared_preference 存储方式是根据key-value形式使用便捷，但有限制： a: 只能使用原始类型: int，double，bool，string 和 string list。 b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。 1234567891011import &apos;package:shared_preferences/shared_preferences.dart&apos;;getAsyncData() async &#123; // 获取实例 var prefs = await SharedPreferences.getInstance(); // 获取存储数据 var count = prefs.getInt(&apos;count&apos;) ?? 0 + 1; // 设置存储数据 await prefs.setInt(&apos;count&apos;, count);&#125;]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dart语言语法糖]]></title>
    <url>%2Fblog%2F2019%2F07%2Fdart%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
    <content type="text"><![CDATA[dart语言语法糖a、 以 _命名的变量或函数为强制私有 var _num; b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式 1234int getInt() =&gt; 2;int getInt() =&gt; isTrue ? 2 : 0; c、 运算符 aa ?? bb; ?? 为null 时 d、异步 async await then async、await使用与rn中使用方式一致 .then也是异步操作 12345678910111213141516171819202122232425/// 设置需要填写的内容 _setDefaultData(List&lt;dynamic&gt; list) &#123; Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;); List&lt;dynamic&gt; list1 = []; /// 对jsonStr数据做解析 jsonStr.then((value) &#123; var data = json.decode(value); if(list != null || list.length &gt; 0) &#123; data = list; &#125; print(&apos;data ====&apos; + data.toString()); data.forEach((item) &#123; if(item[&apos;type&apos;] == &apos;1&apos;) &#123; list1.add(item); &#125; &#125;); &#125;); print(&apos;list1======&apos; + list1.toString()); this.setState(() &#123; this.saveList = list1; &#125;); &#125; 如图这种代码会先输出list1的信息，然后在输出data的信息说明jsonStr.then 为异步操作]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter android端 原理解析]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter-android%E7%AB%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[flutter android端 原理解析首先看MainActivity， 继承FlutterActivity 再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory 12345678910111213141516private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);private final FlutterActivityEvents eventDelegate;private final Provider viewProvider;private final PluginRegistry pluginRegistry;public FlutterActivity() &#123; this.eventDelegate = this.delegate; this.viewProvider = this.delegate; this.pluginRegistry = this.delegate;&#125;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.eventDelegate.onCreate(savedInstanceState);&#125; 一看delegate就知道代理模式 在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值， FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。 FlutterActivityDelegate 就是FlutterActivityEvents类的实现. 看FlutterActivityDelegate类中的onCreate函数 123456789101112131415161718192021222324252627282930public void onCreate(Bundle savedInstanceState) &#123; if (VERSION.SDK_INT &gt;= 21) &#123; Window window = this.activity.getWindow(); window.addFlags(-2147483648); window.setStatusBarColor(1073741824); window.getDecorView().setSystemUiVisibility(1280); &#125; String[] args = getArgsFromIntent(this.activity.getIntent()); FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args); this.flutterView = this.viewFactory.createFlutterView(this.activity); if (this.flutterView == null) &#123; FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView(); this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView); this.flutterView.setLayoutParams(matchParent); this.activity.setContentView(this.flutterView); this.launchView = this.createLaunchView(); if (this.launchView != null) &#123; this.addLaunchView(); &#125; &#125; if (!this.loadIntent(this.activity.getIntent())) &#123; String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext()); if (appBundlePath != null) &#123; this.runBundle(appBundlePath); &#125; &#125; &#125; 首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。 android端与dart端通信1、dart端调用android端代码1、原生android代码新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。 重写onMethodCall方法，在此处写需要实现的逻辑代码 最后是将插件绑定。 12345678910111213141516171819202122232425262728293031323334public class TestPlugin implements MethodChannel.MethodCallHandler &#123; public static final String CHANNEL = &quot;plugin/test&quot;; static MethodChannel channel; // 上下文 private Activity activity; private TestPlugin(Activity activity) &#123; this.activity = activity; &#125; public static void registerWith(PluginRegistry.Registrar registrar) &#123; channel = new MethodChannel(registrar.messenger(), CHANNEL); TestPlugin plugin = new TestPlugin(registrar.activity()); // 在此通道上接受方法调用的回调 channel.setMethodCallHandler(plugin); &#125; @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123; if(methodCall.method.equals(&quot;test&quot;)) &#123; Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show(); result.success(&quot;调用成功&quot;); &#125; // 当未找到该函数 result.notImplemented(); &#125;&#125; 在MainActivity中绑定 1234567891011121314151617public class MainActivity extends FlutterActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); registerPlugin(this); &#125; private void registerPlugin(PluginRegistry registry) &#123; TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL)); &#125;&#125; 2、在dart中调用该原生方法1234567static const _platform = const MethodChannel(&apos;plugin/test&apos;);_toast() &#123; /// 调用原生的方法 _platform.invokeMethod(&apos;test&apos;); &#125; 一个原生插件调用就完成了。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook推广api 推广主页]]></title>
    <url>%2Fblog%2F2019%2F07%2Ffacebook%E6%8E%A8%E5%B9%BFapi-%E6%8E%A8%E5%B9%BF%E4%B8%BB%E9%A1%B5.html</url>
    <content type="text"><![CDATA[主页推广]]></content>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2Fblog%2F2019%2F07%2Fmaven.html</url>
    <content type="text"><![CDATA[mavenmaven 查看依赖树mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXXcode xxx // 打开xxx文件 gradle 查看依赖树gradle app:dependency // 查看依赖树关系]]></content>
  </entry>
  <entry>
    <title><![CDATA[react发布到javaweb]]></title>
    <url>%2Fblog%2F2019%2F07%2Freact%E5%8F%91%E5%B8%83%E5%88%B0javaweb.html</url>
    <content type="text"><![CDATA[react项目发布到javaweb中1、打包react直接执行npm run build命令：发现在build目录下生成资源文件，但是打开index.html发现报错，发现在生成的index.html中引入的文件路径有问题：/static /多余，或者说少了. 正确的路径应该是：static 或者 ./static 发现是%PUBLIC_URL%问题，在构建时应该执行 PUBLIC_URL=./ npm run build 2、集成到javaweb中将上一步生成build目录下的文件都复制放在webapp路径下，启动应用就能直接访问到index.html文件]]></content>
      <tags>
        <tag>react+spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook 营销api集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-%E8%90%A5%E9%94%80api%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[facebook 营销api集成营销api需要通过后端服务器与facebook服务器交互 1、下载营销api java代码git clone https://github.com/facebook/facebook-java-business-sdk.git 编辑器：IDEA 123456789101112// 在pom.xml中添加依赖&lt;dependency&gt; &lt;groupId&gt;com.facebook.business.sdk&lt;/groupId&gt; &lt;artifactId&gt;facebook-java-business-sdk&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;插件maven-source-plugin 无法下载因缺失版本号添加&lt;version&gt;3.1.0&lt;/version&gt;// 解决idea报错在&lt;build&gt;&lt;/build&gt;标签内添加&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;在&lt;plugins&gt;&lt;/plugins&gt;标签外套一个标签&lt;pluginManagement&gt;&lt;/pluginManagement&gt; 添加java文件123456789101112131415161718192021222324252627282930import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;import com.facebook.ads.sdk.APIException;public class QuickStartExample &#123; public static final String ACCESS_TOKEN = &quot;[Your access token]&quot;;//Your access token public static final Long ACCOUNT_ID = 123456789L; //Your account ID public static final String APP_SECRET = &quot;[Your app secret]&quot;;//Your app secret public static final APIContext context = new APIContext(ACCESS_TOKEN, APP_SECRET); public static void main(String[] args) &#123; try &#123; System.out.println(&quot;==========&quot;); AdAccount account = new AdAccount(ACCOUNT_ID, context); Campaign campaign = account.createCampaign() .setName(&quot;Java SDK Test Campaign&quot;) .setObjective(Campaign.EnumObjective.VALUE_LINK_CLICKS) .setSpendCap(10000L) .setStatus(Campaign.EnumStatus.VALUE_PAUSED) .execute(); System.out.println(campaign.fetch()); &#125; catch (APIException e) &#123; e.printStackTrace(); &#125; &#125;&#125; or 123456789101112131415161718192021222324import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.APINodeList;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;public class TestFBJavaSDK&#123; public static final APIContext context = new APIContext( &quot;your-access-token&quot;, &quot;your-appsecret&quot; ); public static void main(String[] args) &#123; AdAccount account = new AdAccount(&quot;act_&#123;your-adaccount-id&#125;&quot;, context); try &#123; APINodeList&lt;Campaign&gt; campaigns = account.getCampaigns().requestAllFields().execute(); for(Campaign campaign : campaigns) &#123; System.out.println(campaign.getFieldName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行java文件既可发布请求到facebook服务器， 需要安全上网 1、主页推广根据提示一步一步提交，到 沙盒账号，如果之前没有添加则新建，要推广的主页，如果无则新建 到下载示例代码，点下载，将会获得一个java文件，里面含有accessToken、appid、ad_account_id、app_secret等信息，将该下载的SAMPLE_CODE.java文件放于与上面两个java文件同级目录，直接运行该java文件即可，注意此时电脑需要科学上网，不然会报错Timeout]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook sdk 集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-sdk-%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[Facebook sdk 集成首先需要在facebook注册一个账号，自通过账号进入facebook的开发者平台 创建应用，只需要填写应用名即可，回生成一个appid。 集成事件功能1、配置远端maven仓库地址 在项目android/build.gradle文件123456789101112131415buildscript&#123; repositories&#123; ... mavenCentral(); // 添加这行 &#125;&#125;allprojects&#123; repositories &#123; ... mavenCentral() // 添加这行 &#125;&#125; 2、添加依赖在app/build.gradle文件中添加依赖123456dependencies&#123; ... implementation &apos;com.facebook.android:facebook-android-sdk:[4,5)&apos; // 添加这行 // 最新sdk版本为 implementation &apos;com.facebook.android:facebook-android-sdk:[5,6)&apos; &#125; 3、添加facebook-app-id在res/values/string.xml中1234&lt;string name=&quot;facebook_app_id&quot;&gt;462119014332748&lt;/string&gt; &lt;string name=&quot;fb_login_protocol_scheme&quot;&gt;fb462119014332748&lt;/string&gt;// 462119014332748为你在facebook应用的appid// fb_login_protocol_scheme应该是用于登陆的 在/app/manifest/AndroidManifest.xml中12345678910111213141516&lt;application&gt; &lt;meta-data android:name=&quot;com.facebook.sdk.ApplicationId&quot; android:value=&quot;@string/facebook_app_id&quot;/&gt; &lt;activity android:name=&quot;com.facebook.FacebookActivity&quot; android:configChanges= &quot;keyboard|keyboardHidden|screenLayout|screenSize|orientation&quot; android:label=&quot;@string/app_name&quot; /&gt; &lt;activity android:name=&quot;com.facebook.CustomTabActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;@string/fb_login_protocol_scheme&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 4、在facebook开发者控制台配置analytics sdk在facebook开发者官网，点击「我的应用」即可进入应用控制台，可以创建应用，只需提供应用名，以及邮箱即可， 点击单个应用即可进入应用控制台进行编辑;上图是应用可添加的功能， 点击Analytics即将功能添加进应用，点设置，前几步都是提示，第四步，填入应用id，app/build.gradle中的applicationid，以及应用默认启动的Actiivty， 第五步，填入密钥散列，注意应该要填入两个，一个开发、一个发布，即debug自带的、一个release时通过jks文件签名生成的。获取方法12345// macos debug ，按下enter键需要输入开机密码keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64// release keytool -exportcert -alias YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl base64 5、发送事件 上面的1、2、3都只是基本配置，下面是手动发送事件 在MainApplication.java中FacebookSdk.sdkInitialize 四个初始化方法都已被遗弃， 看到说是不需要初始化了 在MainApplication.java中 12345678910@Override public void onCreate() &#123; super.onCreate(); // facebook 初始化 FacebookSdk.setIsDebugEnabled(true); AppEventsLogger.activateApp(MainApplication.this); FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS); &#125; 注意facebooksdk回自动收集一些事件,如果不需要自动收集功能需要在清单文件中配置 1234&lt;meta-data android:name=&quot;com.facebook.sdk.AutoLogAppEventsEnabled&quot; android:value=&quot;false&quot;/&gt; 在Actiivty中测试发送自定义事件 123456789101112@Overrideprotected void onResume() &#123; super.onResume(); logEvent();&#125;private void logEvent() &#123; Log.d(&quot;========&quot;, &quot;logEvent&quot;); AppEventsLogger logger = AppEventsLogger.newLogger(this); logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP); logger.logEvent(&quot;Test Event&quot;);&#125; 在测试时发现，当打断点调试时发现，发送事件总是会失败，正常运行却可以在facebook分析工具中看得到提交的事件。 后续：在sdk集成后，可以看到之前定义的事件数据。但是在连接商务平台，想要发布广告时。需要通过自己的事件来定义受众、或者定义类似受众时发现，在商务平台无法获取到自定义事件的数据。甚至都无法获取到我们的应用。后来看官方文档，发现出了自定义事件、自动收集的事件，还有一个标准事件。在我添加了一个标准事件后，就在商务平台上能找到在开发平台提交的app了。但是那些自定义受众、类似受众功能貌似只能绑定到 facebook定义的标准事件，而不能是我们自己的自定义事件 注意，运行时手机需要能连接到facebook后台服务器，大陆用户需要科学上网。]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android okHttp3]]></title>
    <url>%2Fblog%2F2019%2F06%2Fandroid-okHttp3.html</url>
    <content type="text"><![CDATA[OkHttp3使用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode的常用插件与插件开发]]></title>
    <url>%2Fblog%2F2019%2F04%2Fvscode%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。 nodejs123456curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash. ~/.bashrc#显示有远端的版本nvm ls-remote#安装对应的版本nvm install 对应的版本 安装常用工具： 1234567891011npm install hexo-cli -gnpm install hexo-server -gnpm install hexo-deployer-git -gnpm install yarn -gnpm install http-server -gyarn global add servenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalyarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 常用插件安装以下插件：12345678910111213141516171819202122232425262728293031323334#javascripteslintColor PickernpmDebugger for ChromeEclipse Keymap#reactES7 React/Redux/GraphQL/React-Native snippets#vueVeturVue VSCode Snippets#gitGitLenszerofinance-git#其他公共插件Local HistoryXML ToolsPrettier#https://zhuanlan.zhihu.com/p/54031899koroFileHeaderAutoFileNameImport Cost#javaJava Extension PackSpring Boot Extension PackJava Code GeneratorsDocker#android/ios pluginAndroid iOS EmulatorReact Native Tools#see debug:https://github.com/Microsoft/vscode-react-native/blob/master/doc/debugging.md#debugging-on-ios-device#Install ios-deploy: npm install -g ios-deploy 代码注释koroFileHeader添加注释，在全局的settings.json中添加： 参考： https://code.visualstudio.com/docs/editor/emmet https://www.cnblogs.com/summit7ca/p/6944215.html 12345678910111213141516171819202122232425262728"editor.fontSize": 14,"terminal.integrated.fontSize": 14,"emmet.triggerExpansionOnTab": true,"emmet.includeLanguages": &#123; "javascript": "javascriptreact", "vue-html": "html", "razor": "html", "plaintext": "jade"&#125;,// 注释"fileheader.configObj": &#123; // 将该选项设置为true即可开启 "autoAdd": false&#125;,// 头部注释"fileheader.customMade": &#123; "Author": "dave.zhao", "Date": "Do not edit", "LastEditors": "dave.zhao", "LastEditTime": "Do not edit", "Description": ""&#125;,// 函数注释"fileheader.cursorMode": &#123; "Date": "Do not edit", "description": "", "param": ""&#125; 注意：Author和LastEditors填写自己的名字 文件头注释快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i 函数注释快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t 常用配置可以放在全局的settings.json中，也可以放在各个项目的settings.json中： 1234567891011121314151617181920&#123; "eslint.validate": ["javascript", "javascriptreact"], "javascript.updateImportsOnFileMove.enabled": "always", // 代码缩进修改成4个空格 "editor.detectIndentation": false, "editor.tabSize": 4, "editor.formatOnSave": true, // 每次保存的时候将代码按eslint格式进行修复 "eslint.autoFixOnSave": true, // 让prettier使用eslint的代码格式进行校验 "prettier.eslintIntegration": true, // 去掉代码结尾的分号 "prettier.semi": false, // 使用带引号替代双引号 "prettier.singleQuote": true, "prettier.tabWidth": 4, "prettier.printWidth": 250, // 让函数(名)和后面的括号之间加个空格 "javascript.format.insertSpaceBeforeFunctionParenthesis": true&#125; 插件开发参考代码https://github.com/zhaoxunyong/vs-code-git-plugin 参考 https://segmentfault.com/a/1190000008968904 https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://github.com/steveukx/git-js https://www.jianshu.com/p/2b096d8ad9b8 https://github.com/Microsoft/vscode-extension-samples https://www.jianshu.com/p/520c575e91c3 https://segmentfault.com/a/1190000017279102 https://segmentfault.com/a/1190000014758981 https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
