<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java volatile关键字]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-volatile%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java wait方法]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-wait%E6%96%B9%E6%B3%95.html</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java join方法]]></title>
    <url>%2Fblog%2F2020%2F08%2Fjava-join%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续如在main线程调用t.join(),则会阻塞main线程直到t线程执行完。 而join()函数参数，当调用为t.join(2000),代表阻塞2000毫秒, 当2000毫秒完后，main线程会向下执行，但也有例外，join(millis)如在t线程使用 synchronized时，则必须等到synchronized包裹的代码块执行完并传递的millis毫秒后，t.join()的调用线程才会向下执行。 12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; super.run();// synchronized (currentThread()) &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;休眠&quot; + i); &#125; System.out.println(&quot;线程结束&quot;);// &#125; &#125; &#125;; long start = System.currentTimeMillis(); thread.start(); try &#123; thread.join(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;main线程结束&quot;); System.out.println(System.currentTimeMillis() - start); &#125;&#125; 输出结果： main线程结束1005休眠0休眠1休眠2休眠3休眠4线程结束 将thread.join(1000) 改为2000 时，输出结果如下：休眠0main线程结束2005休眠1休眠2休眠3休眠4线程结束 将上面代码synchronized 注释放开后再运行，输出结果如下：休眠0休眠1休眠2休眠3休眠4线程结束main线程结束5011 查看join方法源码12345678910111213141516171819202122232425262728293031/** * Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever. 当为0时，会一直阻塞调用join函数的线程，直到调用join函数的对象线程执行完毕 */public final synchronized void join(long millis) throws InterruptedException &#123; // 获取当时系统时间 long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; // 当传过来的入参时间小于0，抛出异常 throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (millis == 0) &#123; // 当等于0时，只要线程未执行完毕，则一直阻塞 while (isAlive()) &#123; // 当前线程未执行完一直阻塞 wait(0); &#125; &#125; else &#123; // 当时间大于0 while (isAlive()) &#123; // 当前线程还未执行完，则一直循环获取时间，阻塞调用线程到时间结束 long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 注意：wait()是运行在调用线程的，如在main线程中调用t.join();则join()函数的调用线程是main线程，wait()也是运行在main线程的，所以阻塞main线程，而t才是join()的调用对象线程，isAlive也是判断的t线程是否执行完毕，只有在t线程执行完毕，isAlive才为false]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 指纹验证]]></title>
    <url>%2Fblog%2F2020%2F08%2Fandroid-%E6%8C%87%E7%BA%B9%E9%AA%8C%E8%AF%81.html</url>
    <content type="text"><![CDATA[android 指纹识别android API 23时新增的功能，指纹识别 主要类：FingerpringManager 在API28后，FingerpringManager被遗弃，使用BiometricPrompt，此时授权识别的弹窗不能自定义，只能使用官方统一弹窗，只能设置各个授权文案。各个开发商内部实现可能不一致。 通过只是使用指纹识别，直接使用官方api即可，但出于安全或业务场景需求，很多都需要去检测生物库信息是否变更，如指纹库在重新指纹识别前是否发生变更，这个官方api就没有提供方法，需要我们自己实现。 检测指纹库是否发生变更参考：通过检测密钥查看是否变更(https://www.jianshu.com/p/dbb1a43cfb21) 在API28以前，指纹库信息时可以通过反射获取，获取的信息有指纹id、groupId、指纹名称、指纹个数、设备id等等， 12345678910111213141516if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; Log.d(TAG, &quot;getFingerPrintInfo: &quot;); FingerprintManager fingerprintManager = (FingerprintManager) getCurrentActivity().getSystemService(Context.FINGERPRINT_SERVICE); try&#123; Class clz = Class.forName(&quot;android.hardware.fingerprint.FingerprintManager&quot;); Method method = clz.getDeclaredMethod(&quot;getEnrolledFingerprints&quot;, new Class[]&#123;&#125;); method.setAccessible(true); Object obj = method.invoke(fingerprintManager, null); if (obj != null) &#123; Log.e(TAG, &quot;objStr:&quot; + JsonUtils.toJson(obj)); List&lt;FingerprintBean&gt; list = (List&lt;FingerprintBean&gt;) JsonUtils.fromJson(objStr, new TypeToken&lt;List&lt;FingerprintBean&gt;&gt;()&#123;&#125;.getType()); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 而FingerprintBean是这样的：123456789public class FingerprintBean implements Serializable &#123; private static final long serialVersionUID = 1L; private long mDeviceId; private long mFingerId; private long mGroupId; private String mName;&#125; 最理想的方式是我们反射获取到这些指纹库信息，然后将这些信息保存到本地，每次调用指纹识别时，获取当前指纹库信息与之前的指纹库信息比较，只有不同即可判定指纹库信息变更，但在实际操作中，发现在手机上获取到的指纹id只是简单的1、2、3即指纹库里的排列顺序，而指纹名称是可以随意更改，groupId、deviceId都为0，如果使用这些信息去校验，错误率太高。 还有一种方式即是上面参考链接中的，检测指纹库密钥信息是否变更 但在上面链接那种方法中，有几个问题：1、增加、删除指纹无法检测2、使用修改指纹的手指识别后才能检测出修改 于是将反射、密钥检测两者结合，先反射获取指纹库信息，只是比较指纹库指纹个数，先判断指纹个数是否发生变更，就可知道指纹库信息变更了如果指纹个数没有变更，再来校验密钥是否发生变化]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin (二)]]></title>
    <url>%2Fblog%2F2020%2F07%2Fkotlin-%E4%BA%8C.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fblog%2F2020%2F07%2Fandroid-%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画]]></content>
  </entry>
  <entry>
    <title><![CDATA[android 动画]]></title>
    <url>%2Fblog%2F2020%2F07%2Fandroid-%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[android动画动画分为两类，传统动画、属性动画 传统动画传统动画又分为帧动画、补间动画 帧动画是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。有点类似与gif 将图片资源放入到drawable文件夹在drawable下新建资源文件 drawable1.xml 类型：animation-list 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;1000&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;1000&quot; /&gt;&lt;/animation-list&gt; android:drawable 指的是要显示的图片资源android:duration: 图片显示时长 还有一些其它参数 在Activity中调用1234imageView = findViewById(R.id.imageView);imageView.setImageResource(R.drawable.image);AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();drawable.start(); 这样就可以让四张图片动起来了。 这样就是一个帧动画的简单样例 补间动画补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。 补间动画可以通过xml、或者代码形式实现。 xml实现补间动画alpha在res/anim下新建文件alpha_anime.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; android:duration=&quot;1000&quot; android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:repeatMode=&quot;restart&quot; android:repeatCount=&quot;infinite&quot; /&gt; 在Activity中123Animation animation = AnimationUtils.loadAnimation(this.getApplicationContext(), R.anim.alpha_anime);ImageView alphaImage = findViewById(R.id.alphaImageView);alphaImage.startAnimation(animation); 这样就能实现图片渐隐的无限循环效果]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android MVP]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-MVP.html</url>
    <content type="text"><![CDATA[MVPandroid MVP是一种开发架构，由MVC演化而来，因为在MVC中，Activity层，糅合逻辑、ui操作，显得臃肿、混乱。 在MVP中， M：model，数据层 V：View，页面操作 P：Present，M、V的桥接，逻辑操作 MVP的优势 1、代码简洁，逻辑清晰 2、解耦，便于维护 因为MVP将逻辑与视图分离，降低了业务耦合，使得整个代码层次分明，所以也就更好维护 下面以登陆做一个示例]]></content>
      <tags>
        <tag>andorid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android MVVM]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-MVVM.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[android 高级ui]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E9%AB%98%E7%BA%A7ui.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[android 图片加载]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD.html</url>
    <content type="text"></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 网络请求框架]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 序列化]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    <content type="text"><![CDATA[android序列化什么是序列化将java对象转化为二进制过程，就是序列化，将二进制转化为java对象的过程，就是反序列化 为什么要序列化在下面几种场景下我们需要序列化 永久性保存对象，保存对象的字节序列到本地文件中； 对象在网络中传递； 对象在IPC间传递（进程通信） 如何序列化序列化有两种方法，java中自带的实现Serializable，android中特有的Parcelable Serializable新建类实现Serializable，Serializable为空接口，没有要实现的方法， 需要 定义一个静态常量serialVersionUID 1234567891011121314public class SerBean implements Serializable &#123; private static final long serialVersionUID = 263894729013938L; private String name; private int age; public SerBean(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 这样这个类的序列化就完成了。 Parcelable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ParBean implements Parcelable &#123; private String name; private int age; // 系统自动添加，给createFromParcel里面用 protected ParBean(Parcel in) &#123; name = in.readString(); age = in.readInt(); &#125; public static final Creator&lt;ParBean&gt; CREATOR = new Creator&lt;ParBean&gt;() &#123; /** * * @param in * @return *createFromParcel()方法中我们要去读取刚才写出的name和age字段， * 并创建一个Person对象进行返回，其中color和size都是调用Parcel的readXxx()方法读取到的， * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。 * 读取的工作我们利用一个构造函数帮我们完成了 * */ @Override public ParBean createFromParcel(Parcel in) &#123; return new ParBean(in); &#125; //供反序列化本类数组时调用的 @Override public ParBean[] newArray(int size) &#123; return new ParBean[size]; &#125; &#125;; // 内容接口描述，默认返回0即可。 @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); // 写出name dest.writeInt(age); // 写出age &#125; // --------下面为自己写的构造函数和get set public ParBean() &#123; &#125; public ParBean(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 序列化方案区别上面讲了两个序列化方案，Serializable：是java就有的，代码量少，但在序列化时，会产生大量的临时对象，容易造成频繁的minor GC Parcelable：android特有的，代码量比Serializable要多，但使用效率高，且没那么占内存 因为在选择序列化时，优先使用Parcelable，但有一种情况特殊，当数据保存在磁盘上时，Parcelable在外界有变化的情况下，不能很好的保证数据的连续性，因此在此种场景下推荐使用Serializable； 序列化某种程度来说并不安全 因为序列化的对象数据转换为二进制，并且完全可逆。但是在RMI调用时所有private字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的 解决方案1、 序列化Hook化（移位和复位）2、 序列数据加密和签名3、 利用transient的特性解决4、 打包和解包代理 补充 static和transient字段不能被序列化（感兴趣的同学可以深入研究下）]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin]]></title>
    <url>%2Fblog%2F2020%2F05%2Fkotlin.html</url>
    <content type="text"><![CDATA[kotlin学习hello world新建一个kt文件， 1234fun main(args:Array&lt;String&gt;) &#123; println(&quot;Hello world!&quot;);&#125; 程序主入口main方法， 无需新建类即可运行，函数声明用fun 123fun sum(a:Int, b:Int):Int&#123; return a + b;&#125; 返回值写在参数之后 表达式可以作为函数体，返回值类型自动推断1fun sun(a:Int, b:Int) = a+b; 返回无意义的值用Unit表示 fun test():Unit { println(“test”);} 变量赋值变量赋值声明关键字：var、valvar：声明变量val：声明常量 var i:Int = 1;val PI:Double = 3.14; 当声明并赋值时，数据类型可以省略, 会自动推断数据类型var i = 1;val PI = 3.14 当声明但不赋值时，不能省略数据类型var i:Int;val PI:Double; 字符串模板123var s = &quot;aaaaa&quot;;var b = &quot;str = $s&quot;;var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot; 条件表达式1234fun testIf(a:Int, b:Int):Int &#123; if(a &gt; b) return a; return b;&#125; 在kotlin中，if还可以用作表达式 1fun max(a:Int, b:Int) = if(a &gt; b) a else b 空值与null检测当某个值可以为空时，需要在类型后添加?表示可以为空此时，声明时不能省略类型12345var obj:Objects ? = null;// 表示返回值可以为nullfun parseInt(str:String):Int?&#123; ...&#125; 类型检测与自动类型转换is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换 123456789fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String return obj.length &#125; // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null&#125; 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 for循环12345678910var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);// 根据元素遍历for (item in items) &#123; println(item);&#125;// 根据下标便利for (item in items.indices) &#123; println(items[item]);&#125; while 循环12345var index = 0;while (index &lt; items.size) &#123; println(items[index]); index ++;&#125; when表达式123456789101112private fun testWhen(s: Any?) &#123; when(s) &#123; &quot;a&quot; -&gt; 1; &quot;b&quot; -&gt; 2; is String -&gt; 3; 1 -&gt; &quot;n&quot;; 2 -&gt; &#123; println(&quot;222&quot;); &#125;; else -&gt; &quot;else&quot;; &#125; &#125; 有点类似java中的 switch 区间 range12345var x = 6;var y = 9;if(x in 0..y) &#123; println(&quot;x in 0 - y&quot;);&#125; 注意：区间只用于数字 集合集合的迭代可以用的上面的 for in 循环1234var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);for(item in items) &#123; println(item);&#125; 判断集合中是否包含某元素 用while in || when12345678while (&quot;a&quot; in items) &#123; println(&quot;items include a&quot;);&#125;when &#123; &quot;a&quot; in items -&gt; println(&quot;aaa&quot;); &quot;d&quot; in items -&gt; println(&quot;ddd);&#125; 用lambda来过滤和映射集合 ，与java8 lambda stream大致 1234items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125; .sortBy&#123; it &#125; .map&#123; it.toUpperCase() &#125; .forEach&#123; println(it) &#125;]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 掉起摄像头]]></title>
    <url>%2Fblog%2F2020%2F05%2Freact-%E6%8E%89%E8%B5%B7%E6%91%84%E5%83%8F%E5%A4%B4.html</url>
    <content type="text"><![CDATA[在h5中掉起摄像头，碰到一些问题，无法切换到后置摄像头 —-&gt; 将本地http 改为https就可以了chrome浏览器报错：不支持访问用户媒体 —》 将本地http 改为https就可以了 npm start默认采用的是http协议而npm start其实执行的脚本是react-script/start.js文件查看 79行代码1const protocol = process.env.HTTPS === &apos;true&apos; ? &apos;https&apos; : &apos;http&apos;; 我们只要在环境变量中将HTTPS设置为true即可在macos 执行1234567cd ~code .bash_profile添加一行 HTTPS=truesource .bash_profile// 也可以在终端执行export PORT=8081 在 window 新增环境变量 HTTPS true或者在终端执行 set HTTPS=true 本地掉起的摄像头呈现镜像 —-》css 镜像翻转 transform: ‘rotateY(180deg)’ // 水平镜像翻转180 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import React from &apos;react&apos;;import &#123;StyleSheet,css&#125; from &apos;aphrodite/no-important&apos;import &#123; dpw, dph &#125; from &apos;../../common/tool/ScreenFit&apos;;export default class AliveCheck extends React.PureComponent &#123; componentDidMount() &#123; this.video = document.getElementById(&apos;video&apos;); this.canvas = document.getElementById(&apos;canvas&apos;); this.context = this.canvas.getContext(&apos;2d&apos;); const constraints = &#123; audio: false, video : &#123; width: 480, height: 320, sourceId: &apos;default&apos;, facingMode: &#123; exact: &quot;environment&quot; &#125;, // facingMode: &#123; exact: &quot;user&quot; &#125;, permissions: &#123; &quot;audio-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture audio using getUserMedia()&quot; &#125;, &quot;video-capture&quot;: &#123; &quot;description&quot;: &quot;Required to capture video using getUserMedia()&quot; &#125; &#125; &#125; &#125; // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象 if (navigator.mediaDevices === undefined) &#123; navigator.mediaDevices = &#123;&#125;; &#125; if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123; //调用用户媒体设备, 访问摄像头 this.getUserMedia(constraints, this.success, this.error); &#125; else &#123; alert(&apos;不支持访问用户媒体&apos;); &#125; &#125; //访问用户媒体设备的兼容方法 getUserMedia =(constraints, success, error) =&gt; &#123; if (navigator.mediaDevices.getUserMedia) &#123; //最新的标准API navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error); &#125; else if (navigator.webkitGetUserMedia) &#123; //webkit核心浏览器 navigator.webkitGetUserMedia(constraints,success, error) &#125; else if (navigator.mozGetUserMedia) &#123; //firfox浏览器 navigator.mozGetUserMedia(constraints, success, error); &#125; else if (navigator.getUserMedia) &#123; //旧版API navigator.getUserMedia(constraints, success, error); &#125; &#125; success =(stream) =&gt; &#123; //兼容webkit核心浏览器 let CompatibleURL = window.URL || window.webkitURL; //将视频流设置为video元素的源 console.log(stream); //video.src = CompatibleURL.createObjectURL(stream); this.video.srcObject = stream; this.video.play(); &#125; error =(error)=&gt; &#123; console.log(`访问用户媒体设备失败$&#123;error.name&#125;, $&#123;error.message&#125;`); &#125; takePhoto =() =&gt; &#123; alert(&apos;takePhoto&apos;) this.context.drawImage(this.video, 0, 0, 480, 320); &#125; stopCamera =() =&gt; &#123; if (!this.video.srcObject) return let stream = this.video.srcObject let tracks = stream.getTracks(); tracks.forEach(track =&gt; &#123; track.stop() &#125;) &#125; render() &#123; return( &lt;div className=&#123;css(styles.box)&#125;&gt; &lt;video className=&#123;css(styles.video)&#125; id=&quot;video&quot; width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;/video&gt; &lt;div&gt; &lt;button id=&quot;capture&quot; onClick=&#123;this.takePhoto&#125;&gt;拍照&lt;/button&gt; &lt;/div&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; box: &#123; display: &apos;flex&apos;, width: &apos;100%&apos;, height: &apos;100%&apos;, flexDirection: &apos;column&apos;, &#125;, video: &#123; // 水平镜像翻转180 transform: &apos;rotateY(180deg)&apos;, &#125;&#125;)]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常记录]]></title>
    <url>%2Fblog%2F2020%2F05%2F%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[i++++ 在后，先运算完当前结果，再给i赋值 ex：1234567Object [] obj = new Object [16]i = 0；obj[i ++] = &quot;obj&quot;// 会先执行obj[0]=&quot;obj&quot;;// 再执行i = i + 1; –i;– 在前，则先给i赋值，再执行当前运算]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位操作符]]></title>
    <url>%2Fblog%2F2020%2F05%2F%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.html</url>
    <content type="text"><![CDATA[&amp;逻辑 与A &amp; B将A、B都转化为二进制，同为均为1则为1，否则为0 ex：5 &amp; 80000 0101&amp;0000 1000 result ： 0000 0000 结果就是0 逻辑或A | B将A、B都转化为二进制，同为有一位为1则为1，否则为0ex ： 5 &amp; 80000 0101&amp;0000 1000 result ： 0000 1101 结果就是13 逻辑非 逻辑异或 5&gt;&gt;2 0000 0101 &gt;&gt; 2 — 0000 0001 === 1 像右移2左移运算符，&gt;&gt;&gt; &lt;&lt; 5 &lt;&lt; 2像左移20000 0101 &lt;&lt; 2 – 0001 0100 === 20左移运算符， 无符号移动 无符号右移，忽略符号位，空位都以0补齐]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 枚举]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E6%9E%9A%E4%B8%BE.html</url>
    <content type="text"><![CDATA[枚举enum 的全程事 Enumeration 是jdk1.5引进的 被enum 修饰的数据类型就是枚举类型：1enum Test &#123; TEST0, TEST1, TEST2 &#125; 如果枚举不添加任何方法，枚举值默认为从0开始的递增数值，ru上面的： TEST0：0， TEST1：1，TEST2：2 枚举的好处：可以将常量组织起来，便于管理应用场景：状态码：错误码 枚举的本质枚举的本质是一个类，受限制的类 创建enum是，编译器会自动为你生成一个相关的类，这个类继承 java.lang.Enum b编译过后其实是12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; ... &#125; 是一个抽象类，并且继承了Comparable以及Serializable，也就是标记了序列化 而且枚举可以添加自己的方法、变量，但是不能为枚举常量用 “=”赋值，但不能继承其他类，因为已经继承了Enum类，也不能被继承。 枚举可以实现接口，像上面就是内部实现了两个接口，我们也可以自己实现其他接口 枚举添加方法123456789101112131415public enum TestEnum &#123; //此处调用额其实就是下面写的构造函数 TEST(22), TEST1(33), TEST2(44), TEST3(55); private TestEnum(int num) &#123; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 泛型]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E6%B3%9B%E5%9E%8B.html</url>
    <content type="text"><![CDATA[声明中有一个或者多个类型化参数的类或者接口，叫做泛型类或者接口。泛型类和接口统称为泛型。 泛型是一种安全规范，帮助我们在编译前就发现类型安全问题，而不需要等到编译报错。泛型在编译时会被擦除。 关于使用泛型的几个规则： 请不要使用原生态类型 如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势 消除非受检的警告 优先考虑泛型 优先考虑泛型方法 通配符无限通配符 ？上限通配符 ？ extends T下限通配符 ? super T]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 集合]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[java中的集合包括map、set、list collection 所有的linked 都是链表实现所有的hash 都是hash表，存储的对象都需要重写hashcode、equas函数]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程通信 IBinder]]></title>
    <url>%2Fblog%2F2020%2F05%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-IBinder.html</url>
    <content type="text"></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechat-app]]></title>
    <url>%2Fblog%2F2020%2F05%2Fwechat-app.html</url>
    <content type="text"><![CDATA[微信小程序开发]]></content>
      <tags>
        <tag>wechatApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin 类]]></title>
    <url>%2Fblog%2F2020%2F05%2Fkotlin.html</url>
    <content type="text"><![CDATA[kotlin 类kotlin中使用class申明类 构造函数构造函数分为主构造函数、次构造函数 主构造函数kotlin中可以在申明类时申明一个构造函数，并且次构造函数为 主构造函数 12// 申明了主构造函数class Person constructor(var name: String, var age: Int ) &#123;&#125; 如果主构造函数没有使用任何注解或者修饰符，则可以省略constructor关键字 1class Person (var name: String, var age: Int ) &#123;&#125; 主构造函数不能含有代码块，有需要初始化的代码可以放在以init关键字作为前缀的初始化块中。其中init可以申明多个，会根据代码顺序来执行。 123456789class Person (var name: String, var age: Int ) &#123; var myName = name; init &#123; println(&quot;this person&apos;s name was $&#123;myName&#125;&quot;); &#125; init &#123; println(&quot; test &quot;); &#125;&#125; 如果没有申明主构造函数，系统会自动创建一个无参的主构造函数。 次构造函数次构造函数必须要用constructor申明，如果有主构造函数，必须将次构造函数委托给主构造函数 1234567891011121314class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125; 初始化init代码块实际上会成为主构造函数的一部分。当次级构造函数委托给主构造函数，init代码块会成为次级构造函数的第一句语句。即使该类没有主构造函数，这种委托也会隐式发生，仍会执行初始化代码块。 如果一个非抽象类没有申明任何主、次构造函数，默认会生成一个不带参的主构造函数。函数的可见性为public。如果不想类有一个公有构造函数，需要声明一个private的主构造函数。1class TestClass private constructor () &#123;&#125; 在JVM上，如果主构造函数中的所有参数都有默认值，则会默认生成一个额外的无参构造函数，它将使用默认值。 创建类的实例kotlin 在创建实例时，不需要new 关键字12class MyPerson(str: String, var age: Int) &#123;&#125;var person = MyPerson(&quot;jack&quot;, 11); 类成员 构造函数与初始化代码块 函数 属性 嵌套类、内部类 对象申明 继承在kotlin中，所有类都有一个超类 Any，这对于没有超类型声明的类是默认超类： var oneClass; // 从Any隐式继承 Any 类中有三个方法 equas()、 hashcode()、 toString(), 因此所有kotlin类都定义有这三个方法 默认情况下，kotlin中类都是final 的，不可被继承，如果需要声明该类可以被继承，需要使用关键字 open。 并且kotlin中是使用 : 来表示继承。 12open class TestClassSuper &#123;&#125;class TestClassChild : TestClassSuper &#123;&#125; 如果超类中有声明主构造函数，则子类可以声明主构造函数，则并必须用子类中主构造函数参数初始化超类。如果子类没有声明主构造函数，则必须声明次级构造函数，并且使用super初始化基类12345678910111213141516171819open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall);&#125; 函数的重写正如类的继承需要申明open标识该类开放继承，类中的函数标识可以被重写也是需要使用open申明，如果没有函数没有申明open，则在子类中不允许出现同名并且同参数类型的函数。出现同名但不同参数的函数时允许的，正如java中的重载 12345678910111213141516171819202122232425262728293031323334open class MyPerson(str: String, var age: Int) &#123; var name = str; var tall:Double? = null; init &#123; println(&quot;init test $&#123;name&#125;&quot;); &#125; constructor(str: String, age: Int, tall: Double?):this(str, age) &#123; this.tall = tall; &#125; open fun testMethod() &#123; &#125; fun test1() &#123; &#125;&#125;class TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;class Test2 : MyPerson &#123; constructor(str: String, age: Int):super(str, age); constructor(str: String, age: Int, tall: Double?): super(str, age, tall); override fun testMethod() &#123; super.testMethod() &#125; fun test1(str:String) &#123; &#125;&#125; 属性的重写同函数的重写，属性的重写也是需要使用open标识，并在子类中使用override1234open var i = 2;// childClassoverride var i = 4; 在属性的重写中，有一点需要注意，可以用var 重写val，却不能用val重写var；这一点是和java不一样的。因为用val申明的属性本质上申明了get方法，而将其重写为var只是在子类新增了一个set方法 派生类的初始化顺序1、进入子类的构造函数2、进入父类的构造函数并完成初始化3、进入父类的init代码块4、父类中属性的初始化5、子类构造函数完成初始化6、子类init代码块7、子类属性初始化 调用父类方法或属性可以使用super关键字1234// 方法super.method();// 属性super.nema; 内部类中调用外部类父类属性或方法，使用super@Outer1super@OutClass.method();]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android dialog]]></title>
    <url>%2Fblog%2F2020%2F05%2Fandroid-dialog.html</url>
    <content type="text"><![CDATA[dialog在日常开发时会经常使用到弹窗dialog 针对自定义视图的弹窗使用方法， 1234567AlertDialog.Builder builder = new AlertDialog.Builder(context);LayoutInflater inflater = context.getLayoutInflater();View view = inflater.inflate(R.layout.view, null);build.setView(view);AlertDialog dialog = build.create();dialog.show(); 上面就是一个AlertDialog实例的创建过程，其中AlertDialog使用了创建者模式。 关于点击弹窗其他部分、点击手机back而不关闭dialog的方法有如下:12dialog.setCancelable(false); // 点击back、其他部位都不关闭弹窗dialog.setCanceledOnTouchOutside(false);// 点击其他部位不关闭、点back关闭 设置dialog弹窗的大小： 12345678910// 在dialog.show() 之后Window window = dialog.getWindow();if(window != null) &#123; WindowManager.LayoutParams attr = window.getAttributes(); if (attr != null) &#123; attr.height = ViewGroup.LayoutParams.MATCH_PARENT; attr.width = ViewGroup.LayoutParams.MATCH_PARENT; window.setAttributes(attr); &#125;&#125; 这样就将dialog窗口大小设置为了最大，但是可以发现我们的弹窗还是没有充满整个屏幕，因为dialog默认的主题theme就是偏距margin的，所以如果我们想要充满整个屏幕的话，需要改变我们dialog的主题， 12// AlertDialog.Builder builder = new AlertDialog.Builder(context);AlertDialog.Builder builder = new AlertDialog.Builder(context, R.style.AppTheme);]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java流]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava%E6%B5%81.html</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java范型]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava%E8%8C%83%E5%9E%8B.html</url>
    <content type="text"></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm 线程私有区]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjvm-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA.html</url>
    <content type="text"><![CDATA[jvm 线程私有区jvm从多线程角度看，分为线程共享区、线程私有区 而在线程私有区中有：程序计数器、方法栈区（包括虚拟机栈、本地方法栈） 程序计数器较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响 jvm的多线程是通过cpu时间片轮转算法实现的，某个线程在执行过程中会因为时间片耗尽而被挂起，其他线程获得时间片开始执行。当被挂起的线程重新获取到时间片，它要想从之前被挂起的地方开始执行，就需要知道之前执行到了哪里，在jvm中，通过程序计数器来记录字节码执行的位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。 程序计数器的特点1、线程隔离：每个线程都有自己的程序计数器2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。 方法栈区线程在运行时，在执行每一个方法的时候都会打包成一个栈帧，然后将栈帧入栈，当方法执行完时，就会将该栈帧出栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。 栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k 栈帧结构栈帧中含有：局部变量表、操作数据栈、动态链接、返回地址 局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 锁]]></title>
    <url>%2Fblog%2F2020%2F05%2Fjava-%E9%94%81.html</url>
    <content type="text"><![CDATA[java中使用锁，主要是用于解决多线程并发问题多个线程对某个对象进行操作，就存在并发问题。 java内存规定了，所有变量都储存在主内存中，每个线程又有自己的工作内存 线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存 线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 并发三要素原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。 可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：程序执行的顺序按照代码的先后顺序执行。 解决并发问题volatile：保证可见性，不保证原子性当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中 这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见 禁止指令重排序指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则 不会对存在依赖关系的指令重排序，例如 a = 1;b = a; a 和b存在依赖关系，不会被重排序 不能影响单线程下的执行结果。比如：a=1;b=2;c=a+b这三个操作,前两个操作可以重排序，但是c=a+b不会被重排序，因为要保证结果是3 使用场景对于一个变量，单个线程写，其他线程读，这个时候就可以使用volatile来修饰这个变量 123456789101112131415161718public class Utils &#123; private static volatile Utils instance; public static Utils getInstance() &#123; // 1 if(instance == null) &#123; // 2 synchronized(Utils.class) &#123; // 3 if(instance == null) &#123; // 4 instance = new Utils(); // 5 &#125; &#125; &#125; return instance; &#125;&#125; 初始化一个对象有如下步骤：分配内存，初始化对象，指向内存 如上代码，如果不使用volatile修饰，这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，并且执行到注释2，这时候判断instance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。 volatile 原理在jvm底层，volatile是通过内存屏障来实现的，内存屏障会提供三个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将缓存的修改操作立即写到主内存 写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。 valatile局限性volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题 Synchronized多个线程同时写一个变量这个时候使用Synchronized，可以保证同一时刻，只有一个线程可执行某个方法或某个代码块 Synchronized锁升级Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。 偏向锁 ：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。 轻量级锁 ：在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。 重量级锁 ：如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。 Synchromized缺陷不能设置锁超时时间不能通过代码释放锁容易造成死锁 ReentrantLock上面说到Synchronized的缺点，不能设置锁超时时间和不能通过代码释放锁，ReentranLock就可以解决这个问题 在多个条件变量和高度竞争锁的地方 ， 用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性 原文地址(https://www.jianshu.com/p/4eec21c3338e) JVM内存模型、指令重排、内存屏障概念解析(https://www.cnblogs.com/chenyangyao/p/5269622.html) 在java中有一下锁： 公平锁/非公平锁 可重入锁 互斥锁/读写锁 独享锁/共享锁 分段锁 偏向锁/轻量级锁/重量级锁]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 内存结构]]></title>
    <url>%2Fblog%2F2020%2F01%2Fjava-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[java 内存结构首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。 程序计数器程序计数器： 主要功能是记录当前线程执行程序的位置，通过改变计数值来确定执行下一条指令。每个线程的创建，都会创建一个程序计数器，并且对于每个线程而言是互相独立的。比如我们在debuger模式下运行，for循环的停止，异常的抛出，都是通过改变该线程对应的计数值来确定下一个执行指令。 java虚拟机栈java虚拟机栈：主要功能是临时存储线程执行到的每个方法需要的参数，其内存空间在编译时就已确定。与程序计数器一样，每创建一个线程，则创建一个虚拟机栈，线程每执行到一个方法，对应的栈里就会创建一个栈帧，栈帧会存储局部变量表、动态链接、操作数和方法出口等信息，执行方法，栈帧入栈，方法执行完，栈帧出栈。 本地方法栈本地方法栈与java虚拟机栈一样，只是记录native方法执行。jni native调用的c、c++函数 堆得内存结构分为老年代、新生代，内存比为8:2其中新生代分为: edan、from、to 内存分为8:1:1直接new产生的对象被分配到edan（大对象会被直接分配到老年代），当发生GC时，会通过复制清楚算法，清楚edan+from区域可被回收的对象，而不可被回收对象会被复制到to区，而在下一次GC时，会清除edan+to区可回收对象，将不可清楚的对象复制到from区，并且每次回收时，会整理碎片内存。 GCgc分为minor GC、full GCminor 作用区域是新生代内存、算法：复制清除算法。会整理碎片full GC作用区域是老年代内存，算法：标记清除算法，不会整理碎片。 GC时判断是否可回收的依据是：内存可达化：判断堆、方法栈、静态变量、静态方法区中是否有该对象的引用。 每次 gc时会 会stw（stop the world）,线程会被挂起两次]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法（1）简单算法]]></title>
    <url>%2Fblog%2F2020%2F01%2F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[算法（1）简单算法简单常见算法 二分查找法针对有序的数据集，每次查找时都取中间值，逐步缩小查找范围，最后获取到目标值 复杂度：$O(log_n)$ 选择排序选择排序是针对数组的一种排序算法。过程：遍历数组，计算出最值，新建一个数组，将最值放入新数组, 复杂度：$O(n^2)$ 递归递归指函数在内部调用本身，使用递归注意两个条件：基线条件、递归条件。基线条件：跳出递归的条件递归条件：对递归元素逐步减少的条件，要合理利用这两点，不然容易无限循环。 在数组中取最大值12345678910111213function findMax(arr) &#123; let max = 0; if(arr.length === 0) &#123; return max; &#125; else &#123; max = arr[0] &gt; max ? arr[0] : max; arr.splice(0, 1); return findMax(arr); &#125;&#125;var arr = [1, 2, 3, 4, 5];findMax(arr); 递归算法与数据结构中的 栈 是及其相似的。已上面的算法为例，调用findMax([1,2,3,4,5])时，将findMax([1,2,3,4,5])压入栈顶，而findMax会调用findMax([2,3,4,5]),然后将findMax([2,3,4,5])压入栈,如下图所示： 然后从栈顶依次得出计算结果出栈。 快速排序]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 (1)]]></title>
    <url>%2Fblog%2F2020%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.html</url>
    <content type="text"><![CDATA[数据结构 (1) - 简单数据数组数组：有序、内存连续的数据集， 数组是有序的，顺序就是插入的顺序，先插入的值排在前面，内存连续：在内存分配时，数组中的值的内存空间是分配在一起的所以在我们使用数组时，推荐在申明时申明数组的长度，不然在后续插入值时可能会导致之前的数据内存空间不够，需要重新分配整个数据内存空间 数组的索引就是数组中值的下标：从0开始计数。数组的查找通过索引，所以快。而增删、修改时，当插入一个值，则需要将后面的数据都后移，删除也是类似。 数组查询快，增删慢查询：O(1)增删：O(n)修改：O(n) 链表链表：无序、内存非连续、每个节点都具有下一个节点的地址 链表是无序的，内存非连续，因为每一个节点都含有下一个节点的地址，相比于数组，内存非连续，则当数据增多，也不会存在内存空间的问题，因为只需随便分配下一个节点的内存，然后将上一个节点的中含有的下一个节点地址指向最新分配的地址即可。 链表数据第一个、最后一个节点的值是明确的。因为链表是无序的。所以查询慢，因为想要获取一个节点的值，需要先获取上一个节点，通过上一个节点获取到下一个节点的地址。 查询：O(n)增删：O(1)修改：O(1) 栈栈是一种只允许在一端进行插入或删除的线性表 栈的操作只有两种：出栈、进栈特点：先进后出(FILO:first in last out) 只允许对栈顶的元素操作。最先进入的元素将会被压入栈底 集合队列树]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 贝塞尔曲线]]></title>
    <url>%2Fblog%2F2020%2F01%2Fandroid-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF.html</url>
    <content type="text"></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-自定义View-继承EditText]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFEditText.html</url>
    <content type="text"><![CDATA[android-自定义View-继承EditText一直觉得flutter中的输入框效果不错。动画，提示标题都有。这次要通过自定义View, 继承重写EditText来实现同样的输入框效果 源码地址 首先确定大致思路两个元素：TextView、EditText，TextView为标题，EditText为输入框展示当未获取焦点时：1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部2、输入框如果没有输入的内容，则输入框展示的提示文本当获取焦点时：不管有无输入内容，提示文本缩小在输入框上部 TextView并非实质组件，只是绘制Text，当作TextView。 1、先写一个类继承AppCompatEditText，并实现构造函数123456789101112131415161718192021public class AnimatedInput extends AppCompatEditText &#123; public AnimatedInput(Context context) &#123; super(context); this.context = context; &#125; public AnimatedInput(Context context, AttributeSet attrs) &#123; super(context, attrs); this.context = context; initView(attrs); &#125; public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initView(attrs); &#125;&#125; 2、重写onFocusChanged函数这样获取到 是否获取焦点的标识位123456@Override protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123; super.onFocusChanged(focused, direction, previouslyFocusedRect); isFocus = focused; postInvalidate(); &#125; 3、重写onTextChanged函数这样获取到输入框的内容value12345@Override protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; super.onTextChanged(text, start, lengthBefore, lengthAfter); value = text.toString(); &#125; 4、绘制提示文本这时候要分情况，即是否获取焦点、输入框是否有内容1234567891011121314151617181920212223242526272829@Overrideprotected void onDraw(Canvas canvas) &#123; // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸 int width = getMeasuredWidth(); int height = getMeasuredHeight(); top = getPaddingTop(); left = getPaddingLeft(); right = width - left - getPaddingRight(); bottom = height - top; drawTitle(canvas); super.onDraw(canvas);&#125;/** * 绘制标题 * @param canvas */private void drawTitle(Canvas canvas) &#123; if(TextUtils.isEmpty(value)) &#123; if(isFocus) &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125; else &#123; canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint); &#125; &#125; else &#123; canvas.drawText(title, left, top + 20, focusTitlePaint); &#125;&#125; 如此就基本实现了我们的预期目标。这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-自定义View 继承ViewGroup]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFViewGroup.html</url>
    <content type="text"><![CDATA[android 自定义View 继承ViewGroup]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 自定义View 继承View]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFView.html</url>
    <content type="text"><![CDATA[android 自定义View 继承View上篇关于自定义View的介绍接下来将会针对自定义View三种情况一一实现。 源码地址 最后实现效果如下图： 继承View创建一个class MyView 继承View 目标是写一个折线图 现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;LineView&quot;&gt; &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 先新建一个clas 继承View， 并初始化几个构造函数1234567891011121314151617181920212223242526272829303132public class MyView extends View &#123; // 代码生成时，才会调用该构造函数 public MyView(Context context) &#123; super(context); this.context = context; &#125; public MyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; // xml配置时，会调用这个生命周期 public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.context = context; initData(attrs); &#125; // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。 private void initData(AttributeSet attrs) &#123; Log.d(TAG, &quot;initData: &quot;); // 获取xml中配置的数据 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView); paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black)); // 画笔初始化 paint = new Paint(); paint.setColor(context.getResources().getColor(R.color.black)); paint.setTextSize(40); paint.setStrokeWidth(10); // 线条粗细 &#125;&#125; 在onMeasure函数中对尺寸做约束12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.d(TAG, &quot;onMeasure: &quot;); int height = measuretDimension(defaultHeight, heightMeasureSpec); int width = measuretDimension(0, widthMeasureSpec); top = 0; left = 0; bottom = top + height; right = left + width; setMeasuredDimension(width, height);&#125;/** * 测量实际尺寸 * @param defaultSize: 默认尺寸 * @param measureSpec: 测量规格 * @return */public int measureDimension(int defaultSize, int measureSpec) &#123; int resultSize = defaultSize; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; // 没有做限制，取默认值 case MeasureSpec.UNSPECIFIED: resultSize = defaultSize; break; // WRAP case MeasureSpec.AT_MOST: // 要取默认值和测量值中较小值 // 当默认值为0时，取最大值, 即宽充满屏幕 resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize); break; // 具体值 或 MATCH case MeasureSpec.EXACTLY: resultSize = specSize; break; default: break; &#125; return resultSize;&#125; 先绘制两个轴线注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。这两个里的坐标不要弄混。 12345678/** 绘制两条轴线 */private void drawXY(Canvas canvas) &#123; Log.d(TAG, &quot;drawXY: &quot;); // 绘制x轴 canvas.drawLine(left + 20, bottom, right, bottom, paint); // 绘制y轴 canvas.drawLine(left + 20, top, left + 20, bottom, paint);&#125; 在MainActivity中配置该视图123456789&lt;com.justin.customview.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot; android:layout_marginTop=&quot;20dp&quot; android:padding=&quot;10dp&quot; app:axieColor=&quot;@color/black&quot; android:id=&quot;@+id/myView&quot; /&gt; 我们直接运行,效果如下： x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。新增一个方法初始化这些尺寸数据 123456789101112131415161718192021/** * 尺寸数据初始化 */private void initSize () &#123; // 获取padding尺寸 paddingLeft = getPaddingLeft(); paddingTop = getPaddingTop(); paddingRight = getPaddingRight(); paddingBottom = getPaddingBottom(); StringBuilder sb = new StringBuilder(); sb.append(&quot;paddingLeft =&quot;).append(paddingLeft) .append(&quot;paddingTop =&quot;).append(paddingTop) .append(&quot;paddingRight =&quot;).append(paddingRight) .append(&quot;paddingBottom =&quot;).append(paddingBottom); Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString())); top = paddingTop; left = paddingLeft; bottom = height - top - paddingBottom; right = width - left; setMeasuredDimension(width, height);&#125; 这样我们就对padding做了处理，接下来接着绘制我们需要的图形。我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头 123456789101112131415161718private void drawArrow(Canvas canvas) &#123; Path path = new Path(); // 先绘制x轴三角 //先移动到三角形一个点 path.moveTo(right-20, bottom + 20); path.lineTo(right-20, bottom - 20); // 画线 path.lineTo(right, bottom); // 画线 path.close(); // 图形闭合 canvas.drawPath(path, paint); // 绘制y轴三角 path.moveTo(left - 20, top + 20); path.lineTo(left + 20, top + 20); path.lineTo(left, top); path.close(); canvas.drawPath(path, paint);&#125; 这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。 设置数据并绘制点我们已经完成了绘制两条轴线，现在要开始绘制数据了。首先我们要确认标准线，x轴的标准线肯定就是xValue的值，但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。我们先假设我们的值在0-100以内，取5条标准线，每条间距20. 先设置两个数据1234567891011121314151617// 数据 private float[] yValue; private String[] xValue; private int lineNum = 5; /** 设置数据并刷新 */ public void setData(float[]yValue, String[]xValue) &#123; this.yValue = yValue; this.xValue = xValue; postInvalidate(); &#125; /** 设置标准线数目 */ public void setData(int lineNum) &#123; this.lineNum = lineNum; postInvalidate(); &#125; 然后我们开始绘制标准线、各个点123456789101112131415161718192021/** 绘制各个点 */private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 5, paint); &#125;&#125; 而在MainActivity.kt中，我们可以这样使用 1234567891011// kotlin语法class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;) var yValue = floatArrayOf(70f, 80f, 90f); myView.setData(yValue, xValue); &#125;&#125; 此时的实现效果： 现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些 绘制x、y轴标准线值，将各个点连接起来。123456789101112131415161718192021222324252627282930313233343536/** 绘制各个点 */ private void drawPoint(Canvas canvas) &#123; if(xValue == null || yValue == null) return; // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。 float maxHeight = (float)((bottom - top) * 0.9); float itemHeight = maxHeight / 5; int itemValue = yMax / 5; for(int i = 1; i &lt;=5; i ++) &#123; canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint); // 绘制y轴标准值 canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint); &#125; // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值 float maxWidth = (float)((right - left) * 0.9); float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length; for (int i = 1; i &lt;= xValue.length; i ++) &#123; float x = left + itemWidth * i; // 绘制轴线 canvas.drawLine(x, bottom, x, bottom - 15, paint); // 绘制点 float y = bottom - maxHeight * yValue[i-1] / yMax; canvas.drawCircle(x, y, 10, paint); // 绘制点与点之间的连线 if(lastX &gt; 0f) &#123; canvas.drawLine(lastX, lastY, x, y, paint); &#125; // 绘制x轴标准值 canvas.drawText(xValue[i-1], x, bottom + 50, paint); lastX = x; lastY = y; &#125; &#125; 最后实现效果如下图：]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 自定义View]]></title>
    <url>%2Fblog%2F2019%2F12%2Fandroid-%E8%87%AA%E5%AE%9A%E4%B9%89View.html</url>
    <content type="text"><![CDATA[Android 自定义View自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。 首页android自定义View有三种类型，1、继承View，多用于实现一些不规则的图形。 2、继承特定的组件，如TextView， 3、继承ViewGroup，用于视图组 在自定义View中有三个关键的方法：onMeasure、onLayout、onDraw onMeasure测量，ViewGroup 会遍历测量子视图的onMeasure方法。一般view 则是在测量自身。 在这个方法中，一般是对视图的尺寸做一些要求。如：处理padding、处理wrap_parent margin是无需处理的，margin其实是在父容器的onMeasure时处理的。 在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。这两个参数都是父容器传递过来。 视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec LayoutParams我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：android:layout_width = “wrap_parent | 50dp | match_parent”存在三种情况，wrap_parent： 自适应大小，50dp: 具体尺寸match_parent: 充满父容器-父容器大小 MeasureSpec测量规格，MeasureSpec由size和mode组成 1.static int getMode(int measureSpec): // 获取mode2.static int getSize(int measureSpec):// 获取size3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec specMode存在三种情况:EXACTLY:具体尺寸、具体值AT_MOST：表示子视图最多只能是specSize中指定的大小UNSPECIFIED：可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。 size：就是LayputParams中指定的大小 而子视图的大小也就是通过size和specMode获取的，具体关系如下图： EXACTLY AT_MOST UNSPECIFIED &lt;-MeasureSpec wrap_parnet EXACTLY AT_MOST AT_MOST match_parent EXACTLY AT_MOST AT_MOST 50dp 50dp 50dp 50dp ^LayoutParams 总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸 下面会讲具体使用 onLayout布局方法 在调用onLayout时，onMeasure已经完成，子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。 onDraw绘制的方法onDraw是在容器的draw方法时调用的。而绘制的顺序为：1.绘制背景2.如果有必要，保存画布的图层，以准备失效3.绘制视图的内容4.绘制子控件5.如果必要，绘制衰落边缘和恢复层6.绘制装饰（比如滚动条） onDraw 有一个参数(Canvas cancas),canvas 就是画布，画布的范围就是onLayout布局后确定的区域]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react redux]]></title>
    <url>%2Fblog%2F2019%2F12%2Freact-redux.html</url>
    <content type="text"><![CDATA[在react-native中集成redux对react框架而言，状态树、dom树是它的一大优势。而redux就是对数据、状态进行管理。 集成redux1、执行1234npm install redux --savenpm install react-redux --savenpm install redux-thunk --savenpm i redux-logger --save 以上命令下载关于redux的组件。 2、store的配置1234567891011121314// configStore.jsimport &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import rootReducer from &apos;./reducer&apos;;const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);export default configStore =(initState) =&gt; &#123; const store = createStoreWithMiddleware(rootReducer, initState); return store;&#125; 而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰 123456789101112// rootReducerimport &#123; combineReducers &#125; from &apos;redux&apos;;import &#123; reducer as test &#125; from &apos;../Home/store&apos;;const appReducer = combineReducers(&#123; test,&#125;);const rootReducer =(state, action) =&gt; &#123; return appReducer(state, action);&#125;export default rootReducer; test是一个测试的reducer。 在入口处，绑定store，在入口文件中：1234567891011121314151617181920AppRegistry.registerComponent(&apos;projectName&apos;, () =&gt; Root);// 指向了root.js，在root.js中：import &#123; Provider &#125; from &apos;react-redux&apos;;import configStore from &apos;./store/configStore&apos;;const store = configStore();export default class Root extends React.PureComponent &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &#123;...&#125; &lt;/View&gt; &lt;/Provider&gt; ) &#125;&#125; 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142// actionType.jsexport const TEST_REDUCE = &quot;TEST_REDUCE&quot;;// test action.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const test =() =&gt; (&#123; type: TEST_REDUCE,&#125;)export &#123; test,&#125;// test reducer.jsimport &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;const initState = &#123; num: 0,&#125;export default reducer = (state = initState, action) =&gt; &#123; switch(action.type) &#123; case TEST_REDUCE: return &#123; ...state, num: state.num + 1, &#125; default: return &#123; ...initState, &#125; &#125;&#125; 在组件component中使用Test.js 123456789101112131415161718192021222324252627282930313233343536373839import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; action &#125; from &apos;./store&apos;class Test extends Component &#123; testFunction =() =&gt; &#123; this.props.action.test(); &#125; render() &#123; const &#123; num &#125; = this.props; return ( &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;this.testFunction&#125; &gt; &lt;Text&gt; 触发按钮 &lt;/Text&gt; &lt;Text&gt;&#123;num&#125;&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const mapStateToProps = (state) =&gt; (&#123; num: state.test.num,&#125;)const mapActionToProps = dispatch =&gt; &#123; return &#123; action: bindActionCreators(action, dispatch), &#125;&#125;export default connect(mapStateToProps, mapActionToProps)(Test); 具体的使用方法已在上面，下面再去讲解redux原理 redux原理说明redux状态管理大致流程： component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render reducer中数据改变即store中数据改变为何会导致 component props改变呢？其实就是connect函数。 我们在组件中，export default connect(mapStateToProps, mapActionToProps)(Test);connet是一个柯里化函数。第一组入参两个：第一个mapStateToProps，其实就是将store中的数据绑定到props，第二个mapActionToProps，是将action函数绑定到props，所以我们在使用是，如取store中的值，const { num } = this.props;dispatch action：this.props.action.test(); 第二组入参：当前的Test对象。 再往深考虑connect 函数]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android sqlite的使用]]></title>
    <url>%2Fblog%2F2019%2F11%2Fandroid-sqlite%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[android sqlite的使用1、创建表a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法 onCreate（SQLiteDatabase）在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。 onUpgrade（SQLiteDatabase，int，int）当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。 onOpen（SQLiteDatabase）这是当打开数据库时的回调函数，一般在程序中不是很常使用。 在构造函数中创建数据库12345678910// 数据表名 private static final String TABLE_NAME = &quot;userlog.db&quot;; public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public MyDatabase(Context context, int version) &#123; this(context, TABLE_NAME, null, version); &#125; 在onCreate方法中创建数据表数据库数据类型：NULL：null值INTEGER：整数，1、2、3、4、6、8字节REAL：浮点值，8字节TEXT：字符串BLOB：blob数据DATE：日期 年月日TIME：时刻 时分秒 1234567@Override public void onCreate(SQLiteDatabase db) &#123; Log.d(TAG, &quot;onCreate: onCreate&quot;); String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;; db.execSQL(sql); &#125; 然后在需要建表的实话，初始化一个该java类实例即可 增删改查增加 insert 一条数据1、使用sql语句插入一条数据12String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;db.execSQL(sql); 但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’ 此时应该使用 ? 替代符，如下：1234567891011public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123; SQLiteDatabase db = getWritableDatabase(); StringBuilder sql = new StringBuilder(); sql.append(&quot;insert into &quot;) .append(table_name) .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;); Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;; Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString()))); db.execSQL(sql.toString(), values); db.close();&#125;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ValueAnimator]]></title>
    <url>%2Fblog%2F2019%2F10%2FValueAnimator.html</url>
    <content type="text"><![CDATA[属性动画 ValueAnimator]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas 中的方法]]></title>
    <url>%2Fblog%2F2019%2F10%2Fcanvas-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[canvas 中的一些方法在canvas中一般使用的方法为drawXXX(): 绘制的方法clipXXX(): 裁剪的方法 clipRect裁剪画布，clipRect(int left, top, right, bottom);clipRectF(float left, top, right, bottom) 当执行了该方法，如clipRect(0,0,500,500);则后面都只能在(0,0,500,500)区域绘制 用Rect实现多区域裁剪intersect 交集】12345678Rect rect = new Rect(0, 0, 500, 500); rect.intersect(250, 250, 750, 750); canvas.clipRect(rect);// 取到区域(250, 250, 500, 500) 绘制多个区域相交的区域 union 合集12345678Rect rect = new Rect(0, 0, 500, 500); rect.union(250, 250, 750, 750); canvas.clipRect(rect);// 取到的区域为(0, 0, 750, 750) 绘制多个区域之和 clipPath 取出某个区域12345678910111213// 实例化路径mPath = new Path();// 移动起点至[50,50]mPath.moveTo(50, 50); mPath.lineTo(75, 23); mPath.lineTo(150, 100); mPath.lineTo(80, 110); // 闭合路径mPath.close();// 按照路径进行裁剪canvas.clipPath(mPath); 即是将path区域裁剪出来同样后面在能在该path区域绘制图形 Region.Op]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashMap解析]]></title>
    <url>%2Fblog%2F2019%2F09%2FhashMap%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[HashMap源码分析Hash内部类Node：Node(节点)，链表中的节点，当HashMap数据少于6条时，为链表结构，Node为其中的节点。链表数据结构，每一个节点都记录下一个节点的地址。在Node的构造函数中，直接包含了下一个节点，1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; // 将下一个节点作为入参放入构造函数中 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; .... 获取某个节点12345678910111213141516171819202122232425262728293031 public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 当为树结构的时候 if (first instanceof TreeNode) // 获取树形结构中某个节点 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 遍历链表结构 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级rn版本适配android64]]></title>
    <url>%2Fblog%2F2019%2F08%2F%E5%8D%87%E7%BA%A7rn%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8Dandroid64.html</url>
    <content type="text"><![CDATA[google play在2019/08/01起实施强制支持64位手机的措施。 因为之前的version为0.55.4,到0.59.1版本更新太多，采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目]]></content>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava + Retrofit 实现BaseResult]]></title>
    <url>%2Fblog%2F2019%2F07%2FRxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html</url>
    <content type="text"><![CDATA[Rxjava + Retrofit 实现BaseResult最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。答案肯定是可以的。本文只讲使用。 依赖：12345implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos; 普通使用案例首先创建实体数据类Test 1234567891011121314public class Test &#123; private static final String TAG = &quot;=====TEST&quot;; String key = &quot;&quot;; String test = &quot;&quot;; public void log() &#123; Log.d(TAG,&quot;key=&quot; + key); Log.d(TAG, &quot;test=&quot; + test); &#125;&#125; 在写一个接口TestServer，申明请求 1234public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用请求1234567891011121314151617181920212223242526272829303132private void testService() &#123; // 实例化一个Retrofit 对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.1.42:8080/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); TestServer service = retrofit.create(TestService.class); service.getObJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Test&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Test test) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125; 开发考虑我们不可能每个请求都重新创建一个Retrofit对象，而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。 1、写一个result实体类1234567891011121314151617181920212223242526272829303132// 因为每一个接口返回的数据结构都不同，肯定要用泛型。public class Result&lt;T&gt; &#123; private final String TAG = &quot;Result ====&quot;; private String msg; private String code = &quot;0&quot;; private T data; public void logCode() &#123; Log.d(TAG, code); &#125; public long getLongCode() &#123; long resultCode = 0; if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123; resultCode = Long.parseLong(code); &#125; return resultCode; &#125; public void log() &#123; Log.d(TAG, &quot;msg:&quot; +msg + &quot;\n code:&quot; + code + &quot;\n data:&quot; + data); &#125; public T getResultData() &#123; return data; &#125;&#125; 注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论 然后需要写一个BaseObserver观察者基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里还是因为接口返回数据格式问题，使用泛型。public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123; private final String TAG = &quot;====BaseObserver===&quot;; /** * 请求成功 * @param t */ public abstract void onSuccess(T t); /** * 当返回的code值错误时的默认方法 * @param code */ public void onResultCodeErr(long code) &#123; Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code); &#125; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(Result result) &#123; if(result.getLongCode() != 200) &#123; onResultCodeErr(result.getLongCode()); &#125; else &#123; onSuccess((T)result.getResultData()); &#125; result.log(); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); Log.d(TAG, e.getMessage()); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125;&#125; 然后我们的Server类就变成了如下：123456789public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson(); @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用就变成了这样： 1234567891011121314151617BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123; @Override public void onSuccess(Test test) &#123; Log.d(&quot;======&quot;, &quot;onSuccess&quot;); test.log(); &#125; &#125;; /** Retrofit + Rxjav */ private void testRxjavaService() &#123; Retrofit retrofit = RetrofitUtil.getRetrofit(); TestService ts = retrofit.create(TestService.class); ts.getTestRxjavaJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（三）布局组件]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[Flutter入门（三）布局组件之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！ 查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍 ui组件学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。 Text123456789101112131415Text( &apos;要显示的文本&apos;, &#123; textAlign: TextAlign.center, // 文本横向对齐方式 居中 overflow: TextOverflow.ellipsis, // 文本溢出处理方式 textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left) softWrap: true, // 是否自动换行 textScaleFactor: 2.0, // 字体显示倍率 maxLines: 1, // 文本最大行数 style: new TextStyle( color: Colors.purple, fontSize: 20.0, ), // 文本样式 &#125;)]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter入门 vscode调试及查看日志]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[flutter入门 vscode调试及查看日志开发肯定需要调试应用，以及查看日志。 在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。 还有一个print()函数，最终发现这个是可以的。 情景再现a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。 b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出 c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出 正确方法print()日志输出函数通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出 ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。 用vscode调试flutetr一个正常的flutter项目用vscode应该是这样的。之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。 点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目 我打了一个断点，当项目运行起来，如下图。 当我点击按钮，进入断点。如下图可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。 添加断点点击代码左侧的红框区域即可（下图）。 在左上角的调试/新建断点 也可以。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用在上一篇中我们利用android studio运行了一个hello word项目。作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。 ###1、配置插件需要在vscode中下载插件找到这两个插件下载好并重新加载vscode就可以了。 ###2、运行flutter项目的运行命令是 flutter run但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。 在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。还有有一些提示信息 当你需要热加载的时候按 r，需要重启应用按R。所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。 ###3、写第一个flutter应用。按照flutter中文网（https://flutterchina.club/get-started/codelab/）写我们第一个flutter应用。其中我个人碰到一个问题。就是在第2步、使用外部package中， 在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。然后重新打开vscode才好，应该是vscode对这个以来的读取问题。 然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。 ###个人体会 flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼 fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。没有对state这个做解释、没有state的使用说明，然后那个路由也是。 ##待续]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（一）环境配置]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Flutter入门（一）环境配置在/flutter/bin目录下执行 flutter doctor命令。 3、android studio插件下载android studio就不说了，打开android studio/file/setting/plugin/输入 flutter查找并install。第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。 在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project hello word按照惯例，接下来我们跑一个hello world。 照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。 项目目录 项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。 运行点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行 第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter数据持久化]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
    <content type="text"><![CDATA[flutter数据持久化shared_preferences本地存储临时数据此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。 添加插件依赖： 123456// 在pubspec.yaml文件中添加依赖dependencies: flutter: sdk: flutter shared_preferences: &quot;&lt;newest version&gt;&quot; 调用： shared_preference 存储方式是根据key-value形式使用便捷，但有限制： a: 只能使用原始类型: int，double，bool，string 和 string list。 b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。 1234567891011import &apos;package:shared_preferences/shared_preferences.dart&apos;;getAsyncData() async &#123; // 获取实例 var prefs = await SharedPreferences.getInstance(); // 获取存储数据 var count = prefs.getInt(&apos;count&apos;) ?? 0 + 1; // 设置存储数据 await prefs.setInt(&apos;count&apos;, count);&#125;]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dart语言语法糖]]></title>
    <url>%2Fblog%2F2019%2F07%2Fdart%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
    <content type="text"><![CDATA[dart语言语法糖a、 以 _命名的变量或函数为强制私有 var _num; b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式 1234int getInt() =&gt; 2;int getInt() =&gt; isTrue ? 2 : 0; c、 运算符 aa ?? bb; ?? 为null 时 d、异步 async await then async、await使用与rn中使用方式一致 .then也是异步操作 12345678910111213141516171819202122232425/// 设置需要填写的内容 _setDefaultData(List&lt;dynamic&gt; list) &#123; Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;); List&lt;dynamic&gt; list1 = []; /// 对jsonStr数据做解析 jsonStr.then((value) &#123; var data = json.decode(value); if(list != null || list.length &gt; 0) &#123; data = list; &#125; print(&apos;data ====&apos; + data.toString()); data.forEach((item) &#123; if(item[&apos;type&apos;] == &apos;1&apos;) &#123; list1.add(item); &#125; &#125;); &#125;); print(&apos;list1======&apos; + list1.toString()); this.setState(() &#123; this.saveList = list1; &#125;); &#125; 如图这种代码会先输出list1的信息，然后在输出data的信息说明jsonStr.then 为异步操作]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter android端 原理解析]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter-android%E7%AB%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[flutter android端 原理解析首先看MainActivity， 继承FlutterActivity 再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory 12345678910111213141516private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);private final FlutterActivityEvents eventDelegate;private final Provider viewProvider;private final PluginRegistry pluginRegistry;public FlutterActivity() &#123; this.eventDelegate = this.delegate; this.viewProvider = this.delegate; this.pluginRegistry = this.delegate;&#125;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.eventDelegate.onCreate(savedInstanceState);&#125; 一看delegate就知道代理模式 在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值， FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。 FlutterActivityDelegate 就是FlutterActivityEvents类的实现. 看FlutterActivityDelegate类中的onCreate函数 123456789101112131415161718192021222324252627282930public void onCreate(Bundle savedInstanceState) &#123; if (VERSION.SDK_INT &gt;= 21) &#123; Window window = this.activity.getWindow(); window.addFlags(-2147483648); window.setStatusBarColor(1073741824); window.getDecorView().setSystemUiVisibility(1280); &#125; String[] args = getArgsFromIntent(this.activity.getIntent()); FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args); this.flutterView = this.viewFactory.createFlutterView(this.activity); if (this.flutterView == null) &#123; FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView(); this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView); this.flutterView.setLayoutParams(matchParent); this.activity.setContentView(this.flutterView); this.launchView = this.createLaunchView(); if (this.launchView != null) &#123; this.addLaunchView(); &#125; &#125; if (!this.loadIntent(this.activity.getIntent())) &#123; String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext()); if (appBundlePath != null) &#123; this.runBundle(appBundlePath); &#125; &#125; &#125; 首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。 android端与dart端通信1、dart端调用android端代码1、原生android代码新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。 重写onMethodCall方法，在此处写需要实现的逻辑代码 最后是将插件绑定。 12345678910111213141516171819202122232425262728293031323334public class TestPlugin implements MethodChannel.MethodCallHandler &#123; public static final String CHANNEL = &quot;plugin/test&quot;; static MethodChannel channel; // 上下文 private Activity activity; private TestPlugin(Activity activity) &#123; this.activity = activity; &#125; public static void registerWith(PluginRegistry.Registrar registrar) &#123; channel = new MethodChannel(registrar.messenger(), CHANNEL); TestPlugin plugin = new TestPlugin(registrar.activity()); // 在此通道上接受方法调用的回调 channel.setMethodCallHandler(plugin); &#125; @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123; if(methodCall.method.equals(&quot;test&quot;)) &#123; Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show(); result.success(&quot;调用成功&quot;); &#125; // 当未找到该函数 result.notImplemented(); &#125;&#125; 在MainActivity中绑定 1234567891011121314151617public class MainActivity extends FlutterActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); registerPlugin(this); &#125; private void registerPlugin(PluginRegistry registry) &#123; TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL)); &#125;&#125; 2、在dart中调用该原生方法1234567static const _platform = const MethodChannel(&apos;plugin/test&apos;);_toast() &#123; /// 调用原生的方法 _platform.invokeMethod(&apos;test&apos;); &#125; 一个原生插件调用就完成了。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook推广api 推广主页]]></title>
    <url>%2Fblog%2F2019%2F07%2Ffacebook%E6%8E%A8%E5%B9%BFapi-%E6%8E%A8%E5%B9%BF%E4%B8%BB%E9%A1%B5.html</url>
    <content type="text"><![CDATA[主页推广]]></content>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2Fblog%2F2019%2F07%2Fmaven.html</url>
    <content type="text"><![CDATA[mavenmaven 查看依赖树mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXXcode xxx // 打开xxx文件 // gradle 查看依赖树gradle app:dependency // 查看依赖树关系]]></content>
  </entry>
  <entry>
    <title><![CDATA[react发布到javaweb]]></title>
    <url>%2Fblog%2F2019%2F07%2Freact%E5%8F%91%E5%B8%83%E5%88%B0javaweb.html</url>
    <content type="text"><![CDATA[react项目发布到javaweb中1、打包react直接执行npm run build命令：发现在build目录下生成资源文件，但是打开index.html发现报错，发现在生成的index.html中引入的文件路径有问题：/static /多余，或者说少了. 正确的路径应该是：static 或者 ./static 发现是%PUBLIC_URL%问题，在构建时应该执行 PUBLIC_URL=./ npm run build 2、集成到javaweb中将上一步生成build目录下的文件都复制放在webapp路径下，启动应用就能直接访问到index.html文件]]></content>
      <tags>
        <tag>react+spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook 营销api集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-%E8%90%A5%E9%94%80api%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[facebook 营销api集成营销api需要通过后端服务器与facebook服务器交互 1、下载营销api java代码git clone https://github.com/facebook/facebook-java-business-sdk.git 编辑器：IDEA 123456789101112// 在pom.xml中添加依赖&lt;dependency&gt; &lt;groupId&gt;com.facebook.business.sdk&lt;/groupId&gt; &lt;artifactId&gt;facebook-java-business-sdk&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;插件maven-source-plugin 无法下载因缺失版本号添加&lt;version&gt;3.1.0&lt;/version&gt;// 解决idea报错在&lt;build&gt;&lt;/build&gt;标签内添加&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;在&lt;plugins&gt;&lt;/plugins&gt;标签外套一个标签&lt;pluginManagement&gt;&lt;/pluginManagement&gt; 添加java文件123456789101112131415161718192021222324252627282930import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;import com.facebook.ads.sdk.APIException;public class QuickStartExample &#123; public static final String ACCESS_TOKEN = &quot;[Your access token]&quot;;//Your access token public static final Long ACCOUNT_ID = 123456789L; //Your account ID public static final String APP_SECRET = &quot;[Your app secret]&quot;;//Your app secret public static final APIContext context = new APIContext(ACCESS_TOKEN, APP_SECRET); public static void main(String[] args) &#123; try &#123; System.out.println(&quot;==========&quot;); AdAccount account = new AdAccount(ACCOUNT_ID, context); Campaign campaign = account.createCampaign() .setName(&quot;Java SDK Test Campaign&quot;) .setObjective(Campaign.EnumObjective.VALUE_LINK_CLICKS) .setSpendCap(10000L) .setStatus(Campaign.EnumStatus.VALUE_PAUSED) .execute(); System.out.println(campaign.fetch()); &#125; catch (APIException e) &#123; e.printStackTrace(); &#125; &#125;&#125; or 123456789101112131415161718192021222324import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.APINodeList;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;public class TestFBJavaSDK&#123; public static final APIContext context = new APIContext( &quot;your-access-token&quot;, &quot;your-appsecret&quot; ); public static void main(String[] args) &#123; AdAccount account = new AdAccount(&quot;act_&#123;your-adaccount-id&#125;&quot;, context); try &#123; APINodeList&lt;Campaign&gt; campaigns = account.getCampaigns().requestAllFields().execute(); for(Campaign campaign : campaigns) &#123; System.out.println(campaign.getFieldName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行java文件既可发布请求到facebook服务器， 需要安全上网 1、主页推广根据提示一步一步提交，到 沙盒账号，如果之前没有添加则新建，要推广的主页，如果无则新建 到下载示例代码，点下载，将会获得一个java文件，里面含有accessToken、appid、ad_account_id、app_secret等信息，将该下载的SAMPLE_CODE.java文件放于与上面两个java文件同级目录，直接运行该java文件即可，注意此时电脑需要科学上网，不然会报错Timeout]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook sdk 集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-sdk-%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[Facebook sdk 集成首先需要在facebook注册一个账号，自通过账号进入facebook的开发者平台 创建应用，只需要填写应用名即可，回生成一个appid。 集成事件功能1、配置远端maven仓库地址 在项目android/build.gradle文件123456789101112131415buildscript&#123; repositories&#123; ... mavenCentral(); // 添加这行 &#125;&#125;allprojects&#123; repositories &#123; ... mavenCentral() // 添加这行 &#125;&#125; 2、添加依赖在app/build.gradle文件中添加依赖123456dependencies&#123; ... implementation &apos;com.facebook.android:facebook-android-sdk:[4,5)&apos; // 添加这行 // 最新sdk版本为 implementation &apos;com.facebook.android:facebook-android-sdk:[5,6)&apos; &#125; 3、添加facebook-app-id在res/values/string.xml中1234&lt;string name=&quot;facebook_app_id&quot;&gt;462119014332748&lt;/string&gt; &lt;string name=&quot;fb_login_protocol_scheme&quot;&gt;fb462119014332748&lt;/string&gt;// 462119014332748为你在facebook应用的appid// fb_login_protocol_scheme应该是用于登陆的 在/app/manifest/AndroidManifest.xml中12345678910111213141516&lt;application&gt; &lt;meta-data android:name=&quot;com.facebook.sdk.ApplicationId&quot; android:value=&quot;@string/facebook_app_id&quot;/&gt; &lt;activity android:name=&quot;com.facebook.FacebookActivity&quot; android:configChanges= &quot;keyboard|keyboardHidden|screenLayout|screenSize|orientation&quot; android:label=&quot;@string/app_name&quot; /&gt; &lt;activity android:name=&quot;com.facebook.CustomTabActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;@string/fb_login_protocol_scheme&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 4、在facebook开发者控制台配置analytics sdk在facebook开发者官网，点击「我的应用」即可进入应用控制台，可以创建应用，只需提供应用名，以及邮箱即可， 点击单个应用即可进入应用控制台进行编辑;上图是应用可添加的功能， 点击Analytics即将功能添加进应用，点设置，前几步都是提示，第四步，填入应用id，app/build.gradle中的applicationid，以及应用默认启动的Actiivty， 第五步，填入密钥散列，注意应该要填入两个，一个开发、一个发布，即debug自带的、一个release时通过jks文件签名生成的。获取方法12345// macos debug ，按下enter键需要输入开机密码keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64// release keytool -exportcert -alias YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl base64 5、发送事件 上面的1、2、3都只是基本配置，下面是手动发送事件 在MainApplication.java中FacebookSdk.sdkInitialize 四个初始化方法都已被遗弃， 看到说是不需要初始化了 在MainApplication.java中 12345678910@Override public void onCreate() &#123; super.onCreate(); // facebook 初始化 FacebookSdk.setIsDebugEnabled(true); AppEventsLogger.activateApp(MainApplication.this); FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS); &#125; 注意facebooksdk回自动收集一些事件,如果不需要自动收集功能需要在清单文件中配置 1234&lt;meta-data android:name=&quot;com.facebook.sdk.AutoLogAppEventsEnabled&quot; android:value=&quot;false&quot;/&gt; 在Actiivty中测试发送自定义事件 123456789101112@Overrideprotected void onResume() &#123; super.onResume(); logEvent();&#125;private void logEvent() &#123; Log.d(&quot;========&quot;, &quot;logEvent&quot;); AppEventsLogger logger = AppEventsLogger.newLogger(this); logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP); logger.logEvent(&quot;Test Event&quot;);&#125; 在测试时发现，当打断点调试时发现，发送事件总是会失败，正常运行却可以在facebook分析工具中看得到提交的事件。 后续：在sdk集成后，可以看到之前定义的事件数据。但是在连接商务平台，想要发布广告时。需要通过自己的事件来定义受众、或者定义类似受众时发现，在商务平台无法获取到自定义事件的数据。甚至都无法获取到我们的应用。后来看官方文档，发现出了自定义事件、自动收集的事件，还有一个标准事件。在我添加了一个标准事件后，就在商务平台上能找到在开发平台提交的app了。但是那些自定义受众、类似受众功能貌似只能绑定到 facebook定义的标准事件，而不能是我们自己的自定义事件 注意，运行时手机需要能连接到facebook后台服务器，大陆用户需要科学上网。]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android okHttp3]]></title>
    <url>%2Fblog%2F2019%2F06%2Fandroid-okHttp3.html</url>
    <content type="text"><![CDATA[OkHttp3使用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode的常用插件与插件开发]]></title>
    <url>%2Fblog%2F2019%2F04%2Fvscode%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。 nodejs123456curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash. ~/.bashrc#显示有远端的版本nvm ls-remote#安装对应的版本nvm install 对应的版本 安装常用工具： 1234567891011npm install hexo-cli -gnpm install hexo-server -gnpm install hexo-deployer-git -gnpm install yarn -gnpm install http-server -gyarn global add servenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalyarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 常用插件安装以下插件：12345678910111213141516171819202122232425262728293031323334#javascripteslintColor PickernpmDebugger for ChromeEclipse Keymap#reactES7 React/Redux/GraphQL/React-Native snippets#vueVeturVue VSCode Snippets#gitGitLenszerofinance-git#其他公共插件Local HistoryXML ToolsPrettier#https://zhuanlan.zhihu.com/p/54031899koroFileHeaderAutoFileNameImport Cost#javaJava Extension PackSpring Boot Extension PackJava Code GeneratorsDocker#android/ios pluginAndroid iOS EmulatorReact Native Tools#see debug:https://github.com/Microsoft/vscode-react-native/blob/master/doc/debugging.md#debugging-on-ios-device#Install ios-deploy: npm install -g ios-deploy 代码注释koroFileHeader添加注释，在全局的settings.json中添加： 参考： https://code.visualstudio.com/docs/editor/emmet https://www.cnblogs.com/summit7ca/p/6944215.html 12345678910111213141516171819202122232425262728"editor.fontSize": 14,"terminal.integrated.fontSize": 14,"emmet.triggerExpansionOnTab": true,"emmet.includeLanguages": &#123; "javascript": "javascriptreact", "vue-html": "html", "razor": "html", "plaintext": "jade"&#125;,// 注释"fileheader.configObj": &#123; // 将该选项设置为true即可开启 "autoAdd": false&#125;,// 头部注释"fileheader.customMade": &#123; "Author": "dave.zhao", "Date": "Do not edit", "LastEditors": "dave.zhao", "LastEditTime": "Do not edit", "Description": ""&#125;,// 函数注释"fileheader.cursorMode": &#123; "Date": "Do not edit", "description": "", "param": ""&#125; 注意：Author和LastEditors填写自己的名字 文件头注释快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i 函数注释快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t 常用配置可以放在全局的settings.json中，也可以放在各个项目的settings.json中： 1234567891011121314151617181920&#123; "eslint.validate": ["javascript", "javascriptreact"], "javascript.updateImportsOnFileMove.enabled": "always", // 代码缩进修改成4个空格 "editor.detectIndentation": false, "editor.tabSize": 4, "editor.formatOnSave": true, // 每次保存的时候将代码按eslint格式进行修复 "eslint.autoFixOnSave": true, // 让prettier使用eslint的代码格式进行校验 "prettier.eslintIntegration": true, // 去掉代码结尾的分号 "prettier.semi": false, // 使用带引号替代双引号 "prettier.singleQuote": true, "prettier.tabWidth": 4, "prettier.printWidth": 250, // 让函数(名)和后面的括号之间加个空格 "javascript.format.insertSpaceBeforeFunctionParenthesis": true&#125; 插件开发参考代码https://github.com/zhaoxunyong/vs-code-git-plugin 参考 https://segmentfault.com/a/1190000008968904 https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://github.com/steveukx/git-js https://www.jianshu.com/p/2b096d8ad9b8 https://github.com/Microsoft/vscode-extension-samples https://www.jianshu.com/p/520c575e91c3 https://segmentfault.com/a/1190000017279102 https://segmentfault.com/a/1190000014758981 https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
