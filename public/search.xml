<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>CameraX</title>
      <link href="/blog/2022/03/CameraX.html"/>
      <url>/blog/2022/03/CameraX.html</url>
      
        <content type="html"><![CDATA[<p>CameraX 是对 Jetpack 的补充，可让您更轻松地利用 Camera2 API 的功能。</p><h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="keyword">def</span> camerax_version = <span class="string">"1.0.2"</span></span><br><span class="line">  <span class="comment">// The following line is optional, as the core library is included indirectly by camera-camera2</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-core:$&#123;camerax_version&#125;"</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-camera2:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Lifecycle library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX VideoCapture library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-video:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX View class</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-view:1.1.0-beta02"</span></span><br><span class="line">  <span class="comment">// If you want to additionally use the CameraX Extensions library</span></span><br><span class="line">  implementation <span class="string">"androidx.camera:camera-extensions:1.1.0-beta02"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-CameraX-开启预览"><a href="#使用-CameraX-开启预览" class="headerlink" title="使用 CameraX 开启预览"></a>使用 CameraX 开启预览</h2><p>在向应用添加预览时，请使用 PreviewView，这是一种可以剪裁、缩放和旋转以确保正确显示的 View。</p><p>当相机处于活动状态时，图片预览会流式传输到 PreviewView 中的 Surface。</p><h3 id="将-PreviewView-添加到布局"><a href="#将-PreviewView-添加到布局" class="headerlink" title="将 PreviewView 添加到布局"></a>将 PreviewView 添加到布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".camera.CameraActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.camera.view.PreviewView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/previewView"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="请求-CameraProvider"><a href="#请求-CameraProvider" class="headerlink" title="请求 CameraProvider"></a>请求 CameraProvider</h3><p>以下代码展示了如何请求 CameraProvider：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CameraActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> cameraProviderFuture: ListenableFuture&lt;ProcessCameraProvider&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> dataBinding: ActivityCameraBinding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        dataBinding = ActivityCameraBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(dataBinding.root)</span><br><span class="line">        cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查-CameraProvider-可用性"><a href="#检查-CameraProvider-可用性" class="headerlink" title="检查 CameraProvider 可用性"></a>检查 CameraProvider 可用性</h3><p>请求 CameraProvider 后，请验证它能否在视图创建后成功初始化。以下代码展示了如何执行此操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">  <span class="keyword">val</span> cameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line">  bindPreview(cameraProvider)</span><br><span class="line"></span><br><span class="line">&#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure><h3 id="选择相机并绑定生命周期和用例"><a href="#选择相机并绑定生命周期和用例" class="headerlink" title="选择相机并绑定生命周期和用例"></a>选择相机并绑定生命周期和用例</h3><p>创建并确认 CameraProvider 后，请执行以下操作:</p><ul><li><p>1、创建 Preview。</p></li><li><p>2、指定所需的相机 LensFacing 选项。</p></li><li><p>3、将所选相机和任意用例绑定到生命周期。</p></li><li><p>4、将 Preview 连接到 PreviewView。</p></li></ul><p>以下代码展示了一个示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindPreview</span><span class="params">(cameraProvider: <span class="type">ProcessCameraProvider</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> preview: Preview = Preview.Builder()</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cameraSelector: CameraSelector = CameraSelector.Builder()</span><br><span class="line">        .requireLensFacing(CameraSelector.LENS_FACING_BACK)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    preview.setSurfaceProvider(dataBinding.previewView.getSurfaceProvider())</span><br><span class="line">    <span class="keyword">var</span> camera = cameraProvider?.bindToLifecycle(<span class="keyword">this</span> <span class="keyword">as</span> LifecycleOwner, cameraSelector, preview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，bindToLifecycle() 会返回一个 Camera 对象。如需详细了解如何控制相机输出（如变焦和曝光），请参阅此指南。</p><p>现在，您已完成实现相机预览的操作。请构建您的应用，然后确认预览是否出现在您的应用中并能按预期工作。</p><p>PS: 记得需要相机权限</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android-Jetpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见的排序算法</title>
      <link href="/blog/2022/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html"/>
      <url>/blog/2022/02/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，当前元素与下一个元素对比，将较大值放于右侧，<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//选择排序算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length-<span class="number">1</span> ;i++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;args.length ;j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[min]&gt;args[j])&#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=args[i];</span><br><span class="line">            args[i]=args[min];</span><br><span class="line">            args[min]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重 for 循环，取出最小值或者最大值，交互数组位置，使最值位于数组两侧，最后得出一个升序/降序数组<br>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] args)&#123;<span class="comment">//插入排序算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (args[j]&lt;args[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=args[j-<span class="number">1</span>];</span><br><span class="line">                args[j-<span class="number">1</span>]=args[j];</span><br><span class="line">                args[j]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>使用系统自带的排序方法 sorts<br>时间复杂度：O(nlogn)<br>空间复杂度：O(n)</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的遍历一般根据节点可分为三种：前序、中序、后序遍历<br>根据树的层级又有层级遍历</p><p>下面的代码就是一个树结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Node left;</span><br><span class="line"><span class="keyword">private</span> Node right;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Node[ no = "</span> + no + <span class="string">", name ="</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>先取父节点，再取左节点，再去右节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.DLR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><p>先取左节点，再取父节点，再去右节点<br>中序遍历可以得出一个升序结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LDR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LDR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>先取左节点，再取右节点，再去父节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LRD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.left.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.right.LRD();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);<span class="comment">// 先输出根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jetpack-ViewModel</title>
      <link href="/blog/2022/02/jetpack-ViewModel.html"/>
      <url>/blog/2022/02/jetpack-ViewModel.html</url>
      
        <content type="html"><![CDATA[<p>参考 android developer 中的文档：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>当 ViewModel 构造函数为有参构造函数时，使用 private val model : OverTimeViewModel by activityViewModels() 会报错<br>此时处理方案为新建一个Factory类<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> dataSource: OverTimeDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span>(modelClass.isAssignableFrom(OverTimeViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OverTimeViewModel(dataSource) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在写一个静态类，作为Factory作为Provider</span></span><br><span class="line"><span class="keyword">object</span> Injection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideUserDataSource</span><span class="params">(context: <span class="type">Context</span>)</span></span>: OverTimeDao &#123;</span><br><span class="line">        <span class="keyword">val</span> database = AppDatabase.getInstance(context)</span><br><span class="line">        <span class="keyword">return</span> database.overTimeDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideViewModelFactory</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ViewModelFactory &#123;</span><br><span class="line">        <span class="keyword">val</span> dataSource = provideUserDataSource(context)</span><br><span class="line">        <span class="keyword">return</span> ViewModelFactory(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ViewModel实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModelFactory: ViewModelFactory</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> model : OverTimeViewModel <span class="keyword">by</span> activityViewModels&#123; viewModelFactory &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在特定的生命函数中实例化ViewModelFactory</span></span><br><span class="line">viewModelFactory = Injection.provideViewModelFactory(activity!!)</span><br></pre></td></tr></table></figure></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ViewPager2</title>
      <link href="/blog/2022/02/ViewPager2.html"/>
      <url>/blog/2022/02/ViewPager2.html</url>
      
        <content type="html"><![CDATA[<p>参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-swipe-view-2</a></p><p>需要对比 ViewPager2 与 ViewPager 的差异、优劣</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jetpack-Navigation</title>
      <link href="/blog/2022/02/jetpack-Navigation.html"/>
      <url>/blog/2022/02/jetpack-Navigation.html</url>
      
        <content type="html"><![CDATA[<p>具体参考指南地址：<a href="https://developer.android.google.cn/guide/navigation/navigation-getting-started" target="_blank" rel="noopener">https://developer.android.google.cn/guide/navigation/navigation-getting-started</a></p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>Navigation 其实是对 Fragment 跳转的管理，而不是 Activity，需要配置到某个 Activity 中。<br>其实是单 Activity 模式</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jetpack Room</title>
      <link href="/blog/2021/12/jetpack-Room.html"/>
      <url>/blog/2021/12/jetpack-Room.html</url>
      
        <content type="html"><![CDATA[<p><strong>使用 Room 将数据保存到本地数据库</strong></p><p>Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。</p><p>处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的用例是缓存相关数据。这样，当设备无法访问网络时，用户仍可在离线状态下浏览相应内容。设备重新连接到网络后，用户发起的所有内容更改都会同步到服务器。</p><p>由于 Room 负责为您处理这些问题，因此我们强烈建议您使用 Room（而不是 SQLite）。不过，如果您想直接使用 SQLite API，请参阅使用 SQLite 保存数据。</p><p>如需在应用中使用 Room，请将以下依赖项添加到应用的 build.gradle 文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.3.0"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava3 support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava3:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers</span></span><br><span class="line">    testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Paging 3 Integration</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-paging:2.4.0-rc01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常情况记录"><a href="#异常情况记录" class="headerlink" title="异常情况记录"></a>异常情况记录</h2><ul><li>Room AppDatabase_Impl does not exist</li></ul><p>使用了 kotlin 构建了项目,并且使用 kotlin 编写 room 创建数据库,在 build.gradle 文件里做如下修改</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'com.android.library'</span></span><br><span class="line">    id <span class="string">'kotlin-android'</span></span><br><span class="line">    id <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">    id <span class="string">'kotlin-kapt'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//略...</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api<span class="string">"android.arch.persistence.room:runtime:$rootProject.room_version"</span></span><br><span class="line">    kapt<span class="string">"android.arch.persistence.room:compiler:$rootProject.room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 annotationProcessor 替换成 kapt,请注意需要导入 id ‘kotlin-kapt’ 才能使用 kapt</p><p>参考地址：<a href="https://www.cnblogs.com/guanxinjing/p/14990401.html" target="_blank" rel="noopener">https://www.cnblogs.com/guanxinjing/p/14990401.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jetpack DataSource</title>
      <link href="/blog/2021/12/jetpack-DataSource.html"/>
      <url>/blog/2021/12/jetpack-DataSource.html</url>
      
        <content type="html"><![CDATA[<p>Jetpack DataStore 是一种数据存储解决方案，允许您使用协议缓冲区存储键值对或类型化对象。DataStore 使用 Kotlin 协程和 Flow 以异步、一致的事务方式存储数据。</p><p>DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。</p><ul><li>Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。</li><li>Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用协议缓冲区来定义架构，但可以确保类型安全。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jetpack lifecycle</title>
      <link href="/blog/2021/12/jetpack-lifecycle.html"/>
      <url>/blog/2021/12/jetpack-lifecycle.html</url>
      
        <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 库中用来感知生命周期的组件</p><h2 id="使用生命周期感知型组件处理生命周期"><a href="#使用生命周期感知型组件处理生命周期" class="headerlink" title="使用生命周期感知型组件处理生命周期"></a>使用生命周期感知型组件处理生命周期</h2><p>生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您编写出更有条理且往往更精简的代码，此类代码更易于维护。</p><p>一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。</p><p>androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。</p><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p><p>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p><p><strong>事件</strong><br>从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。<br><strong>状态</strong><br>由 Lifecycle 对象跟踪的组件的当前状态</p><p><img src="../../../images/lifecycle.svg" style="zoom:60%"></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(MainLifecycleObserver())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainLifecycleObserver</span></span>() : LifecycleObserver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> TAG: String  = <span class="string">"MainLifecycleObserver"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityCreated: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityResume: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onActivityStopped: "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，就可以實現在 Activity 之外獲取到生命週期的變化，避免在 Activity/Fragment 中的生命週期中寫大量業務代碼</p><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>LifecycleOwner 是单一方法接口，表示类具有 Lifecycle。它具有一种方法（即 getLifecycle()），该方法必须由类实现。如果您尝试管理整个应用进程的生命周期，请参阅 ProcessLifecycleOwner。</p><p>此接口从各个类（如 Fragment 和 AppCompatActivity）抽象化 Lifecycle 的所有权，并允许编写与这些类搭配使用的组件。任何自定义应用类均可实现 LifecycleOwner 接口。</p><p>实现 DefaultLifecycleObserver 的组件可与实现 LifecycleOwner 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。</p><h3 id="自定義-LifecycleOwner"><a href="#自定義-LifecycleOwner" class="headerlink" title="自定義 LifecycleOwner"></a>自定義 LifecycleOwner</h3><p>我們不只是可以綁定視圖的生命週期，可以通過 LifecycleOwner 自定義對應色生命週期<br>如當處於 Activity 的 onCreate、onStart 中都需執行 onStart</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), LifecycleOwner &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LifeCycle 组件实际上并没有带来什么新的功能，他通过观察者模式+注解来让我们更方便的监听 Activity 和 Fragment 的生命周期变化。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kotlin学习指南一</title>
      <link href="/blog/2021/12/kotlin%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80.html"/>
      <url>/blog/2021/12/kotlin%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%E4%B8%80.html</url>
      
        <content type="html"><![CDATA[<p>kotlin 是 google 推出的一門新語言，也是基於 JVM 的。</p><h2 id="kotlin-基础"><a href="#kotlin-基础" class="headerlink" title="kotlin 基础"></a>kotlin 基础</h2><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>新建一个 kt 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主入口 main 方法， 无需新建类即可运行，函数声明用 fun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int, b:Int):Int&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值写在参数之后</p><p>表达式可以作为函数体，返回值类型自动推断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sun(a:Int, b:Int) = a+b;</span><br></pre></td></tr></table></figure><p>返回无意义的值用 Unit 表示</p><p>fun test():Unit {<br>println(“test”);<br>}</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>变量赋值声明关键字：var、val<br>var：声明变量<br>val：声明常量</p><p>var i:Int = 1;<br>val PI:Double = 3.14;</p><p>当声明并赋值时，数据类型可以省略, 会自动推断数据类型<br>var i = 1;<br>val PI = 3.14</p><p>当声明但不赋值时，不能省略数据类型<br>var i:Int;<br>val PI:Double;</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;aaaaa&quot;;</span><br><span class="line">var b = &quot;str = $s&quot;;</span><br><span class="line">var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testIf(a:Int, b:Int):Int &#123;</span><br><span class="line">    if(a &gt; b) return a;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 kotlin 中，if 还可以用作表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun max(a:Int, b:Int) = if(a &gt; b) a else b</span><br></pre></td></tr></table></figure><h2 id="空值与-null-检测"><a href="#空值与-null-检测" class="headerlink" title="空值与 null 检测"></a>空值与 null 检测</h2><p>当某个值可以为空时，需要在类型后添加?表示可以为空<br>此时，声明时不能省略类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj:Objects ? = null;</span><br><span class="line">// 表示返回值可以为null</span><br><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型检测与自动类型转换"><a href="#类型检测与自动类型转换" class="headerlink" title="类型检测与自动类型转换"></a>类型检测与自动类型转换</h2><p>is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 </strong></p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);</span><br><span class="line">// 根据元素遍历</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据下标便利</span><br><span class="line">for (item in items.indices) &#123;</span><br><span class="line">    println(items[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = 0;</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(items[index]);</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when-表达式"><a href="#when-表达式" class="headerlink" title="when 表达式"></a>when 表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private fun testWhen(s: Any?) &#123;</span><br><span class="line">        when(s) &#123;</span><br><span class="line">            &quot;a&quot; -&gt; 1;</span><br><span class="line">            &quot;b&quot; -&gt; 2;</span><br><span class="line">            is String -&gt; 3;</span><br><span class="line">            1 -&gt; &quot;n&quot;;</span><br><span class="line">            2 -&gt; &#123;</span><br><span class="line">              println(&quot;222&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            else -&gt; &quot;else&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有点类似 java 中的 switch</p><h2 id="区间-range"><a href="#区间-range" class="headerlink" title="区间 range"></a>区间 range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = 9;</span><br><span class="line">if(x in 0..y) &#123;</span><br><span class="line">    println(&quot;x in 0 - y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间只用于数字</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的迭代可以用的上面的 for in 循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">for(item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断集合中是否包含某元素 用 while in || when</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (&quot;a&quot; in items) &#123;</span><br><span class="line">    println(&quot;items include a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when &#123;</span><br><span class="line">    &quot;a&quot; in items -&gt; println(&quot;aaa&quot;);</span><br><span class="line">    &quot;d&quot; in items -&gt; println(&quot;ddd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 lambda 来过滤和映射集合 ，与 java8 lambda stream 大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125;</span><br><span class="line">    .sortBy&#123; it &#125;</span><br><span class="line">    .map&#123; it.toUpperCase() &#125;</span><br><span class="line">    .forEach&#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>什么是协程？<br>官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。<br>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</p><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。<br>CPU 调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。<br>而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p><p>协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。</p><p>build.gralde 中引入依赖<br>implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1”</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity4 : AppCompatActivity() &#123;</span><br><span class="line">    val TAG = &quot;MainActivity4&quot;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main2)</span><br><span class="line">        test()</span><br><span class="line">        Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun test() = runBlocking &#123;</span><br><span class="line">        repeat(8) &#123;</span><br><span class="line">            Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>协程执行 0 线程 id：1<br>协程执行 1 线程 id：1<br>协程执行 2 线程 id：1<br>协程执行 3 线程 id：1<br>协程执行 4 线程 id：1<br>协程执行 5 线程 id：1<br>协程执行 6 线程 id：1<br>协程执行 7 线程 id：1<br>线程 main ：1</p><p>我们可以得出结论：<br>runBlocking 会阻塞线程，但允许还是在当前线程</p><h3 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch:Job"></a>launch:Job</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testJob() &#123;</span><br><span class="line">        val job = GlobalScope.launch &#123;</span><br><span class="line">            repeat(8) &#123;</span><br><span class="line">                delay(2000)</span><br><span class="line">                Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>testJob: 线程 main：2<br>testJob: 线程 id:6809<br>testJob: 线程 id:6807<br>testJob: 线程 id:6807<br>testJob: 线程 id:6815<br>testJob: 线程 id:6807<br>testJob: 线程 id:6808<br>testJob: 线程 id:6818<br>testJob: 线程 id:6809</p><p>说明使用 GlobalScope.launch</p><ul><li>并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务</li><li>是非阻塞、异步执行，相当于开启了子线程</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun testAsync()&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        var result1 = GlobalScope.async &#123;</span><br><span class="line">            getResult1()</span><br><span class="line">        &#125;</span><br><span class="line">        var result2 = GlobalScope.async &#123;</span><br><span class="line">            getResult2()</span><br><span class="line">        &#125;</span><br><span class="line">        val result = result1.await() + result2.await()</span><br><span class="line">        Log.e(TAG, &quot;testAsync: ThreadId =  $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult1():Int &#123;</span><br><span class="line">    delay(3000)</span><br><span class="line">    Log.e(TAG, &quot;getResult1: ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult2():Int &#123;</span><br><span class="line">    delay(5000)</span><br><span class="line">    Log.e(TAG, &quot;getResult2:  ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>E/MainActivity4: 线程 main ：2<br>E/MainActivity4: getResult1: ThreadId = 7870<br>E/MainActivity4: getResult2: ThreadId = 7870<br>E/MainActivity4: testAsync: ThreadId = 7870 result = 9</p><p>其中当打印 getResult2 后就打印了 testAsync: result = 9<br>阻塞时间为 5 秒，而不是 8 秒，说明 getResult1、getResult2 是并行的。</p><p>而且发现 threadId 都一样，说明处于同一个线程。<br>但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。</p><ul><li>协程并不等于线程，协程内部会根据任务情况自动调度线程。</li></ul><p>launch()有三个入参： 1.协程下上文；2.协程启动模式；3.协程体：block 是一个带接收者的函数字面量，接收者是 CoroutineScope</p><p>我们在线程中执行的代码就是第三个参数</p><h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>上下文可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。上下文有一个重要的作用就是线程切换，Kotlin 协程使用调度器来确定哪些线程用于协程执行，Kotlin 提供了调度器给我们使用：</p><p>Dispatchers.Main：使用这个调度器在 Android 主线程上运行一个协程。可以用来更新 UI 。在 UI 线程中执行</p><p>Dispatchers.IO：这个调度器被优化在主线程之外执行磁盘或网络 I/O。在线程池中执行</p><p>Dispatchers.Default：这个调度器经过优化，可以在主线程之外执行 cpu 密集型的工作。例如对列表进行排序和解析 JSON。在线程池中执行。</p><p>Dispatchers.Unconfined：在调用的线程直接执行。</p><p>调度器实现了 CoroutineContext 接口。</p><p>我们还可以自己自定义调度器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dis = Executors.newCachedThreadPool().asCoroutineDispatcher()</span><br><span class="line">runBlocking &#123;</span><br><span class="line">    launch(dis) &#123;</span><br><span class="line">        println(&quot;dis 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>在 Kotlin 协程当中，启动模式定义在一个枚举类中：</p><p>public enum class CoroutineStart {<br>DEFAULT,<br>LAZY,<br>@ExperimentalCoroutinesApi<br>ATOMIC,<br>@ExperimentalCoroutinesApi<br>UNDISPATCHED;<br>}<br>一共定义了 4 种启动模式，<br>DEFAULT: 默认的模式，立即执行协程体<br>LAZY: 只有在需要的情况下运行<br>ATOMIC: 立即执行协程体，但在开始运行之前无法取消<br>UNDISPATCHED :立即在当前线程执行协程体，直到第一个 suspend 调用</p><h3 id="协程体"><a href="#协程体" class="headerlink" title="协程体"></a>协程体</h3><p>协程体是一个用 suspend 关键字修饰的一个无参，无返回值的函数类型。被 suspend 修饰的函数称为挂起函数,与之对应的是关键字 resume（恢复）<br>注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>Kotlin 的硬关键宇包括:</p><p>as 一一 用于做类型转换或为 import 语句指定别名<br>as?一一类型安全 的类型转换运算符。<br>break 一一中断循环<br>class 一一声明类。<br>continue 一忽略本次循环剩下的语句，重新开始下一次循环。<br>do 一一用于 do while 循环<br>else 一一在 if 分支中使用<br>false 一一在 Boolean 类型中表示假 的直接量。<br>for 一一用于 for 循环<br>fun 一一声 明函数<br>if－在 if 分支中使用<br>in 一一在 for 循环中使用； in 还可作为双目运算符，检查 一个值是否处于区间或集合 内；<br>in 也可 在 when 表达式中使用； in 还可用于修饰泛型参数，表明该泛型参数支持逆变<br>!in 一一可作为双目运算符 的反义词：！in 也可在 when 表达式中使用<br>is 一一用于做类型检查（类 Java instanceof) 或在 when 表达式中使用<br>!is 一一 用于做类型检查（ is 的反义词〉或在 when 表达式中使用<br>null 一一 代表空的直接量。<br>object ——用于声明对象表达式或定义命名对象<br>package 一一用于为当 前文件指定包<br>return 一一声明函数的返回<br>super 一－用于引用父类实现的方法或属性，或者在子类构造器中调用父类构造器<br>this 一一 代表当前类的对象或在构造器中调用当前类的其他构造器<br>throw 一一用于抛出异常<br>true 一一在 Boolean 类型中表示真的直接量。<br>try 一一开始异常处理<br>typealias 一一用于定义类型别名。<br>val 一声明只读属性或变量。<br>var 一一声明可变属性或变量。<br>when 一一用于 when 表达式。while 一一－用于 while 循环或 do while 循环</p><p>Kotlin 的软关键宇包括：</p><p>by 一一用于将接口或祖先类的实现代理给其他对象。<br>catch 一一在异常处理中用于捕捉异常<br>constructor 一一用于声明构造器。<br>delegate 一用于指定该注解修饰委托属性存储其委托实例的字段<br>dynamic 一一主要用于在 Kotlin/JavaScript 中引用 一个动态类型<br>field 一一用于指定该注解修饰属性的幕后字段。<br>file 一一用于指定该注解修饰该源文件本身<br>finally 一一异常处理中的 finally<br>get 一一用于声明属性的 getter 方法，或者用于指定该注解修饰属性的 getter 方法<br>import 一一用于导包。<br>init 一一用于声明初始化块<br>param 一一用于指定该注解修饰构造器参数<br>property 一一用于指定该注解修饰整个属性（这种目标的注解对 Java 不可见，因为 Java<br>并没有真正的属性）。<br>receiveris 一一用于指定该注解修饰扩展方法或扩展属性的接收者<br>set 一一用于声明属性的 setter 方法，或者用于指定该注解修饰属性的 setter 方法<br>setparam 一一用于指定该注解修饰 setter 方法的参数<br>where 一一用于为泛型参数增加限制。</p><p>Kotlin 的修饰符关键宇包括：</p><p>abstract 一一用于修饰抽象类或抽象成员<br>annotation 一一用于修饰一个注解类。<br>companion 一一用于声明一个伴生对象<br>const 一一用于声明编译时常量<br>crossinline 一一用于禁止在传给内联函数的 Lambd 表达式中执行非局部返回<br>data 一一用于声明数据类。<br>enum 一一用于声明枚举<br>external 一一用于声明某个方法不由 Kotlin 实现（与 Java 的 native 相似〉。<br>final 一一用于禁止被重写<br>infix 一一声明该函数能以双目运算符的格式执行<br>inline 一一用于声明内联函数， Lambda 表达式可在内联函数中执行局部返回。<br>inner 一一用于声明内部类，内部类可以访问外部类的实例<br>internal 一一用于表示被修饰的声明只能在当前模块内可见<br>lateinit——-用于修饰 non-null 属性，用于指定该属性可在构造器以外的地方<br>初始化<br>noinline 一一用于禁止内联函数中个别 Lambda 表达式被内联化<br>open 一一用于修饰类，表示该类可派生子类；或者用于修饰成员，表示该成员可以被<br>重写。<br>out 一一用于修饰泛型参数，表明该泛型参数支持协变。<br>override 一一用于声明重写父类的成员<br>private ——private 访问权限<br>protected ——–protected 访问权限<br>public——-public 访问权限。<br>reified 一一用于修饰内联函数中的泛型形参，接下来在该函数中就可像使用普通类型<br>一样使用该类型参数。<br>sealed 一一用于声明一个密封类。<br>suspend 一一用于标识一个函数后 Lambda 表达式可作为暂停。<br>tailrec 一一用于修饰一个函数可作为尾随递归函数使用。<br>vararg 一一用于修饰形参，表明该参数是个数可变的形参。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/blog/2021/12/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html"/>
      <url>/blog/2021/12/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html</url>
      
        <content type="html"><![CDATA[<h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>浅拷贝与深拷贝的区别：浅拷贝只能拷贝数据中的栈内存空间数据，深拷贝是拷贝所以数据，包括堆内存中的数据</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>在之前讲过的拷贝构造函数，其实就是一种 浅拷贝<br>但是在浅拷贝中，无法拷贝堆内存中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Student1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student1() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student1(char * name) :Student1(name, 99) &#123; cout &lt;&lt; &quot;一个入参 构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    Student1(char * name, int age) &#123; </span><br><span class="line">cout &lt;&lt; &quot;两个入参构造函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">this-&gt;name = (char *) malloc(sizeof(char * ) * 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line"></span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student1() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上所示，Student 类中，在构造函数中，name 是动态开辟在堆内存上的，在析构函数中，会使用free释放 name 在堆内存的内存空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line">Student1 s1;</span><br><span class="line">Student1 s2 = s1; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行完上述代码时，会运行异常，<br>Student1 s2 = s1;  会执行 拷贝构造函数，将 s2 的值都复制给 s1<br>但是之前说过 <em> 拷贝构造函数是 浅拷贝 </em><br>浅拷贝 是不会拷贝堆内存中的数据的， 所以其实 s2 与 s1 中的 name 指向的同一块堆内存空间，<br>当main函数执行完毕，出栈时，会调用 s2、s1的析构函数，当指向s1的析构函数时，会释放 name 中的堆内存空间。<br>等到执行 s2 的析构函数时，又会执行 free(this-&gt;name); 但此时 this-&gt;name已经是一块指向NULL的指针了，此时就会抛出异常。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>上面讲了深拷贝与浅拷贝的区别，以及默认的拷贝构造函数是一次浅拷贝，接下来手动实现一下 深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">char * name;</span><br><span class="line"></span><br><span class="line">Student() &#123; cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">Student(char * name) :Student(name, 99) &#123;</span><br><span class="line">cout &lt;&lt; &quot;一个参数构造函数 this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(char * name, int age) &#123;</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Student() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数 &amp;this-&gt;name:&quot; &lt;&lt; (int)this-&gt;name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">free(this-&gt;name);</span><br><span class="line">this-&gt;name = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student(const Student &amp; stu) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;stu的地址 &amp;stu:&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot; this:&quot; &lt;&lt; (int)this &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">// 重新开辟一个堆内存存放新的 stu对象中的 name</span><br><span class="line">this-&gt;name = (char *)malloc(sizeof(char *)* 10);</span><br><span class="line">        // 复制name中的值</span><br><span class="line">strcpy(this-&gt;name, name);</span><br><span class="line">this-&gt;age = stu.age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void showStudent(Student stu) &#123;</span><br><span class="line">cout &lt;&lt; &quot;showStudent的内存地址&quot; &lt;&lt; (int)&amp;stu &lt;&lt; &quot;  &quot; &lt;&lt; stu.name &lt;&lt; &quot;,&quot; &lt;&lt; stu.age&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">Student stu(&quot;justin&quot;, 31);</span><br><span class="line"></span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line">showStudent(stu);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，在函数 showStudent 中会调用拷贝构造函数 然后执行完毕出栈，调用 析构函数，<br>但上述代码不会出现异常，因为在我们自定义的拷贝构造函数中，我们手动实现了堆内存的拷贝。并每次执行析构函数时，又会释放掉name的堆内存。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/blog/2021/12/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB.html"/>
      <url>/blog/2021/12/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>再java中，数据类型可分为两种：集合（Collection）、图（Map）<br>而这两大类中又可以细分，常用的子类为：<br>ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap</p><h2 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h2><p>集合可以细分为三类：List、Set、Queue</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口扩展自Collection，它可以定义一个允许重复的有序集合</p><p>List中常用的子类有：ArrayList、LinkerList、CopyOnWriteArrayList</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList内部的数据结构为数组，当增加元素数量大于初始容量，会触发扩容，即新建一个之前容量两位的数组，并将之前的元素拷贝过来。<br>查询快，增删慢<br><strong><em>非线程安全</em></strong></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList内部的数据结构为链表，双向链表。<br>查询慢，增删快<br><strong><em>非线程安全</em></strong></p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。<br><strong><em>线程安全，通过ReentrantLock实现</em></strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。<br>Set接口有三个具体实现类：散列集HashSet、链式散列集LinkedHashSet、树形集TreeSet</p><p>Set判断是否重复的原理是，先判断Hash，如果Hash相同再判断equals</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>散列集HashSet是一个用于实现Set接口的具体类，<br>有两个名词需要关注，初始容量和客座率。<br>客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，就会触发扩容。</p><p><strong><em>非线程安全</em></strong></p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>内部数据是链表，是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序<br>HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。<br><strong><em>非线程安全</em></strong></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>内部数据结构为树，<br>扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。<br><strong><em>非线程安全</em></strong></p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>数据结构为队列，特点是先进先出，后进后出<br>而关于队列的实现又有多个：优先级队列、异步队列、同步队列、阻塞队列等。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map中常用的子类有: HashMap、HashTable、LinkedHashMap、TreeMap、ConcurrentHashMap</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap在jdk1.8时发生了变更<br>在JDK1.7及以前的版本中：内部数据结构为：数组+链表，并且链表插入数据的方式为 头插法<br>在jdk1.8以及之后的版本中：内部的数据结构为：数组+链表+红黑树，并且链表插入数据的方式为 尾插法</p><p>数据存放方式为 key value，一一对应，key不允许重复<br>大致原理：根据key得出hash值，根据hash值对数组长度取模得出存放数组的下标，每个数组下标对于的为一个链表，将数据放入到链表，当链表长度大于阈值时，则链表转换为红黑树，红黑树节点数减少小于阈值时，则又转换回链表<br>取值大致过程相同：根据key获取hash，然后得出下标，然后再去链表或者红黑树中根据key对比取值</p><p><strong><em>非线程安全</em></strong></p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap继承自HashMap，它主要是用链表实现来扩展HashMap类，<br>HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们插入图的顺序排序，<br>也可以按它们最后一次被访问的顺序排<br><strong><em>非线程安全</em></strong></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。</p><p>在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。<br><strong><em>非线程安全</em></strong></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 是并发包concurrent下针对HashMap的一种实现，线程安全<br>同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高</p><p><strong><em>线程安全</em></strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java 类加载机制</title>
      <link href="/blog/2021/11/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
      <url>/blog/2021/11/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><ul><li><p>了解 java 类加载机制</p></li><li><p>理解类加载器 ClassLoader</p></li></ul><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><ul><li><p>隐式加载 new 创建类的实例,</p></li><li><p>显式加载：loaderClass,forName 等</p></li><li><p>访问类的静态变量，或者为静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>使用反射方式创建某个类或者接口对象的 Class 对象。</p></li><li><p>初始化某个类的子类</p></li><li><p>直接使用 java.exe 命令来运行某个主类</p></li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类加载有五步：<br>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的一个阶段，ClassLoader 通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个 class 对象</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量（static 修饰的字段变量）分配内存并且设置该类变量的初始值，（如 static int i = 5 这里只是将 i 赋值为 0，在初始化的阶段再把 i 赋值为 5)，<br>这里不包含 final 修饰的 static ，因为 final 在编译的时候就已经分配了。<br>这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到 Java 堆中</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这里主要的任务是把常量池中的符号引用替换成直接引用</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。<br>（前面已经对 static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）</p><h2 id="forName-和-loaderClass-区别"><a href="#forName-和-loaderClass-区别" class="headerlink" title="forName 和 loaderClass 区别"></a>forName 和 loaderClass 区别</h2><ul><li><p>Class.forName()得到的 class 是已经初始化完成的</p></li><li><p>ClassLoader.loaderClass 得到的 class 是还没有链接（验证，准备，解析三个过程被称为链接）的。</p></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派模式要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，<br>但是在双亲委派模式中父子关系采取的并不是继承的关系，而是采用组合关系来复用父类加载器的相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>通过 loadClass 加载类时，会先通过 findLoadClass 查找该类是否已加载，<br>如果未加载，会先通过父加载期加载，依次向上递归，到最上级父加载器加载，<br>如果此时还未加载，再依次向下递归调用 findClass</p><p>就是每个儿子都很懒，遇到类加载的活都给它爸爸干，直到爸爸说我也做不来的时候，儿子才会想办法自己去加载。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>采用双亲委派模式的好处就是 Java 类随着它的类加载器一起具备一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类的时候，就没有必要子类加载器（ClassLoader）再加载一次。其次是考虑到安全因素，Java 核心 API 中定义类型不会被随意替换，假设通过网路传递一个名为 java.lang.Integer 的类，通过双亲委派的的模式传递到启动类加载器，而启动类加载器在核心 Java API 发现这个名字类，发现该类已经被加载，并不会重新加载网络传递过来的 java.lang.Integer.而之际返回已经加载过的 Integer.class，这样便可以防止核心 API 库被随意篡改。可能你会想，如果我们在 calsspath 路径下自定义一个名为 java.lang.SingInteger?该类并不存在 java.lang 中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器，最终会通过系统类加载器加载该类，但是这样做是不允许的，因为 java.lang 是核心的 API 包，需要访问权限，强制加载将会报出如下异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException:Prohibited <span class="keyword">package</span> name: java.lang</span><br></pre></td></tr></table></figure><h2 id="类与加载器"><a href="#类与加载器" class="headerlink" title="类与加载器"></a>类与加载器</h2><p>在 JVM 中标识两个 Class 对象，是否是同一个对象存在的两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个 ClassLoader（指 ClassLoader 实例对象）必须相同。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/blog/2021/11/java-%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8Eclass.html"/>
      <url>/blog/2021/11/java-%E5%8F%8D%E5%B0%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8Eclass.html</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 *</li></ul><p>类名 用途<br>Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口<br>Field 类 代表类的成员变量（成员变量也称为类的属性）<br>Method 类 代表类的方法<br>Constructor 类 代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法 用途<br>asSubclass(Class<u> clazz) 把传递的类的对象转换成代表其子类的对象<br>Cast 把对象转换成代表类或是接口的对象<br>getClassLoader() 获得类的加载器<br>getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className) 根据类名返回类的对象<br>getName() 获得类的完整路径名字<br>newInstance() 创建类的实例<br>getPackage() 获得类的包<br>getSimpleName() 获得类的名字<br>getSuperclass() 获得当前类继承的父类的名字<br>getInterfaces() 获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法 用途<br>getField(String name) 获得某个公有的属性对象<br>getFields() 获得所有公有的属性对象<br>getDeclaredField(String name) 获得某个属性对象<br>getDeclaredFields() 获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法 用途<br>getAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的公有注解对象<br>getAnnotations() 返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations() 返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法 用途<br>getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法<br>getConstructors() 获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors() 获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法 用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法<br>getMethods() 获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数<br>getDeclaredMethods() 获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法 用途<br>isAnnotation() 如果是注解类型则返回 true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 true<br>isAnonymousClass() 如果是匿名类则返回 true<br>isArray() 如果是一个数组类则返回 true<br>isEnum() 如果是枚举类则返回 true<br>isInstance(Object obj) 如果 obj 是该类的实例则返回 true<br>isInterface() 如果是接口类则返回 true<br>isLocalClass() 如果是局部类则返回 true<br>isMemberClass() 如果是内部类则返回 true</p><h3 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h3><p>Field 代表类的成员变量（成员变量也称为类的属性）。</p><p>方法 用途<br>equals(Object obj) 属性与 obj 相等则返回 true<br>get(Object obj) 获得 obj 中对应的属性值<br>set(Object obj, Object value) 设置 obj 中对应属性值</p><h3 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h3><p>Method 代表类的方法。</p><p>方法 用途<br>invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法</p><h3 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h3><p>Constructor 代表类的构造方法。</p><p>方法 用途<br>newInstance(Object… initargs) 根据传递的参数创建类的对象</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先写一个被反射调用的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReflex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ExampleReflex.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String LOG = <span class="string">"LOG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String privateName = <span class="string">"privateName"</span>;</span><br><span class="line">    <span class="keyword">public</span> String publicName = <span class="string">"publicName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"defaultName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FINAL_NAME = <span class="string">"FINAL_NAME"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATIC_FINAL_NAME = <span class="string">"STATIC_FINAL_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodNoParams: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodHasParams: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Private No Params getName: "</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethodHasParams</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateMethodHasParams: "</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"size:"</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodNoParams: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"staticMethodNoParams"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodHasParams: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"_____"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">privateStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateStaticMethod: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPrivateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPrivateName: "</span> + privateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPublicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPublicName: "</span> + publicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logStatic: A: "</span> + A + <span class="string">"   LOG: "</span> + LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logFinal: finalName: "</span> + FINAL_NAME + <span class="string">" STATIC_FINAL_NAME: "</span>+ STATIC_FINAL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，其中包含 public、private、static、final 修饰的属性、以及函数</p><h3 id="返回调用函数"><a href="#返回调用函数" class="headerlink" title="返回调用函数"></a>返回调用函数</h3><h4 id="调用-public-函数"><a href="#调用-public-函数" class="headerlink" title="调用 public 函数"></a>调用 public 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取class</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 根据class 获取一个对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象</span></span><br><span class="line">Method method1 = clazz.getMethod(<span class="string">"publicMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">method1.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公有有参函数 第二个参数是入参参数签名</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"publicMethodHasParams"</span>, String.class);</span><br><span class="line">method2.invoke(obj, <span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用-private-函数"><a href="#调用-private-函数" class="headerlink" title="调用 private 函数"></a>调用 private 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取私有函数</span></span><br><span class="line">Method method3 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 私有函数需要设置允许访问 否则会报错</span></span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">String name = (String) method3.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethod Result: "</span> + name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有有参函数</span></span><br><span class="line">Method method4 = clazz.getDeclaredMethod(<span class="string">"privateMethodHasParams"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">method4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String size = (String) method4.invoke(obj, <span class="number">22</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethodHasParams Result: "</span> + size);</span><br></pre></td></tr></table></figure><p>可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。<br>getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数</p><h4 id="调用-static-函数"><a href="#调用-static-函数" class="headerlink" title="调用 static 函数"></a>调用 static 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态无参函数</span></span><br><span class="line">Method method5 = clazz.getDeclaredMethod(<span class="string">"staticMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line">method5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method5.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态有参函数</span></span><br><span class="line">Method method6 = clazz.getDeclaredMethod(<span class="string">"staticMethodHasParams"</span>, String.class);</span><br><span class="line">method6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String result_str6 = (String) method6.invoke(obj, <span class="string">"public static method"</span>);</span><br><span class="line">Log.d(tag, <span class="string">"staticMethodHasParams Result: "</span> + result_str6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有静态函数</span></span><br><span class="line">Method method7 = clazz.getDeclaredMethod(<span class="string">"privateStaticMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">method7.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method7.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>反射调用静态函数与调用私有函数其实没有不同</p><h3 id="调用反射修改属性"><a href="#调用反射修改属性" class="headerlink" title="调用反射修改属性"></a>调用反射修改属性</h3><h4 id="修改-public、private、static-变量"><a href="#修改-public、private、static-变量" class="headerlink" title="修改 public、private、static 变量"></a>修改 public、private、static 变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改public变量，并输出</span></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field publicField = clazz.getDeclaredField(<span class="string">"publicName"</span>);</span><br><span class="line"><span class="comment">// 在obj实例对象上设置属性新值</span></span><br><span class="line">publicField.set(obj, <span class="string">"publicName_New"</span>);</span><br><span class="line">Method method8 = clazz.getDeclaredMethod(<span class="string">"logPublicName"</span>);</span><br><span class="line">method8.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改private变量</span></span><br><span class="line">Field privateField = clazz.getDeclaredField(<span class="string">"privateName"</span>);</span><br><span class="line"><span class="comment">// 私有属性需要设置可访问</span></span><br><span class="line">privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateField.set(obj, <span class="string">"privateName_New"</span>);</span><br><span class="line">Method method9 = clazz.getDeclaredMethod(<span class="string">"logPrivateName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method9.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态属性</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"A"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(obj, <span class="number">2222</span>);</span><br><span class="line">Method method10 = clazz.getDeclaredMethod(<span class="string">"logStatic"</span>, <span class="keyword">null</span>);</span><br><span class="line">method10.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method10.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意，私有变量时需要调用 setAccessible，不然会报错</p><h4 id="修改-final-修饰的常量"><a href="#修改-final-修饰的常量" class="headerlink" title="修改 final 修饰的常量"></a>修改 final 修饰的常量</h4><p>在 java 中，使用 final 修饰的代表常量，不允许修改。<br>当我们通过反射修改时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改final常量</span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method11 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method11.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method11.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。</p><p>针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的修改final常量方式</span></span><br><span class="line">Field field3 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field3.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method12 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method12.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="反射构造函数"><a href="#反射构造函数" class="headerlink" title="反射构造函数"></a>反射构造函数</h3><p>在上面调用生成实例中：<br>Object obj = clazz.newInstance();</p><p>其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。<br>修改 ExampleReflex.java 中的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Constructor ExampleReflex: "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例</p><p>通过 public 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 获取public 有参的构造函数</span></span><br><span class="line">Constructor constructor1 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 通过构造函数生成对象 参数为入参类型class</span></span><br><span class="line">Object obj = constructor1.newInstance(<span class="string">"NNNNN"</span>);</span><br><span class="line">Method method81 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method81.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method81.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>通过 private 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取private 有参构造函数</span></span><br><span class="line">Constructor constructor2 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line">Object obj2 = constructor2.newInstance(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>反射</title>
      <link href="/blog/2021/10/%E5%8F%8D%E5%B0%84.html"/>
      <url>/blog/2021/10/%E5%8F%8D%E5%B0%84.html</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 java 语言的反射机制。 *</li></ul><p>类名 用途<br>Class 类 代表类的实体，在运行的 Java 应用程序中表示类和接口<br>Field 类 代表类的成员变量（成员变量也称为类的属性）<br>Method 类 代表类的方法<br>Constructor 类 代表类的构造方法</p><h3 id="获得类相关的方法"><a href="#获得类相关的方法" class="headerlink" title="获得类相关的方法"></a>获得类相关的方法</h3><p>方法 用途<br>asSubclass(Class<u> clazz) 把传递的类的对象转换成代表其子类的对象<br>Cast 把对象转换成代表类或是接口的对象<br>getClassLoader() 获得类的加载器<br>getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象<br>getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象<br>forName(String className) 根据类名返回类的对象<br>getName() 获得类的完整路径名字<br>newInstance() 创建类的实例<br>getPackage() 获得类的包<br>getSimpleName() 获得类的名字<br>getSuperclass() 获得当前类继承的父类的名字<br>getInterfaces() 获得当前类实现的类或是接口</u></p><h3 id="获得类中属性相关的方法"><a href="#获得类中属性相关的方法" class="headerlink" title="获得类中属性相关的方法"></a>获得类中属性相关的方法</h3><p>方法 用途<br>getField(String name) 获得某个公有的属性对象<br>getFields() 获得所有公有的属性对象<br>getDeclaredField(String name) 获得某个属性对象<br>getDeclaredFields() 获得所有属性对象</p><h3 id="获得类中注解相关的方法"><a href="#获得类中注解相关的方法" class="headerlink" title="获得类中注解相关的方法"></a>获得类中注解相关的方法</h3><p>方法 用途<br>getAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的公有注解对象<br>getAnnotations() 返回该类所有的公有注解对象<br>getDeclaredAnnotation(Class<a> annotationClass) 返回该类中与参数类型匹配的所有注解对象<br>getDeclaredAnnotations() 返回该类所有的注解对象</a></a></p><h3 id="获得类中构造器相关的方法"><a href="#获得类中构造器相关的方法" class="headerlink" title="获得类中构造器相关的方法"></a>获得类中构造器相关的方法</h3><p>方法 用途<br>getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法<br>getConstructors() 获得该类的所有公有构造方法<br>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法<br>getDeclaredConstructors() 获得该类所有构造方法</p><h3 id="获得类中方法相关的方法"><a href="#获得类中方法相关的方法" class="headerlink" title="获得类中方法相关的方法"></a>获得类中方法相关的方法</h3><p>方法 用途<br>getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法<br>getMethods() 获得该类所有公有的方法<br>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法,能够获取到私有函数<br>getDeclaredMethods() 获得该类所有方法</p><h3 id="类中其他重要的方法"><a href="#类中其他重要的方法" class="headerlink" title="类中其他重要的方法"></a>类中其他重要的方法</h3><p>方法 用途<br>isAnnotation() 如果是注解类型则返回 true<br>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回 true<br>isAnonymousClass() 如果是匿名类则返回 true<br>isArray() 如果是一个数组类则返回 true<br>isEnum() 如果是枚举类则返回 true<br>isInstance(Object obj) 如果 obj 是该类的实例则返回 true<br>isInterface() 如果是接口类则返回 true<br>isLocalClass() 如果是局部类则返回 true<br>isMemberClass() 如果是内部类则返回 true</p><h3 id="Field-类"><a href="#Field-类" class="headerlink" title="Field 类"></a>Field 类</h3><p>Field 代表类的成员变量（成员变量也称为类的属性）。</p><p>方法 用途<br>equals(Object obj) 属性与 obj 相等则返回 true<br>get(Object obj) 获得 obj 中对应的属性值<br>set(Object obj, Object value) 设置 obj 中对应属性值</p><h3 id="Method-类"><a href="#Method-类" class="headerlink" title="Method 类"></a>Method 类</h3><p>Method 代表类的方法。</p><p>方法 用途<br>invoke(Object obj, Object… args) 传递 object 对象及参数调用该对象对应的方法</p><h3 id="Constructor-类"><a href="#Constructor-类" class="headerlink" title="Constructor 类"></a>Constructor 类</h3><p>Constructor 代表类的构造方法。</p><p>方法 用途<br>newInstance(Object… initargs) 根据传递的参数创建类的对象</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>先写一个被反射调用的基础类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleReflex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = ExampleReflex.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String LOG = <span class="string">"LOG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String privateName = <span class="string">"privateName"</span>;</span><br><span class="line">    <span class="keyword">public</span> String publicName = <span class="string">"publicName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"defaultName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String FINAL_NAME = <span class="string">"FINAL_NAME"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATIC_FINAL_NAME = <span class="string">"STATIC_FINAL_NAME"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodNoParams: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"publicMethodHasParams: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Private No Params getName: "</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">privateMethodHasParams</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateMethodHasParams: "</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"size:"</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodNoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodNoParams: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"staticMethodNoParams"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticMethodHasParams</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"staticMethodHasParams: "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"_____"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">privateStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"privateStaticMethod: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPrivateName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPrivateName: "</span> + privateName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logPublicName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logPublicName: "</span> + publicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logStatic: A: "</span> + A + <span class="string">"   LOG: "</span> + LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"logFinal: finalName: "</span> + FINAL_NAME + <span class="string">" STATIC_FINAL_NAME: "</span>+ STATIC_FINAL_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，其中包含 public、private、static、final 修饰的属性、以及函数</p><h3 id="返回调用函数"><a href="#返回调用函数" class="headerlink" title="返回调用函数"></a>返回调用函数</h3><h4 id="调用-public-函数"><a href="#调用-public-函数" class="headerlink" title="调用 public 函数"></a>调用 public 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取class</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 根据class 获取一个对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">// 获取公有无参函数 第一个参数为函数名，后续参数为入参class对象</span></span><br><span class="line">Method method1 = clazz.getMethod(<span class="string">"publicMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line">method1.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取公有有参函数 第二个参数是入参参数签名</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"publicMethodHasParams"</span>, String.class);</span><br><span class="line">method2.invoke(obj, <span class="string">"TEST"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用-private-函数"><a href="#调用-private-函数" class="headerlink" title="调用 private 函数"></a>调用 private 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取私有函数</span></span><br><span class="line">Method method3 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 私有函数需要设置允许访问 否则会报错</span></span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获取返回值</span></span><br><span class="line">String name = (String) method3.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethod Result: "</span> + name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私有有参函数</span></span><br><span class="line">Method method4 = clazz.getDeclaredMethod(<span class="string">"privateMethodHasParams"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">method4.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String size = (String) method4.invoke(obj, <span class="number">22</span>);</span><br><span class="line">Log.d(tag, <span class="string">"privateMethodHasParams Result: "</span> + size);</span><br></pre></td></tr></table></figure><p>可以发现，获取私有函数时不能直接使用 getMethod，而是 getDeclaredMethod。<br>getDeclaredMethod 可以获取到所有函数，getMethod 只能获取到公开函数</p><h4 id="调用-static-函数"><a href="#调用-static-函数" class="headerlink" title="调用 static 函数"></a>调用 static 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取静态无参函数</span></span><br><span class="line">Method method5 = clazz.getDeclaredMethod(<span class="string">"staticMethodNoParams"</span>, <span class="keyword">null</span>);</span><br><span class="line">method5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method5.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态有参函数</span></span><br><span class="line">Method method6 = clazz.getDeclaredMethod(<span class="string">"staticMethodHasParams"</span>, String.class);</span><br><span class="line">method6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">String result_str6 = (String) method6.invoke(obj, <span class="string">"public static method"</span>);</span><br><span class="line">Log.d(tag, <span class="string">"staticMethodHasParams Result: "</span> + result_str6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有静态函数</span></span><br><span class="line">Method method7 = clazz.getDeclaredMethod(<span class="string">"privateStaticMethod"</span>, <span class="keyword">null</span>);</span><br><span class="line">method7.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method7.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>反射调用静态函数与调用私有函数其实没有不同</p><h3 id="调用反射修改属性"><a href="#调用反射修改属性" class="headerlink" title="调用反射修改属性"></a>调用反射修改属性</h3><h4 id="修改-public、private、static-变量"><a href="#修改-public、private、static-变量" class="headerlink" title="修改 public、private、static 变量"></a>修改 public、private、static 变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改public变量，并输出</span></span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field publicField = clazz.getDeclaredField(<span class="string">"publicName"</span>);</span><br><span class="line"><span class="comment">// 在obj实例对象上设置属性新值</span></span><br><span class="line">publicField.set(obj, <span class="string">"publicName_New"</span>);</span><br><span class="line">Method method8 = clazz.getDeclaredMethod(<span class="string">"logPublicName"</span>);</span><br><span class="line">method8.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改private变量</span></span><br><span class="line">Field privateField = clazz.getDeclaredField(<span class="string">"privateName"</span>);</span><br><span class="line"><span class="comment">// 私有属性需要设置可访问</span></span><br><span class="line">privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateField.set(obj, <span class="string">"privateName_New"</span>);</span><br><span class="line">Method method9 = clazz.getDeclaredMethod(<span class="string">"logPrivateName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method9.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态属性</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"A"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field1.set(obj, <span class="number">2222</span>);</span><br><span class="line">Method method10 = clazz.getDeclaredMethod(<span class="string">"logStatic"</span>, <span class="keyword">null</span>);</span><br><span class="line">method10.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method10.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>注意，私有变量时需要调用 setAccessible，不然会报错</p><h4 id="修改-final-修饰的常量"><a href="#修改-final-修饰的常量" class="headerlink" title="修改 final 修饰的常量"></a>修改 final 修饰的常量</h4><p>在 java 中，使用 final 修饰的代表常量，不允许修改。<br>当我们通过反射修改时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改final常量</span></span><br><span class="line">Field field2 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method11 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method11.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method11.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>采用与 public 等一样的方式进行修改时,代码没有报错，但修改也未生效。</p><p>针对 final 修饰的属性，我们需要做的是，获取到修饰符，然后去掉 final，再进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的修改final常量方式</span></span><br><span class="line">Field field3 = clazz.getDeclaredField(<span class="string">"FINAL_NAME"</span>);</span><br><span class="line">field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">modifiers.setInt(field3, field3.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line">field3.set(obj, <span class="string">"FINAL_NAME_NEW"</span>);</span><br><span class="line">Method method12 = clazz.getDeclaredMethod(<span class="string">"logFinal"</span>, <span class="keyword">null</span>);</span><br><span class="line">method12.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="反射构造函数"><a href="#反射构造函数" class="headerlink" title="反射构造函数"></a>反射构造函数</h3><p>在上面调用生成实例中：<br>Object obj = clazz.newInstance();</p><p>其实就是调用默认的构造函数生成实例对象。如果将默认构造函数修改为 private 时，此时就会报错。<br>修改 ExampleReflex.java 中的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExampleReflex</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Constructor ExampleReflex: "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExampleReflex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 Object obj = clazz.newInstance(); 会报错，需要通过反射先获取构造函数，再生成实例</p><p>通过 public 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"weightmeasure.justin.test.ExampleReflex"</span>);</span><br><span class="line"><span class="comment">// 获取public 有参的构造函数</span></span><br><span class="line">Constructor constructor1 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 通过构造函数生成对象 参数为入参类型class</span></span><br><span class="line">Object obj = constructor1.newInstance(<span class="string">"NNNNN"</span>);</span><br><span class="line">Method method81 = clazz.getDeclaredMethod(<span class="string">"getName"</span>, <span class="keyword">null</span>);</span><br><span class="line">method81.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method81.invoke(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>通过 private 有参构造函数生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取private 有参构造函数</span></span><br><span class="line">Constructor constructor2 = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 生成实例</span></span><br><span class="line">Object obj2 = constructor2.newInstance(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p>在上面其实讲的都是反射的使用，包括函数、属性、构造器等<br>而关于反射能够使用的原理，大概描述：<br>当类被加载时，会将类中的构造器、属性、函数，都缓存到 Class 类的内部类 ReflectionData 中。<br>而反射就是，先判断该类是否加载过，加载过则直接去 ReflectionData 中取，<br>如果没加载过就报错。</p><ol><li><p>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</p></li><li><p>每个类都会有一个与之对应的 Class 实例，从而每个类都可以获取 method 反射方法，并作用到其他实例身上；</p></li><li><p>反射也是考虑了线程安全的，放心使用；</p></li><li><p>反射使用软引用 relectionData 缓存 class 信息，避免每次重新从 jvm 获取带来的开销；</p></li><li><p>反射调用多次生成新代理 Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</p></li><li><p>当找到需要的方法，都会 copy 一份出来，而不是使用原来的实例，从而保证数据隔离；</p></li><li><p>调度反射方法，最终是由 jvm 执行 invoke0()执行；</p></li></ol><p>參考連結：<a href="https://www.cnblogs.com/yougewe/p/10125073.html" target="_blank" rel="noopener">https://www.cnblogs.com/yougewe/p/10125073.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 复习导航</title>
      <link href="/blog/2021/10/android-%E5%A4%8D%E4%B9%A0%E5%AF%BC%E8%88%AA.html"/>
      <url>/blog/2021/10/android-%E5%A4%8D%E4%B9%A0%E5%AF%BC%E8%88%AA.html</url>
      
        <content type="html"><![CDATA[<h1 id="java-篇"><a href="#java-篇" class="headerlink" title="java 篇"></a>java 篇</h1><ul><li>类加载机制<ul><li>双亲委派机制</li></ul></li><li>反射</li><li>注解</li><li>注入</li><li>序列化</li><li><p>范型</p></li><li><p>集合</p><ul><li>Map</li><li>List</li><li>LinkedList</li><li>Set</li><li>HashMap</li></ul></li><li><p>内存</p><ul><li>内存抖动</li><li>内存泄露</li><li>内存溢出</li><li>GC 算法</li><li>JVM 结构</li><li>JMM（java 内存模型）</li><li>四种引用类型</li></ul></li><li><p>多线程</p><ul><li>线程池</li><li>wait/notify</li><li>锁</li><li>原子类</li><li>ThreadLocal</li><li>线程的状态、转换</li></ul></li></ul><h1 id="android-篇"><a href="#android-篇" class="headerlink" title="android 篇"></a>android 篇</h1><ul><li><p>四大组件</p><ul><li>Activity</li><li>Service</li><li>BroadcastReceiver<br>-LocalBroadcastReceiver (為何更高效)</li><li>Provider</li></ul></li><li><p>生命周期</p><ul><li>Activity 生命周期</li><li>Service 生命周期</li></ul></li><li><p>消息机制</p><ul><li>Handler</li><li>IdleHandler</li><li>Looper</li><li>MessageQueue</li></ul></li><li><p>事件分发机制</p><ul><li>View/ViewGroup</li><li>滑动冲突</li></ul></li><li><p>自定义 View</p><ul><li>onMeasure</li><li>onLayout</li><li>onDraw</li></ul></li><li><p>注入</p></li><li><p>数据持久化 SharePreferences</p></li><li><p>跨进城通信</p><ul><li>AIDL</li><li>Binder</li></ul></li><li><p>设计模式</p><ul><li>MVC</li><li>MVP</li><li>MVVM</li></ul></li><li><p>第三方插件</p><ul><li>GSON</li><li>okHttp</li><li>Rxjava</li><li>Dagger</li><li>Dagger2</li><li>APT</li><li>ARouter</li><li>Glide</li></ul></li><li><p>UI</p><ul><li>ListView</li><li>ViewPager</li><li>Fragment</li><li>Stub</li><li>RecyclerView</li><li>Adapter</li></ul></li></ul><h1 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h1><ul><li>Kotlin</li><li>C/C++</li></ul><h1 id="混合开发平台"><a href="#混合开发平台" class="headerlink" title="混合开发平台"></a>混合开发平台</h1><ul><li>Cordova</li><li>react-native</li><li>Flutter<ul><li>原理</li><li>渲染机制</li></ul></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm内存说明</title>
      <link href="/blog/2021/08/jvm%E5%86%85%E5%AD%98%E8%AF%B4%E6%98%8E.html"/>
      <url>/blog/2021/08/jvm%E5%86%85%E5%AD%98%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<p>针对 jvm 中的内存问题，一般指三种：内存抖动、内存泄漏、内存溢出</p><h2 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h2><p>在一定时间内，频繁的创建对象然后又回收，使内存存在明显的上下波动<br>一般可能发生在循环中大量创建了局部对象</p><p>内存抖动的影响，抖动频繁的话会导致回收也频繁，而频繁的 GC 是会造成性能影响的。<br>因为每次 GC 时会挂起线程两次，二次还会产生内存碎片。</p><p>要考虑多复用对象，涉及模式：享元模式</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>在程序运行期间，已经没有被使用的对象，引用却一直被持有，导致该对象无法被回收，此时就会造成内存泄漏</p><p>内存泄漏的影响：会造成无用对象无法被回收，使内存空间越来越小，最终可能会造成内存溢出</p><p>一般示例：Inflater 的创建需要 Context 对象，传入 Actiivty 时创建完后，需要将 Inflater 的实例对象置空，此时就会消除对 Activity 对象引用的持有，不然就会造成 Activity 的内存泄漏</p><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>当创建对象时，JVM 无法分配足够的内存，此时就会执行 GC，清理内存已获取足够的空间。<br>但如果 GC 后仍然无法获取足够的空间时，此时就会抛出异常 OOM（内存溢出），中断程序的运行</p><p>影响：会抛出异常，中断程序的运行<br>与内存抖动、内存泄漏不同，内存抖动、内存泄漏都不会影响程序的运行，最多只会影响程序运行的性能，内存溢出则会直接报错，中断程序的运行。<br>内存溢出是内存泄漏的持续结果。</p><p>解决办法：程序内存溢出后会在特定目录输出 .trace 文件，需要分析文件确定造成内存溢出的代码块。</p><p>常见的内存溢出：流使用完后未关闭、Cursor 使用完后未关闭、短时间创建大量的大内存对象</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android学习导航</title>
      <link href="/blog/2021/08/android%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA.html"/>
      <url>/blog/2021/08/android%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA.html</url>
      
        <content type="html"><![CDATA[<p>android 学习思维导图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">JVM知识点 --&gt; A(内存问题)</span><br><span class="line">A --&gt; 内存抖动</span><br><span class="line">A --&gt; 内存泄漏</span><br><span class="line">A --&gt; 内存溢出</span><br><span class="line"></span><br><span class="line">JVM知识点 --&gt; B(JVM结构)</span><br><span class="line">B --&gt; JVM结构</span><br><span class="line">B --&gt; GC回收算法</span><br><span class="line">B --&gt; JMM内存模型</span><br><span class="line"></span><br><span class="line">JVM知识点 --&gt; C(四种引用类型)</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android应用启动过程</title>
      <link href="/blog/2021/07/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html"/>
      <url>/blog/2021/07/android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<p>android 应用启动过程</p><p>首先，手机中的主页面、以及显示各个应用图标的页面本身就是一个 Activity<br>android 应用启动就是我们点击应用图标后的过程</p><p>以下以 API28 为例</p><p>应用启动涉及 L：三个进程、六个大类</p><p>三个进程：<br>Launcher 进程：整个 App 启动流程的起点，负责接收用户点击屏幕事件，它其实就是一个 Activity，里面实现了点击事件，长按事件，触摸等事件，可以这么理解，把 Launcher 想象成一个总的 Activity，屏幕上各种 App 的 Icon 就是这个 Activity 的 button，当点击 Icon 时，会从 Launcher 跳转到其他页面。</p><p>SystemServer 进程：这个进程在整个的 Android 进程中是非常重要的一个，地位和 Zygote 等同，它是属于 Application Framework 层的，Android 中的所有服务，例如 AMS, WindowsManager, PackageManagerService 等等都是由这个 SystemServer fork 出来的。</p><p>App 进程：你要启动的 App 所运行的进程。</p><p>六个大类：<br>ActivityManagerService：（AMS）AMS 是 Android 中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在 Android 中非常重要，它本身也是一个 Binder 的实现类。</p><p>Instrumentation：监控应用程序和系统的交互。</p><p>ActivityThread：应用的入口类，通过调用 main 方法，开启消息循环队列。ActivityThread 所在的线程被称为主线程。</p><p>ApplicationThread：ApplicationThread 提供 Binder 通讯接口，AMS 则通过代理调用此 App 进程的本地方法。</p><p>ActivityManagerProxy：AMS 服务在当前进程的代理类，负责与 AMS 通信。</p><p>ApplicationThreadProxy：ApplicationThread 在 AMS 服务中的代理类，负责与 ApplicationThread 通信。</p><p><strong><em>可以说，启动的流程就是通过这六个大类在这三个进程之间不断通信的过程。</em></strong></p><h2 id="LauncherActivity"><a href="#LauncherActivity" class="headerlink" title="LauncherActivity"></a>LauncherActivity</h2><p>package android.app;</p><p>LauncherActivity 既是显示所有应用图标的系统页面<br>LauncherActivity 布局是一个 ListView</p><p>listView 的数据集就是 所有应用的数据集合，每个应用信息为 ListItem</p><h3 id="ListItem"><a href="#ListItem" class="headerlink" title="ListItem"></a>ListItem</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ResolveInfo resolveInfo;</span><br><span class="line">    <span class="keyword">public</span> CharSequence label;</span><br><span class="line">    <span class="keyword">public</span> Drawable icon; <span class="comment">// 图标</span></span><br><span class="line">    <span class="keyword">public</span> String packageName; <span class="comment">// 应用包名</span></span><br><span class="line">    <span class="keyword">public</span> String className; <span class="comment">// 启动Activity的类名</span></span><br><span class="line">    <span class="keyword">public</span> Bundle extras;</span><br><span class="line"></span><br><span class="line">    ListItem(PackageManager pm, ResolveInfo resolveInfo, IconResizer resizer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resolveInfo = resolveInfo;</span><br><span class="line">        label = resolveInfo.loadLabel(pm);</span><br><span class="line">        ComponentInfo ci = resolveInfo.activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (ci == <span class="keyword">null</span>) ci = resolveInfo.serviceInfo;</span><br><span class="line">        <span class="keyword">if</span> (label == <span class="keyword">null</span> &amp;&amp; ci != <span class="keyword">null</span>) &#123;</span><br><span class="line">            label = resolveInfo.activityInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resizer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            icon = resizer.createIconThumbnail(resolveInfo.loadIcon(pm));</span><br><span class="line">        &#125;</span><br><span class="line">        packageName = ci.applicationInfo.packageName;</span><br><span class="line">        className = ci.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ListView 涉及的所有信息信息是在 Adapter 的构造函数中获取的，<br>也就是说其实在启动 LauncherActivity 时，已经获取到所有应用信息</p><p>接下来查看 Item 的点击事件，即启动应用的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">    Intent intent = intentForPosition(position);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就会进入到 Activity 的 startActivity，最后会进入 Activity 的下列方法中：<br>requestCode: -1 options: null<br>是在系统页面开启另一个应用，所以 mParent = null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options = transferSpringboardActivityOptions(options);</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">                <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">                <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">                <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">                <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">                <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">                <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">                mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">                <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时会进入 Instrumentation.java 中的 execStartActivity 函数（7 个参数的）<br>然后又会调用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br></pre></td></tr></table></figure><p>又会调用到 ActivityManagerService 中的 startActivity<br>然后会调用到 ActivityManagerService 中的 startActivityAsUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">        <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">                .setCaller(caller)</span><br><span class="line">                .setCallingPackage(callingPackage)</span><br><span class="line">                .setResolvedType(resolvedType)</span><br><span class="line">                .setResultTo(resultTo)</span><br><span class="line">                .setResultWho(resultWho)</span><br><span class="line">                .setRequestCode(requestCode)</span><br><span class="line">                .setStartFlags(startFlags)</span><br><span class="line">                .setProfilerInfo(profilerInfo)</span><br><span class="line">                .setActivityOptions(bOptions)</span><br><span class="line">                .setMayWait(userId)</span><br><span class="line">                .execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处使用构建者模式，execute 执行的是 ActivityStarter.java 中的 execute 函数</p><p>而最终会调用到 1193 行的 startActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会执行 ActivityStackSupervisor 中的 resumeFocusedStackTopActivityLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又会执行到 ActivityStack 中的 resumeTopActivityUncheckedLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">    result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又会回到 ActivityStackSupervisor 中的 startSpecificActivityLocked 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                    || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                <span class="comment">// separate apk in the process.</span></span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会通过 AMS 获取进程信息，判断进程是否存在，<br>应用进程存在时会调用 realStartActivityLocked<br>应用进程不存在时会调用 AMS 中的 startProcessLocked 去开启新进程</p><p>暂时先看 应用进程不存在的情景：</p><p>AMS startProcessLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType, String hostingNameStr, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingType, hostingNameStr,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingNameStr, <span class="keyword">boolean</span> disableHiddenApiChecks, String abiOverride)</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">     <span class="keyword">return</span> startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                    startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,</span><br><span class="line">                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,</span><br><span class="line">                            requiredAbi, instructionSet, invokeWith, app.startTime);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ProcessStartResult <span class="title">startProcess</span><span class="params">(String hostingType, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">        <span class="keyword">final</span> ProcessStartResult startResult;</span><br><span class="line">        <span class="keyword">if</span> (hostingType.equals(<span class="string">"webview_service"</span>)) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith,</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用 Process 中 start 去开启进程<br>同时注意，此处会判断进程类型， webview</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后又会调用到 ZygoteStartFailedEx 中的 start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                zygoteArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mLock"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Throw early if any of the arguments are malformed. This means we can</span></span><br><span class="line">        <span class="comment">// avoid writing a partial response to the zygote.</span></span><br><span class="line">        <span class="keyword">int</span> sz = args.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span></span><br><span class="line"><span class="comment">            * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">            * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">            * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * After the zygote process reads these it will write the pid of</span></span><br><span class="line"><span class="comment">            * the child or -1 on failure, followed by boolean to</span></span><br><span class="line"><span class="comment">            * indicate whether a wrapper process was used.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">        Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">        <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">        <span class="comment">// upon.</span></span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终执行 zygoteSendArgsAndGetResult 函数来完成进程的创建。<br>注意：<br>Android 中有一个重要的进程 Zygote，翻译为受精卵进程，所有的应用程序进程都是通过 Zygote 进程 fork 得来的。</p><p>简单来说就是通过 Binder 请求 AMS 进程，然后 AMS 再发送 Socket 消息给 Zygote 进程，最后统一由 Zygote 进程 fork 出应用进程。</p><p>当进程创建完成后，会执行 ActivityThread 中的 main 方法</p><p>在 ActivityThread 中就会启动 消息分发 、 Application 的创建、Activity 的创建</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c++高级</title>
      <link href="/blog/2021/05/c-%E9%AB%98%E7%BA%A7.html"/>
      <url>/blog/2021/05/c-%E9%AB%98%E7%BA%A7.html</url>
      
        <content type="html"><![CDATA[<h1 id="c-高级部分-STL-容器"><a href="#c-高级部分-STL-容器" class="headerlink" title="c++ 高级部分 STL 容器"></a>c++ 高级部分 STL 容器</h1><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。</p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p><h2 id="Vector-数组"><a href="#Vector-数组" class="headerlink" title="Vector 数组"></a>Vector 数组</h2><p>数组的特征：只能保存相同类型的数据、内存连续，数据具备索引，根据索引查找快，增、删慢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 标准模版库 容器学习1 Vector"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector1; <span class="comment">// 创建数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector2(<span class="number">8</span>); <span class="comment">// 创建8个容量的数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vector3(<span class="number">10</span>, <span class="number">-1</span>); <span class="comment">// 创建10个容量的数组，且默认值都是 -1</span></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; vector3.size(); i ++) &#123;</span><br><span class="line">        <span class="comment">// 修改值</span></span><br><span class="line">        vector3[i] = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"i:"</span> &lt;&lt; i &lt;&lt; <span class="string">" value:"</span> &lt;&lt; vector3[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入值</span></span><br><span class="line">    <span class="comment">// 从头部插入</span></span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">40</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">30</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">20</span>);</span><br><span class="line">    vector1.insert(vector1.begin(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 从尾部插入</span></span><br><span class="line">    vector1.insert(vector1.end(), <span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite = vector1.begin(); ite != vector1.end(); ite ++) &#123;</span><br><span class="line">        <span class="comment">// 迭代器获取的是地址</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器遍历"</span> &lt;&lt; *ite &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为vector2在构造函数中申明了容量为8，此时不能进行插入或者删除操作。会报错</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 22);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.end(), 33);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 22);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.end(), 33);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line"><span class="comment">//    vector2.insert(vector2.begin(), 44);</span></span><br><span class="line">    <span class="comment">// 删除尾部</span></span><br><span class="line"><span class="comment">//    vector2.erase(vector2.end());</span></span><br><span class="line"><span class="comment">//    // 删除头部</span></span><br><span class="line"><span class="comment">//    vector2.erase(vector2.begin());</span></span><br><span class="line">    <span class="comment">//  迭代器自动推导类型 类似于kotlin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = vector2.begin(); iter != vector2.end(); iter++) &#123;</span><br><span class="line">        *iter = <span class="number">88</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"自动推导迭代器遍历"</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><p>栈的数据特点：先进后出、后进先出，类似于方法栈进栈、出栈<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL stack 栈的学习"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="comment">// 压栈</span></span><br><span class="line">    stack1.push(<span class="number">1</span>);</span><br><span class="line">    stack1.push(<span class="number">2</span>);</span><br><span class="line">    stack1.push(<span class="number">20</span>);</span><br><span class="line">    stack1.push(<span class="number">22</span>);</span><br><span class="line">    <span class="comment">// 弹栈</span></span><br><span class="line">    stack1.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈顶元素:"</span> &lt;&lt; stack1.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 栈没有迭代器，也没有索引 这样遍历的话，会将栈内元素都弹出。</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历栈元素："</span> &lt;&lt; stack1.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>压栈、弹栈函数都是没有返回值的，<br>top函数获取栈顶元素</p><h2 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h2><p>队列的数据特点： FIFO 先进先出，后进后出。与栈不同<br>队列内部可以使用数组实现、也可以使用链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 三 队列queue学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(<span class="number">1</span>);</span><br><span class="line">    que.push(<span class="number">2</span>);</span><br><span class="line">    que.push(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列队头元素："</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列队尾元素"</span> &lt;&lt; que.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 队列也是没有迭代器的，只能采用与栈相同的方式遍历数据</span></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历 队列队头元素："</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列是队列的一个子集，内部数据结构通过数组实现，而且是数据有序排练，默认是降序。<br>不论数据push的顺序，直接给你降序处理，可以设置成升序排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 三 优先级队列priority_queue学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 默认是降序排列</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int&gt; que;</span></span><br><span class="line">    <span class="comment">// 设置成升序排列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;que;</span><br><span class="line">    </span><br><span class="line">    que.push(<span class="number">20</span>);</span><br><span class="line">    que.push(<span class="number">50</span>);</span><br><span class="line">    que.push(<span class="number">60</span>);</span><br><span class="line">    que.push(<span class="number">30</span>);</span><br><span class="line">    que.push(<span class="number">10</span>);</span><br><span class="line">    que.push(<span class="number">70</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"遍历 优先级队列队头元素："</span> &lt;&lt; que.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h2><p>链表的数据特点，内存非连续，每个节点有下一个节点的指针，增删快，但查询慢，增加、删除都只能在表头操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 四 链表list学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; listArr;</span><br><span class="line">    <span class="comment">// push</span></span><br><span class="line">    listArr.push_front(<span class="number">11</span>); <span class="comment">// 从链头添加一个值</span></span><br><span class="line">    listArr.push_back(<span class="number">80</span>); <span class="comment">// 从链尾添加一个值</span></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    listArr.insert(listArr.end(), <span class="number">99</span>); <span class="comment">// 插入一个值到链尾</span></span><br><span class="line">    listArr.insert(listArr.end(), <span class="number">98</span>); <span class="comment">// 插入一个值到链尾</span></span><br><span class="line">    listArr.insert(listArr.begin(), <span class="number">20</span>); <span class="comment">// 插入一个值到链头</span></span><br><span class="line">    listArr.insert(listArr.begin(), <span class="number">22</span>); <span class="comment">// 插入一个值到链头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    listArr.erase(listArr.begin());</span><br><span class="line"><span class="comment">//    listArr.erase(listArr.end()); // 这一句在运行时报错，不知道为何</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表迭代器遍历："</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除所有元素</span></span><br><span class="line">    listArr.clear();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"clear"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listArr.begin(); it != listArr.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"链表迭代器遍历："</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-红黑树"><a href="#set-红黑树" class="headerlink" title="set 红黑树"></a>set 红黑树</h2><p>内部结构 红黑树 会对你存入的数据进行排序，但是绝对不允许元素相同</p><p>默认会升序排列，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 五 set 学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;setV;</span><br><span class="line">    <span class="comment">// 插入值</span></span><br><span class="line">    <span class="comment">// 默认会升序排列</span></span><br><span class="line">    setV.insert(<span class="number">80</span>);</span><br><span class="line">    setV.insert(<span class="number">70</span>);</span><br><span class="line">    setV.insert(<span class="number">50</span>);</span><br><span class="line">    setV.insert(<span class="number">90</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当插入已经存在的值时，会失败，因为不允许重复</span></span><br><span class="line">    pair&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>, less&lt;<span class="keyword">int</span>&gt;&gt;::iterator, <span class="keyword">bool</span>&gt; result = setV.insert(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// 注意set的insert函数是有返回值的，first是迭代器 second是插入的结果</span></span><br><span class="line">    <span class="keyword">if</span>(result.second) &#123;</span><br><span class="line">        <span class="comment">// 插入成功</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 注意此处取得的迭代器不是从begin开始，而是从插入的值60处开始的。</span></span><br><span class="line">        <span class="keyword">for</span>(; result.first != setV.end(); result.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入结果迭代器遍历的值:"</span> &lt;&lt; * result.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = setV.begin(); it != setV.end(); it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器遍历的值:"</span> &lt;&lt; * it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>转自：<a href="https://www.cnblogs.com/xym4869/p/12250174.html" target="_blank" rel="noopener">https://www.cnblogs.com/xym4869/p/12250174.html</a></p><p>1.函数(function)谓词<br>通过传递函数名, 匹配二元谓词(binary predicates), 根据函数提供的策略, 输出值;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function Predicate*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLarger</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.size() &gt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), isLarger);</span><br></pre></td></tr></table></figure><p>2.函数指针(function pointer)谓词<br>建立一个函数指针, 传入算法, 使用指针代替函数名, 用法类似函数谓词.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s2);</span><br><span class="line">pf = &amp;isLarger;</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), *pf);</span><br></pre></td></tr></table></figure><p>3.Lambda表达式(lambda expression)谓词<br>Lambda表达式格式: [capture list] (parameter list) -&gt; return type { function body }<br>需要匹配谓词数, 一元(unary) 或 二元(binary), 也可以通过[capture list]传递函数的变量;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(),</span><br><span class="line">    [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s2)&#123; <span class="keyword">return</span> s1.size()&gt;s2.size(); &#125;);</span><br></pre></td></tr></table></figure><p>4.函数对象(Function Object)谓词<br>类中重载函数的调用”()”, 使类可以被调用, 并且传入算法谓词中, 进行使用.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Function Object*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargerString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">std</span>::stable_sort(sv.begin(), sv.end(), LargerString());</span><br></pre></td></tr></table></figure><p>5、结构体谓词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doCompareAction2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Person&amp; __x, <span class="keyword">const</span> Person&amp; __y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.id &lt; __y.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;Person, doCompareAction2&gt; setVar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map: key value键值对容器，默认会对key进行排序，所以不能存在重复的key，会添加失败 value可以重复<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 六 map学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;mapVar;</span><br><span class="line">    <span class="comment">// 插入值 需要借助 std::pair</span></span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">"justin"</span>));</span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">5</span>, <span class="string">"justinA"</span>));</span><br><span class="line">    mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"justin"</span>));</span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mapVar.begin(); it != mapVar.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; it-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取插入值的结果</span></span><br><span class="line">    pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = mapVar.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">4</span>, <span class="string">"novia"</span>));</span><br><span class="line">    <span class="keyword">if</span>(result.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入值成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 因为有排序，只会遍历从4以及4以后的元素</span></span><br><span class="line">        <span class="keyword">for</span>(; result.first != mapVar.end(); result.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; result.first-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; result.first-&gt;second &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入值失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询 是根据key查询的</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator findResult = mapVar.find(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(findResult != mapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"已找到"</span> &lt;&lt; findResult -&gt; first &lt;&lt; <span class="string">", "</span> &lt;&lt; findResult-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找key失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>multimap 属于 map下的子集<br>// 1.key可以重复， 2.key重复的数据可以分组,  3.key会排序，  4.value不会排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"STL 七 multimap学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;multimapVar;</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"justin"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"novia"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">10</span>, <span class="string">"justin"</span>));</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"justin"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"novia"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">20</span>, <span class="string">"coco"</span>));</span><br><span class="line">    </span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin1"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin2"</span>));</span><br><span class="line">    multimapVar.insert(make_pair(<span class="number">30</span>, <span class="string">"justin3"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = multimapVar.begin(); it != multimapVar.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; it -&gt; second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO 核心功能是分组</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你要查询的key，为int类型:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iteratorVar = multimapVar.find(result);</span><br><span class="line">    <span class="keyword">while</span> (iteratorVar != multimapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iteratorVar-&gt;first &lt;&lt; <span class="string">","</span> &lt;&lt; iteratorVar-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 需要自己做逻辑控制，不然有问题</span></span><br><span class="line">        iteratorVar++;</span><br><span class="line">        <span class="keyword">if</span> (iteratorVar-&gt;first != result) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 严谨性</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorVar == multimapVar.end()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="防函数"><a href="#防函数" class="headerlink" title="防函数"></a>防函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForEach</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> _size() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"size："</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义防函数"</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fake</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义函数"</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"防函数学习"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    TestForEach forEach;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;setVar;</span><br><span class="line">    setVar.insert(<span class="number">10</span>);</span><br><span class="line">    setVar.insert(<span class="number">20</span>);</span><br><span class="line">    setVar.insert(<span class="number">500</span>);</span><br><span class="line">    setVar.insert(<span class="number">40</span>);</span><br><span class="line">    setVar.insert(<span class="number">30</span>);</span><br><span class="line">    setVar.insert(<span class="number">50</span>);</span><br><span class="line">    setVar.insert(<span class="number">60</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set 红黑树本身没有没有记录size，我们可以通过防函数记录</span></span><br><span class="line">    <span class="comment">// for_each是有返回值的，返回值是 防函数本身</span></span><br><span class="line">    for_each(setVar.begin(), setVar.end(), fake);</span><br><span class="line">    forEach = for_each(setVar.begin(), setVar.end(), forEach);</span><br><span class="line">    forEach._size();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中有很多防函数的使用，其实我们自己可以手动实现一个防函数，并替换源码中的 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义加法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; x, <span class="keyword">const</span> T &amp; y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义实现算法"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用系统自带的加法</span></span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt;sum_int;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int相加"</span> &lt;&lt; sum_int(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    plus&lt;<span class="built_in">string</span>&gt;sum_str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"字符相加"</span> &lt;&lt; sum_str(<span class="string">"AAA"</span>,<span class="string">"BBB"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接下来自己实现加法</span></span><br><span class="line">    plus_d&lt;<span class="keyword">float</span>&gt;sum_flo;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义 float相加"</span> &lt;&lt; sum_flo(<span class="number">1.78f</span>, <span class="number">2.56f</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    plus_d&lt;<span class="built_in">string</span>&gt;sum_s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"自定义 字符相加"</span> &lt;&lt; sum_s(<span class="string">"justin "</span>, <span class="string">"and novia"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模版函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模版 Params1 第一个参数类型 Params2 第二个参数类型 ReturnType 返回值类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Params1, <span class="keyword">typename</span> Params2, <span class="keyword">typename</span> ReturnType&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Params1 first_argument_type; <span class="comment">// 第一个参数的别名</span></span><br><span class="line">    <span class="keyword">typedef</span> Params2 second_argument_type; <span class="comment">// 第二个参数的别名</span></span><br><span class="line">    <span class="keyword">typedef</span> ReturnType result_type; <span class="comment">// 返回值别名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c++基础 五</title>
      <link href="/blog/2021/04/c-%E5%9F%BA%E7%A1%80-%E4%BA%94.html"/>
      <url>/blog/2021/04/c-%E5%9F%BA%E7%A1%80-%E4%BA%94.html</url>
      
        <content type="html"><![CDATA[<h1 id="c-基础-五"><a href="#c-基础-五" class="headerlink" title="c++基础 五"></a>c++基础 五</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>与kotlin中一样，类的继承使用 : 表示。<br>不同的是，c++继承分为私有继承、公开继承，默认为私有继承</p><ul><li>1.默认是 隐式代码： : private Person</li><li>2.私有继承：在子类里面是可以访问父类的成员，但是在类的外面不行</li><li>3.必须公开继承，才可以访问父类的成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> Father &#123; <span class="comment">// 默认私有 private 继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19;// 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"son"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daugther</span> :</span> <span class="keyword">public</span> Father &#123; <span class="comment">// 公开继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        this-&gt;age = 19; // 'age' is a private member of 'Father'</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">"dauther"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    Son son;</span><br><span class="line">    son.setName();</span><br><span class="line"><span class="comment">//    son.name; //报错 'name' is a private member of 'Father'</span></span><br><span class="line">    Daugther daugther;</span><br><span class="line">    daugther.setName();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"daugther.name : "</span> &lt;&lt; daugther.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>子类不能访问父类的私有属性</li><li>子类直接继承为私有继承</li><li>私有继承的子类对象不能访问父类的属性，只能在类中访问</li><li>公开继承的子类对象可以访问父类的属性，在类中同样可以</li></ul><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><ul><li>C++ 是允许多继承的</li><li>Java语言不允许多继承，多继承有歧义，如果Java语言多继承 就会导致代码不健壮，（二义性）</li><li>Java多实现：做的非常棒，严格避免出现 二义性问题（歧义）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">raisChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother raisChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playWithChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mother playWithChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smoking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father smoking"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playWithChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father playWithChild"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span> <span class="keyword">public</span> Mother, <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son work"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father play"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Son son;</span><br><span class="line">    <span class="comment">// 这个是优先寻找子类的函数，因为特别明确，没有问题，还没有产生歧义（二义性）</span></span><br><span class="line">    son.work();</span><br><span class="line">    son.play();</span><br><span class="line">    son.raisChild();</span><br><span class="line">    son.playWithChild(); <span class="comment">// 报错 Member 'playWithChild' found in multiple base classes of different types</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，Son类同时继承自Father、Mother类，这两个类有一些相同的函数work、play、playWithChild<br>但子类Son也实现了work、play时，执行这些函数不会报错，<br>但调用playWithChild则会报错，因为两个父类都有该函数、但子类未实现，此时就存在二义性问题。<br>解决这样的问题，存在两个办法：</p><ul><li>1、指定调用哪个父类的该函数 使用 ::父类.函数名<br><code>son.Father::playWithChild();</code></li><li>2、在子类也实现该函数<br>  在Son类中添加playWithChild函数。</li></ul><p>总结：</p><ul><li>1、c++可以多继承</li><li>2、多继承时，如果多个父类间存在同名同参函数，子类指针使用时，会存在二义性问题，需要子类也实现该函数，或者指定父类调用</li><li>3、真实开发时，一般时子类也会定义同名成员，覆盖掉多个父类同名成员。</li></ul><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>二义性问题出现在菱形继承。<br>关于二义性问题，还有一种解决办法，就是虚继承。<br>第三种解决方案： 【虚基类】 属于 虚继承的范畴<br>真实C++开始，是很少出现，二义性（歧义） 如果出现， 系统源码（系统用 第三种解决方案）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 祖父类</span><br><span class="line">class Object&#123;</span><br><span class="line">public:</span><br><span class="line">    int number;</span><br><span class="line">    void show() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Object show run...&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等下讲 virtual 的原理是什么 ...</span><br><span class="line"></span><br><span class="line">// 父类1</span><br><span class="line">class BaseActivity1 : virtual public Object &#123;</span><br><span class="line">// public:int number; // 人为制作二义性  error: request for member &apos;number&apos; is ambiguous</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 父类2</span><br><span class="line">class BaseActivity2 : virtual public Object &#123;</span><br><span class="line">// public:int number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Son : public BaseActivity1, public BaseActivity2 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;HELLO WORLD!!!!&quot; &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    Object object;</span><br><span class="line">    BaseActivity1 baseActivity1;</span><br><span class="line">    BaseActivity2 baseActivity2;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    object.number = 100;</span><br><span class="line">    baseActivity1.number = 200;</span><br><span class="line">    baseActivity2.number = 300;</span><br><span class="line">    son.number = 400;</span><br><span class="line"></span><br><span class="line">    object.show();</span><br><span class="line">    baseActivity1.show();</span><br><span class="line">    baseActivity2.show();</span><br><span class="line">    son.show();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; object.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; baseActivity1.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; baseActivity2.number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; son.number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）</p><p>上面的例子中：Object就是虚基类，BaseActivity1、BaseActivity2都是虚继承于Object，然后Son都公开继承于BaseActivity1、BaseActivity2<br>在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>多态（虚函数）。   动态多态（程序的角度上：程序在运行期间才能确定调用哪个类的函数 == 动态多态的范畴）<br>Java语言默认支持多态<br>C++默认关闭多态，怎么开启多态？ 虚函数  在父类上给函数增加 virtual关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"BaseActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"MyActivity onStart"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onActivityStart</span><span class="params">(BaseActivity * baseActivity)</span> </span>&#123;</span><br><span class="line">    baseActivity-&gt;onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    HomeActivity * homeActivity = <span class="keyword">new</span> HomeActivity();</span><br><span class="line">    MyActivity * myActivity = <span class="keyword">new</span> MyActivity();</span><br><span class="line">    </span><br><span class="line">    onActivityStart(homeActivity);</span><br><span class="line">    onActivityStart(myActivity);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(myActivity &amp;&amp; homeActivity) &#123;</span><br><span class="line">        <span class="keyword">delete</span> homeActivity;</span><br><span class="line">        homeActivity = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> myActivity;</span><br><span class="line">        myActivity = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多态的定义 *<br>父类的引用指向之类的对象，同一个方法有不同的实现，重写（动态多态）和   重载(静态多态)</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载即为 静态多态<br>重载：函数名相同，但入参不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span> <span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span> <span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    add(<span class="number">1.3f</span>, <span class="number">4.5f</span>);</span><br><span class="line">    add(<span class="number">1.45</span>, <span class="number">1.67</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>c++纯虚函数类似于java中的抽象类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutId)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"XmlResourceParser解析布局文件信息... 反射"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        setContentView(getLayoutId());</span><br><span class="line">        initData();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    virtual int getLayoutId(); // 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity initData"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"HomeActivity initView"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//  错误：抽象类型 BaseActivity 绝对不能实例化</span></span><br><span class="line">    <span class="comment">// BaseActivity ba; // 報錯 Variable type 'BaseActivity' is an abstract class</span></span><br><span class="line">    HomeActivity home;</span><br><span class="line">    home.onCreate();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意纯虚函数记得在函数后面写 = 0<br>如果不写 = 0 则会运行报错</p><h3 id="全纯虚函数"><a href="#全纯虚函数" class="headerlink" title="全纯虚函数"></a>全纯虚函数</h3><p>如果类中的函数都是虚函数，则这个类可以被成为全纯虚函数， 相当于java中的接口</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>与java中的函数回调类似<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> mobile;</span><br><span class="line">    </span><br><span class="line">    User(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> mobile): id(id), name(name), mobile(mobile)&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"用户名:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">" 用户id："</span> &lt;&lt; <span class="keyword">this</span>-&gt;id &lt;&lt; <span class="string">" 用户手机号:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;mobile  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILognResult</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(<span class="keyword">int</span> code, User user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, <span class="built_in">string</span> message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loginAction</span><span class="params">(<span class="built_in">string</span> userName, <span class="built_in">string</span> password, ILognResult &amp; loginResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(userName.empty() || password.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"登录的账号与用户名都不能为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"justin"</span> == userName &amp;&amp; <span class="string">"123321qQ"</span> == password) &#123;</span><br><span class="line">        loginResult.success(<span class="number">200</span>, User(<span class="number">1121</span>, <span class="string">"justin"</span>, <span class="string">"13163396276"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loginResult.fail(<span class="number">404</span>, <span class="string">"用户名或密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginResultImpl</span> :</span> <span class="keyword">public</span> ILognResult &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">(<span class="keyword">int</span> code, User user)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"登录成功：userName:"</span> &lt;&lt; user.name &lt;&lt; <span class="string">" mobile: "</span> &lt;&lt; user.mobile  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, <span class="built_in">string</span> message)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"登录失败：错误状态码:"</span> &lt;&lt; code &lt;&lt; <span class="string">" 错误信息: "</span> &lt;&lt; message  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> userName;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入用户名"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; userName;</span><br><span class="line">    <span class="built_in">string</span> password;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入密码"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; password;</span><br><span class="line">    LoginResultImpl loginResult;</span><br><span class="line">    loginAction(userName, password, loginResult);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码就是一个登录操作的回调 其实是非常类似于 java中的接口回调的</p><h2 id="模版函数"><a href="#模版函数" class="headerlink" title="模版函数"></a>模版函数</h2><p>c++ 中没有范型概念，但是有模版函数，与java中的范型类似</p><p>像我们在之前的 静态多态中对于重载时的举例，加法<br>当我们针对不同的数据类型都需要进行一次重载，但当我们使用函数模版时，写一次即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"result:"</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> a = add(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">float</span> f = add(<span class="number">1.4f</span>, <span class="number">66.8f</span>);</span><br><span class="line">    <span class="keyword">double</span> d = add(<span class="number">3.6</span>, <span class="number">88.99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"f:"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"d:"</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，使用模版函数完成了各个类型的加法计算，使用也与java中的范型及其类似</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NDK C++基础 四</title>
      <link href="/blog/2021/04/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html"/>
      <url>/blog/2021/04/NDK-C-%E5%9F%BA%E7%A1%80-%E5%9B%9B.html</url>
      
        <content type="html"><![CDATA[<h2 id="c-可变参数"><a href="#c-可变参数" class="headerlink" title="c++可变参数"></a>c++可变参数</h2><p>在java中，可变参数使用 int … 需要声明类型<br>在c++中，可变参数直接使用 … 表示，不限制类型，而是在取值时，申明类型<br>在c++，获取可变参数使用 va_list va_start va_arg va_end</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp; <span class="comment">// 可变参数的动作</span></span><br><span class="line">    va_start(vp, count); <span class="comment">// 第二个参数：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num1： "</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    num1 = va_arg(vp, <span class="keyword">int</span>); <span class="comment">// 取值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sum(<span class="number">666</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 va_start 中第二个参数的解释：</p><ul><li>可变参数获取其实是根据内存地址来获取的，将函数传入的可变参数前的一个参数作为 va_start 的第二个参数，就是获取到前一个参数的地址，就可以获取到可变参数的首地址，然后再根据取值的类型，既可获取存储需要的size，就可以获取到每一个可变参数的值 *</li></ul><p>注意事项：</p><ul><li>取值可变参数多个值时，需要用同一个变量接收，即使用同一个内存地址接收</li><li>当取的值超出了可变参数的长度时，并不会报错，而是取到一个系统内存地址的值，随机</li><li>当取值完毕要调用 va_end 来结束可变参数的获取</li></ul><p>我们在使用可变参数时，必须传递一个具体的参数，用于确定可变参数的内存地址，</p><ul><li>同时为了方便使用，我们可以传递可变参数的长度。这样也就不会存在可变参数越界取到随机值的问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp;</span><br><span class="line">    va_start(vp, count);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        num = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">3</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id; <span class="comment">// statin int id = 99; 会报错 Non-const static data member must be initialized out of line</span></span><br><span class="line">    Person()&#123;</span><br><span class="line">        id = <span class="number">99</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = <span class="number">9</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        id = <span class="number">87</span>; <span class="comment">// 编译不通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::id= <span class="number">88</span>; <span class="comment">// 加上这一句，这样就可以了。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person person;</span><br><span class="line">    person.change();</span><br><span class="line">    Person::update(); <span class="comment">// 类名::可以调用静态函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  person.id &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// id没实现也会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">静态的总结：</span><br><span class="line">* <span class="number">1.</span>可以直接通过类名::静态成员（字段/函数）</span><br><span class="line">* <span class="number">2.</span>静态的属性必须要初始化，然后再实现（规则）</span><br><span class="line">* <span class="number">3.</span>静态的函数只能取操作静态的属性和方法（Java）</span><br><span class="line"></span><br><span class="line">#<span class="meta"># this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span> 指当前的对象</span><br><span class="line"></span><br><span class="line">** <span class="keyword">const</span>修饰函数的<span class="keyword">this</span>意义何在。 **</span><br><span class="line">之前讲过常量指针、指针常量、常量指针常量</span><br><span class="line">使用<span class="keyword">const</span> 修饰的函数其实就是对该函数 内部隐式的 <span class="keyword">this</span> 进行<span class="keyword">const</span> 修饰，使当前<span class="keyword">this</span>变为一个 常量指针常量</span><br><span class="line"></span><br><span class="line">* 常量指针 常量是修饰值的，不能修改指，可以修改地址</span><br><span class="line">* 指针常量，不可修改指向的地址，但可以修改指针指向的值</span><br><span class="line">* 常量指针常量 既不能修改指向的地址，也不能修改指针指向的数据，即完全只读</span><br><span class="line"></span><br><span class="line">也就是说使用<span class="keyword">const</span>修饰的函数，既不能修改 当前对象 中属性的值，也不能修改地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = <span class="number">19</span>; <span class="comment">// 报错 Cannot assign to non-static data member within const member function 'test'</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">88</span>;</span><br><span class="line">    &amp;<span class="keyword">this</span> = <span class="literal">NULL</span>; <span class="comment">// 报错 Cannot take the address of an rvalue of type 'const Person *'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>常规来说，private的变量在类之外，都是无法访问的，即使是在外部生成的变量或者子类都是无法修改的。<br>但是在c++中，存在友元函数，可以在友元函数中，类对象可以访问对象的私有属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 友元函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    person-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WoRLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Person person;</span><br><span class="line"><span class="comment">//    person.age = 10; // 会报错 'age' is a private member of 'Person'</span></span><br><span class="line">    person.setAge(<span class="number">19</span>);</span><br><span class="line">    updateAge(&amp;person, <span class="number">88</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"age: "</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>除了友元函数，还存在友元类，和友元类类似，在友元类中，类对象可以访问私有属性与私有函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>;</span> <span class="comment">// 友元类</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student student;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStudentAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        student.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getStudentAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  student.age;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Class cla;</span><br><span class="line">cla.setStudentAge(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"友元类中输出私有属性："</span> &lt;&lt; cla.getStudentAge() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>重写运算符的逻辑，使用关键字 <em> operator</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对+号做运算符重载</span></span><br><span class="line">Point <span class="keyword">operator</span> + (Point point1, Point point2) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = point1.getX() + point2.getX();</span><br><span class="line">    <span class="keyword">int</span> y = point1.getY() + point2.getY();</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(x, y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象1 + 对象2   C++默认不支持的， Java也不支持，Kotlin也不支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++/Kotlin 运算符重载 + 把+重载掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">point2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Point point = point1 + point2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符+重载 point x:"</span> &lt;&lt; point.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这里的加号还是可以正常运算</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是将 运算符重载函数写在类外，还可以将重载函数写在类的内部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对+号重载</span></span><br><span class="line">    <span class="comment">// 系统是这样写的  常量引用：不允许修改，只读模式</span></span><br><span class="line">    <span class="comment">// const 关键字的解释</span></span><br><span class="line">    <span class="comment">// &amp; 性能的提高，如果没有&amp;  运行+ 构建新的副本，会浪费性能</span></span><br><span class="line">    <span class="comment">// 如果增加了&amp; 引用是给这块内存空间取一个别名而已</span></span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp; point) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + point.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + point.y;</span><br><span class="line">        <span class="keyword">return</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对-号重载</span></span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp; point) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x - point.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y - point.y;</span><br><span class="line">        <span class="keyword">return</span>  Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 ++对象 进行重载</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++ () &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"++对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 对象++ 进行重载</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"对象++"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">point2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Point point = point1 + point2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符+重载 point x:"</span> &lt;&lt; point.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    point1++;</span><br><span class="line">    ++point1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"运算符++重载 point1 x:"</span> &lt;&lt; point1.getX() &lt;&lt; <span class="string">"  y: "</span> &lt;&lt; point1.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 ++对象 与 对象++ 的区别</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android aidl</title>
      <link href="/blog/2021/03/android-aidl.html"/>
      <url>/blog/2021/03/android-aidl.html</url>
      
        <content type="html"><![CDATA[<p>AIDL: Android Interface Definition Language （android 接口定义语言）<br>可以使用 AIDL 定于跨进程的客户端与服务端通信(IPC)的编程接口.</p><p>主要流程是在项目中新建一个 aidl 文件，此时会自动在 src 目录下生成 aidl 目录，并创建包名路径，并在路径下生成命名的 aidl 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.justin.ipc.application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 rebuild project，会在 app/build/generated/aidl_source_doutput_dir/denug/out/包名/下生成对应的 IMyAidlInterface.java 文件</p><p>会生成大量代码，首先是接口基本代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">/** Default implementation for IMyAidlInterface. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">justin</span>.<span class="title">ipc</span>.<span class="title">application</span>.<span class="title">IMyAidlInterface</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">         * and return values in AIDL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码， 是 IMyAidlInterface.java 文件中代码主体部分，IMyAidlInterface 继承 android.os.IInterface 接口<br>然后有一个默认的静态内部类 Default 实现 IMyAidlInterface 接口，具体的函数实现都是空，没有具体逻辑。<br>注意其中的 asBinder 函数，这是 android.os.IInterface 中的方法</p><h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>然后在 IMyAidlInterface 接口类中，还有一个静态内部抽象类 Stub 继承自 android.os.Binder 实现 IMyAidlInterface 接口<br>而 android.os.Binder 又实现于 IBinder 接口<br>介于 Binder 对象在系统底层的支持下，Stub 对象就具有了远程传输数据的能力，在生成 Stub 对象的时候会调用 asInterface 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检索 Binder 对象是否是本地接口的实现</span></span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.justin.ipc.application.IMyAidlInterface))) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((com.justin.ipc.application.IMyAidlInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Binder 为什么具有远程通信的能力，因为如上面所说 Stub 继承了 Binder 类<br>下面是官网对 IBinder 接口的描述：<br><code>远程对象的基础接口，轻量级远程过程调用机制的核心部分，专为执行进程内和跨进程调用时的高性能而设计。该接口描述了与可远程对象交互的抽象协议。不要直接实现这个接口，而是从Binder扩展。</code><br>这里我们知道 Binder 实现了 IBinder 接口，也就是说 Binder 具备了远程通信的能力，当不同进程之间（远程）之间通信时，显然使用的是 Stub 的代理对象 Proxy ，<br>而在 Proxy 中的具体函数中，只是将数据序列号，然后在系统跨进程支持下最终调用 onTransact() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">    <span class="keyword">switch</span> (code)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        reply.writeString(descriptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_basicTypes:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        <span class="keyword">int</span> _arg0;</span><br><span class="line">        _arg0 = data.readInt();</span><br><span class="line">        <span class="keyword">long</span> _arg1;</span><br><span class="line">        _arg1 = data.readLong();</span><br><span class="line">        <span class="keyword">boolean</span> _arg2;</span><br><span class="line">        _arg2 = (<span class="number">0</span>!=data.readInt());</span><br><span class="line">        <span class="keyword">float</span> _arg3;</span><br><span class="line">        _arg3 = data.readFloat();</span><br><span class="line">        <span class="keyword">double</span> _arg4;</span><br><span class="line">        _arg4 = data.readDouble();</span><br><span class="line">        java.lang.String _arg5;</span><br><span class="line">        _arg5 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_setName:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        java.lang.String _arg0;</span><br><span class="line">        _arg0 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.setName(_arg0);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_getName:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        <span class="keyword">this</span>.getName();</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这个方法在当系统回调给开发者的时候，传递回来的 code 是一个常量，在跨进程时，每个具体的服务（方法）都会对应一个编号<br>，然后根据这个编号来执行相应的服务（业务），这里说到了最后要执行的具体业务，<br>那么这个业务要体现在什么地方呢，从上面可知 Stub 是一个抽象类，那么它所提供的具体业务必然需要一个具体的实现类来完成，<br>而这个类就是需要我们自己手动根据需要来实现</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 是 Stub 中的一个 静态内部类，实现 IMyAidlInterface 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">justin</span>.<span class="title">ipc</span>.<span class="title">application</span>.<span class="title">IMyAidlInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">    Proxy(android.os.IBinder remote)</span><br><span class="line">    &#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">        * and return values in AIDL.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeInt(anInt);</span><br><span class="line">        _data.writeLong(aLong);</span><br><span class="line">        _data.writeInt(((aBoolean)?(<span class="number">1</span>):(<span class="number">0</span>)));</span><br><span class="line">        _data.writeFloat(aFloat);</span><br><span class="line">        _data.writeDouble(aDouble);</span><br><span class="line">        _data.writeString(aString);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().basicTypes(anInt, aLong, aBoolean, aFloat, aDouble, aString);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_setName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().setName(name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().getName();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.IMyAidlInterface sDefaultImpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 Proxy 中的几个具体方法，主要是对数据做序列化处理，然后调用 mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, 0);</p><p>mRemote 在 Proxy 的构造函数内被赋值，而 Proxy 是在 Stub 中的 asInterface 函数， 所以又回到了 上面的逻辑。</p><h3 id="手动实现进程通信"><a href="#手动实现进程通信" class="headerlink" title="手动实现进程通信"></a>手动实现进程通信</h3><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>创建一个 Service，并运行在其他进程，模拟跨进程调用 Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestAIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestAIDLService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAIDLTestImp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AndroidManifest.xml 文件中，配置 Service</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyTestAIDLService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 process=”:remote” 表示运行在另一进程，进程号为： 主进程 + ‘:remote’</p><h4 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h4><p>写三个按钮，一个绑定服务，一个解绑服务，一个调用服务中的 Binder 获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = MainActivity.class.getName() + <span class="string">"MYTEST："</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button btn_bind, btn_unbind, btn_get;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IMyAidlInterface interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isConnected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        btn_bind = findViewById(R.id.bind_server);</span><br><span class="line">        btn_unbind = findViewById(R.id.unbind_server);</span><br><span class="line">        btn_get = findViewById(R.id.btn_getInfo);</span><br><span class="line"></span><br><span class="line">        btn_bind.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">            bindService();</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_unbind.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">           unbindService();</span><br><span class="line">        &#125;);</span><br><span class="line">        btn_get.setOnClickListener((View view) -&gt; &#123;</span><br><span class="line">            getInfo();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isConnected = <span class="keyword">true</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyTestAIDLService.class);</span><br><span class="line">        bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isConnected) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"unbindService: 已解绑，请勿重复提交"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isConnected = <span class="keyword">false</span>;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        Log.d(TAG, <span class="string">"unbindService: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaces.setName(<span class="string">"name"</span>);</span><br><span class="line">            String result = interfaces.getName();</span><br><span class="line">            Log.d(TAG, <span class="string">"getInfo: "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onServiceConnected: "</span>);</span><br><span class="line">            interfaces = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">            System.out.println(TAG + <span class="string">"具体的业务对象："</span>+interfaces);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onServiceDisconnected: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindingDied</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onBindingDied: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们依次点击绑定服务、获取信息，输出如下：<br>onServiceConnected:<br>具体的业务对象：com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157<br>getInfo: name</p><p>当我们在 AndroidManifest.xml 中去除 Service 的 process 配置，即让 service 与 MainActivity 处于同一进程时，<br>输出如下：<br>onServiceConnected:<br>具体的业务对象：com.justin.ipc.application.MyAIDLTestImp@da080a<br>getInfo: name</p><p>对比发现，输出的 interfaces 对象不同<br>原因是在 Stub 中 asInterface 函数中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.justin.ipc.application.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.justin.ipc.application.IMyAidlInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.justin.ipc.application.IMyAidlInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在同一进程中，queryLocalInterface 返回的 iin 不为空，此时获取的就是 om.justin.ipc.application.MyAIDLTestImp@da080a</p><p>而处于跨进程通信时，queryLocalInterface 返回的 iin 为空，此时会返回 new com.justin.ipc.application.IMyAidlInterface.Stub.Proxy(obj);<br>一个新的 Proxy 对象，也就是上面的 com.justin.ipc.application.IMyAidlInterface$Stub$Proxy@2b5157</p><h3 id="跨进程通信的身份认证"><a href="#跨进程通信的身份认证" class="headerlink" title="跨进程通信的身份认证"></a>跨进程通信的身份认证</h3><p>在跨进程通信时，可能需要对通信双方进行安全认证<br>认证方式一般包括：自定义权限、数据认证</p><h4 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h4><p>自定义权限，一般适用于需要提供功能给第三方应用使用时，做一个权限认证。<br>需要我们先在自己应用中申明我们的自定义权限</p><h4 id="申明自定义权限"><a href="#申明自定义权限" class="headerlink" title="申明自定义权限"></a>申明自定义权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.justin.ipc.application"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"com.justin.custom.permission.PERSONAL"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:description</span>=<span class="string">"自定义权限描述"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:permissionGroup</span>=<span class="string">"MINE_CUSTOM_PERMISSION_GROUP"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释下各个属性：</p><ul><li>name，该标签就是权限的名字。</li><li>您需要为权限提供标签和说明。这些是用户在查看权限列表 (android:label) 或有关单个权限的详细信息 (android:description) 时能够看到的字符串资源。标签应当简短，用几个词描述该权限所保护的关键功能。说明应该用几个句子描述权限允许权限获得者执行哪些操作。我们通常会使用包含两个句子的说明：第一句描述权限；第二句提醒用户在向应用授予权限后可能会出现哪类错误。</li><li>android:permissionGroup 属性为可选项，仅用于帮助系统向用户显示权限。在大多数情况下，您应将其设置为标准系统组（在 android.Manifest.permission_group 中列出），但您也可以自行定义组。最好使用现有的组，因为这可以简化用户看到的权限界面。</li><li>protectionLevel 属性为必需项，用于指示系统如何向用户告知哪些应用正在请求权限或者谁可以获得该权限</li></ul><p>Android 将权限分为若干个保护级别:normal, dangerous, signature 等。<br>normal 就是正常权限，该权限并不会给用户或者设备的隐私带来风险； 在 6.0 后不需要动态申请<br>dangerous 就是危险权限，该级别的权限通常会给用户的数据或设备的隐私带来风险； 在 6.0 后需要动态申请<br>signature 指的是，只有相同签名的应用才能使用该权限。 在 6.0 后需要动态申请</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>当我们申明了自定义权限后，在其他应用中使用时，就与系统的权限使用是一样的配置。</p><p>而我们也会对权限进行校验</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>andorid MVC</title>
      <link href="/blog/2021/03/andorid-MVC.html"/>
      <url>/blog/2021/03/andorid-MVC.html</url>
      
        <content type="html"><![CDATA[<p>MVC 模式：</p><p>1）Model (模型层) 在 MVC 中 Model 一般用来保存数据的状态，比如数据存储，网络请求。同时还与View 存在一定的耦合，通过某种事件机制（比如观察者模式） 通知 View 状态的改变来让view 更新。</p><p>2）View (视图层)一般由一些GUI 组建组成，同时响应用户的交互行为并触发 Controller 的逻辑，View 还有可能修改Model 的状态 以使其与 Model 同步，View 还会在model 中注册 model 事件的改变。以此来刷新自己并展示给用户。</p><p>3）Control （控制层）控制器由View 根据用户行为触发并响应来自view 的用户交互，然后根据view 的事件逻辑来修改对应的Model, Control 并不关心 View 如何展示 相关数据或状态，而是通过修改 Model 来实现view 的数据的刷新。</p><p>view 层即指 xml文件</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/blog/2021/03/android-%E5%8A%A8%E7%94%BB.html"/>
      <url>/blog/2021/03/android-%E5%8A%A8%E7%94%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="android动画"><a href="#android动画" class="headerlink" title="android动画"></a>android动画</h1><p>动画分为两类，传统动画、属性动画</p><h2 id="传统动画"><a href="#传统动画" class="headerlink" title="传统动画"></a>传统动画</h2><p>传统动画又分为帧动画、补间动画</p><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。<br>有点类似与gif</p><p>将图片资源放入到drawable文件夹<br>在drawable下新建资源文件 drawable1.xml  类型：animation-list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image1&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image2&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image3&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image4&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><p>android:drawable 指的是要显示的图片资源<br>android:duration: 图片显示时长</p><p>还有一些其它参数</p><p>在Activity中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imageView = findViewById(R.id.imageView);</span><br><span class="line">imageView.setImageResource(R.drawable.image);</span><br><span class="line">AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">drawable.start();</span><br></pre></td></tr></table></figure></p><p>这样就可以让四张图片动起来了。</p><p>这样就是一个帧动画的简单样例</p><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）<br>其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。</p><p>补间动画可以通过xml、或者代码形式实现。</p><h3 id="xml实现补间动画"><a href="#xml实现补间动画" class="headerlink" title="xml实现补间动画"></a>xml实现补间动画</h3><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>android 动画分为补间动画、属性动画。<br>补间动画的原理是在draw绘制时，一直改变draw绘制的图形，但在layout时的坐标都没有变化， 所以对视图的响应还是在原来的坐标。<br>属性动画，是通过改变视图的属性来达到动画的效果，在设置属性动画时，就需要针对被更改的属性提供get/set方法。所以对视图的响应就在动画那一刻视图显示的位置。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>NDK-c++基础 三</title>
      <link href="/blog/2021/03/NDK-c-%E5%9F%BA%E7%A1%80-%E4%B8%89.html"/>
      <url>/blog/2021/03/NDK-c-%E5%9F%BA%E7%A1%80-%E4%B8%89.html</url>
      
        <content type="html"><![CDATA[<p>c++语言基础，<br>c++中能运行c语言，但c语言不能运行c++</p><p>C++语言面向对象 + 标准特性<br>C语言面向过程，函数+结构体<br>C++里面可以运行C语言，可以调用C语言，反之 就不行C语言无法运行C++<br>以后我们85%以上 都是 用C++去写功能</p><p>在c语言中基本运行需要引入<br><code>#include &lt;stdio.h&gt;</code><br>在c++中需要引入<br><code>#include &lt;iostream&gt;</code>    </p><h2 id="打印语句"><a href="#打印语句" class="headerlink" title="打印语句"></a>打印语句</h2><ul><li>cout *<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO WORLD!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YYYYYY\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Line1\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"Line2\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"line3\n"</span>;</span><br></pre></td></tr></table></figure></li></ul><p>需要引入<br><code>using namespace std;</code><br>namespace 命名空间</p><p>&lt;&lt; 是一个操作重载符，cout 更正确的写法是： std::cout<br>因为我们已经引入 命名空间，所以可以省略为： cout</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在c或者c++中，常量使用 const 声明，但是在c语言中，常量是个伪命题，因为c中可以直接修改指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">90</span>;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;i; <span class="comment">// c++ Cannot initialize a variable of type 'int *' with an rvalue of type 'const int *'</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>i 已经被定义成常量<br>上面这段代码在c语言中可以运行，并能修改i地址处的值为10，达到了修改常量值的目的。<br>但是在c++中会报错，ide工具就会直接报错：Cannot initialize a variable of type ‘int <em>‘ with an rvalue of type ‘const int </em>‘</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>&amp; *</li></ul><p>c++中 &amp; 标示引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a = i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a地址:"</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">"\ni地址:"</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c地址:"</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">"\nd地址:"</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>打印结果：<br>a地址:0x7ffeefbff4c8<br>i地址:0x7ffeefbff4c8<br>c地址:0x7ffeefbff4bc<br>d地址:0x7ffeefbff4b8</p><p>因为 a 是 i 的引用。 a 指向 i， 所以 a 与 i 的地址一致。<br>而c 与 d 不同，c、d都是一个新的对于9的引用。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>c++ 申明类使用关键字 class<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> * name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如此一个基本类就定义完成，成员变量使用private修饰，在外部不可访问，提供public修饰的set、get函数来操作成员变量。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"空构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="keyword">int</span> age): age(age) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"一个参数的构造函数： age"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="keyword">char</span> * name) &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"一个参数的构造函数： name"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="keyword">int</span> age, <span class="keyword">char</span> * name)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"两个参数的构造函数： name"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上所示，第2个与第三个其实效果是一样的，都是对成员变量直接赋值。<br>还有构造函数的相互调用问题:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">char</span> * name): Person(age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"两个参数的构造函数： name"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>调用两个参数的构造函数时，会调用到一个参数的构造函数，</p><ul><li>而且打印会先打印一个参数的构造函数的日志，然后再打印两个参数构造函数的日志  *</li></ul><h3 id="类的引用"><a href="#类的引用" class="headerlink" title="类的引用"></a>类的引用</h3><p>我们在上面申明了一个类，然后我们可以根据类申明引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"HELLO TESTCLASS"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Person person;</span><br><span class="line">person.setAge(<span class="number">29</span>);</span><br><span class="line">person.setName(<span class="string">"justin"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; person.getAge() &lt;&lt; <span class="string">",  name:"</span> &lt;&lt; person.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">24</span>, <span class="string">"novia"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; person1.getAge() &lt;&lt; <span class="string">",  name:"</span> &lt;&lt; person1.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br><code>HELLO TESTCLASS空构造函数age:29,  name:justin一个参数的构造函数： age两个参数的构造函数： nameage:24,  name:novia</code></p><p>在上述代码中，生成的person都是普通的引用，数据内存都是在栈区。<br>接下来看一下在C++中如何使用堆区内存</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>与c语言不同，c++中使用 new 生成的对象都存放在堆内存中，而存放在堆内存中的数据，需要自己手动<br>c++使用 delete 释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person * person = <span class="keyword">new</span> Person(<span class="number">29</span>, <span class="string">"justin"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age:"</span> &lt;&lt; person-&gt;getAge() &lt;&lt; <span class="string">",  name:"</span> &lt;&lt; person-&gt;getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person;</span><br><span class="line">person = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li><p>QA: 为何栈区内存不需要释放内存<br>我们都知道函数在出栈时，会释放栈区内存，那为何不需要使用delete释放。<br>其实函数并不是没有调用delete来释放，在函数出栈时，有静默的调用了delete，来释放栈区的内存</p></li><li><p>QA：为何调用了delete后，还能调用指针并获取到值<br>因为delete的原理并不是直接清空数据，而是标记该块内存地址为可用，当应用有向堆内存重新申请内存时，就可能申请到这块内存，此时数据才会被修改，<br>如果此块内存一直没有被申请到时，调用该指针后，还是能访问到之前的数据的。<br>当调用 delete 时，该指针即成为悬空指针，继续调用就有可能出现异常，规范用法时指向NULL；</p></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>当对象内存被回收时，会执行对象的析构函数，类似与java对象的finalize函数<br>但与finalize函数不同的是，java对象可以在finalize中实现自我拯救，<br>c++析构函数中，不能实现自我拯救，主要是用于一些数据清除、销毁工作，如解绑、释放堆内存空间，是的，对象中如果也有开辟堆内存时，就需要在此处释放，不然该内存会被一直占用。<br>析构函数的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~Person()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">Person(<span class="keyword">const</span> Person &amp; person)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = person.name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = person.age;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行复制拷贝时，就会执行复制拷贝函数，系统默认的复制拷贝函数会自动完成复制值，<br>手动重写复制拷贝函数时，我们也需要手动赋值</p><p>此时传入的person就是旧对象，this即是拷贝后生成的新对象</p><h4 id="拷贝的场景"><a href="#拷贝的场景" class="headerlink" title="拷贝的场景"></a>拷贝的场景</h4><ul><li>person1 = person2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">24</span>, <span class="string">"novia"</span>)</span></span>;</span><br><span class="line">Person person2 = person1;</span><br></pre></td></tr></table></figure><p>当执行 Person person2 = person1; 即会执行 拷贝构造函数 来对person2赋值，</p><ul><li>参数传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test函数中,参数person的地址: "</span> &lt;&lt; &amp;person &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">24</span>, <span class="string">"novia"</span>)</span></span>;</span><br><span class="line">    Person person2 = person1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person1.age:"</span> &lt;&lt; person1.getAge() &lt;&lt; <span class="string">",  Person1.name:"</span> &lt;&lt; person1.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person2.age:"</span> &lt;&lt; person2.getAge() &lt;&lt; <span class="string">",  Person2.name:"</span> &lt;&lt; person2.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"person1地址---"</span> &lt;&lt; &amp;person1 &lt;&lt; <span class="string">"  ,person2地址---"</span> &lt;&lt; &amp;person2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    test(person2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><p>一个参数的构造函数： age<br>两个参数的构造函数： name<br>拷贝构造函数<br>Person1.age:24,  Person1.name:novia<br>Person2.age:24,  Person2.name:novia<br>person1地址—0x7ffeefbff4b8  ,person2地址—0x7ffeefbff4a8<br>拷贝构造函数<br>test函数中,参数person的地址: 0x7ffeefbff488<br>析构函数<br>析构函数<br>析构函数</p><p>可以看到test函数中打印的person地址 与我们调用 test 函数传递的 person2 地址并不相同。这被叫做 <em> 行参 </em></p><p>像避免上面的操作，避免产生大量的副本对象，占用内存，有几个办法，</p><ul><li><p>1、使用引用<br>在上面就讲过引用，引用也是直接执行地址的，所以当我们使用引用时，就不会重新拷贝赋值了。<br>修改一下test函数的入参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Person &amp; person)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test函数中,参数person的地址: "</span> &lt;&lt; &amp;person &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、运算符重载<br>重写 = 运算符，使之返回之前的地址。</p></li></ul><ul><li>注意事项 *<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person2 = person1; <span class="comment">// 1</span></span><br><span class="line">Person person2;</span><br><span class="line">person2 = person1; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><p>方式2是不会调用 拷贝构造函数， 方式1 才会。<br>为什么？</p><p>因为person2其实已经调用了无参构造函数，<br>Person person2; 这一句已经调用了无参构造函数，<br>person2 = person1; 只是重新赋值而已。</p><h3 id="常量指针-常量引用-指针常量-常量指针常量"><a href="#常量指针-常量引用-指针常量-常量指针常量" class="headerlink" title="常量指针 常量引用 指针常量 常量指针常量"></a>常量指针 常量引用 指针常量 常量指针常量</h3><p>之前讲过常量，代表不可更改值</p><p>常量下还有 常量指针 常量引用 指针常量 常量指针常量</p><p>注意常量修饰的位置 </p><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> number2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * a_p  = &amp;number;</span><br><span class="line">*a_p = <span class="number">100</span>; <span class="comment">// 修改值 会报错，</span></span><br><span class="line">a_p = &amp;number2; <span class="comment">// 修改地址 不会报错</span></span><br></pre></td></tr></table></figure><p>const 用来修饰类型，这个指针即为常量指针<br>声明了常量指针 a_p，<br>*a_p = 100; 会提示错误：Read-only variable is not assignable<br>常量代表只读,  常量指针 常量是修饰值的，不可以直接修改指针指向的数据，只能通过修改指针指向的地址来修改值</p><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; a = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>const 用来修饰引用，这个引用即为 常量引用<br>常量引用指向的数据也是不能直接修改的。<br>拷贝构造函数 重的参数就是一个常量引用。</p><h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> b_p = &amp;number;</span><br><span class="line"><span class="comment">//    b_p = &amp;number2; // 会报错 Cannot assign to variable 'b_p' with const-qualified type 'int *const'</span></span><br><span class="line">*b_p = <span class="number">190</span>; <span class="comment">// 不报错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*bp指向的值为"</span> &lt;&lt; *b_p &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>const 用来修饰指针，这个指针即是 指针常量<br>上面的输出结果：<br>*bp指向的值为190</p><p>指针常量，不可修改指向的地址，但可以修改指针指向的值</p><h4 id="常量指针常量"><a href="#常量指针常量" class="headerlink" title="常量指针常量"></a>常量指针常量</h4><p>常量指针常量 其实相当于 常量指针 与 指针常量 两个的合并。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> c_p = &amp;number;</span><br><span class="line">c_p = &amp;number2; <span class="comment">// 报错</span></span><br><span class="line">*c_p = <span class="number">99</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p><p>常量指针常量 既不能修改指向的地址，也不能修改指针指向的数据，即完全只读</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android SharedPreferences</title>
      <link href="/blog/2021/03/android-SharedPreferences.html"/>
      <url>/blog/2021/03/android-SharedPreferences.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SharedPreferences 存取值原理，其实还是将数据写入到xml文件 以及 缓存中。<br>Context.getSharedPreferences 都是在ContextImpl中实现，但是在API23之前、23之后实现方式却不同</p><h2 id="API-23"><a href="#API-23" class="headerlink" title="API 23"></a>API 23</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 第一次为空时，初始化值</span><br><span class="line">        if (sSharedPrefs == null) &#123;</span><br><span class="line">            sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取对应packageName下的 sp实例集合 也是当前应用第一次使用时初始化</span><br><span class="line">        final String packageName = getPackageName();</span><br><span class="line">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</span><br><span class="line">        if (packagePrefs == null) &#123;</span><br><span class="line">            packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</span><br><span class="line">            sSharedPrefs.put(packageName, packagePrefs);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">                Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            if (name == null) &#123;</span><br><span class="line">                name = &quot;null&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据传入的name获取对应的sp实例，第一次初始化  获取对应的文件</span><br><span class="line">        sp = packagePrefs.get(name);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            File prefsFile = getSharedPrefsFile(name);</span><br><span class="line">            sp = new SharedPreferencesImpl(prefsFile, mode);</span><br><span class="line">            packagePrefs.put(name, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public File getSharedPrefsFile(String name) &#123;</span><br><span class="line">    return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextImpl 中 维护有一个 静态集合 sSharedPrefs = ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;<br>sSharedPrefs 全局唯一</p><p>该map中 key为 应用包名，value 为一个 packagePrefs ArrayMap&lt;String, SharedPreferencesImpl&gt;,</p><p>SharedPreferencesImpl 是单个sp实例信息， 文件、数据map缓存</p><p>packagePrefs 存有一个应用中所有的 sp实例 SharedPreferencesImpl</p><p>sSharedPrefs 存有所有应用关于sp的实例信息</p><p><strong> 存取值其实就是在集合sSharedPrefs中通过包名packageName获取到 packagePrefs，再根据 初入的name获取到指定的 SharedPreferencesImpl实例，然后再通过实例来读写数据 </strong></p><p>getSharedPrefsFile 就是返回 应用data文件夹/shared_prefs/ name.xml</p><h2 id="API-24及以上"><a href="#API-24及以上" class="headerlink" title="API 24及以上"></a>API 24及以上</h2><p>ContextImp 中存在两个 getSharedPreferences函数，<br>public SharedPreferences getSharedPreferences(String name, int mode);<br>public SharedPreferences getSharedPreferences(File file, int mode);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</span><br><span class="line">private static ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">  </span><br><span class="line">    if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">            Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (name == null) &#123;</span><br><span class="line">            name = &quot;null&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 获取name 对应的文件</span><br><span class="line">        if (mSharedPrefsPaths == null) &#123;</span><br><span class="line">            mSharedPrefsPaths = new ArrayMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        file = mSharedPrefsPaths.get(name);</span><br><span class="line">        if (file == null) &#123;</span><br><span class="line">            file = getSharedPreferencesPath(name);</span><br><span class="line">            mSharedPrefsPaths.put(name, file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        // 获取当前运行应用的 sp集合</span><br><span class="line">        final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        if (sp == null) &#123;</span><br><span class="line">            checkMode(mode);</span><br><span class="line">            if (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">                if (isCredentialProtectedStorage()</span><br><span class="line">                        &amp;&amp; !getSystemService(UserManager.class)</span><br><span class="line">                                .isUserUnlockingOrUnlocked(UserHandle.myUserId())) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;SharedPreferences in credential encrypted &quot;</span><br><span class="line">                            + &quot;storage are not available until after user is unlocked&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 新建 SharedPreferencesImpl 对象</span><br><span class="line">            sp = new SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        // If somebody else (some other process) changed the prefs</span><br><span class="line">        // file behind our back, we reload it.  This has been the</span><br><span class="line">        // historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    if (sSharedPrefsCache == null) &#123;</span><br><span class="line">        sSharedPrefsCache = new ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String packageName = getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    if (packagePrefs == null) &#123;</span><br><span class="line">        packagePrefs = new ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在api24以后，ContextImpl中不再维护有静态的sSharedPrefs集合，<br>而是维护有一个ArrayMap mSharedPrefsPaths ，以及一个静态集合ArrayMap sSharedPrefsCache<br>sSharedPrefs key为name，value为文件<br>sSharedPrefsCache ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt;  key为包名packageName， value 为集合ArrayMap&lt;File, SharedPreferencesImpl&gt;</p><p>getSharedPreferences(String name, int mode)函数中，先通过name获取到对应的文件，再调用public SharedPreferences getSharedPreferences(File file, int mode);</p><h2 id="API-23-与-24-的差异"><a href="#API-23-与-24-的差异" class="headerlink" title="API 23 与 24 的差异"></a>API 23 与 24 的差异</h2><p>从上面来看，API23与24差异很小，其实就是将内部的集合的key从 string 改成了 file，<br>在API24中，增多一个mSharedPrefsPaths集合，在集合中就有 name 与 file的映射关系。<br>对于需要频繁获取的sp实例来说，可能略有优化，但是也增加了内存消耗。</p><p>## </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage</span><br><span class="line">SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = false;</span><br><span class="line">    mMap = null;</span><br><span class="line">    mThrowable = null;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">private void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = false;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void loadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mLoaded) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Debugging</span><br><span class="line">    if (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;</span><br><span class="line">        Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = null;</span><br><span class="line">    StructStat stat = null;</span><br><span class="line">    Throwable thrown = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                str = new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16 * 1024);</span><br><span class="line">                map = (Map&lt;String, Object&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ErrnoException e) &#123;</span><br><span class="line">        // An errno exception means the stat failed. Treat as empty/non-existing by</span><br><span class="line">        // ignoring.</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = true;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        // It&apos;s important that we always signal waiters, even if we&apos;ll make</span><br><span class="line">        // them fail with an exception. The try-finally is pretty wide, but</span><br><span class="line">        // better safe than sorry.</span><br><span class="line">        try &#123;</span><br><span class="line">            if (thrown == null) &#123;</span><br><span class="line">                if (map != null) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mMap = new HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // In case of a thrown exception, we retain the old map. That allows</span><br><span class="line">            // any open editors to commit and store updates.</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新建 SharedPreferencesImpl 时，会初始化一些变量，并且执行startLoadFromDisk<br>在startLoadFromDisk 中会新开线程执行 loadFromDisk<br>在loadFromDisk 中，会删除原文件，然后将 备份文件重命名 </p><p>然后就是通过文件流读取 文件信息，将读取到的信息赋值给 SharedPreferencesImpl中的 map对象。<br>同时对文件的读取都是加锁操作的。当文件读取完成了，执行mLock.notifyAll();唤醒所有操作线程。 </p><p><code>loadFromDisk 需要新开线程也是互斥的问题，必须保证load 与读写不在同一线程，才能让不会一直await，在加载完能够唤醒读写的操作继续。</code></p><h3 id="getValue"><a href="#getValue" class="headerlink" title="getValue()"></a>getValue()</h3><p>内部有针对不同类型的get方法，基本都一致，看一个就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String getString(String key, @Nullable String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        return v != null ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读操作也是加锁的，防止读、写同时，导致数据异常，同时也跟上面的 loadFromDisk 中加锁呼应，防止问价还未加载完就进行读写操作</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put操作需要通过内部类EditorImpl来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">public Editor edit() &#123;</span><br><span class="line">    // 当文件未加载完，即loadFromDisk未执行完时，会一直等待。</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    // 每次获取edit时都是重新创建一个对象。</span><br><span class="line">    return new EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次获取Edit对象时都是返回一个新的对象，所以尽量将数据操作合并，不要频繁去重新获取edit对象。<br>在看一下put数据的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, Object&gt; mModified = new HashMap&lt;&gt;();</span><br><span class="line">@Override</span><br><span class="line">public Editor putString(String key, @Nullable String value) &#123;</span><br><span class="line">    synchronized (mEditorLock) &#123;</span><br><span class="line">        mModified.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行put方法时，只是将数据提交到 EditorImpl 中的一个HashMap中，<br>只有在commit 或者 apply时，才会将数据合并、写入到文件中。</p><ul><li>QA：为何要设计一个mModified，来保存数据，而不是直接提交合并到文件？<br>这样可以避免频繁操作文件，只有在执行commit、apply时才去操作文件，提高效率，是一种优化手段。</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean commit() &#123;</span><br><span class="line">    long startTime = 0;</span><br><span class="line"></span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    // 合并mModified数据到一个新的集合，并清除mModified数据，并记录哪些key的value发生更改，最后将合并的数据包装成一个MemoryCommitResult对象</span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    // 将mcr加入文件写入队列，注意第二个参数为null，标示 直接写入，不需等待</span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</span><br><span class="line">        mcr, null /* sync write on this thread okay */);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 等待写入结果</span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                    + &quot; committed after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                    + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 唤醒监听器，发送消息，数据更改操作结束</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    return mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void apply() &#123;</span><br><span class="line">    final long startTime = System.currentTimeMillis();</span><br><span class="line">    final MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    final Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (DEBUG &amp;&amp; mcr.wasWritten) &#123;</span><br><span class="line">                    Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration</span><br><span class="line">                            + &quot; applied after &quot; + (System.currentTimeMillis() - startTime)</span><br><span class="line">                            + &quot; ms&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 apply、commit两个函数基本相同，主要时在 enqueueDiskWrite 函数执行时，传入的第二个参数不同 </p><h3 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</span><br><span class="line">                                  final Runnable postWriteRunnable) &#123;</span><br><span class="line">    // commit时,传入的postWriteRunnable为null， isFromSyncCommit 为true， </span><br><span class="line">    // apply时 postWriteRunnable != null isFromSyncCommit = false</span><br><span class="line"></span><br><span class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</span><br><span class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (mWritingToDiskLock) &#123;</span><br><span class="line">                    writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mDiskWritesInFlight--;</span><br><span class="line">                &#125;</span><br><span class="line">                if (postWriteRunnable != null) &#123;</span><br><span class="line">                    postWriteRunnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    // commit 才会进入这个判断，并最终执行writeToDiskRunnable 然后return</span><br><span class="line">    if (isFromSyncCommit) &#123;</span><br><span class="line">        boolean wasEmpty = false;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            wasEmpty = mDiskWritesInFlight == 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wasEmpty) &#123;</span><br><span class="line">            writeToDiskRunnable.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // apply 会执行此处</span><br><span class="line">    QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commit、apply差异"><a href="#commit、apply差异" class="headerlink" title="commit、apply差异"></a>commit、apply差异</h3><p>从上面的注释也可以看出， commit会直接在当前线程执行 writeToDiskRunnable.run();<br>而 apply 会将 writeToDiskRunnable 加入队列 QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);等待线程池执行任务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SP是线程安全的，通过锁、await、notifyAll，保证并行时不会读写异常。</p><p>SP通过全局静态ArrayMap维护一个集合，通过packageName、name找到对应的读写文件file、SPImpl实例。</p><p>读操作是加载file完之后，直接在缓存的一个集合Map中根据key读取即可。</p><p>写操作是先将需要写入的数据都缓存到一个HashMap中，再在commit或者apply时与file中的数据合并，并标示哪些key发生改变，包装成一个MemoryCommitResult对象。</p><p>写操作只是修改缓存的HashMap，修改持久化的数据还需要执行commit或者apply。</p><p>commit 是当前线程直接执行，而 apply是添加到任务队列等待线程池执行。</p><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><ul><li><p>不要存放大的key和value在SharedPreferences中，否则会一直存储在内存中得不到释放，内存使用过高会频发引发GC，导致界面丢帧甚至ANR。</p></li><li><p>不相关的配置选项最好不要放在一起，单个文件越大读取速度则越慢。</p></li><li><p>读取频繁的key和不频繁的key尽量不要放在一起（如果整个文件本身就较小则忽略，为了这点性能添加维护得不偿失）。</p></li><li><p>不要每次都edit，因为每次都会创建一个新的EditorImpl对象，最好是批量处理统一提交。否则edit().commit每次创建一个EditorImpl对象并且进行一次IO操作，严重影响性能。</p></li><li><p>commit发生在UI线程中，apply发生在工作线程中，对于数据的提交最好是批量操作统一提交。虽然apply发生在工作线程（不会因为IO阻塞UI线程）但是如果添加任务较多也有可能带来其他严重后果<br>  （参照ActivityThread源码中handleStopActivity方法实现）</p></li><li><p>尽量不要存放json和html，这种可以直接文件缓存。</p></li><li><p>不要指望它能够跨进程通信 Context.PROCESS</p></li><li><p>最好提前初始化SharedPreferences，避免SharedPreferences第一次创建时读取文件线程未结束而出现等待情况。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 应用启动流程</title>
      <link href="/blog/2021/03/android-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html"/>
      <url>/blog/2021/03/android-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<p>android 应用启动过程分为冷启动、热启动</p><p>我们从应用入口开始分析</p><h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h2><p>android 应用的主入口，<br>在 main 函数中，会启动消息机制。</p><p>在 performLaunchActivity 函数中，会构建 Activity 对象，然后调用 activity 中的 attach 函数。</p><p>而在 attach 函数中，会构建 Activity 的 PhoneWindow 以及 decorView</p><p>在 ActivityThread 中的 handleResumeActivity 函数中，会将 decorView 添加到 windowManager 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.window = r.activity.getWindow();</span><br><span class="line">View decor = r.window.getDecorView();</span><br><span class="line">decor.setVisibility(View.INVISIBLE);</span><br><span class="line">ViewManager wm = a.getWindowManager();</span><br><span class="line"><span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">  a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">  wm.addView(decor, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NDK c语言基础 二</title>
      <link href="/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C.html"/>
      <url>/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%BA%8C.html</url>
      
        <content type="html"><![CDATA[<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>申明关键字 struct</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    </span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似与java中的bean类，kotlin中的data class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    struct Person * person;</span><br><span class="line">    person-&gt;name = &quot;justin&quot;; // xcode可以这样写，其他工具可能需要使用 strcpy 函数来对字符串复制来进行赋值</span><br><span class="line">    person-&gt;age = 29;</span><br><span class="line">    printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以直接在结构体后实例化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; ppp1  = &#123;&quot;9999&quot;, 21&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>在不同的ide工具中，c语言的语法可能略有不同，为了统一，推出一个类型定义，<br>如此保证在不同的ide工具，使用一样的代码运行</p><p>在源码中也是大量使用</p><p>关键字 typedef</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    char * name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; ppp1  = &#123;&quot;9999&quot;, 21&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">typedef struct Person Person; // 为结构体定义一个类型，后续申明结构体对象就不需要使用struct关键字</span><br><span class="line">typedef Person * Person_; // 为结构体指针定一个类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    Person_ person;</span><br><span class="line">    person-&gt;name = &quot;justin&quot;;</span><br><span class="line">    person-&gt;age = 29;</span><br><span class="line">    printf(&quot;name:%s,age:%d\n&quot;, person-&gt;name, person-&gt;age);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>file</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMM java内存模型</title>
      <link href="/blog/2021/03/JMM-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"/>
      <url>/blog/2021/03/JMM-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、现代计算机内存模型"><a href="#一、现代计算机内存模型" class="headerlink" title="一、现代计算机内存模型"></a>一、现代计算机内存模型</h2><p>早期的计算机中由于CPU和内存的速度是差不多的，所以CPU是直接访问内存地址的。<br>而在现代计算机中，CPU指令的运行速度远远超过了内存数据的读写速度，为了降低这两者间这高达几个数量级的差距，所以在CPU与主内存之间加入了CPU高速缓存。</p><p>高速缓存可以很好地解决CPU与主内存之间的速度差距，但CPU缓存并不是所有CPU共享的，因此产生了一个新的问题：数据一致性问题。</p><p><img src="../../../images/memory.png" style="zoom:70%"></p><h2 id="二、缓存一致性协议（MESI）"><a href="#二、缓存一致性协议（MESI）" class="headerlink" title="二、缓存一致性协议（MESI）"></a>二、缓存一致性协议（MESI）</h2><h3 id="MESI四种状态"><a href="#MESI四种状态" class="headerlink" title="MESI四种状态"></a>MESI四种状态</h3><p>因为存在多个cpu，也就存在多个cpu缓存，CPU缓存的一致性问题会导致并发处理的不同步。<br>所以引入一种解决办法：缓存一致性协议（MESI）</p><p>MESI 这个名称本身是由：Modified（修改）、Exclusive（独享）、Shared（共享）、Invalid（无效）。<br>这个四个单词也代表了缓存协议中对缓存行（即Cache Line，缓存存储数据的单元）声明的四种状态，用2 bit表示，它们所代表的含义如下所示</p><p>状态 ｜ 描述 ｜ 监听任务<br>Modified（修改 ｜ 这行数据有效，数据被修改了，和内存种的数据不一致，数据只存在于本Cache中 ｜ 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。<br>Exclusive（独享）｜ 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中 ｜ 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。<br>S共享（Shared ｜ 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中 ｜ 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。<br>I无效（Invalid） ｜ 这行数据无效 ｜ 无</p><p>理解： 某数据如果多个缓存读取，则处于S共享状态，如果只是单个则处于E独享状态。<br>    某个CPU2对CPU2缓存中某数据作出修改，则CPU2缓存该数据处于Modified状态，如果该数据是S共享状态，则其他缓存该行数据变成I无效状态。</p><h3 id="如何保证缓存一致性"><a href="#如何保证缓存一致性" class="headerlink" title="如何保证缓存一致性"></a>如何保证缓存一致性</h3><pre><code>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存中的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</code></pre><h2 id="三、JMM-java-内存模型"><a href="#三、JMM-java-内存模型" class="headerlink" title="三、JMM java 内存模型"></a>三、JMM java 内存模型</h2><p><img src="../../../images/jmm.png" style="zoom:70%"></p><p>线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地工作内存（Local Memory），工作内存中存储了线程以读/写共享变量的副本。<br>（本地工作内存是 JMM 的一个抽象概念，并不真实存在，线程中所谓工作内存其实还是存在于主内存中的。）</p><h3 id="Java内存模型与现代计算机内存模型区分"><a href="#Java内存模型与现代计算机内存模型区分" class="headerlink" title="Java内存模型与现代计算机内存模型区分"></a>Java内存模型与现代计算机内存模型区分</h3><p>Java内存模型和现代计算机内存模型都需要解决一致性问题，但是这个一致性问题在现代计算机内存模型中指代的是缓存一致性问题，MESI协议所设计的目的也是为了解决这个问题。而在Java内存模型中，这个一致性问题则是指代内存一致性问题。两者之间有一定区别。</p><p>缓存一致性</p><p>计算机数据需要经过内存、计算机缓存再到寄存器，计算机缓存一致性是指硬件层面的问题，指的是由于多核计算机中有多套缓存，各个缓存之间的数据不一致问题。缓存一致性协议（如MESI）就是用来解决多个缓存副本之间的数据一致性问题。</p><p>内存一致性</p><p>线程的数据则是放在内存中，共享副本也是，内存一致性保证的是多线程程序并发时的数据一致性问题。我们常见的volatile、synchronized关键字就是用来解决内存一致性问题。这里屏蔽了计算机硬件问题，<br>主要解决原子性、可见性和有序性问题。</p><p>至于内存一致性与缓存一致性问题之间的关系，就是实现内存一致性时需要利用到底层的缓存一致性（之后的volatile关键字会涉及）。</p><h2 id="四、并发编程的特性"><a href="#四、并发编程的特性" class="headerlink" title="四、并发编程的特性"></a>四、并发编程的特性</h2><p>首先我们要先了解并发编程的三大特性：原子性，可见性，有序性；</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指一个操作是不可间断的，即使是多个线程同时执行，该操作也不会被其他线程所干扰。<br>既操作的连续性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 具有原子性，赋值</span><br></pre></td></tr></table></figure></p><p>i++;<br>不具备原子性<br><code>因为i++juyou多部操作1、读取 i 的值到内存空间2、i + 13、刷新结果到内存</code></p><p>多个具备原子性操作放在一起并不具备原子性<br>y=x</p><p>先读取x的值到内存空间 x = 10； 这一步具备原子性<br>在给y赋值 y = 10; 也一步也具备原子性<br>但y=x不具备原子性</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>内存可见性（Memory visibility）是指当某个线程正在使用对象状态而同时另一个线程正在修改该状态，此时需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p><p>每个线程都有一个私有的本地工作内存并存储了线程间读/写的共享副本。</p><p>如果某个线程对这个副本中值进行修改，却没有对主内存进行同步，则会导致其他线程访问过时的数据。</p><p>使用volatile关键字就可以保证数据在不同线程副本的可见性，当有线程在副本中进行修改，就会强制修改主内存中值，同步到其他线程的副本中。<br>保证所有线程访问到值都为最新值</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性即程序按照我们代码所书写的那样，按其先后顺序执行。第一次接触这个特性可能会有所疑惑，所以在了解有序性之前我们需要来了解执行重排序以及相关概念。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了提高性能，编译器和处理器会对程序的指令做重排序操作，重排序分为3种类型：</p><ul><li>编译器优化的重排序：属于编译器重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；</li><li>指令级并行的重排序：属于处理器重排序，现代处理器采用指令级并行技术来将多条指令重叠执行。如果不存在数据依赖，处理器可以改变语句对应机器指令的执行顺序；</li><li>内存系统的重排序：处于处理器重排序由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul><p>指令重排序对于程序执行有利有弊，我们并不是要去完全禁止它。<br>对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序。<br>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型个的内存屏障指令，通过内存屏障指令来禁止特定的处理器重排序。</p><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><p>不管如何重排序，要保证程序运行的结果保持不变，编译器、runtime和处理器都必须遵循as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。</p><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 10; // 1</span><br><span class="line">int y = 20; // 2</span><br><span class="line">int a = x + y; // 3</span><br></pre></td></tr></table></figure></p><p>明显第3行依赖于第2行、第1行，所以第三行不会重排序，而第1行、第2行可能会被重排序。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>如果说 as-if-serial 是 JMM 提供用来解决单线程间的内存可见性问题的话，那么 happens-before 就是JMM向程序员提供的可跨越线程的内存可见性保证。<br>具体表现为：如果线程A的写操作a与线程B的读操作b之间具有 happens-before 关系，那么JMM将保证这个操作a对操作b可见。<br>此外，happens-before 还有传递关系，表现为：a happens-before b，b happens-before c，那么a happens-before c。</p><p>注意：两个操作之间存在happens-before关系，并不意味着一个操作必须要在后一个操作之前执行，只要求前一个操作执行的结果对后一个操作可见。<br>如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不违法（也就是说，JMM允许这种重排序）。</p><p><code>比对 happens-before 与 as-if-serial。</code></p><ul><li><p>1、as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</p></li><li><p>2、as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。</p></li><li><p>3、as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NDK c语言基础 (一)</title>
      <link href="/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%80.html"/>
      <url>/blog/2021/03/NDK-c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E4%B8%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="c语言基础"><a href="#c语言基础" class="headerlink" title="c语言基础"></a>c语言基础</h1><h2 id="创建C语言程序"><a href="#创建C语言程序" class="headerlink" title="创建C语言程序"></a>创建C语言程序</h2><p>xcode -&gt; create new xcode project -&gt; macos -&gt; command line tools<br>在macos系统即可创建一个c语言程序</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>int 整型，占4个字节<br>double 双精度小数 占8个字节<br>float 单精度小数 占4个字节<br>char 字符 占1个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d\n&quot;, i, sizeof(i));</span><br><span class="line">double db = 1.34;</span><br><span class="line">printf(&quot;db的值:%lf,所占字节%d\n&quot;, db, sizeof(db));</span><br><span class="line">float fl = 1.12;</span><br><span class="line">printf(&quot;fl的值:%f,所占字节%d\n&quot;, fl, sizeof(fl));</span><br><span class="line">char ch = &apos;A&apos;;</span><br><span class="line">printf(&quot;ch的值:%c,所占字节%d\n&quot;, ch, sizeof(ch));</span><br></pre></td></tr></table></figure><p>打印结果：<br>i的值:2,所占字节4<br>db的值:1.340000,所占字节8<br>fl的值:1.120000,所占字节4<br>ch的值:A,所占字节1</p><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>使用 &amp; 变量 即可获取到变量的内存地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">printf(&quot;i的值:%d,所占字节%d， 内存地址为%p\n&quot;, i, sizeof(i), &amp;i);</span><br></pre></td></tr></table></figure></p><p>i的值:2,所占字节4， 内存地址为0x7ffeefbff4c8</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>&amp;i 既是取出i的内存地址，也是i的指针。<br>或者换个说法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">int * i_p = &amp;i;</span><br></pre></td></tr></table></figure></p><p>取出指针的值使用 *</p><ul><li>i_p 既可取出值 i = 10；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 22;</span><br><span class="line">int * i_p = &amp;i;</span><br><span class="line">printf(&quot;i 的值：%d, i_p指针指向的值: %d \n&quot;, i, *i_p);</span><br><span class="line">printf(&quot;i的地址：%p, i_p的地址%p \n&quot;, i_p, &amp;i_p);</span><br></pre></td></tr></table></figure><p>打印：<br>    i 的值：22, i_p指针指向的值: 22<br>    i的地址：0x7ffeefbff4c8, i_p的地址0x7ffeefbff4c0<br>可以是 &amp; 对指针再次取内存地址</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5];</span><br><span class="line">printf(&quot;a的值：%p， a的内存地址：%p, a[0]的地址%p\n&quot;, a, &amp;a, &amp;a[0]);</span><br></pre></td></tr></table></figure><p>打印结果：a的值：0x7ffeefbff4b0， a的内存地址：0x7ffeefbff4b0, a[0]的地址0x7ffeefbff4b0</p><p>可以看到 打印 a、&amp;a、&amp;a[0]出现的结果都一样。</p><p><strong> 1、为何a与&amp;a一样 </strong><br>因为a是数组，除基本数据类型外的其他变量，变量本身就是指向内存地址的。所以 a == &amp;a<br><strong> 2、为何&amp;a与&amp;a[0]一样 </strong><br>因为a是数组，数组内存连续，所以数组下标为0的内存地址就是数组本身的内存地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int j = 0;</span><br><span class="line">for (j = 0; j &lt; 5; j ++) &#123;</span><br><span class="line">    printf(&quot;当前下标为%d,下标内存地址为%p\n&quot;, j, &amp;a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>    当前下标为0,下标内存地址为0x7ffeefbff4b0<br>    当前下标为1,下标内存地址为0x7ffeefbff4b4<br>    当前下标为2,下标内存地址为0x7ffeefbff4b8<br>    当前下标为3,下标内存地址为0x7ffeefbff4bc<br>    当前下标为4,下标内存地址为0x7ffeefbff4c0<br>可以看到内存地址以每次为4增加，因为这是int数组，int占4个字节，所以每次增加4</p><h2 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * p = &amp;a[j] + 1;</span><br><span class="line">printf(&quot;p的值为:%p\n&quot;, p);</span><br><span class="line">*(&amp;a[j] + 0) = j;</span><br></pre></td></tr></table></figure><p>&amp;a[j] 是取出下标j处的地址。<br>&amp;a[j] + 1 是指针在a[j]处偏移1位，既指向a[j + 1];<br>*(&amp;a[j] + 0) = j; + 0 其实相当于未偏移，就是对a[j]赋值</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>首先函数指针的申明格式：函数返回值类型 (* 指针变量名) (函数参数列表);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void add(int a, int b)&#123;</span><br><span class="line">    printf(&quot;sum = %d\n&quot;, a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(void (*method)(int, int), int a, int b) &#123;</span><br><span class="line">    method(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello \n&quot;);</span><br><span class="line">    test(add, 3, 4);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在test函数入参中，有一个函数指针，<br>在main函数中，调用test函数，并将add函数作为入参传递到test函数中。</p><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>指向指针的指针就是多级指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;HELLO WORLD!\n&quot;);</span><br><span class="line">    </span><br><span class="line">    int a = 0;</span><br><span class="line">    int * b = &amp;a;</span><br><span class="line">    int **c = &amp;b;</span><br><span class="line">    int *** d = &amp;c;</span><br><span class="line">    printf(&quot;d的地址%p \n&quot;, d);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用来表示多维数组</p><h2 id="静态分配内存"><a href="#静态分配内存" class="headerlink" title="静态分配内存"></a>静态分配内存</h2><p>在c语言中，内存区域分为栈区、堆区</p><p>函数被调用时，就会进栈，函数执行完毕则会出栈，而在函数中默认方式申明生成的数据都是系统静态分配内存的，<br>当函数执行完毕，出栈后，在该函数中静态分配的内存会被回收，系统会自己执行，无需手动处理。<br>静态分配内存都是在栈区</p><p>栈区总容量较小，大约是2M，各个系统、设备可能不一致，超出会抛出异常</p><h2 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h2><p>动态分配内存需要手动调用API才可，动态分配的内存不会自动回收，动态分配的内存都是在堆区。<br>堆区总容量较大，至少超过40M，各个系统、设备可能不一致， 超出也会抛出异常。</p><p>调用动态分配内存：malloc(int size)函数<br>调用回收动态内存：free(void *);</p><p>需要额外引入依赖文件：#include &lt;stdlib.h&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int num;</span><br><span class="line">    printf(&quot;请输入数字\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">    printf(&quot;num的值为：%d\n&quot;, num);</span><br><span class="line">    </span><br><span class="line">    int * arr = (int *)malloc(sizeof(int) * num);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0; i &lt; num; i ++) &#123;</span><br><span class="line">        arr[i] = i + 10000;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; num; ++i) &#123;</span><br><span class="line">        printf(&quot;%d对应值为%d\n&quot;, i, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    free(arr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重新分配"><a href="#重新分配" class="headerlink" title="重新分配"></a>重新分配</h3><p>就是将之前动态分配的内存重新分配，使用：realloc(void *<strong>ptr, size_t </strong>size);<br>第一个参数：原来的内存指针<br>第二个参数：新的内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int * new_arr = (int *)realloc(arr, sizeof(int) * (num + new_num));</span><br><span class="line">if(new_arr) &#123;</span><br><span class="line">    int j = num;</span><br><span class="line">    for (; j &lt; (num + new_num); j ++) &#123;</span><br><span class="line">        new_arr[j] = j + 100000;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt; (num + new_num); i ++) &#123;</span><br><span class="line">        printf(&quot;新数组第%d个值为%d\n&quot;, i, new_arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(new_arr);</span><br><span class="line">    new_arr = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 题目 </strong><br>截取字符串中指定字符<br>char c = “ABCDEFGHIJK”;</p><p>截取第3位到第6位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void substring(char * result, char *str, int start, int end) &#123;</span><br><span class="line">    for (int i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        printf(&quot;char:%c\n&quot;, *(str + i));</span><br><span class="line">        *(result++) = *(str + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char * str = &quot;ABCDEFGHIJK&quot;;</span><br><span class="line">    char * result;</span><br><span class="line">    substring(result, str, 3, 6);</span><br><span class="line">    printf(&quot;result:%c\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>https详解</title>
      <link href="/blog/2021/02/https%E8%AF%A6%E8%A7%A3.html"/>
      <url>/blog/2021/02/https%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Https详解"><a href="#Https详解" class="headerlink" title="Https详解"></a>Https详解</h1><h2 id="什么是Https"><a href="#什么是Https" class="headerlink" title="什么是Https"></a>什么是Https</h2><p>在说HTTPS之前先说说什么是HTTP，HTTP就是我们平时浏览网页时候使用的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。<br>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br>SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，<br>之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，<br>但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，<br>今后TLS将会继承SSL优良血统继续为我们进行加密服务。目前TLS的版本是1.2，定义在RFC 5246中，暂时还没有被广泛的使用 ()</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/blog/2021/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
      <url>/blog/2021/02/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式的定义与特点："><a href="#观察者模式的定义与特点：" class="headerlink" title="观察者模式的定义与特点："></a>观察者模式的定义与特点：</h1><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><p>观察者模式是一种对象行为型模式，其主要优点如下：</p><ol><li><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</p></li><li><p>目标与观察者之间建立了一套触发机制。</p></li></ol><p>它的主要缺点如下：</p><ol><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 屏幕渲染</title>
      <link href="/blog/2021/02/android-%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93.html"/>
      <url>/blog/2021/02/android-%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h1><p> CPU负责计算数据，把计算好数据交给GPU,<br> GPU会对图形数据进行渲染，渲染好后放到buffer里存起来<br> display负责将buffer里的数据显示在屏幕</p><p> 简单的说就是CPU/GPU准备好数据，存入buffer，<br> display每隔一段时间去buffer里取数据，然后显示出来。<br> display读取的频率是固定的，比如每个16ms读一次，但是CPU/GPU写数据是完全无规律的</p><p>底层每16ms会发送一次VSync，更新界面</p><p>CPU：执行应用层的measure、layout、draw等操作，绘制完成后将数据提交给GPU<br>GPU：进一步处理数据，并将数据缓存起来<br>屏幕：由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点</p><p>因为display取buffer数据渲染的频率固定，而GPU往buffer写数据却是不固定的，难免存在场景：GPU还在往buffer写数据，但此时display正要显示，此时就会显示异常。</p><p>为避免这种现象，引入一种新方案：双缓存机制</p><h2 id="双缓存机制"><a href="#双缓存机制" class="headerlink" title="双缓存机制"></a>双缓存机制</h2><p>android的渲染机制中引入双缓存机制。新增一个缓存 back buffer, back buffer 会定时与 frame buffer交换数据</p><p><img src="../../../images/buffer.png" style="zoom:70%"></p><p><strong> 当你的应用正在往Back Buffer中填充数据时，系统会将Back Buffer锁定。<br>如果到了GPU交换两个Buffer的时间点，你的应用还在往Back Buffer中填充数据，GPU会发现Back Buffer被锁定了，它会放弃这次交换。 </strong></p><p>这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的丢帧，<br>所以为了避免丢帧的发生，我们就要尽量减少布局层级，减少不必要的View的invalidate调用，减少大量对象的创建（GC也会占用CPU时间）等等</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong> Q1：Android 每隔 16.6 ms 刷新一次屏幕到底指的是什么意思？是指每隔 16.6ms 调用 onDraw() 绘制一次么？<br>Q2：如果界面一直保持没变的话，那么还会每隔 16.6ms 刷新一次屏幕么？</strong></p><p>答：我们常说的 Android 每隔 16.6 ms 刷新一次屏幕其实是指底层会以这个固定频率来切换每一帧的画面，而这个每一帧的画面数据就是我们 app 在接收到屏幕刷新信号之后去执行遍历绘制 View 树工作所计算出来的屏幕数据。而 app 并不是每隔 16.6ms 的屏幕刷新信号都可以接收到，只有当 app 向底层注册监听下一个屏幕刷新信号之后，才能接收到下一个屏幕刷新信号到来的通知。而只有当某个 View 发起了刷新请求时，app 才会去向底层注册监听下一个屏幕刷新信号。</p><p>也就是说，只有当界面有刷新的需要时，我们 app 才会在下一个屏幕刷新信号来时，遍历绘制 View 树来重新计算屏幕数据。如果界面没有刷新的需要，一直保持不变时，我们 app 就不会去接收每隔 16.6ms 的屏幕刷新信号事件了，但底层仍然会以这个固定频率来切换每一帧的画面，只是后面这些帧的画面都是相同的而已。</p><p><strong> Q3：界面的显示其实就是一个 Activity 的 View 树里所有的 View 都进行测量、布局、绘制操作之后的结果呈现，那么如果这部分工作都完成后，屏幕会马上就刷新么？ </strong></p><p>答：我们 app 只负责计算屏幕数据而已，接收到屏幕刷新信号就去计算，计算完毕就计算完毕了。至于屏幕的刷新，这些是由底层以固定的频率来切换屏幕每一帧的画面。所以即使屏幕数据都计算完毕，屏幕会不会马上刷新就取决于底层是否到了要切换下一帧画面的时机了。</p><p><strong> Q4：网上都说避免丢帧的方法之一是保证每次绘制界面的操作要在 16.6ms 内完成，但如果这个 16.6ms 是一个固定的频率的话，请求绘制的操作在代码里被调用的时机是不确定的啊，那么如果某次用户点击屏幕导致的界面刷新操作是在某一个 16.6ms 帧快结束的时候，那么即使这次绘制操作小于 16.6 ms，按道理不也会造成丢帧么？这又该如何理解？ </strong> </p><p>之所以提了这个问题，是因为之前是以为如果某个 View 发起了刷新请求，比如调用了 invalidte()，那么它的重绘工作就马上开始执行了，所以以前在看网上那些介绍屏幕刷新机制的博客时，经常看见下面这张图：</p><p>那个时候就是不大理解，为什么每一次 CPU 计算的工作都刚刚好是在每一个信号到来的那个瞬间开始的呢？毕竟代码里发起刷新屏幕的操作是动态的，不可能每次都刚刚好那么巧。</p><p>梳理完屏幕刷新机制后就清楚了，代码里调用了某个 View 发起的刷新请求，这个重绘工作并不会马上就开始，而是需要等到下一个屏幕刷新信号来的时候才开始，所以现在回过头来看这些图就清楚多了。</p><p><strong> Q5：大伙都清楚，主线程耗时的操作会导致丢帧，但是耗时的操作为什么会导致丢帧？它是如何导致丢帧发生的？ </strong></p><p>答：造成丢帧大体上有两类原因，一是遍历绘制 View 树计算屏幕数据的时间超过了 16.6ms；二是，主线程一直在处理其他耗时的消息，导致遍历绘制 View 树的工作迟迟不能开始，从而超过了 16.6 ms 底层切换下一帧画面的时机。</p><p>第一个原因就是我们写的布局有问题了，需要进行优化了。而第二个原因则是我们常说的避免在主线程中做耗时的任务。</p><p>针对第二个原因，系统已经引入了同步屏障消息的机制，尽可能的保证遍历绘制 View 树的工作能够及时进行，但仍没办法完全避免，所以我们还是得尽可能避免主线程耗时工作。</p><p>其实第二个原因，可以拿出来细讲的，比如有这种情况， message 不怎么耗时，但数量太多，这同样可能会造成丢帧。如果有使用一些图片框架的，它内部下载图片都是开线程去下载，但当下载完成后需要把图片加载到绑定的 view 上，这个工作就是发了一个 message 切到主线程来做，如果一个界面这种 view 特别多的话，队列里就会有非常多的 message，虽然每个都 message 并不怎么耗时，但经不起量多啊。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题答案</title>
      <link href="/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.html"/>
      <url>/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>当调用Handler的sendMessageDelayed时，会调用sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage</p><p>而在MessageQueue的enqueueMessage中。就会根据when大小插入到链表，when越小就在链表越前，其实相当于根据时间排序，越接近的时间越在链头</p><p>Looper中的消息既能同步也能异步，在Handler的构造时传入async = true；即为异步消息</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题合集</title>
      <link href="/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html"/>
      <url>/blog/2021/02/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="android"><a href="#android" class="headerlink" title="android"></a>android</h1><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1、Object的方法有哪些？</p><p>2、为什么要有HashCode方法，hash算法的原理，在Java中哪些地方用到，进而问到了HashMap的源码</p><p>3、Java有几种锁，synchronized与Lock有什么区别，Lock的实现原理，有没有碰到死锁的情况</p><p>4、Android源码中用到了哪些设计模式，举例说明</p><p>5、一个Android正常启动有多少个线程?(这里当时是比较懵逼的，第一反应是一个主线程，然后觉得应该不止这么简单，想到应用Activity启动的话，应该还有2个Binder线程，可能一个管理JVM的线程，面试官接着问还有哪些。。果断放弃不知道…)</p><p>6、Binder机制的实现思想</p><p>7、简单描述Https的实现思路</p><p>8、描述下快速排序的思想，时间复杂度？什么场景对应着最坏情况？</p><p>9、给定无序数组和一个值，找到两个数和为值的元素，不能使用额外空间复杂度（不要使用HashMap）</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面是视频面试，还是个周六下午。。。</p><p>1、TCP/IP四层模型，网络层和传输层有什么区别？网络层的主要工作是什么</p><p>2、socket.accept()函数对应着TCP三次握手中哪一次握手，哪个函数代表连接建立完毕，四次挥手的过程？</p><p>3、有做过哪些优化工作，卡顿优化，内存优化，启动优化，APK体积优化，每个做了哪些工作</p><p>4、JNI开发中有碰到什么问题？怎么定位native crash</p><p>5、递归非递归反转链表</p><p>6、打印回环数组</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>1、Looper消息机制，postDelay的Message怎么处理，Looper中的消息是同步还是异步？什么情况下会有异步消息</p><p>2、事件分发机制的源码</p><p>3、android的屏幕刷新机制，怎么优化UI卡顿情况</p><p>4、有没有使用过插件化框架，实现原理？</p><p>5、你在项目中碰到什么比较棘手的问题？怎么解决的？</p><p>6、找到一个无序数组中第一次出现最多次数的元素</p><h2 id="某手机海外部门（offer）"><a href="#某手机海外部门（offer）" class="headerlink" title="某手机海外部门（offer）"></a>某手机海外部门（offer）</h2><p>上来就是笔试题，其实之前没怎么做过面试题，难道现在都是这个套路了….？20分钟后做完就开始面试了</p><p>1、手写线程安全的观察者模式</p><p>2、找到一个字符串中出现最多的字母</p><p>3、描述Java面对对象六大原则针对项目中谈谈自己的看法</p><p>4、android阅读过哪些源码，举例说明</p><p>5、项目中的优化工作，内存，卡顿优化，leakcanary的原理实现</p><p>6、Tcp/Udp的区别，项目中的C/S端双向认证如何实现</p><p>7、项目中有碰到过哪些比较难解决的问题。</p><p>8、android 8.0，9.0有哪些新特性，有没有了解过</p><h2 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a>深信服</h2><p>1、HashMap的原理以及android中为什么建议用ArrayMap和SpareArray替代HashMap？</p><p>2、android如何保证进程不被杀死</p><p>3、Java怎么与C++进行交互，以及native crash如何定位的</p><p>4、C/S如何保证双向认证（项目中使用到的，可以理解为Https的原理），用到了哪些加密算法</p><p>5、LBS定位如何去除野点（指因为定位偏差过大的点），大数据量如何和后台交互？</p><p>6、设计模式用过哪些，动态代理的原理？</p><p>7、项目中有做过哪些优化，优化成效如何？</p><h2 id="TCL（offer）"><a href="#TCL（offer）" class="headerlink" title="TCL（offer）"></a>TCL（offer）</h2><p>是一个猎头推荐的一个职位，主要应该是做TV上的相关项目，有VR类型类似的项目等等，一面居然是一个妹子和一个男的一起进来的，还是第一次遇到，没问多少基础知识点，更多的是根据自身项目问一些东西</p><p>1、TCP/UDP的区别，有看过具体报文的信息吗</p><p>2、你觉得开发一个SDK，需要注意哪些地方，有没有做过SDK性能测试</p><p>3、有了解过音视频的编解码吗</p><p>4、你觉得你这个项目中比较难的地方在哪里，你是如何解决的</p><p>5、开放题：让你加载一个200M左右的GIF，如何实现及优化，不可降低画质</p><p>6、如何优化一个列表滑动的流畅性</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发</title>
      <link href="/blog/2021/02/%E5%B9%B6%E5%8F%91.html"/>
      <url>/blog/2021/02/%E5%B9%B6%E5%8F%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发指单位时间的访问量<br>并行指同一时刻的访问量</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><ul><li><p>ABA问题</p></li><li><p>开销问题</p></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ForkJoinTask</title>
      <link href="/blog/2021/01/ForkJoinTask.html"/>
      <url>/blog/2021/01/ForkJoinTask.html</url>
      
        <content type="html"><![CDATA[<h1 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h1><p>ForkJoin 是采用分而治之的思维，将一个大任务分解为若干个相互独立的子任务（异步），<br>达到提高运算效率。<br>我们做一个简单的运算 计算1-100000的累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class TestJoinTask &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; task = pool.submit(new MyForkJoinTask(1, 100000));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int result = task.get();</span><br><span class="line">            System.out.println(&quot;result = &quot; + result);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行完毕&quot; + &quot;   time = &quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传入的范型Integer是返回结果类型</span><br><span class="line">     */</span><br><span class="line">    static class MyForkJoinTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private int startValue;</span><br><span class="line"></span><br><span class="line">        private int endValue;</span><br><span class="line"></span><br><span class="line">        private int limitValue = 100;</span><br><span class="line"></span><br><span class="line">        public MyForkJoinTask(int startValue, int endValue) &#123;</span><br><span class="line">            if(startValue &gt; endValue) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;startValue &lt; endValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            this.startValue = startValue;</span><br><span class="line">            this.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Integer compute() &#123;</span><br><span class="line">            if(endValue - startValue &lt;= limitValue) &#123;</span><br><span class="line">                System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行计算&quot;);</span><br><span class="line">                // 两个值在限制值内 进行计算</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for(int i = startValue; i &lt;= endValue; i ++) &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">            MyForkJoinTask task1 = new MyForkJoinTask(startValue, (endValue + startValue) / 2);</span><br><span class="line">            task1.fork();</span><br><span class="line">            MyForkJoinTask task2 = new MyForkJoinTask((endValue + startValue) / 2 + 1, endValue);</span><br><span class="line">            task2.fork();</span><br><span class="line">            return task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们将一个从0 - 100000的累加任务分解为500个子任务：每200位数累加</p><p>在日志打印中，我们可以看到，有多个线程在执行任务，也就是说，分解的任务其实都是提交到线程池中执行，</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android ViewPager/ViewPager2解析</title>
      <link href="/blog/2021/01/android-ViewPager-ViewPager2%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2021/01/android-ViewPager-ViewPager2%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android RecyclerView解析</title>
      <link href="/blog/2021/01/android-RecyclerView%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2021/01/android-RecyclerView%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android ListView解析</title>
      <link href="/blog/2021/01/android-ListView%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2021/01/android-ListView%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="ListView解析"><a href="#ListView解析" class="headerlink" title="ListView解析"></a>ListView解析</h1><p>首先是简单使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ListViewActivity : AppCompatActivity() &#123;</span><br><span class="line">    <span class="function">override fun <span class="title">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_list_view)</span><br><span class="line">        <span class="keyword">var</span> list = arrayListOf(Person(<span class="string">"novia"</span>, <span class="number">24</span>), Person(<span class="string">"justin"</span>, <span class="number">29</span>), Person(<span class="string">"doudou"</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">var</span> adapter = MyListAdapter(list, <span class="keyword">this</span>)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyListAdapter(var list: ArrayList&lt;Person&gt;, var context: Context) : BaseAdapter() &#123;</span><br><span class="line">        <span class="function">override fun <span class="title">getCount</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">getItem</span><span class="params">(position: Int)</span>: Person </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(position);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">getItemId</span><span class="params">(position: Int)</span>: Long </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(position).hashCode().toLong()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">override fun <span class="title">getView</span><span class="params">(position: Int, convertView: View?, parent: ViewGroup?)</span>: View </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> view = LayoutInflater.from(context).inflate(R.layout.item_listview, parent, <span class="keyword">false</span>)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_name).setText(getItem(position).name)</span><br><span class="line">            view.findViewById&lt;TextView&gt;(R.id.item_age).setText(<span class="string">""</span> + getItem(position).age + <span class="string">"岁"</span>)</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">data class <span class="title">Person</span><span class="params">(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: Int)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>但是ListView的特点是会将所有条目都渲染出来，当子条目较多时，会存在性能问题，当加载图片时，甚至会导致OOM</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>okhttp(二) 拦截器</title>
      <link href="/blog/2021/01/okhttp-%E4%BA%8C-%E6%8B%A6%E6%88%AA%E5%99%A8.html"/>
      <url>/blog/2021/01/okhttp-%E4%BA%8C-%E6%8B%A6%E6%88%AA%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="okhttp-二-拦截器"><a href="#okhttp-二-拦截器" class="headerlink" title="okhttp(二) 拦截器"></a>okhttp(二) 拦截器</h1><p>在前文中讲到了okhttp中的分发器</p><p>接下来讲okhttp中的拦截器</p><p>在上文中讲到，同步执行excuet时，会通过 getResponseWithInterceptorChain 获取response，<br>在异步enqueue后，后面会调用AsyncCall中execute，而里面也是通过getResponseWithInterceptorChain 来获取response。</p><p>调用的都是RealCall中的getResponseWithInterceptorChain函数。</p><h2 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain"></a>getResponseWithInterceptorChain</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors()); //自定义拦截器加入到集合</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">            originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个数组，添加各个拦截器，<br>然后初始化一个 Interceptor.Chain 对象，注意第2、3、4个参数都是null，而第5个参数是index：0<br>然后调用proceed函数</p><h2 id="RealInterceptorChain-java"><a href="#RealInterceptorChain-java" class="headerlink" title="RealInterceptorChain.java"></a>RealInterceptorChain.java</h2><p>RealInterceptorChain 实现 Interceptor接口中的Chain接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line">  private final int index;</span><br><span class="line">  private final Request request;</span><br><span class="line">  private final Call call;</span><br><span class="line">  private final EventListener eventListener;</span><br><span class="line">  private final int connectTimeout;</span><br><span class="line">  private final int readTimeout;</span><br><span class="line">  private final int writeTimeout;</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,</span><br><span class="line">      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123;</span><br><span class="line">    this.interceptors = interceptors;</span><br><span class="line">    this.connection = connection;</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line">    this.httpCodec = httpCodec;</span><br><span class="line">    this.index = index;</span><br><span class="line">    this.request = request;</span><br><span class="line">    this.call = call;</span><br><span class="line">    this.eventListener = eventListener;</span><br><span class="line">    this.connectTimeout = connectTimeout;</span><br><span class="line">    this.readTimeout = readTimeout;</span><br><span class="line">    this.writeTimeout = writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int connectTimeoutMillis() &#123;</span><br><span class="line">    return connectTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, millis, readTimeout, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int readTimeoutMillis() &#123;</span><br><span class="line">    return readTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, millis, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int writeTimeoutMillis() &#123;</span><br><span class="line">    return writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, readTimeout, millis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Call call() &#123;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EventListener eventListener() &#123;</span><br><span class="line">    return eventListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Confirm that the intercepted response isn&apos;t null.</span><br><span class="line">    if (response == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (response.body() == null) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是RealInterceptorChain的全部代码，注意看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 最开始index = 0，注意这里构造RealInterceptorChain时，传入的为index+1</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的最前面的，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 RetryAndFollowUpInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>看注释现在可能又点绕，接着往下看，Interceptor是一个接口，没必要看，可以直接先看RetryAndFollowUpInterceptor</p><h2 id="RetryAndFollowUpInterceptor-重试以及重定向拦截器"><a href="#RetryAndFollowUpInterceptor-重试以及重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor 重试以及重定向拦截器"></a>RetryAndFollowUpInterceptor 重试以及重定向拦截器</h2><p>RetryAndFollowUpInterceptor 实现 Interceptor 接口</p><p>查看其中的intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Call call = realChain.call();</span><br><span class="line">        EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * todo  管理类，维护了 与服务器的连接、数据流与请求三者的关系。真正使用的拦截器为 Connect</span><br><span class="line">         */</span><br><span class="line">        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line"></span><br><span class="line">        int followUpCount = 0;</span><br><span class="line">        Response priorResponse = null;</span><br><span class="line"></span><br><span class="line">        // 在这里无限循环，只有抛出异常或者return response才会中断</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (canceled) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Response response;</span><br><span class="line">            boolean releaseConnection = true;</span><br><span class="line">            try &#123;</span><br><span class="line">                //todo 请求出现了异常，那么releaseConnection依旧为true。</span><br><span class="line">                response = realChain.proceed(request, streamAllocation, null, null);</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">            &#125; catch (RouteException e) &#123;</span><br><span class="line">                //todo 路由异常，连接未成功，请求还没发出去</span><br><span class="line">                //The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">                if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">                    throw e.getLastConnectException();</span><br><span class="line">                &#125;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                //todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span><br><span class="line">                // HTTP2才会抛出ConnectionShutdownException。所以对于HTTP1 requestSendStarted一定是true</span><br><span class="line">                //An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">                boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">                if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;</span><br><span class="line">                releaseConnection = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">                //todo 不是前两种的失败，那直接关闭清理所有资源</span><br><span class="line">                if (releaseConnection) &#123;</span><br><span class="line">                    streamAllocation.streamFailed(null);</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 如果进过重试/重定向才成功的，则在本次响应中记录上次响应的情况</span><br><span class="line">            //Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">            if (priorResponse != null) &#123;</span><br><span class="line">                response = response.newBuilder()</span><br><span class="line">                        .priorResponse(</span><br><span class="line">                                priorResponse.newBuilder()</span><br><span class="line">                                        .body(null)</span><br><span class="line">                                        .build()</span><br><span class="line">                        )</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 处理3和4xx的一些状态码，如301 302重定向</span><br><span class="line">            Request followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">            if (followUp == null) &#123;</span><br><span class="line">                if (!forWebSocket) &#123;</span><br><span class="line">                    streamAllocation.release();</span><br><span class="line">                &#125;</span><br><span class="line">                return response;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">            //todo 限制最大 followup 次数为20次</span><br><span class="line">            if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">            &#125;</span><br><span class="line">            //todo 判断是不是可以复用同一份连接</span><br><span class="line">            if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">                streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">                        createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">                this.streamAllocation = streamAllocation;</span><br><span class="line">            &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">                        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp;</span><br><span class="line">            priorResponse = response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到此处的主要逻辑，<br>将传入的chain对象转为RealInterceptorChain，<br>无限循环，然后在循环中调用chain.proceed函数，获取response，<br>循环的主要作用为catch异常，并针对RouteException 或者 IOException 做重试操作，其他异常则终止，</p><p>而chain.proceed又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 1； index + 1 = 2；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 1，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 BridgeInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"><a href="#BridgeInterceptor-负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应" class="headerlink" title="BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应"></a>BridgeInterceptor 负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应</h2><p>BridgeInterceptor 也是实现 Interceptor 接口</p><p>同样直接查看intercept函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        Request userRequest = chain.request();</span><br><span class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">        RequestBody body = userRequest.body();</span><br><span class="line">        if (body != null) &#123;</span><br><span class="line">            MediaType contentType = body.contentType();</span><br><span class="line">            if (contentType != null) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long contentLength = body.contentLength();</span><br><span class="line">            if (contentLength != -1) &#123;</span><br><span class="line">                requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">                requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">                requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also</span><br><span class="line">      // decompressing</span><br><span class="line">        // the transfer stream.</span><br><span class="line">        boolean transparentGzip = false;</span><br><span class="line">        if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">            transparentGzip = true;</span><br><span class="line">            requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">        if (!cookies.isEmpty()) &#123;</span><br><span class="line">            requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">            requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest);</span><br><span class="line"></span><br><span class="line">        if (transparentGzip</span><br><span class="line">                &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">                &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">            GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">            Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                    .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">                    .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            responseBuilder.headers(strippedHeaders);</span><br><span class="line">            String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">            responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return responseBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个函数的逻辑，<br>先对请求头信息进行再处理，然后执行chain.proceed获取networkResponse，<br>然后再对networkResponse进行再包装处理</p><p>同RetryAndFollowUpInterceptor一样，又会调用到chain.proceed函数，<br>又会回到上面RealInterceptorChain中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 2； index + 1 = 3；</span><br><span class="line"> RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 2，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CacheInterceptor 拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    // 然后调用拦截器的 intercept函数</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>再看CacheInterceptor代码</p><h2 id="CacheInterceptor-负责读取缓存以及更新缓存"><a href="#CacheInterceptor-负责读取缓存以及更新缓存" class="headerlink" title="CacheInterceptor 负责读取缓存以及更新缓存"></a>CacheInterceptor 负责读取缓存以及更新缓存</h2><p>CacheInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    //todo 通过url的md5数据 从文件缓存查找 （GET请求才有缓存）</span><br><span class="line">    Response cacheCandidate = cache != null</span><br><span class="line">            ? cache.get(chain.request())</span><br><span class="line">            : null;</span><br><span class="line"></span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    //todo 缓存策略:根据各种条件(请求头)组成 请求与缓存</span><br><span class="line">    CacheStrategy strategy =</span><br><span class="line">            new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    //</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有网络请求也没有缓存</span><br><span class="line">    //If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">        return new Response.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(504)</span><br><span class="line">                .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-1L)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 没有请求，肯定就要使用缓存</span><br><span class="line">    //If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">    if (networkRequest == null) &#123;</span><br><span class="line">        return cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 去发起请求</span><br><span class="line">    Response networkResponse = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">        if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">    if (cacheResponse != null) &#123;</span><br><span class="line">        //todo 服务器返回304无修改，那就使用缓存的响应修改了时间等数据后作为本次请求的响应</span><br><span class="line">        if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">            // Update the cache after combining headers but before stripping the</span><br><span class="line">            // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            return response;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //todo 走到这里说明缓存不可用 那就使用网络的响应</span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    //todo 进行缓存</span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">        if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response,</span><br><span class="line">                networkRequest)) &#123;</span><br><span class="line">            // Offer this request to the cache.</span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; catch (IOException ignored) &#123;</span><br><span class="line">                // The cache cannot be written.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程就是获取一个networlRequets，以及一个缓存的cacheResponse，<br>如果networlRequets与cacheResponse，则直接报504的网络异常<br>如果networlRequets为空，则只能返回cacheResponse，<br>如果networlRequets不为空，则执行网络请求，获取networkResponse，<br>如果cacheResponse 不为空  且 networkResponse响应码304，代表无更改，则可以返回，</p><p>再往下就是对networlRequets进行处理，并加入缓存。</p><p>注意：此处获取networkResponse也是调用chain.proceed，于是与上面一直，也会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 3； index + 1 = 4；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 3，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 ConnectInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><p>此时会调用到ConnectInterceptor中的intercept函数</p><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>ConnectInterceptor 也是实现 Interceptor 接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">    public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">        Request request = realChain.request();</span><br><span class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">        // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">        RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">        return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码就是ConnectInterceptor类中所有源码，<br>intercept函数中，重新获取了几个参数，和上面的几个Interceptor实现类不太一样，<br>最后调用的proceed函数是四个参数的，最后还是会走到 RealInterceptorChain中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当从RetryAndFollowUpInterceptor再过来时，index = 4； index + 1 = 5；</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">// 获取到传入的拦截器数组中的 index = 4，如果我们没有在OkHttpClient传入自定义拦截器，则会取出 CallServerInterceptor 拦截器</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// 然后调用拦截器的 intercept函数</span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>CallServerInterceptor 也是实现 Interceptor 接口，<br>CallServerInterceptor 中 intercept 函数就是直接与服务端通信的，<br>而在这里会获取到真正的response，并返回到上一层，也就是ConnectInterceptor的intercept，同理会依次向上返回。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>在上面看到的，一层一层拦截器向下调用，Interceptor类实现 调用 Interceptor类实现，<br>每一层的拦截器实现自己的功能，然后交付给下一层拦截器，<br>这种设计模式就是责任链模式。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react Hook</title>
      <link href="/blog/2021/01/react-Hook.html"/>
      <url>/blog/2021/01/react-Hook.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h1><p>Hook 是React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>在这里，useState 就是一个 Hook （等下我们会讲到这是什么意思）。通过在函数组件里调用它来给组件添加一些内部 state。<br>React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。<br>它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    View,</span><br><span class="line">    Text,</span><br><span class="line">    TouchableOpacity,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'------test'</span>);</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;View style=&#123;&#123; <span class="attr">marginTop</span>: <span class="number">100</span> &#125;&#125;&gt;</span><br><span class="line">            &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; setCount(count + <span class="number">1</span>) &#125;&#125;&gt;</span><br><span class="line">                &lt;Text&gt;点击获取次数：&#123;count&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>TouchableOpacity&gt;</span><br><span class="line">            &lt;Text onPress=&#123;() =&gt; &#123; setCount(count + <span class="number">1</span>) &#125;&#125; style=&#123;&#123; <span class="attr">marginTop</span>: <span class="number">100</span>, <span class="attr">fontSize</span>: <span class="number">30</span> &#125;&#125;&gt;test&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上图所示，是在react-native中简单使用Hook，使用其中的useState<br>const [count, setCount] = useState(0);<br>结构赋值，第一个count为获取的参数，<br>第二个参数setCount是修改第一个参数的函数，<br>useState(0)中，useState是在react中引入，后面的 0 是 count 的默认数据。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>useEffect 是一个副作用函数，默认在每次渲染之后都会执行。<br>而且保证每次运行effect时，DOM已经渲染完毕。</p><p>传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。<br>事实上这正是我们可以在 effect 中获取最新的 useState中 的值，而不用担心其过期的原因。<br>每次我们重新渲染，都会生成新的 effect，替换掉之前的。<br>某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。</p><ul><li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</li><li></li></ul><p>useEffect提供清除操作，当我们需要在React组件清除时，执行某一些操作，可以在useEffect中，返回清除函数。<br>当React清除时，会执行useEffect中的返回函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// when react remove </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</li></ul><p>React 何时清除 effect？ React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。<br>这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p><p>还可以对useEffect进行优化，useEffect接受两个参数，第二个参数为比较值，当这个值发生了变化，才会执行useEffect。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// when react remove </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><p>这样，只有当count发生变化，即我们调用过 setCount来改变count的值，下一次渲染完毕，才会执行useEffect</p><p>所以，当我们需要执行一些只需执行一次的逻辑时，可以传入一个定值，一般使用空数组[]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// when react remove </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;, []])</span><br></pre></td></tr></table></figure><p>如上所示，request只会在第一次渲染完毕执行一次，remove函数也时只会执行一次</p><h2 id="Hook规则"><a href="#Hook规则" class="headerlink" title="Hook规则"></a>Hook规则</h2><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则</p><ul><li><p>只在最顶层使用 Hook<br>  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。<br>  遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。</p></li><li><p>只在 React 函数中调用 Hook<br>  不要在普通的 JavaScript 函数中调用 Hook</p></li></ul><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><ul><li>自定义一个Hook函数</li><li>函数命名以use开始</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IOC</title>
      <link href="/blog/2021/01/IOC.html"/>
      <url>/blog/2021/01/IOC.html</url>
      
        <content type="html"><![CDATA[<p>Android 推荐应用架构建议将代码划分为多个类，以从分离关注点这一原则（其中，层次结构的每个类都具有一项已定义的责任）中受益。这就需要将更多更小的类连接在一起，以实现彼此之间的依赖关系。</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>android ioc 技术</p><p>源码地址：<a href="https://github.com/wangchongwei/ioc.git" target="_blank" rel="noopener">https://github.com/wangchongwei/ioc.git</a></p><h2 id="dagger"><a href="#dagger" class="headerlink" title="dagger"></a>dagger</h2><p>dagger使用：<br>主要使用了工厂模式、APT技术</p><p>利用注解处理器，变异时生成大量代码，完成自动注入</p><p>dagger 的使用主要作用：不必编写冗长乏味且容易出错的样板代码。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>Dagger 可以执行以下操作，使您无需再编写冗长乏味又容易出错的样板代码：</p></li><li><p>生成您在手动 DI 部分手动实现的 AppContainer 代码（应用图）。</p></li><li><p>为应用图中提供的类创建 factory。这就是在内部满足依赖关系的方式。</p></li><li><p>重复使用依赖项或创建类型的新实例，具体取决于您如何使用作用域配置该类型。</p></li><li><p>为特定流程创建容器，操作方法与上一部分中使用 Dagger 子组件为登录流程创建容器的方法相同。这样可以释放内存中不再需要的对象，从而提升应用性能。</p></li></ul><p>只要您声明类的依赖项并指定如何使用注释满足它们的依赖关系，Dagger 便会在构建时自动执行以上所有操作。Dagger 生成的代码与您手动编写的代码类似。在内部，Dagger 会创建一个对象图，然后它可以参考该图来找到提供类实例的方式。对于图中的每个类，Dagger 都会生成一个 factory 类型类，它会使用该类在内部获取该类型的实例。</p><p>在构建时，Dagger 会走查您的代码，并执行以下操作：</p><ul><li><p>构建并验证依赖关系图，确保：</p><ul><li>每个对象的依赖关系都可以得到满足，从而避免出现运行时异常。</li><li>不存在任何依赖循环，从而避免出现无限循环。</li></ul></li><li><p>生成在运行时用于创建实际对象及其依赖项的类。</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Glide框架解析</title>
      <link href="/blog/2020/12/Glide%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2020/12/Glide%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<p>Glide是android平台中的一个图片加载框架，<br>可以加载本地图片、网络图片、动态图</p><p>Glide的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(url).into(imageView);</span><br></pre></td></tr></table></figure><p>可以看出分成三部分：with、load、into<br>下面我们也分成三部分针对讲解</p><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with函数其实是对生命周期的管理<br>在Glide源码中，可以看到几个with函数,入参类型各不相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">    return getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Activity activity) &#123;</span><br><span class="line">    return getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull FragmentActivity activity) &#123;</span><br><span class="line">    return getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull Fragment fragment) &#123;</span><br><span class="line">    return getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@Deprecated</span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull android.app.Fragment fragment) &#123;</span><br><span class="line">    return getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public static RequestManager with(@NonNull View view) &#123;</span><br><span class="line">    return getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>with函数的入参有</p><ul><li>Context</li><li>Activity</li><li>FragmentActivity</li><li>androidX.Fragment</li><li>android.app.Fragment</li><li>View<br>可以看到，在with函数中都是调用getRetriever返回RequestManager对象，而调用getRetriever的入参有两个类型</li><li>1、context</li><li>2、activity</li></ul><p>getRetriever的两种入参类型又是根据上面with函数获取的，<br>针对fragment、fragmentActiivty、Actiivty获取对应的actiivty<br>针对context、view，则获取对应的context</p><p>再看一下getRetriever函数</p><h3 id="getRetriever"><a href="#getRetriever" class="headerlink" title="getRetriever"></a>getRetriever</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;</span><br><span class="line">    Preconditions.checkNotNull(</span><br><span class="line">        context,</span><br><span class="line">        &quot;You cannot start a load on a not yet attached View or a Fragment where getActivity() &quot;</span><br><span class="line">            + &quot;returns null (which usually occurs when getActivity() is called before the Fragment &quot;</span><br><span class="line">            + &quot;is attached or after the Fragment is destroyed).&quot;);</span><br><span class="line">    return Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br><span class="line">@NonNull</span><br><span class="line">public RequestManagerRetriever getRequestManagerRetriever() &#123;</span><br><span class="line">    return requestManagerRetriever;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，getRetriever返回就是一个 RequestManagerRetriever对象</p><p>也就是说 with函数最后调用到了RequestManagerRetriever对象的get函数</p><h3 id="RequestManagerRetriever"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a>RequestManagerRetriever</h3><p>看在Glide.java中的with函数就知道，RequestManagerRetriever中get函数也存在多个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public RequestManager get(@NonNull Context context) &#123;</span><br><span class="line">    if (context == null) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);</span><br><span class="line">    &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123;</span><br><span class="line">      if (context instanceof FragmentActivity) &#123;</span><br><span class="line">        return get((FragmentActivity) context);</span><br><span class="line">      &#125; else if (context instanceof Activity) &#123;</span><br><span class="line">        return get((Activity) context);</span><br><span class="line">      &#125; else if (context instanceof ContextWrapper) &#123;</span><br><span class="line">        return get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return getApplicationManager(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull FragmentActivity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">      return supportFragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull Fragment fragment) &#123;</span><br><span class="line">    Preconditions.checkNotNull(fragment.getActivity(),</span><br><span class="line">          &quot;You cannot start a load on a fragment before it is attached or after it is destroyed&quot;);</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(fragment.getActivity().getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      FragmentManager fm = fragment.getChildFragmentManager();</span><br><span class="line">      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">  @NonNull</span><br><span class="line">  public RequestManager get(@NonNull Activity activity) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">      return get(activity.getApplicationContext());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assertNotDestroyed(activity);</span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      return fragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@NonNull</span><br><span class="line">public RequestManager get(@NonNull View view) &#123;</span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        return get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Preconditions.checkNotNull(view);</span><br><span class="line">    Preconditions.checkNotNull(view.getContext(),</span><br><span class="line">        &quot;Unable to obtain a request manager for a view without a Context&quot;);</span><br><span class="line">    Activity activity = findActivity(view.getContext());</span><br><span class="line">    if (activity == null) &#123;</span><br><span class="line">        return get(view.getContext().getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (activity instanceof FragmentActivity) &#123;</span><br><span class="line">        Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);</span><br><span class="line">        return fragment != null ? get(fragment) : get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android.app.Fragment fragment = findFragment(view, activity);</span><br><span class="line">    if (fragment == null) &#123;</span><br><span class="line">        return get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    return get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个get函数，传入context对象，对context做分发，<br>其他的get函数，都是判断当前执行线程是否在main线程，如果不是 则都会走到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return getApplicationManager(context)</span><br></pre></td></tr></table></figure></p><p>在main线程时，会根据传入的参数获取对应的activity，activity为null，则也会执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return getApplicationManager(context)</span><br></pre></td></tr></table></figure></p><p>如果activity不为空，则执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">return supportFragmentGet(</span><br><span class="line">          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));</span><br></pre></td></tr></table></figure></p><p>其中android.app.Fragment会略有差异，因为该Fragment为android包下，已被遗弃，但执行逻辑其实大同小异</p><p>接下来我们再看supportFragmentGet函数</p><h3 id="supportFragmentGet"><a href="#supportFragmentGet" class="headerlink" title="supportFragmentGet()"></a>supportFragmentGet()</h3><p>跟随Fragment的生命周期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">private RequestManager supportFragmentGet(</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull FragmentManager fm,</span><br><span class="line">    @Nullable Fragment parentHint,</span><br><span class="line">    boolean isParentVisible) &#123;</span><br><span class="line"></span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    if (requestManager == null) &#123;</span><br><span class="line">        // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        requestManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getApplicationManager"><a href="#getApplicationManager" class="headerlink" title="getApplicationManager"></a>getApplicationManager</h3><p>跟随应用的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  private RequestManager getApplicationManager(@NonNull Context context) &#123;</span><br><span class="line">    // Either an application context or we&apos;re on a background thread.</span><br><span class="line">    if (applicationManager == null) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">        if (applicationManager == null) &#123;</span><br><span class="line">          // Normally pause/resume is taken care of by the fragment we add to the fragment or</span><br><span class="line">          // activity. However, in this case since the manager attached to the application will not</span><br><span class="line">          // receive lifecycle events, we must force the manager to start resumed using</span><br><span class="line">          // ApplicationLifecycle.</span><br><span class="line"></span><br><span class="line">          // TODO(b/27524013): Factor out this Glide.get() call.</span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  new ApplicationLifecycle(),</span><br><span class="line">                  new EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样的话，就可以看得出调用with函数时，会绑定到一个requestManaget对象，<br>但是分两种：</p><ul><li>1、子线程，或出入的Context为ApplicationContext —》 applicationManager   —— 跟随应用的生命周期</li><li>2、main线程 &amp; 非ApplicationContext  —-》 requestManager —- 跟随当前Fragment/Activity的生命周期</li></ul><p>接着看RequestManager</p><h2 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h2><p>查看RequestManager的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public RequestManager(</span><br><span class="line">      @NonNull Glide glide, @NonNull Lifecycle lifecycle,</span><br><span class="line">      @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) &#123;</span><br><span class="line">    this(glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory(), context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)</span><br><span class="line">RequestManager(</span><br><span class="line">    Glide glide,</span><br><span class="line">    Lifecycle lifecycle,</span><br><span class="line">    RequestManagerTreeNode treeNode,</span><br><span class="line">    RequestTracker requestTracker,</span><br><span class="line">    ConnectivityMonitorFactory factory,</span><br><span class="line">    Context context) &#123;</span><br><span class="line">    this.glide = glide;</span><br><span class="line">    this.lifecycle = lifecycle;</span><br><span class="line">    this.treeNode = treeNode;</span><br><span class="line">    this.requestTracker = requestTracker;</span><br><span class="line">    this.context = context;</span><br><span class="line"></span><br><span class="line">    connectivityMonitor =</span><br><span class="line">    factory.build(</span><br><span class="line">        context.getApplicationContext(),</span><br><span class="line">        new RequestManagerConnectivityListener(requestTracker));</span><br><span class="line">    </span><br><span class="line">    if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        mainHandler.post(addSelfToLifecycle);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lifecycle.addListener(this);</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addListener(connectivityMonitor);</span><br><span class="line"></span><br><span class="line">    defaultRequestListeners =</span><br><span class="line">    new CopyOnWriteArrayList&lt;&gt;(glide.getGlideContext().getDefaultRequestListeners());</span><br><span class="line">    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());</span><br><span class="line"></span><br><span class="line">    glide.registerRequestManager(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个构造函数，上面的构造函数会调用到下面的构造函数，只有上面的函数才对外暴露。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>okhttp解析(一) 执行与分发</title>
      <link href="/blog/2020/12/okhttp%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2020/12/okhttp%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="okhttp解析"><a href="#okhttp解析" class="headerlink" title="okhttp解析"></a>okhttp解析</h1><p>okhttp 是一个网络框架，是当下android使用最频繁的网络请求框架，由Square公司开源。</p><p>google在Android4.4后开始将源码中的HttpUrlConnection底层实现替换为okhttp，现在流程的Retrofit框架底层同样是使用okhttp的。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>支持http1、http2、Quic以及WebSocket</li><li>连接池复用底层TCP(Socket),减少请求延时</li><li>无缝支持GZIP减少通信数据流量</li><li>缓存相应数据减少重复请求次数</li><li>请求失败自动重试主机其他ip，自动重定向</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>okhttp具体使用可以查看：</p><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>在client执行request时，会调用newCall方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Call newCall(Request request) &#123;</span><br><span class="line">    return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会返回一个RealCall对象，而RealCall是Call接口的一个实现。</p><p>client调用newCall时，只是返回一个RealCall对象，请求还没有发送出去。<br>需要执行RealCall的execute()或者enqueue()</p><p>这两个方法由什么区别呢，现在看一下。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>这是一个同步方法，即会直接执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">        executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(this);</span><br><span class="line">    try &#123;</span><br><span class="line">        client.dispatcher().executed(this);</span><br><span class="line">        // 发起请求</span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">        if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        eventListener.callFailed(this, e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处会调用client.dispatcher().executed(this); 其实是将当前RealCall对象加入到Dispatch的同步执行队列<br>在最后执行完毕会调用 client.dispatcher().finished(this); 其实是将当前RealCall对象从Dispatch的同步执行队列移除，因为当前RealCall对象的任务已执行完毕</p><p>会获取到response，并直接return</p><h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h3><p>这是一个异步方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">        executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(this);</span><br><span class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的两个方法中，最后都会调用到dispatcher的对应函数，Dispatch是一个分发器</p><p>注意调用dispatch的enqueue函数时，会将responseCallback包装成一个AsyncCall对象，<br>AsyncCall为RealCall的一个内部类</p><h3 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">    private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        super(&quot;OkHttp %s&quot;, redactedUrl());</span><br><span class="line">        this.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host() &#123;</span><br><span class="line">        return originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request() &#123;</span><br><span class="line">        return originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealCall get() &#123;</span><br><span class="line">        return RealCall.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void execute() &#123;</span><br><span class="line">        boolean signalledCallback = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行请求 （拦截器）</span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line"></span><br><span class="line">            if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                signalledCallback = true;</span><br><span class="line">                responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                signalledCallback = true;</span><br><span class="line">                responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (signalledCallback) &#123;</span><br><span class="line">                // Do not signal the callback twice!</span><br><span class="line">                Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                eventListener.callFailed(RealCall.this, e);</span><br><span class="line">                responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            client.dispatcher().finished(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AysncCall实质上实现的是Runnable，execute执行的是获取response过程，<br>请求成功则执行responseCallback.onResponse，否则执行responseCallback.onFailure</p><p>最后执行client.dispatcher().finished(this); 注意最后传入的this指向是AsyncCall实例对象，</p><h2 id="Dispatch"><a href="#Dispatch" class="headerlink" title="Dispatch"></a>Dispatch</h2><p>Dispatch是okHttp内一个任务分发器，用于管理任务、管理线程池。<br>我们可以自定义Dispatch，如果没有传入自定义的，okHttp内部也有默认的，okhttp3.Dispatcher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">    private int maxRequests = 64;</span><br><span class="line">    private int maxRequestsPerHost = 5;</span><br><span class="line">    private @Nullable</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Executes calls. Created lazily.</span><br><span class="line">    * 内部的线程池</span><br><span class="line">    */</span><br><span class="line">    private @Nullable</span><br><span class="line">    ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Ready async calls in the order they&apos;ll be run.</span><br><span class="line">    * 等待执行的异步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet.</span><br><span class="line">    * 正在执行的异步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Running synchronous calls. Includes canceled calls that haven&apos;t finished yet.</span><br><span class="line">    * 正在执行的同步队列</span><br><span class="line">    */</span><br><span class="line">    private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在Dispatch内部有一个线程池，有三个队列，这三个队列下面会用的，会根据不同的任务添加到不同的队列</p><p>看一下Dispatch内部的executed以及enqueue函数</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">    if (executorService == null) &#123;</span><br><span class="line">        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">                new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;,</span><br><span class="line">                false));</span><br><span class="line">    &#125;</span><br><span class="line">    return executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于线程池的详细解析可以查看之前的文章：<br>线程池第4个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p><ul><li>ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小<br>  当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。<br>  所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。</li><li>LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定<br> 当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的integer.MAX_VALUE,此时添加任务会一直成功。<br> 最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。</li><li>SynchronousQueue: 无容量的队列<br>  使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。<br>  唯一制约就是配置的最大线程数，如果使用Integer.MAX_VALUE就实现了真正的无等待。</li></ul><p>而在okhttp中就采用的SynchronousQueue，但进程内存是有限制的，不能无限添加，所以在Okhttp内部又有maxRequests限制，保证不超过64个。</p><h3 id="executed"><a href="#executed" class="headerlink" title="executed"></a>executed</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在同步函数中，会将call 添加到同步执行队列</p><h3 id="enqueue-1"><a href="#enqueue-1" class="headerlink" title="enqueue"></a>enqueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">    //todo : 1、如果正在执行的请求小于64</span><br><span class="line">    // 2、相同host的请求不能超过5个</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        runningAsyncCalls.add(call);  //正在执行的请求</span><br><span class="line">        executorService().execute(call); //线程池跑任务</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异步执行时，会判断当前正在执行异步队列大大小是否小于64 &amp;&amp; 传入的call的Host在正在执行队列中数量是否小于，<br>如果都满足，则会被放入正在执行异步队列，并且调用线程池执行该任务<br>如果不满足，则会被放入待执行异步队列</p><p>注意：此处的call为一个AsyncCall实例，</p><p>上面在AsyncCall中讲过了，当AsyncCall执行完毕会调用finished（AsyncCall）函数来移除正在执行异步队列中的这个AsyncCall对象</p><h3 id="finished"><a href="#finished" class="headerlink" title="finished"></a>finished</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 异步执行队列移除AsyncCall对象</span><br><span class="line">void finished(AsyncCall call) &#123;</span><br><span class="line">    finished(runningAsyncCalls, call, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同步队列移除RealCall对象</span><br><span class="line">void finished(RealCall call) &#123;</span><br><span class="line">    finished(runningSyncCalls, call, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">    int runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">        if (promoteCalls) promoteCalls();</span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = this.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异步执行队列移除AsyncCall对象时，会执行promoteCalls()；<br>而且当this.idleCallback不为空，而且异步执行队列为空时,<br>会执行this.idleCallback.run();</p><h3 id="promoteCalls"><a href="#promoteCalls" class="headerlink" title="promoteCalls"></a>promoteCalls</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从异步等待队列中取任务执行</span><br><span class="line"> */</span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</span><br><span class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall call = i.next();</span><br><span class="line">        // 同一Host请求只能同时有5个</span><br><span class="line">        if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            i.remove();</span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>promoteCalls函数主题其实就是从等待异步队列中取任务放入到执行异步任务队列中，并执行。</p><ul><li>先判断异步执行队列大小是否大于64，是则不向下执行</li><li>再判断待执行异步队列是否没有数据，是则不向下执行</li><li>然后遍历readyAsyncCalls队列，判断当前AsyncCall的Host是否在异步执行队列中&lt;5,<br>小于5时，将该任务从待执行异步队列移除，并将该任务添加到执行异步队列，并放入线程池<br>判断异步执行队列大小是否大于64，是的话，终止遍历</li></ul><p>到这里，okHttp的任务执行基本就看完了。</p><p>当然还有任务的取消</p><h3 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void cancelAll() &#123;</span><br><span class="line">    for (AsyncCall call : readyAsyncCalls) &#123;</span><br><span class="line">        call.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (AsyncCall call : runningAsyncCalls) &#123;</span><br><span class="line">        call.get().cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (RealCall call : runningSyncCalls) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是遍历三个队列，调用Call对象的cancel方法。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android-自定义View-继承Drawable</title>
      <link href="/blog/2020/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFDrawable.html"/>
      <url>/blog/2020/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFDrawable.html</url>
      
        <content type="html"><![CDATA[<p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>最后实现效果如下图：</p><p><img src="../../../images/fish.gif" style="zoom:20%"></p><p>思路：<br>1、将正个鱼分成几个部分，鱼头圆，鱼身二阶贝塞尔曲线，鱼尾，鱼鳍<br>2、因为鱼会摆动，需要考虑一个角度问题，需要定义一个点，来确定整个的角度<br>3、以鱼的重心点作为基准点，即鱼身的中心点<br>4、根据鱼的中心点以及每条线的长度获取其他点的坐标，就可以绘制整个图形<br>5、鱼的摆动根据属性动画来绘制，但要考虑鱼头与鱼尾的摆动频率不一致，可以使用三角函数，0-360，鱼头设置一倍，鱼尾设置多倍，<br>此时就能鱼头与鱼尾摆动频率不一致了。<br>6、鱼尾分两段，摆动的方向不一致，一段带动另一段，一个采用正旋sin，一个采用余旋cos</p><p>进阶：鱼能游动<br>7、点击时的水波纹<br>8、鱼回头问题</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 嵌套滑动</title>
      <link href="/blog/2020/12/Android-%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8.html"/>
      <url>/blog/2020/12/Android-%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Android View的事件分发</title>
      <link href="/blog/2020/12/Android-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html"/>
      <url>/blog/2020/12/Android-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h1><p>首先用户的交互事件都是先交给Actiivty，然后再来向下分发事件</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>我们可以查看Activity的dispatchTouchEvent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要明确一点，ACTION_DOWN是一次完整的交互事件的起点，onUserInteraction是一个空函数可以不要管，</p><p>会将事件分发到window的superDispatchTouchEvent，而window指的是PhoneWindow，在andorid源码中，只有一个window的实现类，就是PhoneWindow，如果window的dispatch返回为true则不向下执行，否则会执行到Activity的onTouchEvent，</p><h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在PhoneWindow.java中 superDispatchTouchEvent函数又代理给DecorView的superDispatchTouchEvent</p><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p>DecorView继承自FrameLayout，FrameLayout继承自ViewGroup<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>DecorView中的superDispatchTouchEvent直接调用父类的dispatchTouchEvent，<br>而在FrameLayout中没有重写dispatchTouchEvent函数，所以会直接调用到ViewGroup的dispatchTouchEvent函数</p><h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>首先，所有的View都是继承自View的，ViewGroup也是继承自View</p><p>在ViewGroup的dispatchTouchEvent函数中，代码太长，先将部分代码收缩起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// mInputEventConsistencyVerifier是View中的一个变量，这里是对事件的一些校验</span></span><br><span class="line">       <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">       <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">       <span class="comment">// 此处是对一些无障碍功能的设置</span></span><br><span class="line">       <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">           ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 局部变量，每一个事件分发时，都会重置为false</span></span><br><span class="line">       <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重新校验</span></span><br><span class="line">       <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> handled;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其实主要逻辑还是在 if (onFilterTouchEventForSecurity(ev)) { 这个代码区域里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFilterTouchEventForSecurity</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection RedundantIfStatement</span></span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Window is obscured, drop this touch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对事件安全过滤的函数，正常情况都能通过。<br>接着看dispatchTouchEvent函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final int action = ev.getAction();</span><br><span class="line">final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">// Handle an initial down.</span><br><span class="line">if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    // Throw away all previous state when starting a new touch gesture.</span><br><span class="line">    // The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">    // due to an app switch, ANR, or some other state change.</span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是ACTION_DOWN就清除、重置touch事件，因为在上面讲过，ACTION_DOWN是一次交互的起点，在这里将上一次交互的状态都清除掉</p><h3 id="判断事件是否拦截"><a href="#判断事件是否拦截" class="headerlink" title="判断事件是否拦截"></a>判断事件是否拦截</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是判断是否开启拦截，注意这里的判断逻辑，intercepted是是否拦截标志位<br>disallowIntercept： 是否允许拦截，此处是一个外部拦截，在子视图中设置的，子视图设置是否让父容器拦截事件<br>如果disallowIntercept = false，再取执行内部拦截，onInterceptTouchEvent，查看ViewGroup是否拦截，为内部拦截<br>disallowIntercept为true时，代表子视图不允许父容器拦截，则intercepted = false;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for cancelation.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">``` </span><br><span class="line">当被拦截时，或者touchTarget不为空时，设置事件的TargetAccessibilityFocus为<span class="keyword">false</span></span><br><span class="line">然后判断事件是否是取消事件</span><br><span class="line">初始化一个变量alreadyDispatchedToNewTouchTarget=<span class="keyword">false</span>, 是否已经将事件绑定到一个targetView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    <span class="comment">// 当不是取消、没有被拦截时</span></span><br><span class="line">    <span class="comment">// If the event is targeting accessibility focus we give it to the</span></span><br><span class="line">    <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">    <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">    <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">    <span class="comment">// state since these events are very rare.</span></span><br><span class="line">    <span class="comment">// 获取到该事件绑定的view</span></span><br><span class="line">    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">            ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码段中，其实只是执行了一个操作，即遍历子View，获取该事件对应的处理的View。<br>注意这里有一个函数调用 dispatchTransformedTouchEvent</p><p>当遍历找到需要处理这个事件的View或者确定不存在该View时，即执行这个函数，对这个事件进行重新分发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为空，将事件交给View.dispatchTouchEvent处理</span></span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 子View处理</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">    <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the number of pointers is the same and we don't need to perform any fancy</span></span><br><span class="line">    <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">    <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">    <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述函数总结其实就是判断childView是否为空，如果为空的话，就再将事件转交给View.dispatchTouchEvent来处理，<br>super.dispatchTouchEvent，因为ViewGroup继承自View，此时会调用到View.dispatchTouchEvent<br>如果childView存在，则执行childView.dispatchTouchEvent，如果childView还是ViewGroup，还会再次执行这个过程，<br>遍历-找寻子View-分发，注意在分发过程中，如果已经返回为true了，则不会再向下分发。</p><p>接下来看View的dispatchTouchEvent</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the event should be handled by accessibility focus first.</span></span><br><span class="line">    <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">        <span class="comment">// We don't have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class="line">        <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class="line">        event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// Defensive cleanup for new gesture</span></span><br><span class="line">        <span class="comment">// 当手指触碰时，停止滚动</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="comment">// 当onTouch事件返回了true时，此处返回true</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当onTouch事件返回了true时，此处返回true</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">    <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span></span><br><span class="line">    <span class="comment">// of the gesture.</span></span><br><span class="line">    <span class="comment">// 当手指抬起、取消时，结束滚动</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下onTouchEvent事件，onTouchEvent是对事件的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">        setPressed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">    <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">    <span class="comment">// events, it just doesn't respond to them.</span></span><br><span class="line">    <span class="keyword">return</span> clickable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果View是不可点击的，如：ImageView,直接return false</p><p>View里因为设置了 onClickListener(), 这样就导致 View是 clickable (或者可以直接在xml里加上android:clickable=”true”)，即可点击，那么View.onTouchEvent就会永远返回 True, 代表View consume了该事件。<br>注意：只要View consume了该事件，那么该事件既不会往下传(不会传给子view)，也不会往上传(后面Activity/ViewGroup 的 onTouchEvent将不会再调用)。</p><p>View中不存在拦截，只有ViewGroup才有拦截</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络通信</title>
      <link href="/blog/2020/12/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html"/>
      <url>/blog/2020/12/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="计算机网络发展概史"><a href="#计算机网络发展概史" class="headerlink" title="计算机网络发展概史"></a>计算机网络发展概史</h2><p>计算机的发展大致分为以下四个阶段<br>1、诞生阶段，单个计算机为中心的远程联机系统<br>2、ARPANET，多个主机通过通信线路互联起来<br>3、开放性的标准化体系结构，OSI诞生<br>4、Internet互联网</p><p>OSI模型分为7层，tcp/ip模型分为4层，并存在对应关系<br>osi：物理层、链路层、 网络层、 传输层、  会话层、表示层、应用层<br>tcp/ip：链路层、     网络层、 传输层、         应用层</p><p>ip -&gt; 网络层  tcp｜udp -&gt; 传输层 http | https -&gt; 应用层</p><p>像我们日常中所说的4G、5G网络，是作用在链路层</p><p>TCP协议的基本特性：<br>面向链接、可靠性、RTT和RTO、数据排序、流量控制、全双工</p><h2 id="数据流通"><a href="#数据流通" class="headerlink" title="数据流通"></a>数据流通</h2><p>在构造一个请求包时，从上往下，依次添加各个层级信息<br>在解析一个请求包时，从下往上，依次解析出各个层级的信息</p><h2 id="Tcp协议"><a href="#Tcp协议" class="headerlink" title="Tcp协议"></a>Tcp协议</h2><ul><li>优势：<br>  面向连接<br>  可靠性<br>  RTT和RTO<br>  数据排序<br>  流量控制<br>  全双工</li></ul><p>tcp协议位于传输层</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP协议中，Client与Server端建立链接会经历三次握手过程</p><p>1、Client 向 Server端发送报文，<br>    含有SYN = 1； seq(序列号)=1234(系统决定，1234是举例)，Client端进入SYN_SENT状态<br>2、Server 接收到 Client端报文，向Client端发送一个确认报文，<br>    含有 SYN = 1；ACK = 1; ack=1235(1234 + 1);seq(序列号)=2637(系统决定，2637是举例)<br>    Server端进入SYN_SYN_RCND状态<br>3、Client端接收到Server的确认报文，向Server端也发送一次确认报文，<br>    含有 ACK = 1；ack=2638(2637+1);<br>    Client与Server端都进入ESTABLISHED状态，通信建立，开始会话</p><p>以上就是三次握手的过程</p><p>问题：<br>为何tcp协议需要三次握手，而不是两次</p><p>因为三次是保证连接可靠、效率最高的次数。<br>第一次：客户端询问服务端能否建立通信<br>第二次：服务端向客户端确认可以通信<br>第三次：客户端向服务端确认可以通信<br>然后建立通信。</p><h3 id="洪泛攻击"><a href="#洪泛攻击" class="headerlink" title="洪泛攻击"></a>洪泛攻击</h3><p>黑客伪造大量虚假ip向服务端发送第一次握手报文，使server端大量通信进入SYN_SYN_RCND状态，消耗server资源，<br>使服务端无法响应其他的请求，甚至宕机。</p><p>处理方案：防火墙、</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>当要断开连接时，客户端与服务端之间将进行四次挥手，来确保数据传输都完毕，确保连接断开。</p><p>1、client向server端发送FIN报文，<br>    含有FIN = 1，seq(序列号)=J(系统决定，J是举例)，Client进入FIN_WAITING<br>2、server收到客户端发送的报文，同时向Server发送一个FIN ACK 确认报文<br>    含有ACK = 1； ack = J + 1; Server进入CLOSE_WAITING<br>3、server向client发送一个FIN报文，<br>    含有FIN = 1； seq = K；Server进入 CLOSE状态<br>4、client收到上述两个server端报文，Client进入TIME_WAITING状态,同时client向server发送一个ACK报文，<br>    含有FIN = 1； ACK = 1； ack = K + 1;<br>    server接收到此报文后，进入CLOSED状态，<br>    而client，在经过2 * MSL的时间段后，client进入CLOSED状态。</p><p>注意：四次挥手设计到四次报文的传输，但在实际中，可能会存在报文合并的现象，就是报文发送的次数可能只有3次甚至两次。<br>MSL理论上是2分钟，可实际一般会被重写为30s，所以最后等待时间为1min-4min。</p><h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><p>因为tcp是全双工(即客户端和服务器端可以相互发送和接收请求)，所以需要双方都确认关闭连接。</p><h3 id="为什么需要TIME-WAIT状态？"><a href="#为什么需要TIME-WAIT状态？" class="headerlink" title="为什么需要TIME-WAIT状态？"></a>为什么需要TIME-WAIT状态？</h3><p>在第三次报文发送，client接收到时，client会进入TIME_WAIT状态，而且是需要经过经过2 * MSL，才会进入CLOSED状态，<br>为何这么设计呢，因为要考虑最后一个报文的接收，要考虑到Server未接收到时，需要重新发送，还要考虑，如果Client即时进入CLOSED，连接断开，端口可能会有一个新的程序使用，可能存在报文被发送到这个新启动的程序。</p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>使用wireshark可以抓包，查看到连接过程中的每一次数据包的传递</p><p>使用过滤器查看</p><p>tcp udp 可以指定协议</p><p>tcp.port==80 端口</p><p>ip.src==192.168.101.130 ip<br>连接符使用and</p><p>tcp and tcp.port==3306 and ip.src==192.168.101.130</p><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><p>Http（Hyper Text Transfer Protocol）超文本传输协议</p><p>服务器传输超文本到本地浏览器的传送协议</p><h3 id="一次完整的Http请求过程"><a href="#一次完整的Http请求过程" class="headerlink" title="一次完整的Http请求过程"></a>一次完整的Http请求过程</h3><p>1、首先进行DNS域名解析（本地缓存、操作系统缓存或DNS服务器）<br>2、三次握手建立TCP连接<br>3、客户端发起Http请求<br>4、服务端响应Http请求<br>5、客户端解析http代码，并请求http代码中的资源<br>6、客户端渲染展示内容<br>7、四次挥手关闭tcp连接</p><h3 id="questtion"><a href="#questtion" class="headerlink" title="questtion"></a>questtion</h3><p>1、DNS 劫持</p><p>2、http劫持</p><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p>UDP是非面向连接的，所以优点是快，缺点就是不安全、可能数据丢失</p><p>要构造一个UDP请求时，需要使用DatagramSocket</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity一键换肤</title>
      <link href="/blog/2020/12/Activity%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4.html"/>
      <url>/blog/2020/12/Activity%E4%B8%80%E9%94%AE%E6%8D%A2%E8%82%A4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Activity一键换肤"><a href="#Activity一键换肤" class="headerlink" title="Activity一键换肤"></a>Activity一键换肤</h1><h2 id="Activity绘制过程"><a href="#Activity绘制过程" class="headerlink" title="Activity绘制过程"></a>Activity绘制过程</h2><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><p>查看ActivityThread代码源码，<br>performLaunchActivity函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Activity activity = null;</span><br><span class="line">try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        if (r.state != null) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">    r.assistToken);</span><br></pre></td></tr></table></figure></p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>我们在看Activity类中的attach函数中的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">mWindow.setWindowControllerCallback(this);</span><br><span class="line">mWindow.setCallback(this);</span><br><span class="line">mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">mWindow.getLayoutInflater().setPrivateFactory(this);</span><br></pre></td></tr></table></figure></p><p>再看我们在Activity中设置布局的setContentView函数在Activity中的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看出我们传入的layout布局是设置到window对象上的，继续往里看<br>Window类中的setContentView是一个抽象方法，而getWindow()返回的是我们上面的PhoneWindow对象，我们看PhoneWindow中的setContentView方法</p><h3 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h3><p>PhoneWindow.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">    // before this happens.</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">    // before this happens.</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        final Scene newScene = new Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当初次运行时，肯定会走到installDecor 函数，在此函数中，又会新建一个DecorView绑定到window上。</p><p>也就是说我们的window上还有挂载一个DecorView</p><p>而在installDecor中，会对mContentParent判断，当为空时，会初始化<br>mContentParent = (DecorContentParent) mDecor.findViewById(R.id.decor_content_parent);</p><p>所以其实我们的view的层级其实是：<br>Window -&gt; DecorView -&gt; mContentParent + 我们自己的布局<br>而我们自己的View最后都是调用到LayoutInflater.inflate来加载的。</p><h3 id="LayoutInflater"><a href="#LayoutInflater" class="headerlink" title="LayoutInflater"></a>LayoutInflater</h3><p>最后所有View的加载会走到tryCreateView函数<br>LayoutInflater 中的 tryCreateView函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@UnsupportedAppUsage(trackingBug = 122360734)</span><br><span class="line">@Nullable</span><br><span class="line">public final View tryCreateView(@Nullable View parent, @NonNull String name,</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull AttributeSet attrs) &#123;</span><br><span class="line">    if (name.equals(TAG_1995)) &#123;</span><br><span class="line">        // Let&apos;s party like it&apos;s 1995!</span><br><span class="line">        return new BlinkLayout(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    if (mFactory2 != null) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; else if (mFactory != null) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        view = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (view == null &amp;&amp; mPrivateFactory != null) &#123;</span><br><span class="line">        view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看得出先判断mFactory2是否存在，存在的话，会通过mFactory2.onCreateView来创建View<br>再判断mFactory是否存在，存在的话，会通过mFactory.onCreateView来创建View<br>如果上面两个都不存在，则会调用mPrivateFactory来创建</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>根据上面的描述，我们知道所有的View创建都会走到LayoutInflater.tryCreateView函数，<br>而且这里有一个工厂类mFactory2，如果我们能创建一个mFactory2对象，并设置上去，那所有的view创建就都会走到我们自己的代码，<br>则我们可以获取到所有的view</p><p>换肤：是替换所有可以替换的颜色、背景，包括背景颜色、背景图片，因为我们替换了背景颜色，所以文本颜色也是需要替换。<br>我们明确了换肤的目标，原理呢就是：<br>换肤插件module中具有的资源名与宿主app的资源名都一致，只是资源值不同，<br>如在宿主app中res/value/colors.xml中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--宿主app--&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimary&quot;&gt;#3F51B5&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#303F9F&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorAccent&quot;&gt;#FF4081&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#ffce3d3a&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;!--插件module--&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimary&quot;&gt;#1F1F1F&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#373935&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;colorAccent&quot;&gt;#ffffff&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;tabSelectedTextColor&quot;&gt;#FFA500&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>如上所示，所有的资源名称都是一致，只是资源内容不同，图片也是如此。<br>当需要换肤时，通过获取宿主app的资源名称，到插件module中获取该名称的对应资源，然后替换</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>注解</title>
      <link href="/blog/2020/12/%E6%B3%A8%E8%A7%A3.html"/>
      <url>/blog/2020/12/%E6%B3%A8%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><p>注解作用可以在源码、编译、运行时起作用，</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>新建一个 @interface<br>与java类或接口大致相同的格式要求，但使用关键字 @interface</p><p>可以在自定义注解上使用其他注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public @interface CustomAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android消息机制</title>
      <link href="/blog/2020/11/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6.html"/>
      <url>/blog/2020/11/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<p>在 andorid 中，系统的行为、用户的输入等事件都会被包装为一个消息，<br>进行消息发送、处理</p><p>关于消息的处理，就离不开 Handler、Message、Loop<br>在平时使用时，Handler 多用于多线程之间通信。</p><ul><li>那么 Handler 如何实现多线程通信？</li><li>多线程之间为何不会互相干扰？</li><li>为什么不使用用 wait/notify？</li></ul><h2 id="Handler-多线程通信"><a href="#Handler-多线程通信" class="headerlink" title="Handler 多线程通信"></a>Handler 多线程通信</h2><p>先看一下普通使用案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyActiivty extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private Handler myHandler = new Handler() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">                if(msg.what=100) &#123;</span><br><span class="line">                    // TODO</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyThread extends Thread() &#123;</span><br><span class="line">        @Overtide</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            Message message = Message.obtain();</span><br><span class="line">            message.what = 100;</span><br><span class="line">            myHandler.sendMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的在子线程发送消息，回到主线程处理消息的过程，<br>通过在子线程构造一个 message 对象，在主线程中获取到该 message 对象，来处理消息。</p><p>所以其实 Handler 处理多线程通信是通过共享 Message 对象内存来实现的。<br>内存是不区分线程的，这种通信原理就是在子线程与主线程共享 message 内存</p><p>所以 那么 Handler 如何实现多线程通信？<br>通过 内存共享 实现。</p><p>在多线程时，Handler 又是如何保证消息如何在正确的线程发送的呢，或者说是如何保证执行的线程是正确的了。<br>这就要引入我们的 Loop、消息队列概念了。</p><p>handler 处理消息模型:</p><p><img src="../../../images/looper.png" style="zoom:60%"></p><p>handler 负责发送、处理消息<br>looper 负责一直轮询消息<br>messageQueue 消息队列，负责存放、取出消息</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>讲到 looper 负责一直轮询消息，但是好像在上面的代码中，都没有使用到 looper。</p><p>其实是在主线程中，系统已经默认为我们创建了 looper，<br>在 ActivityThread.java 的 main 方法中（ActivityThread 即为主线程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Install selective syscall interception</span></span><br><span class="line">        AndroidOs.install();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">        <span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line">        <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，调用了 Loop.prepareMainLooper()、Looper.loop()函数，<br>而且在 Looper.loop()后面就抛出异常，<br>也就是说主线程中 loop 一旦停止轮询，则会抛出异常闪退。正常情况时，loop 就是一直在轮询。</p><p>查看 Looper 的这两个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 prepareMainLooper 中可以看到，不允许调用两次，否则会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(<span class="string">"log.looper."</span></span><br><span class="line">                    + Process.myUid() + <span class="string">"."</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">".slow"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure the observer won't change while processing a transaction.</span></span><br><span class="line">        <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">        <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">        <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">        Object token = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Drained"</span>);</span><br><span class="line">                    slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">"delivery"</span>,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                    slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">"dispatch"</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop 函数中，首先获取通过 myLooper()函数获取 looper 对象，如果 looper 对象为空，则抛出异常，提示必须在当前线程先执行 Looper.prepare()<br>然后获取 looper 对象持有的 messageQueue，<br>然后就是 for(;;)无限循环，获取 messageQueue 下一条消息<br>获取到 message 后调用 msg.target.dispatchMessage(msg);<br>将这条消息发送出去。<br>最后执行 msg.recycleUnchecked()，相当于一个回收利用。</p><p>我们看一下 myLooper 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明 looper 是存放在 ThreadLocal 中的。<br>关于 ThreadLocal，在之前已经大致讲过了。<br>ThreadLocal 讲解（<a href="https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）" target="_blank" rel="noopener">https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html）</a><br>在每一个线程，都存在一个对应且唯一的值</p><p>我们可以看一下 prepare 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到与 prepareMainLooper 的不同，因为 prepareMainLooper 是在主线程调用，而主线程只有一个，<br>所以直接使用 sMainLooper 来保存主线程的 looper，而且主线程中 prepare(false)；标示不允许 looper 退出。</p><p>而在子线程时，就是将 looper 对象保存到 sThreadLocal 中，sThreadLocal.get()不为 null 时，会抛出异常。<br>也就是说子线程中 prepare 只允许调用一次，保证了每个线程中的 looper 对象唯一性</p><p>然后看到子线程和主线程的另一个差异 prepare(false) &amp;&amp; prepare(true)<br>因为 andorid，所有事件如：用户的操作、ui 的渲染等都是作为消息发送的，而这些都是在主线程操作的，所以在主线程中是不允许退出 loop 循环，否则抛出异常。</p><p>而在子线程中 prepare(true)，允许退出，其实在子线程中新建 handler、looper 时，当我们不需要再使用，需要终止 loop 循环。<br>此时需要调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void quitSafely() &#123;</span><br><span class="line">    mQueue.quit(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>在上面中已经讲过 Looper，looper 中持有一个 messageQueue<br>final MessageQueue queue = me.mQueue;<br>mQueue 在 Looper 的私有构造函数中被初始化</p><p>接下来我们看一下 MessageQueue<br>队列是一种数据结果，FIFO 先进先出<br>MessageQueue 是一个消息队列，默认也是先进先出，有序执行</p><p>之前说了，MessageQueue 主要用于存放、取出消息。<br>在 Looper 中主要用到了 messagequeue 的 next 函数，用于取出下一条消息</p><p>我们先看一下存放消息</p><h3 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程已经退出，mQuitting 为 true，则抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msg.when = when;</span><br><span class="line">Message p = mMessages;</span><br><span class="line"><span class="keyword">boolean</span> needWake;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">    <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">    msg.next = p;</span><br><span class="line">    mMessages = msg;</span><br><span class="line">    needWake = mBlocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当全局变量 mMessages 为空，或者当前传入的 when 为 0， 或者当前 when 小于全局变量 mMessages.when(即时间在前)<br>其实判断的是两种状态，1:messageQueue 队列为空 2:添加的消息执行时间在前<br>此时将该消息置于队首，<br>needWake = mBlocked；<br>如果 mBlocked 为 true，needWake 也为 true，就是如果之前阻塞则唤醒，反之无需唤醒</p><p>再看不满足上面情况下时,即消息队列中已添加过消息，而且要添加的消息.when 在上一次添加的消息之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">    <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">    <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">    needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">    Message prev;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">            needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">    prev.next = msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环，遍历链表，当找到节点为 null 即遍历完 || 传入的 when 小于遍历节点的 when（即传入消息的时间在遍历节点时间之前时）<br>终止循环，将 msg.next -&gt; p<br>原来<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; p -&gt; …<br>现在<br>prev.next -&gt; n.next -&gt; … -&gt; n.next -&gt; msg.next -&gt; p -&gt; …</p><p>也就是说，message 链表是按照 when 排序的，when 越小，在越靠近链头<br>为何要根据 when 排序了，其实是因为 message 执行时间是要按时间排序，要执行时间越小，代表时间越早，所以放在链头</p><p>以上是消息队列，入队函数，再看一下出队函数</p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一段代码可以先不看，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块设计到消息的同步屏障，放到下面再将，我们先只看出队时的逻辑<br>next 函数就是取出下一条消息。<br>开启 for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">    Binder.flushPendingCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 nextPollTimeoutMillis 不等于 0 时，会阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">Message msg = mMessages;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当当前 message 不为空时：<br>如果当前时间小于 msg.when，即没到执行时间，则阻塞线程到 msg.when 时间<br>将 msg.next 赋值给全局变量 mMessages，再将 msg.next 指向 null<br>然后返回 msg 这一个节点，如此不会返回一个链表</p><p>如果 msg 为空，说明队列为空，没有消息，此时赋值 nextPollTimeoutMillis = -1;下一次循环时，就会阻塞。</p><ul><li>MessageQueue 添加消息、取出消息是线程安全的吗？<br>是，是线程安全的。</li><li><p>如何保证线程安全的？<br>通过锁，存放消息以及取出消息时都有设置 synchronized (this)，<br>synchronized 后面修饰的是 this，同一个对象在多线程环境调用函数时，只会有一个线程获取到锁，进行操作。<br>synchronized 是内置锁，JVM 已经内置处理了锁的获取以及释放</p></li><li><p>为什么不使用用 wait/notify？<br>在上述代码可以看到使用了阻塞、锁，阻塞是直接调用 native 函数来阻塞，<br>其实在内部已经使用了 wait/notify。</p></li></ul><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>上面讲了消息机制中的 Handler、Looper、MessageQueue；<br>现在我们再讲一下消息的本体 Message</p><p>首先通过我们在上面的分析，可以知道 Message 在数据结构上看，是一个链表，而且是只有 next 指针，所以是个单链表。<br>Message 中没有什么复杂操作，都是一些赋值函数<br>有两个地方可以注意下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                    + <span class="string">"is still in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message 的回收函数不是将对象置为空，而是将 Message 中的变量都还原为默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message 还提供 obtain 函数，不会直接 new 一个 Message 对象，而是共享之前的对象，改变对象的内部属性。</p><p>所以我们在实际使用中都是使用 Message.obtain()来构建 message 对象，而不是一直使用 new ，这样可以避免频繁的生成、回收，避免内存抖动。</p><p>这种设计被成为 _ 享元设计模式 _</p><h2 id="Message-同步屏障"><a href="#Message-同步屏障" class="headerlink" title="Message 同步屏障"></a>Message 同步屏障</h2><p>上面讲的消息 message 链表是根据 when 时间排序，那如果有紧急的消息必须马上处理呢，这个时候不可能等其他先执行而必须是马上执行的事件时，怎么办？</p><p>这个时候就可以用到 同步屏障。</p><p>在 MessageQueue 中具备两个函数：postSyncBarrier、removeSyncBarrier<br>设置与移除同步屏障，注意这两个方法都是 hide，供系统内部使用，想自己调用只能通过反射，<br>而且在新版本反射使用会报错。</p><h3 id="postSyncBarrier"><a href="#postSyncBarrier" class="headerlink" title="postSyncBarrier"></a>postSyncBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">        <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">            <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构建一个 Message 对象 msg，遍历当前 message 链表，将该 msg 插入到一个 when 大于传入 when 的节点后，<br>并注意 msg 的 target 为 null；<br>然后就与上面讲到的 next 函数中代码呼应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会遍历获取到最后一条异步消息，msg， &amp;&amp; prevMsg.next = msg;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (msg != null) &#123;</span><br><span class="line">    if (now &lt; msg.when) &#123;</span><br><span class="line">        // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Got a message.</span><br><span class="line">        mBlocked = false;</span><br><span class="line">        if (prevMsg != null) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = null;</span><br><span class="line">        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处就是在链表中移除 msg 节点，并 return msg 对象。<br>也就是说，当设置消息屏障时，会在 Message 链表中从后向前取出异步消息，直至移除同步屏障</p><h3 id="removeSyncBarrier"><a href="#removeSyncBarrier" class="headerlink" title="removeSyncBarrier"></a>removeSyncBarrier</h3><p>移除同步屏障</p><h3 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h3><p>在上面讲到的 MessageQueue 中的 next 函数中，我们看到了一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">    mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.remove(idler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当队列 MessageQueue 为空或者 未到消息的执行时间时，此时会从 mPendingIdleHandlers 数组中，取出 IdleHandler 对象，进行执行 queueIdle 函数。<br>如果 queueIdle 返回结果为 true，代表可以重复执行，返回为 false，则执行一次会将该任务移除。</p><p>IdleHandler 相当于闲时任务，只有在空闲时才会执行。</p><h4 id="常见面试提问："><a href="#常见面试提问：" class="headerlink" title="常见面试提问："></a>常见面试提问：</h4><ul><li>如何在页面绘制完成后执行一个任务<br>此时就可以使用 IdleHandler，因为调用到 IdleHandler 中的 queueIdle 函数时，保证消息队列中的 Message 都被消费了。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>handler 消息机制大概流程：<br>生成 Looper 对象，生成 Handler 对象，Lopper.looper 循环<br>在 Handler 构造函数内，获取到上面生成的 looper 对象，通过 ThreadLocal 保存到对应的线程，与 MessageQueue 绑定<br>在需要发送消息的地方调用 handler.sendMessage(),在 sendMessage 时，将 message 与 handler 绑定，将 message.target 赋值为当前 handler<br>同时，sendMessage 时，调用 messageQueue.enqueueMessage 将 message 放入消息队列。<br>同时，Looper.loop()在循环一直取出消息 message，然后通过 message.target 获取到 handler 对象，最终回调到 handler.handlerMessage 函数。</p><p>这样消息从产生到处理流程就走完了。</p><h3 id="总结提问："><a href="#总结提问：" class="headerlink" title="总结提问："></a>总结提问：</h3><ul><li>Looper.loop()一直在循环，为什么不会导致应用卡死(ANR)?</li></ul><p>答：loop()循环与 ANR 是两个不相关的事情，loop 只是循环事件，ANR 是处理事件耗时，导致无法响应用户的下一次输入。<br>系统的 ANR 弹窗都是通过消息机制发送，并弹出提示窗的。</p><ul><li><p>fragment 生命周期</p></li><li><p>Handler 内存泄漏<br>原理：</p></li><li><p>postDelay 的 Message 怎么处理</p></li></ul><p>当调用 Handler 的 sendMessageDelayed 时，会调用 sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue.enqueueMessage</p><p>而在 MessageQueue 的 enqueueMessage 中。</p><h2 id="汇总总结"><a href="#汇总总结" class="headerlink" title="汇总总结"></a>汇总总结</h2><p>调用 Looper.prepare 会往 ThreadLocal 中存放一个新的 Looper 对象，<br>新建 Handler 时，会获取当前线程的 looper 对象，如果无则报错。<br>获取到 looper 就将当前的 handler 与当前线程的 looper 关联。<br>而 looper 中有一个 MessageQueue 消息队列实例 mQueue</p><p>handler 与 mQueue 就通过 Looper 关联起来</p><p>Handler —-&gt; Looper &lt;——- MessageQueue</p><p>handler 的 sendMessage 调用链如下：</p><p>handler.sendMessage —&gt; sendMessageDelayed —&gt; sendMessageAtTime —&gt; enqueueMessage —&gt; MessageQueue.enqueueMessage</p><p>在 enqueueMessage 中，传入的 when 是在 sendMessageAtTime 传入的系统当前时间，此时会遍历链表，以时间排序，将新来的 message 放入链表。</p><p>Message 的数据结构是链表</p><p>target 就是处理 message 的 handler、when 就是消息发送的时间，正常情况链表就是根据 when 排列的， 越小在链头，时间戳越大的越靠近当前时间。<br>也就是说 Message 中的链表，正常情况是按时间先后顺序来的 以前—-&gt;现在</p><p>消息机制就是一个完整的生产者、消费者模式，上述的部分就是生产者部分，往消息队列中放入消息。</p><p>再到消费者部分，Loop.loop()</p><p>无限循环，往 messageQueue 队列中取数据，<br>Looper.loop —&gt; MessageQueue.next<br>在 Message.next 函数中，会去判断是否存在消息屏障，如果有，则取出里面的同步消息，优先处理该消息</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APT注解处理器</title>
      <link href="/blog/2020/11/APT%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8.html"/>
      <url>/blog/2020/11/APT%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h1><p>APT(Annotation Processing Tool) 是一种处理注释的工具，它对源代码文件进行检测找出<br>其中的Annotation，根据注解自动生成代码，如果想要自定义的注解处理器能够正常运行，必须要通过<br>APT工具来进行处理。 也可以这样理解，只有通过声明APT工具后，程序在编译期间自定义注解解释器<br>才能执行。 通俗理解：根据规则，帮我们生成代码、生成类文件</p><p>在使用APT在项目编译时期动态生成我们需要的java文件时，有两种方式，<br>传统方式、javapoet</p><p>项目源码(<a href="https://github.com/wangchongwei/apt" target="_blank" rel="noopener">https://github.com/wangchongwei/apt</a>)</p><h2 id="javapoet"><a href="#javapoet" class="headerlink" title="javapoet"></a>javapoet</h2><p>以面向对象(OOP)思维，在编译时，动态生成java文件</p><p>优点：OOP思维，不需要导包<br>缺点：倒序写法，从函数-&gt;类-&gt;包</p><p>这种方式和写作思维不同，从调用链尾部到头部。<br>开源组件butterknife、ARouter都是使用javapoet方式</p><p>example:</p><p>新建一个工程，<br>并在工程新建一个javaLib，在此工程新建一个注解类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE) // 表明注解是添加在类上</span><br><span class="line">@Retention(RetentionPolicy.CLASS) // 表明在编译器执行</span><br><span class="line">public @interface ARouter &#123;</span><br><span class="line"></span><br><span class="line">    String path(); // 声明注解时 必须参数</span><br><span class="line"></span><br><span class="line">    String group() default &quot;&quot;; // 因为已经设置了default值，所以这个是选填参数</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时我们就完成了一个注解的定义<br>然后再新建一个javaLib，在此工程新建一个处理注解的类，而这个类就是我们在编译时生成java类的主要代码部分<br>在此工程build.gradle中添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // 背后的服务 能够监听 你是否在编译中.....</span><br><span class="line">    // AS3.4.1 + Gradle 5.1.1 + auto-service:1.0-rc4</span><br><span class="line">    compileOnly&apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br><span class="line">    annotationProcessor&apos;com.google.auto.service:auto-service:1.0-rc4&apos;</span><br><span class="line"></span><br><span class="line">    // 帮助我们通过类调用的形式来生成Java代码 [JavaPoet]</span><br><span class="line">    implementation &quot;com.squareup:javapoet:1.9.0&quot;</span><br><span class="line"></span><br><span class="line">    // 依赖注解module</span><br><span class="line">    implementation project(&quot;:annotations&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们开始写监听到注解时需要生成java类的部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class) // 启用服务 google 自动服务，一直监控</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;com.justin.annotationprocessor.ARouter&quot;&#125;) // 注解 包名.类名</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_8) // 环境的版本</span><br><span class="line"></span><br><span class="line">@SupportedOptions(&quot;student&quot;) // 接收在app/build.gradle中声明的参数</span><br><span class="line">public class ARouterProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Elements elements;</span><br><span class="line"></span><br><span class="line">    private Messager messager;</span><br><span class="line"></span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    private Types typeTool;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">        elements = processingEnvironment.getElementUtils();</span><br><span class="line">        messager = processingEnvironment.getMessager();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">        typeTool = processingEnvironment.getTypeUtils();</span><br><span class="line"></span><br><span class="line">        // 获取在app/build.gradle中申明的参数</span><br><span class="line">        String value = processingEnvironment.getOptions().get(&quot;student&quot;);</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, &quot;=========&gt;&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        // 此时会运行两次，一次执行，一次检查</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; compiler is running&quot;);</span><br><span class="line"></span><br><span class="line">        if(set.isEmpty()) &#123;</span><br><span class="line">            // 使用注解的类集合为空</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取被 ARouter注解的 &quot;类节点信息&quot;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class);</span><br><span class="line">        for(Element element : elements) &#123;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">                举例我们需要生成这样一个类</span><br><span class="line">             package com.example.helloworld;</span><br><span class="line"></span><br><span class="line">             public final class HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">             public static void main(String[] args) &#123;</span><br><span class="line">             System.out.println(&quot;Hello, JavaPoet!&quot;);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             public int add(int a, int b)&#123;</span><br><span class="line">                return 5;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line">            // javapoet生成java文件的方式时，OOP思维，先生成函数，再生成类，最后生成包</span><br><span class="line">            // 1 生成函数</span><br><span class="line">            MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;main&quot;) // 构造一个函数， 函数名</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC) // public 、static</span><br><span class="line">                    .returns(void.class) // 返回值类型</span><br><span class="line">                    .addParameter(String[].class, &quot;args&quot;) // 入参类型</span><br><span class="line">                    .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)// 函数执行语句 不需要添加分号</span><br><span class="line">                    .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, agent!&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 多个函数</span><br><span class="line">            MethodSpec methodSpec1 = MethodSpec.methodBuilder(&quot;add&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                    .returns(int.class)</span><br><span class="line">                    .addParameter(int.class, &quot;a&quot;)</span><br><span class="line">                    .addParameter(int.class, &quot;b&quot;) // 可以添加多个入参</span><br><span class="line">                    .addStatement(&quot;return 5&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 2 生成类</span><br><span class="line">            TypeSpec myClass = TypeSpec.classBuilder(&quot;HelloWorld&quot;) // 构造一个类，类名</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL) // 添加申明 public、final</span><br><span class="line">                    .addMethod(methodSpec) // 绑定函数</span><br><span class="line">                    .addMethod(methodSpec1) // 绑定多个函数</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            // 3、生成包</span><br><span class="line">            JavaFile myPackage = JavaFile.builder(&quot;com.example.helloworld&quot;, myClass).build();</span><br><span class="line">            try &#123;</span><br><span class="line">                myPackage.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;=====&gt; 创建HelloWorld类失败,异常原因：&quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后使用@ARouter注解<br>在MainActivity中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ARouter(path = &quot;main/MainActivity&quot;)</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击build项目，即会在app/build/ap_generated_sources/debug下生成对应的包以及java文件</p><p><img src="../../../images/javapoet.jpg" style="zoom:20%"></p><p>在上述方式中，我们只是写成了一个固定的java文件，还没有体现动态生成概念。<br>下面我们就要改造，动态接收参数来生成代码<br>只显示动态生成代码部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 获取被 ARouter注解的 &quot;类节点信息&quot;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(ARouter.class);</span><br><span class="line">        for(Element element : elements) &#123;</span><br><span class="line">            // 动态生成java代码</span><br><span class="line">            // 获取组件class的包路径</span><br><span class="line">            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();</span><br><span class="line">            // 获取注解的类名</span><br><span class="line">            String className = element.getSimpleName().toString();</span><br><span class="line">            // 获取到注解以及注解时的参数</span><br><span class="line">            ARouter aRouter = element.getAnnotation(ARouter.class);</span><br><span class="line">            String path = aRouter.path();</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             模板：</span><br><span class="line">             public class MainActivity3$$$$$$$$$ARouter &#123;</span><br><span class="line">             public static Class findTargetClass(String path) &#123;</span><br><span class="line">             return path.equals(&quot;/app/MainActivity3&quot;) ? MainActivity3.class : null;</span><br><span class="line">             &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             */</span><br><span class="line">            // 1、方法</span><br><span class="line">            MethodSpec method = MethodSpec.methodBuilder(&quot;findTargetClass&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                    .returns(Class.class)</span><br><span class="line">                    .addParameter(String.class, &quot;path&quot;)</span><br><span class="line">                    .addStatement(&quot;return path.equals($S) ? $T.class : null&quot;,</span><br><span class="line">                            path,</span><br><span class="line">                            ClassName.get((TypeElement) element) // 获取注解类的class对象</span><br><span class="line">                    )</span><br><span class="line">                    .build();</span><br><span class="line">            // 2 类</span><br><span class="line">            TypeSpec mineClass = TypeSpec.classBuilder(className + &quot;$$$$$$$$$ARouter&quot;)</span><br><span class="line">                    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                    .addMethod(method)</span><br><span class="line">                    .build();</span><br><span class="line">            // 3 包</span><br><span class="line">            JavaFile minePackage = JavaFile</span><br><span class="line">                    .builder(packageName, mineClass)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                minePackage.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + className + &quot;类失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此时我们就完成了自动获取注解类的包名、类名、注解时的path<br>自动生成的类也在相同包名下，获取注解时的path，可以做一些操作</p><h2 id="传统方式生成java文件"><a href="#传统方式生成java文件" class="headerlink" title="传统方式生成java文件"></a>传统方式生成java文件</h2><p>在编译时，一行一行，从头到尾，以写文本的方式写一个java文件</p><p>优点：套版格式，思路清晰<br>缺点：所有代码都需要写，包括导包，如果有任一一个字符错误、分号缺失，都会导致报错。</p><p>这种方式需要及其细心<br>开源组建EventBus就是采用的这种方式</p><p>example：<br>首先自定义注解类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(TYPE) </span><br><span class="line">@Retention(CLASS) // 编译期    XUtil==运行期</span><br><span class="line">public @interface Binding &#123;</span><br><span class="line"></span><br><span class="line">    String router();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后写注解处理类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7) // 环境的版本</span><br><span class="line">@AutoService(Processor.class) // 启用服务</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;com.derry.arouter_annotations.Binding&quot;&#125;) // 注解</span><br><span class="line">public class BindingProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Elements elementTool;</span><br><span class="line">    private Messager messager;</span><br><span class="line">    private Filer filer;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">        elementTool = processingEnvironment.getElementUtils();</span><br><span class="line">        messager = processingEnvironment.getMessager();</span><br><span class="line">        filer = processingEnvironment.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line"></span><br><span class="line">        if(set.isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Binding.class);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line"></span><br><span class="line">            // 获取包名</span><br><span class="line">            String packageName = elementTool.getPackageOf(element).getQualifiedName().toString();</span><br><span class="line">            String className = element.getSimpleName().toString();</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.NOTE, &quot;被@ARetuer注解的类有：&quot; + className);</span><br><span class="line">            String findClassName = className + &quot;$$$$$$$Binding&quot;;</span><br><span class="line"></span><br><span class="line">            Binding binding = element.getAnnotation(Binding.class);</span><br><span class="line">            try &#123;</span><br><span class="line">                JavaFileObject javaFileObject = filer.createSourceFile(packageName + &apos;.&apos; + findClassName, element.getEnclosingElement());</span><br><span class="line">                Writer writer = javaFileObject.openWriter();</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                sb.append(&quot;package &quot;).append(packageName).append(&quot;;\n\n&quot;);</span><br><span class="line">                sb.append(&quot;public class &quot;).append(findClassName).append(&quot;&#123;\n&quot;);</span><br><span class="line">                sb.append(&quot;public String findTargetRouter()&#123;\n&quot;);</span><br><span class="line">//                sb.append(&quot;return &quot; + binding.router().toString()).append(&quot;;\n&quot;);</span><br><span class="line">                sb.append(&quot;return \&quot;test\&quot;;\n&quot;);</span><br><span class="line">                sb.append(&quot;&#125;\n&quot;);</span><br><span class="line">                sb.append(&quot;&#125;\n&quot;);</span><br><span class="line">                writer.write(sb.toString());</span><br><span class="line">                writer.flush();</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, &quot;创建&quot; + findClassName + &quot;类失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> andorid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 性能优化</title>
      <link href="/blog/2020/11/android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"/>
      <url>/blog/2020/11/android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="android性能优化"><a href="#android性能优化" class="headerlink" title="android性能优化"></a>android性能优化</h1><p>性能优化分为几个方向：</p><ul><li>内存优化</li><li>电量优化</li><li>渲染优化</li><li>size大小优化</li><li>异常捕获</li></ul><h2 id="apk瘦身"><a href="#apk瘦身" class="headerlink" title="apk瘦身"></a>apk瘦身</h2><p>针对与apk大小优化而言，<br>首先需要知道apk中主要结构，了解其中是哪些部分比较大。<br>然后来针对性优化。</p><p>一般而言比较占用的是：资源文件、架构文件(.so)</p><h3 id="资源文件优化"><a href="#资源文件优化" class="headerlink" title="资源文件优化"></a>资源文件优化</h3><p>针对资源文件，首先我们去除没有被使用的资源，然后就是降低所用资源的大小。</p><p>在app/build.gradle文件中设置shrinkResources true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">        shrinkResources true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>则会在Gradle打包release apk时，自动忽略未使用的资源文件，包括：图片、xml</p><p>但要注意此时也会忽略隐式调用的资源文件，如通过反射调用，或者react-native中在js调用drawable木土图片，<br>在这两种场景时，都会被忽略。<br>针对这种场景，可以通过keep文件，保持这些资源文件不会被忽略。</p><p>在res目录下新建xml目录，在xml目录下新建文件keep.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources</span><br><span class="line">xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">tools:keep=&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;</span><br><span class="line">tools:discard=&quot;@layout/unused2&quot; /&gt;</span><br></pre></td></tr></table></figure><p>其中tools:keep是强制不忽略，tools:discard是强制忽略</p><p>上面讲述的是去除无用资源，还有我们可以去除无用的代码，如未被调用的函数，未被使用的变量</p><p>minifyEnabled设置为true，设置在与shrinkResources一起的地方。<br>注意shrinkResources需要与minifyEnabled一起使用才会生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">        shrinkResources true</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="针对架构-so优化"><a href="#针对架构-so优化" class="headerlink" title="针对架构.so优化"></a>针对架构.so优化</h3><p>在大型项目，特别时继承第三方过多时，此时.so文件才是占用最多的部分。</p><h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>开发时怕的不是出现问题，而是问题无法重现。<br>因为android碎片化严重 生产上的问题肯定要比开发时问题多。而且很多都是在开发端未必能重现的。<br>此时需要我们记录发生在用户手机上的异常。</p><p>针对异常可以分类，java异常、native异常。<br>native异常即是native函数c++代码异常</p><h3 id="java异常捕获"><a href="#java异常捕获" class="headerlink" title="java异常捕获"></a>java异常捕获</h3><p>在andorid app中捕获java异常，只需要实现Thread.UncaughtExceptionHandler</p><h3 id="native异常"><a href="#native异常" class="headerlink" title="native异常"></a>native异常</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程与进程</title>
      <link href="/blog/2020/10/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.html"/>
      <url>/blog/2020/10/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<p>进程是操作系统资源分配的基本单位，</p><p>线程是处理器（CPU）任务调度和执行的基本单位<br>线程依赖于进程，一个进程可能对应多个线程。</p><p>并发与并行</p><p>1、并发（Concurrent）：指两个或多个事件在同一时间间隔内发生，即交替做不同事的能力，多线程是并发的一种形式。例如垃圾回收时，用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p><p>2、并行（Parallel）：指两个或者多个事件在同一时刻发生，即同时做不同事的能力。例如垃圾回收时，多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>同时能处理的最大线程数取决于CPU内核数量，<br>有些机器还有逻辑处理器，</p><p>能同时处理任务的线程最大数量为CPU内核与逻辑处理器的较大值。</p><p>如内核：4，逻辑处理器：8<br>那么CPU正在能同时处理的任务数量为8。</p><p>但为何我们写代码的时候，设置多线程运行时为何感觉可以同时设置很多个线程数量呢。</p><p>这个就跟CPU的时间轮转片调度算法有关了</p><p>在早期的时间片轮转法中,系统将所有的就绪进程按先来先服务的原则,排成一个队列,每次调度时,把CPU分配给队首进程,并令其执行一个时间片.时间片的大小从几ms到几百ms.当执行的时间片用完时,由一个计时器发出时钟中断请求,调度程序便据此信号来停止该进程的执行,并将它送往就绪队列的末尾;然后,再把处理机分配给就绪队列中新的队首进程,同时也让它执行一个时间片.这样就可以保证就绪队列中的所有进程,在一给定的时间内,均能获得一时间片的处理机执行时间.</p><p>所以我们在多线程运行时，超过内核数量的线程任务在执行时，其实是在切换运行的。<br>只是因为CPU的时间片粒度很小，所以在切换时，很多都是无感的</p><h2 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h2><p>java中的程序天生的多线程的，启动线程有两种方式。</p><ul><li><p>继承Thread类</p></li><li><p>实现Runnable接口 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args) &#123;</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        MyThread2 thread2 = new MyThread2();</span><br><span class="line">        new Thread(thread2).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            System.out.println(&quot;extends Thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class MyThread2 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;implements Runnable&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><p>线程启动了，如何终止呢？<br>Thread类中提供了stop、suspend、resume等函数，但都是已经遗弃的，不提倡使用，<br>在API29时，调用内部就是直接抛出异常UnsupportedOperationException。</p><p>为何遗弃，因为suspend函数，只会终止当前线程，而不会释放线程已经占有的资源(比如锁)，而是占有资源进入睡眠状态，这样容易引发死锁问题。<br>而stop函数也是同理，在终止线程时，不会保证线程资源能够正常释放<br>所以这些函数都已经被遗弃，不提倡使用。</p><p>正确的中断线程的方法，是调用Thread中的interrupt().<br>interrupt()函数不会强制中断线程，而只是改变了一个线程的标志位，线程通过检测自身的标志位是否被置为true来判断是否需要继续执行。</p><p>可以调用isInterrupted()来获取该标志位，判断线程任务是否应该中断，<br>还可以调用Thread中的静态函数interrupted()来判断，但是interrupted()函数调用时，会将标志位重新置于false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300);</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            while (!currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(&quot;线程正常运行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">//            while (!Thread.interrupted()) &#123;</span><br><span class="line">//                System.out.println(&quot;线程正常运行&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">            System.out.println(&quot;线程已经被终止   flag ---&quot; + currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果可以看得出isInterrupted()与interrupted()的区别。</p><h2 id="run-start"><a href="#run-start" class="headerlink" title="run() start()"></a>run() start()</h2><p>我们new一个Thread实例对象，只是创建了一个对象，并没有与操作系统的真正的线程挂钩，<br>只有在执行start函数时，才是真正启动了一个线程，执行了其中的run方法</p><p>start()的调用，让线程进入就绪队列等待分配cpu，分到cpu后执行run()方法，start方法不能重复调用，否则抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">        /**</span><br><span class="line">         * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">         * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">         * to this method in the future may have to also be added to the VM.</span><br><span class="line">         *</span><br><span class="line">         * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">         */</span><br><span class="line">        // Android-changed: Replace unused threadStatus field with started field.</span><br><span class="line">        // The threadStatus field is unused on Android.</span><br><span class="line">        if (started)</span><br><span class="line">            throw new IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        /* Notify the group that this thread is about to be started</span><br><span class="line">         * so that it can be added to the group&apos;s list of threads</span><br><span class="line">         * and the group&apos;s unstarted count can be decremented. */</span><br><span class="line">        group.add(this);</span><br><span class="line"></span><br><span class="line">        // Android-changed: Use field instead of local variable.</span><br><span class="line">        // It is necessary to remember the state of this across calls to this method so that it</span><br><span class="line">        // can throw an IllegalThreadStateException if this method is called on an already</span><br><span class="line">        // started thread.</span><br><span class="line">        started = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Android-changed: Use Android specific nativeCreate() method to create/start thread.</span><br><span class="line">            // start0();</span><br><span class="line">            nativeCreate(this, stackSize, daemon);</span><br><span class="line">            started = true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">                /* do nothing. If start0 threw a Throwable then</span><br><span class="line">                  it will be passed up the call stack */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要逻辑在这个native函数中nativeCreate()</p><h2 id="Thread中其他函数"><a href="#Thread中其他函数" class="headerlink" title="Thread中其他函数"></a>Thread中其他函数</h2><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield(): 使当前让出cpu占有权，但让出时间不可限定，也不会让出锁资源，而且执行yield()的线程也不一定持有锁，我们可以在释放锁后执行这个方法。<br>执行yield()后让出cpu，但也可能在下一个时间片重新获取cpu。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join() ：将指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行，比如在线程B中执行了A线程的join函数，<br>直到A线程执行完毕，才会执行B线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread a = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                System.out.println(&quot;这是a线程在执行&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                    System.out.println(&quot;这是a线程在休眠结束&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread b = new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                try &#123;</span><br><span class="line">                    a.join();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;这是b线程在执行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>锁，内置锁，具体详情可以查看：<a href="https://wangchongwei.github.io/blog/2020/09/Synchronized%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">https://wangchongwei.github.io/blog/2020/09/Synchronized%E8%AF%A6%E8%A7%A3.html</a></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>只保证可见性，不能保证原子性</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>在每个线程存在副本，各个线程数据互不干扰。<br>具体详情可以查看： <a href="https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html" target="_blank" rel="noopener">https://wangchongwei.github.io/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html</a></p><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin 是采用分而治之的思维，将一个大任务分解为若干个相互独立的子任务（异步），<br>达到提高运算效率。<br>我们做一个简单的运算 计算1-100000的累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class TestJoinTask &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; task = pool.submit(new MyForkJoinTask(1, 100000));</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int result = task.get();</span><br><span class="line">            System.out.println(&quot;result = &quot; + result);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行完毕&quot; + &quot;   time = &quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 传入的范型Integer是返回结果类型</span><br><span class="line">     */</span><br><span class="line">    static class MyForkJoinTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private int startValue;</span><br><span class="line"></span><br><span class="line">        private int endValue;</span><br><span class="line"></span><br><span class="line">        private int limitValue = 100;</span><br><span class="line"></span><br><span class="line">        public MyForkJoinTask(int startValue, int endValue) &#123;</span><br><span class="line">            if(startValue &gt; endValue) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;startValue &lt; endValue&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            this.startValue = startValue;</span><br><span class="line">            this.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Integer compute() &#123;</span><br><span class="line">            if(endValue - startValue &lt;= limitValue) &#123;</span><br><span class="line">                System.out.println(&quot;线程名&quot; + Thread.currentThread().getName() + &quot;  执行计算&quot;);</span><br><span class="line">                // 两个值在限制值内 进行计算</span><br><span class="line">                int sum = 0;</span><br><span class="line">                for(int i = startValue; i &lt;= endValue; i ++) &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                return sum;</span><br><span class="line">            &#125;</span><br><span class="line">            MyForkJoinTask task1 = new MyForkJoinTask(startValue, (endValue + startValue) / 2);</span><br><span class="line">            task1.fork();</span><br><span class="line">            MyForkJoinTask task2 = new MyForkJoinTask((endValue + startValue) / 2 + 1, endValue);</span><br><span class="line">            task2.fork();</span><br><span class="line">            return task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们将一个从0 - 100000的累加任务分解为500个子任务：每200位数累加</p><p>在日志打印中，我们可以看到，有多个线程在执行任务，也就是说，分解的任务其实都是提交到线程池中执行，</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程依附与其他线程，当其他线程结束时，守护线程自动退出</p><p>在守护线程中的 finally 中代码可能不会执行</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 8.0屏幕朝向</title>
      <link href="/blog/2020/10/android-8-0%E5%B1%8F%E5%B9%95%E6%9C%9D%E5%90%91.html"/>
      <url>/blog/2020/10/android-8-0%E5%B1%8F%E5%B9%95%E6%9C%9D%E5%90%91.html</url>
      
        <content type="html"><![CDATA[<p>在android8.0设备发现一个问题，在androidManifest.xml中已配置了固定的屏幕方向，<br>但是在应用中，点击设备menu键，选择应用时，此时应用仍然可以旋转。</p><p>在MainActivity中通过代码设置 setRequestedOrientation时会报错：Only fullscreen activities can request orientation</p><p>原因是在android8.0 的Activity.java 的代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line">       if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line"></span><br><span class="line">       if (getApplicationInfo().targetSdkVersion &gt;= O &amp;&amp; mActivityInfo.isFixedOrientation()) &#123;</span><br><span class="line">           final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window);</span><br><span class="line">           final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta);</span><br><span class="line">           ta.recycle();</span><br><span class="line"></span><br><span class="line">           if (isTranslucentOrFloating) &#123;</span><br><span class="line">               throw new IllegalStateException(</span><br><span class="line">                       &quot;Only fullscreen opaque activities can request orientation&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果sdk版本&gt;O &amp;&amp; 当前Activity的屏幕方向固定时，<br>判断当前主题样式，如果包含透明样式，则会抛出该异常。</p><p>很明显这段代码存在问题，sdk&gt;=O其实就是android8.0(26)及以上。<br>而后面两个要求，固定屏幕方向在特定应用时很常见的，而透明样式页比较常见，<br>我们常用透明背景做一个简单的启动优化，避免其他样式导致的闪屏现象。</p><p>而这段代码也在8.0之后的版本修复，但是现在市面存在的手机在andorid8.0的时候基本都存在该问题。</p><p>修复方式时只能去除透明背景，但为了修复26存在的问题，修改应用整个的表现有些得不偿失。</p><p>所以我们可以针对特定版本修改资源。</p><p>首先去掉AndroidManifest.xml中的 android:screenOrientation 配置，</p><p>在res新增values-v26文件夹，这样在sdk26的手机就会在这个文件夹下寻找对应的资源，如果没有才会有主目录values中去找。</p><p>在values-v26中修改styles.xml，去掉此处的透明背景。</p><p>再在代码中调用setRequestedOrientation来固定屏幕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line"></span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时则不会再报错，<br>也不存在之前所说的点击menu键，回到应用会旋转问题。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android内存优化</title>
      <link href="/blog/2020/10/android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html"/>
      <url>/blog/2020/10/android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><p>内存检测工具 MAT<br>android studio profile</p><p>内存抖动<br>内存泄漏<br>内存溢出</p><p>JMM 内存结果模型</p><p>GC算法</p><p>对象的生命周期：内存分配初始化、不可见、不可达、收集、终结、内存重新分配</p><p>四种引用类型</p><p>incomegoing: 持有该对象的对象<br>outgoing: 该对象持有的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    C c = new C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    C c = new C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">    public C() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    C instance = new C()</span><br><span class="line">    public C getInstance() &#123;</span><br><span class="line">        return c</span><br><span class="line">    &#125;</span><br><span class="line">    D d = new D()</span><br><span class="line">    E e = new E()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 的incomegoing为 A、B、C<br>C 的outgoing为 C、D、E</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ContentProvider</title>
      <link href="/blog/2020/10/ContentProvider.html"/>
      <url>/blog/2020/10/ContentProvider.html</url>
      
        <content type="html"><![CDATA[<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>ContentProvider 内容提供者 是android四大组件之一，为不同应用、进程之间数据共享，制定统一的接口</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Service、IntentService</title>
      <link href="/blog/2020/10/Service%E3%80%81IntentService.html"/>
      <url>/blog/2020/10/Service%E3%80%81IntentService.html</url>
      
        <content type="html"><![CDATA[<h1 id="Service、IntentService"><a href="#Service、IntentService" class="headerlink" title="Service、IntentService"></a>Service、IntentService</h1><p>Service是android中四大组件之一，用于处理后台任务，不能处理耗时任务，否则会造成ANR<br>而IntentService继承自Service，但是可以处理耗时任务，因为在内部开启了一个子线程。</p><h2 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h2><p>Service的生命周期分为两种情形，一种是通过startService启动，另一种是通过bindService启动。<br>在这两种情况下时，Service的生命周期是有差异的。</p><h3 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h3><p>通过startService去启动一个Service，<br>如果该Service未被创建，则会走onCreate、onStartCommand、onStart生命周期<br>如果该Service已被创建，则不会执行onCreate，只会执行onStartCommand、onStart</p><p>onStart为正常运行时的生命周期</p><p>而且startService可以被多次调用<br>被重复调用后会执行下面的生命周期</p><p>通过startService启动的Service存活不依赖与Activity，即使启动该Service的Activity已经被销毁，但该Service仍然可以存活。<br>通过startService启动的Service需要调用stopService来销毁该Service,此时会执行onDestroy周期函数</p><h3 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h3><p>bindService时，Service是依赖Activity的，当当前Activity被销毁、或者调用unBindService时，Service都会被销毁。</p><p>所以每一次调用bindService时，Service都会被重新创建<br>所以通过bindService去启动一个Service，<br>会走onCreate、onBind生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ServiceConnect() : ServiceConnection &#123;</span><br><span class="line">    override fun onServiceDisconnected(name: ComponentName?) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onServiceDisconnected: &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onServiceConnected(name: ComponentName?, service: IBinder?) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onServiceConnected: &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">btn_bindService.setOnClickListener &#123;</span><br><span class="line">    var conn = ServiceConnect()</span><br><span class="line">    bindService(Intent(this, MyService::class.java), conn, Context.BIND_AUTO_CREATE)</span><br><span class="line">    hasBind = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行到onBind时，还会执行onServiceConnected</p><p>在Service中，不能执行耗时操作，超过5秒，则会造成程序不响应ANR<br>当我们需要执行耗时操作时，则必须开启子线程，或者使用IntentService</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService有与Service一样的生命周期，<br>只是在内部开启了一个子线程，暴露onHandleIntent来执行耗时任务，<br>当子线程执行完就会终止当前Service</p><p>IntentService中的部分源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">    public ServiceHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Servicehandler是IntentService的一个内部类，当收到消息时调用onHandleIntent,当执行完，则调用stopSelf，终止当前服务</p><p>在OnCreate中，新建了一个HandleThread，并运行。<br>创建一个Servicehandler，而该ServiceHandler的Looper对象为HandleThread线程中创建的，</p><p>当执行到onStart生命周期时，<br>handler发送一条消息，此时就会走到ServiceHandler中的handlerMessage中，也就会执行onHandleIntent中。<br>因为mServiceLooper = thread.getLooper();<br>所以onHandleIntent是运行在HandlerThread中的。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fragment的懒加载实现，参数传递与保存</title>
      <link href="/blog/2020/09/Fragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%9D%E5%AD%98.html"/>
      <url>/blog/2020/09/Fragment%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%9D%E5%AD%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h1><p>关于Fragment的懒加载，针对ViewPager、ViewPager2又有不同，</p><h2 id="ViewPager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager</h2><p>针对ViewPager，其实是使用Fragment中的setUserVisibleHint函数以及onHiddenChanged函数，通过getUserVisibleHint()获取当前的Fragment是否可见，<br>当不可见时，则不加载，当可见时再创建视图并缓存。<br>这样可以只加载一次，大致原理就是如此。</p><h2 id="ViewPager2"><a href="#ViewPager2" class="headerlink" title="ViewPager2"></a>ViewPager2</h2><p>ViewPager是androidX下的包，之前使用的setUserVisibleHint、getUserVisibleHint等都已被申明遗弃，<br>而在ViewPager2时通过FragmentTransaction.setMaxLifecycle() 来实现懒加载</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Application生命周期</title>
      <link href="/blog/2020/09/Application%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
      <url>/blog/2020/09/Application%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
      
        <content type="html"><![CDATA[<h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><p>Application是指代一个应用，默认我们在android应用中可以不指定，<br>也可以写一个类，继承Application，在AndroidManifest.xml中指定applictaion类即可</p><p>Application是应用的入口。</p><p>Application的生命周期就是应用的生命周期。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期函数有：<br>onCreate、onLowMemory、onTrimMemory、onTerminate、onConfigurationChanged</p><p>各个生命周期函数解释</p><ul><li>onCreate: 应用被创建时调用，是程序的主入口，在此处做一些初始化操作，不要做耗时操作。</li><li>onLowMemory： 当系统整体内存可用量较少时触发，可以在这里做一些不重要数据的清除、释放资源，避免因内存不足导致App被系统杀掉</li><li>onTrimMemory(int level)： andorid4.0后出的API，用来取代onLowMemory函数的，其中这个函数还有一个入参，来表示等级。</li><li>onTerminate： 当Application结束时，又系统决定调用时机。常规手动kill app进程没有触发此函数</li></ul><h3 id="onTrimMemory"><a href="#onTrimMemory" class="headerlink" title="onTrimMemory"></a>onTrimMemory</h3><p>此函数是在android4.0后引入的，能实现的组件不止Application，还有Activity、Fragment、Service、ContentProvider<br>作用是指导应用程序在不同情况下进行自身的内存释放，以避免被系统杀掉，提高用户体验</p><p>根据不同的情况，在函数中的提现就是 onTrimMemory函数中的 level这个入参。<br>level有7个值，</p><ul><li>TRIM_MEMORY_UI_HIDDEN：表示应用程序的所有UI界面被隐藏了，即用户点击了Home键或者Back键、Pause键导致应用的UI界面不可见．这时候应该释放一些资源．</li></ul><p>当app运行在前台时，会回调下面这三个值，内存余量从高到低排列</p><ul><li><p>TRIM_MEMORY_MODERATE：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。</p></li><li><p>TRIM_MEMORY_RUNNING_CRITICAL：表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。<br>这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</p></li><li><p>TRIM_MEMORY_RUNNING_LOW：表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，<br>同时这也会直接影响到我们应用程序的性能。</p></li></ul><p>当app缓存在后台时，会回调一下三个值，内存余量从高到低排列</p><ul><li><p>TRIM_MEMORY_BACKGROUND：表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，<br>是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，<br>这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。</p></li><li><p>TRIM_MEMORY_RUNNING_MODERATE： 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。</p></li><li><p>TRIM_MEMORY_COMPLETE：表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，<br>在这个时候应当尽可能地把一切可以释放的东西都进行释放。</p></li></ul><p>onTrimMemory 主要是在考虑内存优化时需要考虑。在此处做数据清除、资源释放</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> andorid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity的启动模式</title>
      <link href="/blog/2020/09/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html"/>
      <url>/blog/2020/09/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h1><p>首先，Activity有四大启动模式：<br>standard、singleTask、singleTop、singleInstance</p><p>如何设置Activity的启动模式：</p><ul><li><p>静态设置，在AndoridManifest.xml文件中，对Activity设置launchMode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.MainActivity3&quot;</span><br><span class="line">    android:launchMode=&quot;singleInstance&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态设置，在Activity跳转时，intent设置FLAG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var intent = Intent(this, MainActivity::class.java);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure></li></ul><p>并且注意，同时设置了两种方式时，动态设置会覆盖静态设置</p><h2 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard: 标准模式，默认模式，当设置为此模式时，每一次跳入都会重新创建实例<br>每次会新创建一个实例，并加入到启动它的Activity的任务栈中。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>singleTask: 栈内复用模式，当设置此模式时，如果栈内没有该Activity就会重新创建，如果已经有了，则会复用栈内已存在的该Activity，而不会重新创建，<br>并会移除之前在栈中处于该Activity上部的所有的Activity。<br>ex：A的启动模式是standard， B的启动模式为singleTask</p><p>A -&gt; B -&gt; A -&gt; B</p><p>A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以不会重新创建b的实例，而是复用之前B的实例，同时会调用onNewIntent生命周期函数，<br>而且会销毁之前处于栈顶的A。<br>最后栈内就是： A、B，B位于栈顶</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop：栈顶复用，与singleTask有部分相似，singleTask是只要在栈内就会复用，而singleTop是只有在栈顶才会复用，<br>如果栈内存在实例，但不处于栈顶，则表现与standard一致，<br>如果站内存在实例，且处于栈顶，则表现与singleTask一致，</p><p>ex：A的启动模式是standard、B的启动模式是singleTop<br>A -&gt; B -&gt; A -&gt; B<br>A -&gt; B 时，因为当前Activity栈中只有A，所以会新创建一个B的实例，<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，但之前的B不在栈顶，所以会重新创建一个B的实例</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>singleInstance: 独立运行在一个单独的task中，而且只会存在一个实例<br>在Activity跳转时，注意查看，普通的Activity跳转和Activity Task跳转，两者的动画效果是不同的。</p><p>ex: A的启动模式是standard、B的启动模式是singleInstance<br>A -&gt; B -&gt; A -&gt; B<br>A -&gt; B 时，因为当前Activity栈task A中只有A，会重新创建一个task B并新建一个B的实例放入task B<br>A -&gt; B -&gt; A, 因为A的启动模式为standard，所以会新创建一个A的实例，并放入到task A中<br>A -&gt; B -&gt; A -&gt; B, 因为此时栈中已经有B的实例，所以会将task B置顶，<br>最后的栈情况为： A -&gt; A -&gt; B，如下图所示：</p><p><img src="../images/activity_stack.png" alt="activity-stack"></p><p>我们可以通过指令：adb shell dumpsys activity<br>查看Activity栈中的Activity task情况</p><p>通过关键字：ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)<br>即可搜索到上述截图情况</p><h2 id="任务栈"><a href="#任务栈" class="headerlink" title="任务栈"></a>任务栈</h2><p>我们一直提到一个栈，那什么是Activity所需要的任务栈呢，<br>这需要提到一个参数：TaskAffinity</p><h3 id="TaskAffinity"><a href="#TaskAffinity" class="headerlink" title="TaskAffinity"></a>TaskAffinity</h3><p>可以翻译为任务相关性，这个参数主要标识了一个Activity所需要的任务栈的名字<br>默认情况下，所有activity所需的任务栈的名字为应用包名。<br>当然我们也可以为每个Activity单独指定TaskAffinity，但是我们指定的必须不能与包名相同，<br>否则就相当于没指定。</p><p>相同TaskAffinity的Activity会运行在同一个任务栈中</p><p>TaskAffinity一般与启动模式或allowTaskReparenting搭配使用</p><h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a>allowTaskReparenting</h3><p>当应用A调用应用B的Activity C，<br>如果Activity C的allowTaskReparenting设置为true，<br>当应用B被启动后，则会将应用A的任务栈转移到应用B的任务栈。</p><p>当应用A调用应用B的Activity C，然后按Home键回到桌面，此时会显示被应用A启动的Activity C，<br>而不是应用B的默认Activity</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android生命周期</title>
      <link href="/blog/2020/09/android%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
      <url>/blog/2020/09/android%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
      
        <content type="html"><![CDATA[<p>准备对andorid基础性的东西都进行整理，梳理一下。</p><h1 id="android的生命周期"><a href="#android的生命周期" class="headerlink" title="android的生命周期"></a>android的生命周期</h1><p>单个Actiivty正常的生命周期</p><p>onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory</p><p>这就是一个Activity从被创建到被销毁过程。</p><p>其中正常运行状态为onResume</p><p>当Activity从前台被置于后台，<br>onResume -&gt; onPause -&gt; onStop</p><p>当从后台重新置于前台<br>onStop -&gt; onPause -&gt; onResatrt -&gt; onStart-&gt; onResume</p><p>其中可以发现，只要Activity置于前台都会执行onStart函数，所以我们可以考虑在这里做一下需要在前台就处理的逻辑</p><p>各个生命周期函数：<br>onCreate: Activity被创建，此时Activity处于不可见、不可交互<br>onStart: 此时Activity 部分可见不可交互<br>onRestart: Activity从后台重新回到前台，部分可见不可交互<br>onResume: 完全可见可交互，为Activity正常运行状态<br>onPause: Activity处于暂停，从前台被置于后台 部分可见部分不可见，不可交互<br>onStop: 完全置于后台，完全不可见，<br>onDestroy: Activity被销毁</p><p>上面就是一个正常的Activity的生命周期，</p><h2 id="屏幕旋转"><a href="#屏幕旋转" class="headerlink" title="屏幕旋转"></a>屏幕旋转</h2><p>在Activity生命周期中，还设计一些其他：<br>Activity旋转：<br>onCreate -&gt; onStart -&gt; onResume<br>此时被旋转<br>-&gt; onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p><p>可以发现当Activity被旋转时，整个Activity是被销毁然后重新创建的。其中新增调用了两个生命周期函数<br>onSaveInstanceState: 当Activity被系统异常销毁时被调用，用于存储数据，用于系统恢复Activity时恢复数据<br>onRestoreInstanceState: 当Actiivty被系统异常销毁并重新创建时，取出在onSaveInstanceState时存储的数据</p><p>注意，在onCreate函数中，其实也是有参数的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, &quot;onCreate: &quot;)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此处的savedInstanceState也是在onSaveInstanceState时存储的数据，但此处可能为nll，<br>因为在正常的Activity时，此处就是null，只有在Activity被异常销毁然后被系统重新创建时，此处才有值。<br>如果要在此处使用，切记要判空。</p><h2 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h2><p>onNewIntent与Activity的启动模式有关</p><p>当Activity未设置启动模式时，则不会触发该生命周期函数</p><p>当Activity已经处于应用的Activity栈中</p><ul><li>如果Actiivty的LaunchMode为Standard时，即默认模式，此时不会触发该生命周期函数。</li><li>如果Activity的LaunchMode为SignleTop，如果ActivityA已经处于栈顶，再通过StartActivityForResult调用该Activity，<br>此时会触发的生命周期函数为： onPause -&gt; onNewIntent -&gt; onResume</li><li>如果Activity的LainchMode为SingleInstance,SingleTask时，并且ActivityA已经处于Activity栈中，再次通过StartActivityForResult调用该Activity，此时生命周期函数：onNewIntent—&gt;onRestart—&gt;onStart—&gt;onResume</li></ul><p>onNewIntent只会在Activity设置了启动模式，并且Activity被复用时才会调起。</p><p>注意：只对startActivityForResult调起的Activity起作用，statActivity本质调用的也是startActivityForResult，Activity正常的切换前后台时不会触发的。</p><h2 id="Activity交互"><a href="#Activity交互" class="headerlink" title="Activity交互"></a>Activity交互</h2><p>A -&gt; B:<br>A正常运行处于 onResume，打开B</p><p>A onPause -&gt; B onCreate -&gt; B onStart -&gt; B onResume -&gt; A onStop<br>点击跳入B页面， 首先A进入暂停，B开始创建，到onResume完全可见可交互，于是A被完全遮挡，变成完全不可见、处于后台，进入onStop</p><p>A -&gt; B -&gt;goBack-&gt; A</p><p>在B页再执行返回</p><p>B onPause -&gt; A onRestart -&gt; A onStart -&gt; A onResume -&gt; B Stop -&gt; B onDestory<br>和A进入B类似，B返回A时，B进入暂停，A变得重新可见到A完全可见，进入onResume，然后B进入停止，并销毁</p><p>B启动模式设置为 SingleTop，B -&gt; B<br>B onPause -&gt; B onNewIntent -&gt; B onResume<br>因为 B已经处于栈顶，启动模式为 SingleTop 则不会重新创建B的实例</p><p>将A的启动模式设置为SingleTask</p><p>可以通过在andorid studio的终端 Terminal中输入：adb shell dumpsys activity<br>查看当前应用的Activity task栈</p><h3 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h3><p>关于onSaveInstanceState，在api28以前，实在onPause之后、onStop之前调用，<br>在api28以后，是在onStop之后调用</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react-native 适配androidX</title>
      <link href="/blog/2020/09/react-native-%E9%80%82%E9%85%8DandroidX.html"/>
      <url>/blog/2020/09/react-native-%E9%80%82%E9%85%8DandroidX.html</url>
      
        <content type="html"><![CDATA[<h1 id="androidX"><a href="#androidX" class="headerlink" title="androidX"></a>androidX</h1><p>在API28后，android新增androidX依赖，用于解决以前的android.support.v*依赖混乱问题。<br>对v1-v9做了合并处理。</p><p>然后很多使用的第三方依赖中在新版本都适配了androidX，当你需要使用这些插件的较新版本时，只能去适配androidX。</p><p>最近使用react-native-firebase时，被提示必须使用17.0.0+的 Firebase Crashlytics SDK，否则2020年11月15日之后，将不再向firebase发送错误日志。</p><h2 id="适配androidX"><a href="#适配androidX" class="headerlink" title="适配androidX"></a>适配androidX</h2><p>点击andorid studio上方导航栏Refactor/Migrate to AndroidX<br>这时会提示你，gradle tool version 最低3.2.0<br>项目中每一个project的build.gradle都需要修改</p><p>classpath(“com.android.tools.build:gradle:3.2.0”)<br>其中3.2.0为最低版本。</p><p>注意，选择的版本可能maven仓库找不到。<br>如在第三方插件中，设置的maven仓库可能不存在该版本。<br>如： 我使用的是版本：3.4.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:3.4.0&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时会报错，404，找不到。<br>因为在jcenter远程仓库中不存在该版本。</p><p>3.4.0的版本只有google的maven仓库中有，所以需要修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>查看maven插件地址：<a href="https://maven.aliyun.com/mvn/search" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/search</a></p><p>同时需要修改每个project的targetSdkVersion</p><p>将所有project的版本都修改为3.4.0之后，在点即Migrate to AndroidX,<br>此时会提示你需要修改的地方，</p><ul><li>java文件，去除一些v*的引入</li><li>build.gradle 去除一些v*的依赖</li><li>manifest.xml 需要修改一些属性，如配置的FileProvider,修改name属性<br><code>android:name=&quot;androidx.core.content.FileProvider&quot;</code></li></ul><p>修改完后，无报错时直接运行。</p><p>会有一些java文件报错，就是引入的之前的v*的包，需要手动修改，哪里报错改哪里。</p><p>最后运行，运行成功</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kotlin 在android老项目中引入kotlin</title>
      <link href="/blog/2020/09/kotlin-%E5%9C%A8android%E8%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5kotlin.html"/>
      <url>/blog/2020/09/kotlin-%E5%9C%A8android%E8%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5kotlin.html</url>
      
        <content type="html"><![CDATA[<h1 id="在android项目中引入kotlin"><a href="#在android项目中引入kotlin" class="headerlink" title="在android项目中引入kotlin"></a>在android项目中引入kotlin</h1><p>存在两种方法</p><ul><li>1、手动修改，在module/build.gradle中添加kotlin依赖</li><li>2、使用android studio 等ide工具<h2 id="在项目引入kotlin依赖"><a href="#在项目引入kotlin依赖" class="headerlink" title="在项目引入kotlin依赖"></a>在项目引入kotlin依赖</h2></li></ul><p>修改项目的build.gradle 文件中</p><p>buildscript {</p><pre><code>ext {    kotlin_version = &quot;1.3.10&quot;}dependencies {    classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;}</code></pre><p>}</p><p>在app/build.gradle中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &quot;com.android.application&quot;</span><br><span class="line">// 在顶行下添加</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br></pre></td></tr></table></figure><p>然后同步一下即可</p><h2 id="在andorid-studio操作"><a href="#在andorid-studio操作" class="headerlink" title="在andorid studio操作"></a>在andorid studio操作</h2><p>点击 android studio工具栏的 Tools -&gt; Kotlin -&gt; Configure Kotlin in Project</p><p>此时会弹窗选择需要添加kotlin依赖的module，可以选择某个modulw，也可以选择项目</p><h2 id="android-studio-一键转换java代码为kotlin代码"><a href="#android-studio-一键转换java代码为kotlin代码" class="headerlink" title="android studio 一键转换java代码为kotlin代码"></a>android studio 一键转换java代码为kotlin代码</h2><p>选中某个java文件，需要该文件聚焦，<br>然后点击android studio工具栏  Code -&gt; Convert Java File to Kotlin File</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>google play 提交要求</title>
      <link href="/blog/2020/09/google-play-%E6%8F%90%E4%BA%A4%E8%A6%81%E6%B1%82.html"/>
      <url>/blog/2020/09/google-play-%E6%8F%90%E4%BA%A4%E8%A6%81%E6%B1%82.html</url>
      
        <content type="html"><![CDATA[<h1 id="google-play-提交要求"><a href="#google-play-提交要求" class="headerlink" title="google play 提交要求"></a>google play 提交要求</h1><p>本文于2020/09/09日起记录在google play提交版本时，google play提出的提交要求</p><h2 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h2><p>在2020/08/05日，提交版本发现多了一个警告<br><img src="../images/google_targetSdkVersion.png" alt="google_targetSdkVersion.png"></p><p>新提交的应用在8月开始，必须设定targetSdkVersion为29或以上，<br>已存在的应用提交新版本时，必须设定targetSdkVersion为29或以上</p><h3 id="关于targetSdkVersion的原理"><a href="#关于targetSdkVersion的原理" class="headerlink" title="关于targetSdkVersion的原理"></a>关于targetSdkVersion的原理</h3><p>targetSdkVersion相当于在编写代码时设定一个假想的运行手机版本，打包后，再运行到真实设备。<br>最终的运行表现取决与targetSdkVersion与真实运行设备版本中的低值。</p><p>targetSdkVersion的预设就相当于预设一个代码运行环境，<br>我们所写的代码功能如果是只有部分版本才有的API，我们需要先判断真实的运行版本是否符合。<br>如在android6.0后引入权限请求，在每次请求权限时，我们需要判断SDK版本是否大于等于23.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void request() &#123;</span><br><span class="line">    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        requestPermissions(new String[]&#123;Manifest.permission.CAMERA&#125;, 101);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，是否需要判断版本其实和minSdkVersion也是有关的，如上面的代码，因为权限请求是23以后的，如果我们直接将minSdkVersion设置为23，则此时就不需要判断版本了，因为肯定是运行在23之后的手机，因为23以前的手机此时会无法安装该应用。</p><p>ex:<br>当我们设定targetSdkVersion=29，即android10，<br>而用户手机为API=23，即android6.0，<br>此时app的表现会是6.0。</p><p>当我们设定targetSdkVersion=23，即android6，<br>而用户手机为API=29，即android10，<br>此时app的表现也会是6.0。</p><h2 id="64位框架"><a href="#64位框架" class="headerlink" title="64位框架"></a>64位框架</h2><p>在去年时，google play要求提及的应用必须支持64位的框架，<br>也就是.so文件必须支持64位架构，<br>在提交审核的apk中，有armeabi-v7a则必须也要有arm64-v8a，如果有x86，则必须也要有x86_64。<br>react-native 原本只有armeabi-v7a，在之后的版本0.59.10中就开始内部源码中支持64位含有arm64-v8a下的.so文件</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git使用</title>
      <link href="/blog/2020/09/git%E4%BD%BF%E7%94%A8.html"/>
      <url>/blog/2020/09/git%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>git是一款分布式代码版本控制工具</p><p>初始化使用：<br>当我们在gitlab、github初始化一个项目路径后，<br>需要将本地仓库的代码提交到新建好的远端仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;remoteurl&gt; // 链接远端仓库 &lt;remoteurl&gt;为远端仓库地址</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit info&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>设置全局用户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;userName&quot;</span><br><span class="line">git config --global user.email &quot;useremail&quot;</span><br></pre></td></tr></table></figure></p><p>git fetch 拉取代码<br>git merge 合并代码<br>git pull 拉取并合并代码<br>git push 将本地仓库的commit提交到远端仓库</p><p>git checkout <branchname> 切换分支<br>git checkout -b <branchname> 新建分支并切换</branchname></branchname></p><p>git branch -d <branchname> 删除分支 不能删除有未提交commit的分支<br>git branch -D <branchname> 强制删除分支</branchname></branchname></p><p>git push -u origin <branchname> 将本地分支推送到远端，如果远端没有此分支则会创建</branchname></p><p>git reset –hard <commitid> 代码回滚到某个commit commitId可以通过git log查看</commitid></p><p>git log 可以查看每一个的commit，显示的信息有 commit date，commit person，commitId，commit info</p><p>git merge A 将A分支合并到当前分支</p><p>git rebase A 将A分支合并并且将A分支节点置于当前分支之后</p><p>git mv <filename> <filename> 修改文件名，因为git默认忽略文件大小写，<br>如修改文件名 File.js 到 file.js此时是无法检测到更改，需要使用命令：<br>git mv File.js file.js</filename></filename></p><h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>在github中已修改默认分支为main 而不再是master</p><p>此时针对命令为<br>git init<br>git remote add origin <remoteurl> // 链接远端仓库 <remoteurl>为远端仓库地址<br>git branch -M main<br>git push -u origin main</remoteurl></remoteurl></p><h2 id="异常解决"><a href="#异常解决" class="headerlink" title="异常解决"></a>异常解决</h2><h3 id="refusing-to-merge-unrelated-histories"><a href="#refusing-to-merge-unrelated-histories" class="headerlink" title="-refusing to merge unrelated histories"></a>-refusing to merge unrelated histories</h3><p>当执行git push时提示先执行git pull<br>而执行git pull时报错如标题，<br>此时需执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lock详解</title>
      <link href="/blog/2020/09/Lock%E8%AF%A6%E8%A7%A3.html"/>
      <url>/blog/2020/09/Lock%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>Lock 是java中的一个锁接口，在jdk1.5新增</p><p>synchronized 是内置锁，不需要手动释放</p><p>与synchronized不同，Lock需要手动获取锁，手动释放锁<br>而且Lock可以被设置为公平锁</p><p>而且Lock可以设置获取锁的超时时间</p><h2 id="Lock的实现类-ReentrantLock"><a href="#Lock的实现类-ReentrantLock" class="headerlink" title="Lock的实现类 ReentrantLock"></a>Lock的实现类 ReentrantLock</h2><p>ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性;<br>ReentrantLock提供公平锁、非公平锁</p><h3 id="继承关系图"><a href="#继承关系图" class="headerlink" title="继承关系图"></a>继承关系图</h3><p><img src="../../../images/sync.png" style="zoom:70%"></p><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>ReentrantLock 默认为非公平锁<br>NonfairSync<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         */</span><br><span class="line">        // Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.</span><br><span class="line">        // @ReservedStackAccess</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在NonfairSync 获取锁时，先判断执行CAS操作是否能够成功，</p><ul><li><p>如果成功将1设置到state上，那么此时锁没有被线程占用，<br>  则会调用到AbstractOwnableSynchronizer中的setExclusiveOwnerThread函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  也就是把当前线程设为此锁的拥有者</p></li><li><p>如果执行CAS操作失败，就会执行 acquire(1); 会调用AbstractQueuedSynchronizer中的acquire</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  acquire会执行两个判断：</p><ul><li>tryAcquire</li><li>acquireQueued<br>当两个判断都返回true时，则会调用selfInterrupt();自己中断自己</li></ul></li></ul><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><p>在NonfairSync中，tryAcquire(1)会调用nonfairTryAcquire，<br>nonfairTryAcquire是Sync类中的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        // 此处会尝试重新执行CAS操作 如果成功，则回到上面的操作</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 判断当前线程是否已经获取锁 可重入锁</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，tryAcquire其实就是再次判断state是否没有被占用 返回true，以及当前线程是否已经占有此锁 返回true，否则就返回false。</p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><pre><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))此处arg = 1；先查看addWaiter函数</code></pre><h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(mode);</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        if (oldTail != null) &#123;</span><br><span class="line">            U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">            if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addWaiter 方法采用了自旋非阻塞的方式进行了入队操作</p><p>在看一下完整的acquireQueued函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取当前节点的前驱节点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //当前节点为第二个节点时,尝试获取锁</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断是否可以挂起</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        throw t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>当构造ReentrantLock实例时传入true，则为公平锁 FairSync</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">       private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">       final void lock() &#123;</span><br><span class="line">           acquire(1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">        * recursive call or no waiters or is first.</span><br><span class="line">        */</span><br><span class="line">       // Android-removed: @ReservedStackAccess from OpenJDK 9, not available on Android.</span><br><span class="line">       // @ReservedStackAccess</span><br><span class="line">       protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">           final Thread current = Thread.currentThread();</span><br><span class="line">           int c = getState();</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">               if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               int nextc = c + acquires;</span><br><span class="line">               if (nextc &lt; 0)</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而看公平锁FairSync中的tryAcquire函数，多了一个判断 !hasQueuedPredecessors()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>公平锁的lock方法在进行cas判断时多了一个hasQueuedPredecessors()方法，<br>它会在AQS队列中没有中没有线程的情况下才会申请锁，<br>而不像非公平锁一样，非公平锁一来不管AQS里是否有排队的线程就直接申请锁</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Synchronized详解</title>
      <link href="/blog/2020/09/Synchronized%E8%AF%A6%E8%A7%A3.html"/>
      <url>/blog/2020/09/Synchronized%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized详解"><a href="#Synchronized详解" class="headerlink" title="Synchronized详解"></a>Synchronized详解</h1><p>Synchronized是内置锁，锁的是对象，<br>Synchronized 有几个使用方式，但其实都是作用于对象。</p><ul><li>1、作用于方法块</li><li>2、作用于obj</li><li>3、作用于this</li><li>4、作用于class</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void lockFun() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void lockThis() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">            System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">            System.out.println(&quot;当前线程Name: &quot; + Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中，lockFun是作用于方法块，lockThis是作用于this，但实际上这两个函数都是作用于当前的类的实例对象上的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void lockClass() &#123;</span><br><span class="line">    synchronized (Test.class) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized void lockStatic() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在lockClass与lockStatic中，lockStatic作用与static静态函数，lockClass作用与Test.class对象，但实际都是作用与Test的所有实例对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void lockObj(Object o) &#123;</span><br><span class="line">    synchronized (o)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lockObj就是直接作用于Object对象。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 设计模式</title>
      <link href="/blog/2020/09/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
      <url>/blog/2020/09/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java IO</title>
      <link href="/blog/2020/09/java-IO.html"/>
      <url>/blog/2020/09/java-IO.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>动态代理</title>
      <link href="/blog/2020/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html"/>
      <url>/blog/2020/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>注解</title>
      <link href="/blog/2020/09/%E6%B3%A8%E8%A7%A3.html"/>
      <url>/blog/2020/09/%E6%B3%A8%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据传输与序列化</title>
      <link href="/blog/2020/09/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
      <url>/blog/2020/09/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><ul><li>Serializable java自带</li><li>Parcelable android中</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Callback Future</title>
      <link href="/blog/2020/09/Callback-Future.html"/>
      <url>/blog/2020/09/Callback-Future.html</url>
      
        <content type="html"><![CDATA[<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p><strong> Future代表一个异步计算的结果，并且它提供一些方法来让调用者检测异步过程是否完成，或者取得异步计算的结果，或者取消正在执行的异步任务。 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt;future = calcute(9);</span><br><span class="line">        while (!future.isDone())&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System.out.println(&quot;正在执行&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            int result = future.get();</span><br><span class="line">            System.out.println(&quot;result = &quot; + result);</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Future&lt;Integer&gt;calcute(Integer i) &#123;</span><br><span class="line">        return executorService.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;return future for &quot; + i);</span><br><span class="line">            return i *i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单Future使用用例写完，使用线程池+Callback+Future，完成了一个简单的计算操作。</p><p>Future是一个接口，先看一下内部方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean var1);</span><br><span class="line"></span><br><span class="line">    boolean isCancelled();</span><br><span class="line"></span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    V get() throws ExecutionException, InterruptedException;</span><br><span class="line"></span><br><span class="line">    V get(long var1, TimeUnit var3) throws ExecutionException, InterruptedException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get()函数是返回计算结果，注意get会同步操作，每天返回结果前，会阻塞线程。<br>get还有一个重载函数get(long var1, TimeUnit var3)，第一个参数是时长，第二个是单位。<br>表示在多少时长内获取结果，如果仍未返回，则抛出异常TimeoutException。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    int result2 = future2.get(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; catch(TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cancel(boolean) 表示是否取消该future，</p><p>不能在调用cancel(true)/cancel(false)后，调用get()函数，否则会抛出异常CancellationException</p><p>isCancelled()函数是判断该future是否已取消</p><p>isDone()函数是判断该future是否已完成</p><p>isDone()函数是实时状态读取，不会阻塞线程。</p><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>Callback 是一个接口，内部只有一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callback 可以理解为一个执行任务，如上面例子中的计算</p><h2 id="FutureTask介绍"><a href="#FutureTask介绍" class="headerlink" title="FutureTask介绍"></a>FutureTask介绍</h2><p>Future是一个接口，<br>RunnableFuture也是一个接口，继承Future、Runnable两个接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而FutureTask是对RunnableFuture的基本实现</p><p>FutureTask 有一个状态值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 状态值存在如下几种变化：</span><br><span class="line">* Possible state transitions:</span><br><span class="line">* NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">* NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">* NEW -&gt; CANCELLED</span><br><span class="line">* NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line">*/</span><br><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br></pre></td></tr></table></figure></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android AsyncTask</title>
      <link href="/blog/2020/09/android-AsyncTask.html"/>
      <url>/blog/2020/09/android-AsyncTask.html</url>
      
        <content type="html"><![CDATA[<p>AsyncTask 顾名思义 即是异步任务。在内部实现了线程的切换，并会一直回调任务进度。<br>适用于耗时任务、网络请求，并需要与主线程进行交互。</p><p>AsyncTask 内部有一个线程池，使用线程池执行任务，并通过Handler 来发送消息、回调状态，任务执行完毕使用Handler与主线程交互，使用Handler一直回调任务进度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt;</span><br><span class="line">// Params Progress Result 分别时三个范性，代指参数、任务执行进度、返回结果体</span><br><span class="line"></span><br><span class="line">// API 29 与 API 28略有不同</span><br><span class="line">private static final int CORE_POOL_SIZE = 1; // 核心线程数</span><br><span class="line">private static final int MAXIMUM_POOL_SIZE = 20; // 最大线程数</span><br><span class="line">private static final int BACKUP_POOL_SIZE = 5; // 备份线程数</span><br><span class="line">private static final int KEEP_ALIVE_SECONDS = 3; // 空闲线程空闲存活时间</span><br><span class="line">// 线程工厂</span><br><span class="line">private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123;</span><br><span class="line">    // 线程数原子类 保证原子操作</span><br><span class="line">    private final AtomicInteger mCount = new AtomicInteger(1);</span><br><span class="line">    // 重写该方法是为了对线程加 别名 AsyncTask #</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 当任务超出时的拒绝策略。</span><br><span class="line">private static final RejectedExecutionHandler sRunOnSerialPolicy =</span><br><span class="line">    new RejectedExecutionHandler() &#123;</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        android.util.Log.w(LOG_TAG, &quot;Exceeded ThreadPoolExecutor pool size&quot;);</span><br><span class="line">        // As a last ditch fallback, run it on an executor with an unbounded queue.</span><br><span class="line">        // Create this executor lazily, hopefully almost never.</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (sBackupExecutor == null) &#123; // 当任务添加到队列失败，并且最大线程数已满，此时会新建一个备份线程池去执行任务</span><br><span class="line">                sBackupExecutorQueue = new LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">                sBackupExecutor = new ThreadPoolExecutor(</span><br><span class="line">                        BACKUP_POOL_SIZE, BACKUP_POOL_SIZE, KEEP_ALIVE_SECONDS,</span><br><span class="line">                        TimeUnit.SECONDS, sBackupExecutorQueue, sThreadFactory);</span><br><span class="line">                sBackupExecutor.allowCoreThreadTimeOut(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sBackupExecutor.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public static final Executor THREAD_POOL_EXECUTOR;</span><br><span class="line">// 类加载时就会执行 初始化线程池 注意初入的队列参数为 new SynchronousQueue&lt;Runnable&gt;() 任务添加都会失败，都会开启新线程执行直到最大线程数满</span><br><span class="line">static &#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">            new SynchronousQueue&lt;Runnable&gt;(), sThreadFactory);</span><br><span class="line">    threadPoolExecutor.setRejectedExecutionHandler(sRunOnSerialPolicy);</span><br><span class="line">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看 execute 执行任务函数</p><h2 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h2><p>execute函数存在重载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">    return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MainThread</span><br><span class="line">public static void execute(Runnable runnable) &#123;</span><br><span class="line">    sDefaultExecutor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行execute时，并传入Runnabe时，执行sDefaultExecutor.execute(runnable);<br>sDefaultExecutor 是 Async 的一个内部类 SerialExecutor 的一个实例对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line"></span><br><span class="line">        public synchronized void execute(final Runnable r) &#123;</span><br><span class="line">            mTasks.offer(new Runnable() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        r.run();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        scheduleNext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            if (mActive == null) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected synchronized void scheduleNext() &#123;</span><br><span class="line">            if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，就是在数组队列mTasks队尾添加一个runnable，scheduleNext函数就是弹出队首任务并通过THREAD_POOL_EXECUTOR执行。</p><p>再看一下 execute(Params… params) 函数</p><h2 id="execute-Params…-params"><a href="#execute-Params…-params" class="headerlink" title="execute(Params… params)"></a>execute(Params… params)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 此处传入的 exec 也是 一个 SerialExecutor 对象。</span><br><span class="line">@MainThread</span><br><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">        Params... params) &#123;</span><br><span class="line">    // 当一个任务状态不是处于 等待执行 而又执行了这个函数时，会抛出异常。</span><br><span class="line">    if (mStatus != Status.PENDING) &#123;</span><br><span class="line">        switch (mStatus) &#123;</span><br><span class="line">            case RUNNING:</span><br><span class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                        + &quot; the task is already running.&quot;);</span><br><span class="line">            case FINISHED:</span><br><span class="line">                throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                        + &quot; the task has already been executed &quot;</span><br><span class="line">                        + &quot;(a task can be executed only once)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变状态为正在执行</span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line">    // 此处传入的时一个FutureTask 对象 mFuture</span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">public enum Status &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 任务等待执行</span><br><span class="line">         */</span><br><span class="line">        PENDING,</span><br><span class="line">        /**</span><br><span class="line">         * 任务正在执行</span><br><span class="line">         */</span><br><span class="line">        RUNNING,</span><br><span class="line">        /**</span><br><span class="line">         * 任务已经完成</span><br><span class="line">         */</span><br><span class="line">        FINISHED,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FutureTask 实现 Runnable 接口，但是功能更加丰富，能获取任务执行的结果Result，能主动取消Runnable<br>exec.execute(mFuture) 最后也会执行到 SerialExecutor 的 execute 函数，也会被添加到 队列队尾，</p><h2 id="InternalHandler"><a href="#InternalHandler" class="headerlink" title="InternalHandler"></a>InternalHandler</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static InternalHandler sHandler;</span><br><span class="line">private static Handler getMainHandler() &#123;</span><br><span class="line">    synchronized (AsyncTask.class) &#123;</span><br><span class="line">        if (sHandler == null) &#123;</span><br><span class="line">            sHandler = new InternalHandler(Looper.getMainLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        return sHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Handler getHandler() &#123;</span><br><span class="line">    return mHandler;</span><br><span class="line">&#125;</span><br><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">    public InternalHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case MESSAGE_POST_RESULT:</span><br><span class="line">                // There is only one result</span><br><span class="line">                result.mTask.finish(result.mData[0]);</span><br><span class="line">                break;</span><br><span class="line">            case MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局的mHandler是InternalHandler实例，而且传入的looper对象是 getMainLooper();<br>所以finish，与 onProgressUpdate 一定会走到main线程</p><p>如果通过直接执行AsyncTask中的静态方法execute(Runnable runnable) 来执行runnable时，是不会触发回调， 并且是没有返回的。</p><p>因为只有在AsyncTask构造函数内，对mWorker、mFuture、mHandler都做了包装处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> public AsyncTask(@Nullable Looper callbackLooper) &#123;</span><br><span class="line">    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()</span><br><span class="line">        : new Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        public Result call() throws Exception &#123;</span><br><span class="line">            mTaskInvoked.set(true);</span><br><span class="line">            Result result = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                //noinspection unchecked</span><br><span class="line">                result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125; catch (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(true);</span><br><span class="line">                throw tr;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void done() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; catch (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是AsyncTask其中一个构造函数，而其他构造函数都会调用到此处，最后都会执行此处逻辑。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程池</title>
      <link href="/blog/2020/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"/>
      <url>/blog/2020/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
      
        <content type="html"><![CDATA[<h1 id="java-线程池"><a href="#java-线程池" class="headerlink" title="java 线程池"></a>java 线程池</h1><p>线程池是用来管理以及调度线程的容器。</p><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><ul><li>复用线程，避免大量线程重复创建、销毁，降低消耗</li><li>提升效率，当线程池内未饱和时，无需等待线程的重新创建和初始化，便能立即执行</li><li>方便线程并发管理，避免线程无限制的创建，可能造成的 OOM、cpu 过高等问题，规定了最大并发数</li><li>延时定时执行任务</li></ul><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>创建线程池的几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService pool1 = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">ExecutorService pool2 = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">ExecutorService pool3 = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">ExecutorService pool4 = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">10</span>, <span class="number">60</span>,</span><br><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure><p>最后都会执行到 ThreadPoolExecutor 的构造函数中</p><h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即时是 ThreadPoolExecutor 的其他几个构造函数，最后也会调用到这个 7 参的构造函数</p><ul><li>corePoolSize: 核心线程数量，当向线程池提交一个任务时，如果线程数小于核心线程数，不管是否有线程处于空闲状态，都会创建一个新的线程来执行该任务，<br>直到线程池中的线程数大于等于核心线程数量</li><li><p>maximumPoolSize: 最大线程数，线程池中线程数量最大值，当向线程池提交任务，核心线程都已创建完毕，且核心线程都处于工作状态，此时会先将该任务提交到阻塞队列，如果阻塞队列已满， 并线程池中线程数量小于最大线程数时，此时会新创建一个线程执行该任务。如果阻塞队列已满，且线程数也达到最大值，此时会执行线程饱和策略。</p></li><li><p>keepAliveTime：非核心线程可空闲时长，非核心线程处于空闲时，且空闲时长超过 keepAliveTime，则该线程会被回收，但不会回收核心线程</p></li><li><p>unit： keepAliveTime 的时长单位</p></li><li><p>workQueue： 阻塞队列，用于保存和运输待执行任务的阻塞队列</p></li><li><p>threadFactory：线程工厂，用于创建工作线程，threadFactory 也是采用 new Thread()形式创建一个新线程，但命名线程名称，格式为：pool-m-thread-n（m 为线程池的编号，n 为线程池内的线程编号）。</p></li><li><p>defaultHandler： 线程饱和策略，当线程池和阻塞队列都满了，再添加任务时，会执行此策略</p></li></ul><p>线程池第 5 个参数，是传入一个等待队列，一般来说等待队列有三种：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</p><ul><li>ArrayBlocking: 基于数组的等待队列，初始化需要指定固定大小<br>当使用此队列，向线程池提交任务时，会首先加入到等待队列中，当等待队列满了，提交到队列中失败时，就是就会检查线程池的最大线程数是否达到最大，没有则启动线程执行任务。<br>所以最终可能出现后提交的任务先执行，而先提交的任务还在等待队列等待执行。</li><li>LinkedBlockingQueue: 基于链表的等待队列，初始化可以指定大小，也可以不指定<br>当指定大小后，表现就和 ArrayBlockingQueue 一致，如果没指定大小，则会使用默认的 integer.MAX_VALUE,此时添加任务会一直成功。<br>最终所有的任务都会在核心线程中执行，如果核心线程线程被占用，则会一直等待。</li><li>SynchronousQueue: 无容量的队列<br>使用此队列就是希望拥有最大的并发量，因为无论如何，向队列中添加任务都会失败，此时就会一直检查线程池线程数是否达到最大线程数，没有达到则会一直新建线程来执行任务。<br>唯一制约就是配置的最大线程数，如果使用 Integer.MAX_VALUE 就实现了真正的无等待。</li></ul><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p><img src="../images/threadPool.png" alt="提交任务流程">;</p><h5 id="execute-提交任务"><a href="#execute-提交任务" class="headerlink" title="execute 提交任务"></a>execute 提交任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ctl 是一个原子 Integer 对象，存储的是正在运行的线程数<br>看英文注释也写的很清楚了，分三部，<br>1、判断正在运行的线程是否小于核心线程数，是的话则 调用 addWorker(command, true)；并不再向下执行<br>2、判断队列能否添加 command 以及 线程池是否还在运行，而且双重检测，成功将加任务加入到阻塞队列，<br>再进行第二次判断，如果线程池没有再运行 &amp;&amp; 移除这个任务，执行拒绝<br>或者工作线程数 == 0， 则直接 addWorker(null, false);<br>3、尝试添加失败，执行 reject(command)</p><h5 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h5><p>查看添加任务的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">            firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>外层 for 循环： 当线程池已经 SHUTDOWN 时，不能添加任务<br>内层 for 循环：当前线程数大于总容量 ｜｜ 为添加核心线程时，&gt; 核心线程数 当为非核心线程时，&gt; 最大线程数，不能添加任务<br>如果能添加时，终止外层 for 循环</p><p>compareAndIncrementWorkerCount 函数是将当前的正在运行的线程数 + 1；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">            <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">            <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                workers.add(w);</span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 是 ThreadPoolExecutor 中的内部类，implements Runnable<br>此处就是在构建一个 Worker，并启动线程执行。</p><h3 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h3><p>当提交一个任务时，</p><p>1、查询核心线程是否已满，如果未满则新创建核心线程执行该任务</p><p>2、当核心线程已满，判断阻塞队列是否已满，如果阻塞队列未满则将该任务加入到阻塞队列中</p><p>3、当阻塞队列已满时，判断线程池是否已满，如果未满，则新创建线程执行该任务</p><p>4、当线程池已满时，则执行饱和策略，</p><!-- 而且当未达到最大线程数时，会取出队列中的任务执行。 --><h2 id="线程池为何需要使用阻塞队列"><a href="#线程池为何需要使用阻塞队列" class="headerlink" title="线程池为何需要使用阻塞队列"></a>线程池为何需要使用阻塞队列</h2><p>1、因为线程池是管理并调度线程、以完成任务，肯定不可能无限制的创建线程，</p><p>2、提高核心线程的使用效率</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 强、软、弱、虚四种引用类型</title>
      <link href="/blog/2020/08/java-%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html"/>
      <url>/blog/2020/08/java-%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>在jdk 1.2之前，一个对象只有 “已被引用” 和 “未被引用”两种概念，在jdk1.8之后，引用类型分为4类：<br>强引用：Strong Reference<br>软引用：Soft Reference<br>弱饮用：Weak Reference<br>虚引用：Phantom Reference<br>这4中引用的强度依次减弱</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>java中默认的引用类型，只要引用存在，永远不会回收，哪怕内存不足，系统会抛出OOM异常，也不会回收。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>只有当内存不足时，才会回收，回收后如果还是内存不足才会抛出OOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void testSoftReference() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">byte[] buff = new byte[1024 * 1024];</span><br><span class="line">SoftReference&lt;byte[]&gt; sr = new SoftReference&lt;&gt;(buff);</span><br><span class="line">list.add(sr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.gc(); //主动通知垃圾回收</span><br><span class="line"></span><br><span class="line">for(int i=0; i &lt; list.size(); i++)&#123;</span><br><span class="line">Object obj = ((SoftReference) list.get(i)).get();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>// 无论内存是否足够，只要JVN开始回收，弱饮用都会被回收<br>很多文章都说，只要执行GC就会回收软引用，这种结论是错误的。</p><p><strong>当一个对象只被弱引用实例引用（持有）时，这个对象就会被GC回收</strong></p><ul><li>被回收的对象弱饮用实例引用的对象，而不是弱饮用本身</li><li>如果显式地声明了一个变量E e，并使之指向一个对象：e = new E()，这时变量e就是对对象的一个强引用。如果变量e所引用的这个对象同时又被WeakReference的一个实例持有，则由于存在对对象的一个强引用e，对象并不符合上述回收规则，因此对象至少在变量e的作用域范围内都不会被回收。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class TestWeakReference &#123;</span><br><span class="line">    private static List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testWeakReference();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void testWeakReference() &#123;</span><br><span class="line">        byte[]buff = new byte[1024 * 1024];</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff);</span><br><span class="line">            list.add(weakReference);</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        for (int i =0; i &lt; list.size(); i ++) &#123;</span><br><span class="line">            Object o = ((WeakReference)list.get(i)).get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述情况下，buff是一个强引用类型，在它的作用域时是不可回收的，即使除了弱饮用持有没有其他的引用。</p><p>将上述代码改一下，将buff与gc作用域修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class TestSoftReference &#123;</span><br><span class="line">    private static List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    private static List&lt;Object&gt; lists = new ArrayList&lt;&gt;();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        testWeakReference();</span><br><span class="line">        gc();</span><br><span class="line">    &#125;</span><br><span class="line">    static WeakReference&lt;byte[]&gt; softReference;</span><br><span class="line">    private static void testWeakReference() &#123;</span><br><span class="line">        byte[]buff = new byte[1024 * 1024];</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            softReference = new WeakReference&lt;&gt;(buff);</span><br><span class="line">            list.add(softReference);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void gc() &#123;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        for (int i =0; i &lt; list.size(); i ++) &#123;</span><br><span class="line">            Object o = ((WeakReference)list.get(i)).get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这种情况下，gc执行的作用域与buff的作用域是同级的另一个作用域，且buff无其他引用，则可以回收</p><p>将上述代码再修改一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class TestWeakReference &#123;</span><br><span class="line">    private static List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testWeakReference();</span><br><span class="line">    &#125;</span><br><span class="line">    private static void testWeakReference() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            byte[]buff = new byte[1024 * 1024];</span><br><span class="line">            WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(buff);</span><br><span class="line">            list.add(weakReference);</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        for (int i =0; i &lt; list.size(); i ++) &#123;</span><br><span class="line">            Object o = ((WeakReference)list.get(i)).get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时buff的作用域只在for循环内，此时是可以被回收的，因为输出的结果均为null</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用是最弱的引用类型，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。<br>永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h2 id="引用队列（ReferenceQueue）"><a href="#引用队列（ReferenceQueue）" class="headerlink" title="引用队列（ReferenceQueue）"></a>引用队列（ReferenceQueue）</h2><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p><p>与软引用、弱引用不同，虚引用必须和引用队列一起使用。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java ThreadLocal解析</title>
      <link href="/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2020/08/java-ThreadLocal%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal 是一个线程的内部存储类，对于被存储的对象，在不同的线程读取的变量是独立的。</p><p>实现原理是：对每一个线程都有一个 ThreadLocalMap，ThreadLocal 维护每个 ThreadLocalMap 中的值<br>ThreadLocalMap 内部是一个[]Enter, 不同的 ThreadLocal 都是存储在线程的同一个 ThreadLocalMap 中的，只是下标位置不同，<br>同一个 ThreadLocal 在不同线程的 ThreadLocalMap 中的下标值即索引值是相同的。</p><h2 id="ThreadLocal-方法解析"><a href="#ThreadLocal-方法解析" class="headerlink" title="ThreadLocal 方法解析"></a>ThreadLocal 方法解析</h2><p>ThreadLocal 最常用的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;();</span><br><span class="line">threadLocal.set(&quot;1&quot;);</span><br><span class="line">String name = threadLocal.get();</span><br></pre></td></tr></table></figure><p>在主线程初始化 ThreadLocal 实例，在各个线程调用 set、get，设置、获取存储在各个线程中的值</p><p>查看源码</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 set 函数时，会去获取当前线程的 ThreadLocalMap 对象，该对象是在 Thread.java 中申明，默认值为 null。<br>当 map 为 null 时，则调用 createMap,为 threadLocals 对象赋值，不为 null，在调用 ThreadLocalMap 中的 set 函数，将值保存到数组中</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 get 方法时，获取当前线程的 ThreadLocalMap 对象，如果 map 不为 null，则获取 map 持有的 Entry 对象，再返回该 Entry 对象持有的 value 值。<br>如果 map 为 null 或者获取的 Enter 对象为 null，则会调用 setInitialValue，而 initialValue 的返回值是 null。<br>当 map 为 null 时，会调用 createMap 方法，实例化 ThreadLocalMap</p><p>上面的 set、get 都会调用 getMap 方法，来获取当前线程的 ThreadLocalMap 实例</p><h3 id="getMap"><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>threadLocals 是在 Thread.java 中声明的，默认值为 null，也就是说每个线程中都有这个对象，只是默认是 null。</p><h3 id="createMap"><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h3><p>在 set、get 中都会对当前线程的 ThreadLocalMap 对象判断，当为 null 时，会调用 createMap 对 ThreadLocalMap 对象 threadLocals 赋值，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须为2的次方</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终存储数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// table 有值的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize后的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getEntry 函数就是获取 key 对应的节点 Entry<br>在 getEntry、set 函数中可以看到 value 存储在[]Entry 中的下标位置是由 key.threadLocalHashCode &amp; (len-1)计算得出的。<br>就是 ThreadLocal 中的 threadLocalHashCode 对[]Entry 长度取模<br>getEntry，通过下标获取 e，如果不为 null 而且再次校验 key 相等，则返回 e<br>set 时，e 不为 null，而且 key 相等，代表已存在，则替换 e.value，<br>key 不相等，代表不存在，而添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>当 Entry[] 中存入的值数量已达到数组长度的 3/4；<br>则会调用 resize 函数，调整 Entry[]的长度，<br>将新数组长度*2，遍历老数组，<br>重新获取下标 h，判断 h 处是否有值，无值填充，有值则重新获取 h，再填充</p><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>ThreadLocalMap 的内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 是调用 ThreadLocal 保存的值，</p><h2 id="ThreadLocal-内存泄漏"><a href="#ThreadLocal-内存泄漏" class="headerlink" title="ThreadLocal 内存泄漏"></a>ThreadLocal 内存泄漏</h2><p>首先要知道 ThreadLocal 的结构：</p><p>Thread 持有 ThreadLocalMap<br>ThreadLocalMap 持有 Entry 数组<br>Entry 持有 ThreadLocal 和 value</p><p>Enry 是弱引用，但是 value data 是强引用，而这就是内存泄漏的点</p><p>Entry 虽然是继承自弱引用，但是存储的 value 是强引用，<br>所以在 ThreadLocal 仍然存在内存泄漏可能，<br>即使在 set 时会调用 replaceStaleEntry 来清理数据</p><p>最好是在确定线程中不再使用 ThreadLocal 中线程副本时，调用 remove 函数，清除线程副本</p><h2 id="ThreadLocal-线程不安全"><a href="#ThreadLocal-线程不安全" class="headerlink" title="ThreadLocal 线程不安全"></a>ThreadLocal 线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Person person = <span class="keyword">new</span> Person(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Person&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        person.setAge(person.age + <span class="number">1</span>);</span><br><span class="line">        threadLocal.set(person);</span><br><span class="line">        System.out.println(<span class="string">"age = "</span> + threadLocal.get().getAge());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            person.setAge(person.age + <span class="number">1</span>);</span><br><span class="line">            threadLocal.set(person);</span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                sleep(1);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            System.out.println(<span class="string">"age = "</span> + threadLocal.get().getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>age = 21<br>age = 22<br>age = 23<br>age = 24<br>age = 25<br>age = 26</p><p>如果将注释的 sleep 代码放开，打印结果：<br>age = 21<br>age = 26<br>age = 26<br>age = 26<br>age = 26<br>age = 26</p><p>我们在主线程与 5 个子线程中改变了 person 的 age 值，使加 1，并打印了 person 的 age 值<br>ThreadLocal 在每个线程存有一个线程副本，按照理解打印结果应该都是 21 才对，因为每个线程副本取 age 应该都是 20，加 1 就是 21<br>但从我们执行的情况来看，线程与线程之间的变量值在相互干扰。导致 age 值在不同线程之间也在累加。</p><p>这是因为我们在 ThreadLocal 中存有的 person 对象是静态对象的引用，而静态对象全局唯一，导致在不同线程之间的引用，指向了同一个对象。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>ThreadLocalMap 為 ThreadLocal 的一個静态内部类，在 Thread 中有一个变量 ThreadLocalMap threadLocals;<br>ThreadLocalMap 中又有一個静态内部类：Enter，Enter 是继承至弱引用：WeakReference，<br>Enter 是一个 key、value 结构，key 为 ThreadLocal 对象，value 为 Object 强引用对象，而这就是内存泄露点。</p><p>ThreadLocalMap 中有一个 Enter 数组 table，用于存放我们放进区的数据<br>每次存放數據時，根據使用的 threadLocal 的 hash 值對 table 的長度取余，即为该要存放的数据要在 table 中的下标，<br>如果该处下标的 value 不为 null，则下标向后移一位，如果到最后一位了，则移到 0 处。<br>存放数据时。现根据传入的 key 获取 hash，再取余获取对应 index，从下标处还是后移遍历 enter，</p><ul><li>取到 key 为 enter 的 k 相等，则说明为替换。修改 enter 的 value 即可，并结束操作</li><li>enter 的 k 为 null，代表此处的 key 已被回收<br>遍历完后，说明是添加，直接插入到该下标处一个新 Enter 对象</li></ul><p>当存放的数据条数大于等于总长度 3/4 时，触发扩容 resize<br>每次 resize 的长度时上一次的两倍。<br>resize 时会遍历旧数组，如果 Enter 不为 null 但 key 为 null，代表弱引用被回收，此时直接将 value 置为 null，便于 GC。<br>使用 key 的 hash 对新数组长度取余，hash 碰撞则后移，与上面的一致。</p><p>threadLocal 获取数据 get 时，会调用 threadLocalMap 的 getEntry 函数，先计算下标，获取到的 e 不为 null，而且 key 相同，则返回 e<br>否则调用 getEntryAfterMiss ，getEntryAfterMiss 会尝试再次获取 e，包括会尝试后移下标来匹配 key 是否相等。<br>如果下标 key 为 null，会将该处 value 置为 null，便于 gc</p><p>ThreadLocal 调用 remove 函数时，会调用到 ThreadLocalMap 的 remove 函数，会遍历 table，先回收弱引用 key，在调用 expungeStaleEntry 将 value 置空</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java volatile关键字</title>
      <link href="/blog/2020/08/java-volatile%E5%85%B3%E9%94%AE%E5%AD%97.html"/>
      <url>/blog/2020/08/java-volatile%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
      
        <content type="html"><![CDATA[<h2 id="valotile-可见性"><a href="#valotile-可见性" class="headerlink" title="valotile 可见性"></a>valotile 可见性</h2><p>1、修改volatile变量时会强制将修改后的值刷新的主内存中。</p><p>2、修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class TestThread &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Work work = new Work();</span><br><span class="line"></span><br><span class="line">        new Thread(work::work).start();</span><br><span class="line">        new Thread(work::work).start();</span><br><span class="line">        new Thread(work::work).start();</span><br><span class="line">        new Thread(work::shutdown).start();</span><br><span class="line">        new Thread(work::work).start();</span><br><span class="line">        new Thread(work::work).start();</span><br><span class="line">        new Thread(work::work).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Work&#123;</span><br><span class="line">        volatile boolean isShutdown = false;</span><br><span class="line"></span><br><span class="line">        void shutdown() &#123;</span><br><span class="line">            System.out.println(&quot;shutdown -----&quot;);</span><br><span class="line">            isShutdown = true;</span><br><span class="line">            System.out.println(&quot;shutdown ---- down&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void work() &#123;</span><br><span class="line">            while (!isShutdown) &#123;</span><br><span class="line">                System.out.println(&quot;work ----&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码运行后输出的结果如下：<br>work —-<br>work —-<br>work —-<br>work —-<br>work —-<br>work —-<br>work —-<br>work —-<br>work —-<br>work —-<br>work —-<br>shutdown —–<br>work —-<br>shutdown —- down<br>work —-<br>work —-</p><p>说明一个问题：<br>volatile的可见性，<br>volatile变量时会强制将修改后的值刷新的主内存<br>修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。<br>将主内存的值刷新，其他线程去读取主内存的值是需要一定时间的，</p><p>底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存（缓存行锁定）并回写到主内存。其中lock前缀指令在多核处理器下会引发两件事情：</p><p>会将当前处理器缓存行的数据立即回写到系统内存。<br>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效（通过MESI缓存一致性协议）。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java wait方法</title>
      <link href="/blog/2020/08/java-wait%E6%96%B9%E6%B3%95.html"/>
      <url>/blog/2020/08/java-wait%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="wait-、notify-、notifyAll"><a href="#wait-、notify-、notifyAll" class="headerlink" title="wait()、notify()、notifyAll()"></a>wait()、notify()、notifyAll()</h1><p>wait()、notify()、notifyAll()这三个函数都是Object类中的方法，而Object类是所有类的父类，所以所有对象实例都有该方法.</p><p>wait():阻塞当前之前直到该对象(调用wait函数的对象)在另一个线程调用了notify()或者notifyAll();<br>notify():唤醒单个线程<br>notifyAll():唤醒所有线程</p><p>这三个方法，都是Java语言提供的实现线程间阻塞(Blocking)和控制进程内调度(inter-process communication)的底层机制。在解释如何使用前，先说明一下两点：</p><ol><li><p>正如Java内任何对象都能成为锁(Lock)一样，任何对象也都能成为条件队列(Condition queue)。而这个对象里的wait(), notify()和notifyAll()则是这个条件队列的固有(intrinsic)的方法。</p></li><li><p>一个对象的固有锁和它的固有条件队列是相关的，为了调用对象X内条件队列的方法，你必须获得对象X的锁。这是因为等待状态条件的机制和保证状态连续性的机制是紧密的结合在一起的。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TestWait &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args) &#123;</span><br><span class="line">        TestWaitBean bean = new TestWaitBean(&quot;bean&quot;);</span><br><span class="line">        System.out.println(&quot;init bean&quot;);</span><br><span class="line">        System.out.println(&quot;invoke bean wait&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            bean.wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;wait finished&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestWaitBean &#123;</span><br><span class="line">        String name;</span><br><span class="line">        public TestWaitBean(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码运行后会抛出异常java.lang.IllegalMonitorStateException<br>因为未获取对象bean的锁，就去调用bean.wait()</p><p>修改一下代码，实现一个简单的阻塞、唤醒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class TestWait &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args) &#123;</span><br><span class="line">        TestWaitBean bean = new TestWaitBean(&quot;bean&quot;);</span><br><span class="line">        System.out.println(&quot;init bean&quot;);</span><br><span class="line">        System.out.println(&quot;invoke bean wait&quot;);</span><br><span class="line">        WeakUpThread thread = new WeakUpThread(bean);</span><br><span class="line">        thread.start();</span><br><span class="line">        synchronized (bean) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                bean.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System.out.println(&quot;wait finished&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestWaitBean &#123;</span><br><span class="line">        String name;</span><br><span class="line">        public TestWaitBean(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class WeakUpThread extends Thread &#123;</span><br><span class="line">        Object lock;</span><br><span class="line">        public WeakUpThread(Object lock) &#123;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;Current Thread is sleep 2000ms&quot; );</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    System.out.println(&quot; weakUp!!!&quot;);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>不管是调用wait，还是notify、notifyAll，都要是在同步修饰的代码块或者方法中，即必须先获取对象锁，在调用对象方法</li></ul><p>使用wait、notifyAll实现一个多线程的生产者、消费者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">class BlockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String []args) &#123;</span><br><span class="line">        List&lt;Object&gt;list = new ArrayList&lt;&gt;();</span><br><span class="line">        Block block = new Block(list);</span><br><span class="line">        list.add(null);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(new PutThread(block, new Person(&quot;person1&quot;)), &quot;thread1&quot;);</span><br><span class="line">        Thread thread2 = new Thread(new PutThread(block, new Person(&quot;person2&quot;)), &quot;thread2&quot;);</span><br><span class="line">        Thread thread3 = new Thread(new PutThread(block, new Person(&quot;person3&quot;)), &quot;thread3&quot;);</span><br><span class="line">        Thread thread4 = new Thread(new PutThread(block, new Person(&quot;person4&quot;)), &quot;thread4&quot;);</span><br><span class="line">        Thread thread5 = new Thread(new OutThread(block), &quot;thread5&quot;);</span><br><span class="line">        Thread thread6 = new Thread(new OutThread(block), &quot;thread6&quot;);</span><br><span class="line">        Thread thread7 = new Thread(new OutThread(block), &quot;thread7&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread5.start();</span><br><span class="line">        thread6.start();</span><br><span class="line">        thread7.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class PutThread implements Runnable &#123;</span><br><span class="line">        Block block;</span><br><span class="line">        Person person;</span><br><span class="line"></span><br><span class="line">        public PutThread(Block block, Person person) &#123;</span><br><span class="line">            this.block = block;</span><br><span class="line">            this.person = person;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; puting the person name is &quot; + person.getName());</span><br><span class="line">            block.put(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class OutThread implements Runnable &#123;</span><br><span class="line">        Block block;</span><br><span class="line">        public OutThread(Block block) &#123;</span><br><span class="line">            this.block = block;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Person  person = (Person) block.get();</span><br><span class="line">            if(person != null) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; get the person name is &quot; + person.getName());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; the person is null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static class Block&lt;T&gt; &#123;</span><br><span class="line">        List&lt;T&gt;t;</span><br><span class="line">        Object lock = new Object();</span><br><span class="line">        int currentIndex = 0;</span><br><span class="line">        volatile boolean isRead = false;</span><br><span class="line">        public Block(List&lt;T&gt;t)&#123;</span><br><span class="line">            this.t= t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void put(T at) &#123;</span><br><span class="line">            if(t == null) throw new NullPointerException(&quot;t is null&quot;);</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(isRead) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentIndex++;</span><br><span class="line">                    t.add(at);</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public T get() &#123;</span><br><span class="line">            synchronized (lock)&#123;</span><br><span class="line">                T at = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(currentIndex == 0) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() +  &quot; 当前下标已为0 阻塞 等待写入再取&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(isRead)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() +  &quot; 当前正在读 阻塞 等待写入再取 index&quot; + currentIndex);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    isRead = true;</span><br><span class="line">                    at = t.remove(currentIndex);</span><br><span class="line">                    if(at == null) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() +  &quot; index&quot; + currentIndex);</span><br><span class="line">                        return  null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentIndex --;</span><br><span class="line">                    return at;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    isRead = false;</span><br><span class="line">                    return at;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Person&#123;</span><br><span class="line">        private String name = &quot;&quot;;</span><br><span class="line">        public Person(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em> 上述生产者、消费者只能适用于多个线程直接的put、get </em></strong><br>因为wait、和notify/notifyAll本身就是互斥的，因为调用wait后，就会阻塞当前调用线程，<br>本身线程的notify/notifyAll也就不会被调用，所以说上述代码只能实现多个线程直接的场景，<br>还有就是上述代码只是简单的实现，而且是读操作加锁，一般而言应该是写操作时堵塞。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java join方法</title>
      <link href="/blog/2020/08/java-join%E6%96%B9%E6%B3%95.html"/>
      <url>/blog/2020/08/java-join%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续<br>如在main线程调用t.join(),则会阻塞main线程直到t线程执行完。</p><p>而join()函数参数，当调用为t.join(2000),代表阻塞2000毫秒, 当2000毫秒完后，main线程会向下执行，<br>但也有例外，join(millis)<br>如在t线程使用 synchronized时，则必须等到synchronized包裹的代码块执行完并传递的millis毫秒后，t.join()的调用线程才会向下执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">//                synchronized (currentThread()) &#123;</span><br><span class="line">                    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            sleep(1000);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(&quot;休眠&quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;线程结束&quot;);</span><br><span class="line">//                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            thread.join(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;main线程结束&quot;);</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>main线程结束<br>1005<br>休眠0<br>休眠1<br>休眠2<br>休眠3<br>休眠4<br>线程结束</p><p>将thread.join(1000) 改为2000 时，输出结果如下：<br>休眠0<br>main线程结束<br>2005<br>休眠1<br>休眠2<br>休眠3<br>休眠4<br>线程结束</p><p>将上面代码synchronized 注释放开后再运行，输出结果如下：<br>休眠0<br>休眠1<br>休眠2<br>休眠3<br>休眠4<br>线程结束<br>main线程结束<br>5011</p><p>查看join方法源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  Waits at most &lt;code&gt;millis&lt;/code&gt; milliseconds for this thread to  </span><br><span class="line"> * die. A timeout of &lt;code&gt;0&lt;/code&gt; means to wait forever.    当为0时，会一直阻塞调用join函数的线程，直到调用join函数的对象线程执行完毕</span><br><span class="line"> */</span><br><span class="line">public final synchronized void join(long millis)    throws InterruptedException &#123;</span><br><span class="line">    // 获取当时系统时间</span><br><span class="line">    long base = System.currentTimeMillis();</span><br><span class="line">    long now = 0;</span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        // 当传过来的入参时间小于0，抛出异常</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (millis == 0) &#123;</span><br><span class="line">        // 当等于0时，只要线程未执行完毕，则一直阻塞</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            // 当前线程未执行完一直阻塞</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 当时间大于0</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            // 当前线程还未执行完，则一直循环获取时间，阻塞调用线程到时间结束</span><br><span class="line">            long delay = millis - now;</span><br><span class="line">            if (delay &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br>wait()是运行在调用线程的，<br>如在main线程中调用t.join();<br>则join()函数的调用线程是main线程，wait()也是运行在main线程的，所以阻塞main线程，<br>而t才是join()的调用对象线程，isAlive也是判断的t线程是否执行完毕，只有在t线程执行完毕，isAlive才为false</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 指纹验证</title>
      <link href="/blog/2020/08/android-%E6%8C%87%E7%BA%B9%E9%AA%8C%E8%AF%81.html"/>
      <url>/blog/2020/08/android-%E6%8C%87%E7%BA%B9%E9%AA%8C%E8%AF%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="android-指纹识别"><a href="#android-指纹识别" class="headerlink" title="android 指纹识别"></a>android 指纹识别</h1><p>android API 23时新增的功能，指纹识别</p><p>主要类：FingerpringManager</p><p>在API28后，FingerpringManager被遗弃，使用BiometricPrompt，此时授权识别的弹窗不能自定义，<br>只能使用官方统一弹窗，只能设置各个授权文案。各个开发商内部实现可能不一致。</p><p>通过只是使用指纹识别，直接使用官方api即可，但出于安全或业务场景需求，很多都需要去检测生物库信息是否变更，<br>如指纹库在重新指纹识别前是否发生变更，这个官方api就没有提供方法，需要我们自己实现。</p><h2 id="检测指纹库是否发生变更"><a href="#检测指纹库是否发生变更" class="headerlink" title="检测指纹库是否发生变更"></a>检测指纹库是否发生变更</h2><p>参考：<br>通过检测密钥查看是否变更(<a href="https://www.jianshu.com/p/dbb1a43cfb21" target="_blank" rel="noopener">https://www.jianshu.com/p/dbb1a43cfb21</a>)</p><p>在API28以前，指纹库信息时可以通过反射获取，获取的信息有指纹id、groupId、指纹名称、指纹个数、设备id等等，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    Log.d(TAG, &quot;getFingerPrintInfo: &quot;);</span><br><span class="line">    FingerprintManager fingerprintManager = (FingerprintManager) getCurrentActivity().getSystemService(Context.FINGERPRINT_SERVICE);</span><br><span class="line">    try&#123;</span><br><span class="line">        Class clz = Class.forName(&quot;android.hardware.fingerprint.FingerprintManager&quot;);</span><br><span class="line">        Method method = clz.getDeclaredMethod(&quot;getEnrolledFingerprints&quot;, new Class[]&#123;&#125;);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        Object obj = method.invoke(fingerprintManager, null);</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            Log.e(TAG, &quot;objStr:&quot; + JsonUtils.toJson(obj));</span><br><span class="line">            List&lt;FingerprintBean&gt; list = (List&lt;FingerprintBean&gt;) JsonUtils.fromJson(objStr, new TypeToken&lt;List&lt;FingerprintBean&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而FingerprintBean是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class FingerprintBean implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private long mDeviceId;</span><br><span class="line">    private long mFingerId;</span><br><span class="line">    private long mGroupId;</span><br><span class="line">    private String mName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最理想的方式是我们反射获取到这些指纹库信息，然后将这些信息保存到本地，每次调用指纹识别时，获取当前指纹库信息与之前的指纹库信息比较，<br>只有不同即可判定指纹库信息变更，<br>但在实际操作中，发现在手机上获取到的指纹id只是简单的1、2、3即指纹库里的排列顺序，而指纹名称是可以随意更改，groupId、deviceId都为0，<br>如果使用这些信息去校验，错误率太高。</p><p>还有一种方式即是上面参考链接中的，<br>检测指纹库密钥信息是否变更</p><p>但在上面链接那种方法中，有几个问题：<br>1、增加、删除指纹无法检测<br>2、使用修改指纹的手指识别后才能检测出修改</p><p>于是将反射、密钥检测两者结合，<br>先反射获取指纹库信息，只是比较指纹库指纹个数，先判断指纹个数是否发生变更，就可知道指纹库信息变更了<br>如果指纹个数没有变更，再来校验密钥是否发生变化</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kotlin (二)</title>
      <link href="/blog/2020/07/kotlin-%E4%BA%8C.html"/>
      <url>/blog/2020/07/kotlin-%E4%BA%8C.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>android 动画</title>
      <link href="/blog/2020/07/android-%E5%8A%A8%E7%94%BB.html"/>
      <url>/blog/2020/07/android-%E5%8A%A8%E7%94%BB.html</url>
      
        <content type="html"><![CDATA[<h1 id="android动画"><a href="#android动画" class="headerlink" title="android动画"></a>android动画</h1><p>动画分为两类，传统动画、属性动画</p><h2 id="传统动画"><a href="#传统动画" class="headerlink" title="传统动画"></a>传统动画</h2><p>传统动画又分为帧动画、补间动画</p><h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>是通过在特定帧显示不同图片，使连贯起来在视觉上看起来像动画。<br>有点类似与gif</p><p>将图片资源放入到drawable文件夹<br>在drawable下新建资源文件 drawable1.xml  类型：animation-list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image1&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image2&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image3&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=&quot;@drawable/image4&quot;</span><br><span class="line">        android:duration=&quot;1000&quot; /&gt;</span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><p>android:drawable 指的是要显示的图片资源<br>android:duration: 图片显示时长</p><p>还有一些其它参数</p><p>在Activity中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imageView = findViewById(R.id.imageView);</span><br><span class="line">imageView.setImageResource(R.drawable.image);</span><br><span class="line">AnimationDrawable drawable = (AnimationDrawable) imageView.getDrawable();</span><br><span class="line">drawable.start();</span><br></pre></td></tr></table></figure></p><p>这样就可以让四张图片动起来了。</p><p>这样就是一个帧动画的简单样例</p><h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>补间动画分为四种类形式： alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）<br>其实就是四种动画效果，我们选择单独选择一种、也可以同时使用几种。</p><p>补间动画可以通过xml、或者代码形式实现。</p><h3 id="xml实现补间动画"><a href="#xml实现补间动画" class="headerlink" title="xml实现补间动画"></a>xml实现补间动画</h3><h4 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h4><p>在res/anim下新建文件alpha_anime.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:fromAlpha=&quot;0.0&quot;</span><br><span class="line">    android:toAlpha=&quot;1.0&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span><br><span class="line">    android:repeatMode=&quot;restart&quot;</span><br><span class="line">    android:repeatCount=&quot;infinite&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></p><p>在Activity中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animation animation = AnimationUtils.loadAnimation(this.getApplicationContext(), R.anim.alpha_anime);</span><br><span class="line">ImageView alphaImage = findViewById(R.id.alphaImageView);</span><br><span class="line">alphaImage.startAnimation(animation);</span><br></pre></td></tr></table></figure></p><p>这样就能实现图片渐隐的无限循环效果</p><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p>在res/anim下新建文件scale.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:fromXScale=&quot;0.0&quot;</span><br><span class="line">    android:fromYScale=&quot;0.0&quot;</span><br><span class="line">    android:pivotX=&quot;50%&quot;</span><br><span class="line">    android:pivotY=&quot;50%&quot;</span><br><span class="line">    android:toXScale=&quot;1.0&quot;</span><br><span class="line">    android:toYScale=&quot;1.0&quot;</span><br><span class="line">    android:repeatMode=&quot;restart&quot;</span><br><span class="line">    android:repeatCount=&quot;infinite&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line"></span><br><span class="line">    android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</span><br><span class="line">    android:fromYDelta=&quot;100%p&quot;</span><br><span class="line">    android:toYDelta=&quot;0%p&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:fromXDelta=&quot;100%&quot;</span><br><span class="line">    android:toXDelta=&quot;0%&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">    &lt;rotate</span><br><span class="line">        android:fromDegrees=&quot;0&quot;</span><br><span class="line">        android:pivotX=&quot;50%&quot;</span><br><span class="line">        android:pivotY=&quot;50%&quot;</span><br><span class="line">        android:toDegrees=&quot;359&quot;</span><br><span class="line">        android:duration = &quot;1000&quot;</span><br><span class="line">        android:drawable = &quot;@mipmap/image1&quot;</span><br><span class="line">        android:visible = &quot;true&quot;&gt;</span><br><span class="line">    &lt;/rotate&gt;</span><br><span class="line">&lt;/rotate&gt;</span><br></pre></td></tr></table></figure><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android MVP</title>
      <link href="/blog/2020/05/android-MVP.html"/>
      <url>/blog/2020/05/android-MVP.html</url>
      
        <content type="html"><![CDATA[<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>android MVP是一种开发架构，由MVC演化而来，<br>因为在MVC中，Activity层，糅合逻辑、ui操作，显得臃肿、混乱。</p><p>在MVP中，</p><ul><li>M：model，数据层</li><li>V：View，页面操作</li><li>P：Present，M、V的桥接，逻辑操作</li></ul><h2 id="MVP的优势"><a href="#MVP的优势" class="headerlink" title="MVP的优势"></a>MVP的优势</h2><ul><li>1、代码简洁，逻辑清晰</li><li>2、解耦，便于维护</li></ul><p>因为MVP将逻辑与视图分离，降低了业务耦合，使得整个代码层次分明，所以也就更好维护</p><p>下面以登陆做一个示例</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> andorid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android MVVM</title>
      <link href="/blog/2020/05/android-MVVM.html"/>
      <url>/blog/2020/05/android-MVVM.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>android 高级ui</title>
      <link href="/blog/2020/05/android-%E9%AB%98%E7%BA%A7ui.html"/>
      <url>/blog/2020/05/android-%E9%AB%98%E7%BA%A7ui.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>android 图片加载</title>
      <link href="/blog/2020/05/android-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD.html"/>
      <url>/blog/2020/05/android-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 网络请求框架</title>
      <link href="/blog/2020/05/android-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6.html"/>
      <url>/blog/2020/05/android-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 序列化</title>
      <link href="/blog/2020/05/android-%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
      <url>/blog/2020/05/android-%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="android-序列化"><a href="#android-序列化" class="headerlink" title="android 序列化"></a>android 序列化</h1><h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>将 java 对象转化为二进制过程，就是序列化，<br>将二进制转化为 java 对象的过程，就是反序列化</p><h2 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h2><p>在下面几种场景下我们需要序列化</p><ul><li>永久性保存对象，保存对象的字节序列到本地文件中；</li><li>对象在网络中传递；</li><li>对象在 IPC 间传递（进程通信）</li></ul><h2 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h2><p>序列化有两种方法，java 中自带的实现 Serializable，android 中特有的 Parcelable</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>Serializable 接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。<br>新建类实现 Serializable，Serializable 为空接口，没有要实现的方法， 需要 定义一个静态常量 serialVersionUID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SerBean implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 263894729013938L;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public SerBean(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这个类的序列化就完成了。</p><p>Serializable 序列化过程其实是将数据写入到文件，而反序列化则是将读取文件中的数据，重新生成对象。</p><h4 id="Serializable-原理"><a href="#Serializable-原理" class="headerlink" title="Serializable 原理"></a>Serializable 原理</h4><ul><li>序列化：将对象写入到 IO 流中，并保存信息到文件中</li><li>反序列化：从文件中读取信息， 然后构建 IO 流中恢复对象。 反序列化过程并没有调用构造函数，而是 JVM 生成</li></ul><h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParBean</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统自动添加，给createFromParcel里面用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ParBean</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;ParBean&gt; CREATOR = <span class="keyword">new</span> Creator&lt;ParBean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         *createFromParcel()方法中我们要去读取刚才写出的name和age字段，</span></span><br><span class="line"><span class="comment">         * 并创建一个Person对象进行返回，其中color和size都是调用Parcel的readXxx()方法读取到的，</span></span><br><span class="line"><span class="comment">         * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。</span></span><br><span class="line"><span class="comment">         * 读取的工作我们利用一个构造函数帮我们完成了</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ParBean <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ParBean(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//供反序列化本类数组时调用的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ParBean[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ParBean[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容接口描述，默认返回0即可。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name); <span class="comment">// 写出name</span></span><br><span class="line">        dest.writeInt(age); <span class="comment">// 写出age</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------下面为自己写的构造函数和get set</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParBean</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parcelable 序列号是在内存空间进行的。</p><h3 id="Parcelable-原理"><a href="#Parcelable-原理" class="headerlink" title="Parcelable 原理"></a>Parcelable 原理</h3><p>Parcelable 是序列话过程是通过 native 函数进行的，属性是通过指针偏移来保存信息，所以反序列化过程读取属性的顺序必须要与写入属性的过程一样，否则会反序列化失败。<br>简单理解就是将 java 中对象的各个属性都保存到 native 空间，然后将各个地址指针存放到 java 引用中，<br>当反序列化时，调用 writeToParcel 写入保存到 native 空间中的属性，然后调用 createFromParcel 生成实例对象，然后就完成了整个反序列化过程。</p><p>writeToParcel 中的 write 顺序要与 protected 构造函数中的 read 顺序保持一致，否则会在反序列化时出错。</p><h2 id="序列化方案区别"><a href="#序列化方案区别" class="headerlink" title="序列化方案区别"></a>序列化方案区别</h2><p>上面讲了两个序列化方案，<br>Serializable：是 java 就有的，代码量少，但在序列化时，会产生大量的临时对象，容易造成频繁的 minor GC</p><p>Parcelable：android 特有的，代码量比 Serializable 要多，但使用效率高，且没那么占内存</p><p>因为在选择序列化时，优先使用 Parcelable，但有一种情况特殊，当数据保存在磁盘上时，Parcelable 在外界有变化的情况下，<br>不能很好的保证数据的连续性，因此在此种场景下推荐使用 Serializable；</p><p>选择序列化方法的原则</p><p>1）在使用内存的时候，Parcelable 比 Serializable 性能高，所以推荐使用 Parcelable。</p><p>2）Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。</p><p>3）Parcelable 不能使用在要将数据存储在磁盘上的情况，因为 Parcelable 不能很好的保证数据的持续性在外界有变化的情况下。尽管 Serializable 效率低点，但此时还是建议使用 Serializable 。</p><h2 id="序列化某种程度来说并不安全"><a href="#序列化某种程度来说并不安全" class="headerlink" title="序列化某种程度来说并不安全"></a>序列化某种程度来说并不安全</h2><ul><li><p>因为序列化的对象数据转换为二进制，并且完全可逆。但是在 RMI 调用时<br>所有 private 字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的</p></li><li><p>解决方案<br>1、 序列化 Hook 化（移位和复位）<br>2、 序列数据加密和签名<br>3、 利用 transient 的特性解决<br>4、 打包和解包代理</p></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>static 和 transient 字段不能被序列化（感兴趣的同学可以深入研究下）</li></ul><p>因为 static 修饰的变量不属于对象，而是属于类</p><h3 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h3><p>如果一个可序列化的类的成员不是基本类型，也不是 String 类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kotlin</title>
      <link href="/blog/2020/05/kotlin.html"/>
      <url>/blog/2020/05/kotlin.html</url>
      
        <content type="html"><![CDATA[<h1 id="kotlin学习"><a href="#kotlin学习" class="headerlink" title="kotlin学习"></a>kotlin学习</h1><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>新建一个kt文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args:Array&lt;String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主入口main方法， 无需新建类即可运行，函数声明用fun</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a:Int, b:Int):Int&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值写在参数之后 </p><p>表达式可以作为函数体，返回值类型自动推断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sun(a:Int, b:Int) = a+b;</span><br></pre></td></tr></table></figure></p><p>返回无意义的值用Unit表示</p><p>fun test():Unit {<br>    println(“test”);<br>}</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><p>变量赋值声明关键字：var、val<br>var：声明变量<br>val：声明常量</p><p>var i:Int = 1;<br>val PI:Double = 3.14;</p><p>当声明并赋值时，数据类型可以省略, 会自动推断数据类型<br>var i = 1;<br>val PI = 3.14</p><p>当声明但不赋值时，不能省略数据类型<br>var i:Int;<br>val PI:Double;</p><h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;aaaaa&quot;;</span><br><span class="line">var b = &quot;str = $s&quot;;</span><br><span class="line">var c = &quot;$&#123;b.replace(&quot;str&quot;, &quot;who&quot;)&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun testIf(a:Int, b:Int):Int &#123;</span><br><span class="line">    if(a &gt; b) return a;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kotlin中，if还可以用作表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun max(a:Int, b:Int) = if(a &gt; b) a else b</span><br></pre></td></tr></table></figure><h2 id="空值与null检测"><a href="#空值与null检测" class="headerlink" title="空值与null检测"></a>空值与null检测</h2><p>当某个值可以为空时，需要在类型后添加?表示可以为空<br>此时，声明时不能省略类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj:Objects ? = null;</span><br><span class="line">// 表示返回值可以为null</span><br><span class="line">fun parseInt(str:String):Int?&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型检测与自动类型转换"><a href="#类型检测与自动类型转换" class="headerlink" title="类型检测与自动类型转换"></a>类型检测与自动类型转换</h2><p>is:判断数据是否是某个类型。如果一个不可变的局部变量已经被判断为某个类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun getStringLength(obj: Any): Int? &#123;</span><br><span class="line">    if (obj is String) &#123;</span><br><span class="line">        // 如果走到了这里，说明判断出obj时String，虽然方法参数里obj声明的是any，但是此时已经不需要显式的将obj转为String</span><br><span class="line">        return obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 强调为不可变是因为如果可变，那可能会变成其他类型，那就不适用了 </strong></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;apple&quot;, &quot;banana&quot;, &quot;&quot;kiwifruit);</span><br><span class="line">// 根据元素遍历</span><br><span class="line">for (item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据下标便利</span><br><span class="line">for (item in items.indices) &#123;</span><br><span class="line">    println(items[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = 0;</span><br><span class="line">while (index &lt; items.size) &#123;</span><br><span class="line">    println(items[index]);</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private fun testWhen(s: Any?) &#123;</span><br><span class="line">        when(s) &#123;</span><br><span class="line">            &quot;a&quot; -&gt; 1;</span><br><span class="line">            &quot;b&quot; -&gt; 2;</span><br><span class="line">            is String -&gt; 3;</span><br><span class="line">            1 -&gt; &quot;n&quot;;</span><br><span class="line">            2 -&gt; &#123;</span><br><span class="line">              println(&quot;222&quot;);  </span><br><span class="line">            &#125;;</span><br><span class="line">            else -&gt; &quot;else&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有点类似java中的 switch</p><h2 id="区间-range"><a href="#区间-range" class="headerlink" title="区间 range"></a>区间 range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 6;</span><br><span class="line">var y = 9;</span><br><span class="line">if(x in 0..y) &#123;</span><br><span class="line">    println(&quot;x in 0 - y&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：区间只用于数字</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的迭代可以用的上面的 for in 循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var items = listof(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">for(item in items) &#123;</span><br><span class="line">    println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断集合中是否包含某元素 用while in || when<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (&quot;a&quot; in items) &#123;</span><br><span class="line">    println(&quot;items include a&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when &#123;</span><br><span class="line">    &quot;a&quot; in items -&gt; println(&quot;aaa&quot;);</span><br><span class="line">    &quot;d&quot; in items -&gt; println(&quot;ddd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用lambda来过滤和映射集合 ，与java8 lambda stream大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.filter&#123; it.indexOf(&quot;a&quot;) &gt;= 0 &#125;</span><br><span class="line">    .sortBy&#123; it &#125;</span><br><span class="line">    .map&#123; it.toUpperCase() &#125;</span><br><span class="line">    .forEach&#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>什么是协程？<br>官方原话：协程是一种并发设计模式，您可以在 Android 平台上使用它来简化异步执行的代码。<br>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。</p><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。<br>CPU调度线程是基于时间片轮转算法实现，当线程过多时，每个时间片中切换、挂起线程就占用了接近一半的时间，执行效率非常低。<br>而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p><p>协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。</p><p>build.gralde中引入依赖<br>implementation “org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1”</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity4 : AppCompatActivity() &#123;</span><br><span class="line">    val TAG = &quot;MainActivity4&quot;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main2)</span><br><span class="line">        test()</span><br><span class="line">        Log.e(TAG,&quot;线程main ：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun test() = runBlocking &#123;</span><br><span class="line">        repeat(8) &#123;</span><br><span class="line">            Log.e(TAG, &quot;协程执行$it 线程id：$&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>协程执行0 线程id：1<br>协程执行1 线程id：1<br>协程执行2 线程id：1<br>协程执行3 线程id：1<br>协程执行4 线程id：1<br>协程执行5 线程id：1<br>协程执行6 线程id：1<br>协程执行7 线程id：1<br>线程main ：1</p><p>我们可以得出结论：<br>runBlocking会阻塞线程，但允许还是在当前线程</p><h3 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch:Job"></a>launch:Job</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun testJob() &#123;</span><br><span class="line">        val job = GlobalScope.launch &#123;</span><br><span class="line">            repeat(8) &#123;</span><br><span class="line">                delay(2000)</span><br><span class="line">                Log.e(TAG, &quot;testJob: 线程id:$&#123;Thread.currentThread().id&#125;&quot;, )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：<br>testJob: 线程main：2<br>testJob: 线程id:6809<br>testJob: 线程id:6807<br>testJob: 线程id:6807<br>testJob: 线程id:6815<br>testJob: 线程id:6807<br>testJob: 线程id:6808<br>testJob: 线程id:6818<br>testJob: 线程id:6809</p><p>说明使用GlobalScope.launch </p><ul><li>并不是在单一线程执行的，当多个任务时，系统自动创建线程、分配线程来执行任务</li><li>是非阻塞、异步执行，相当于开启了子线程</li></ul><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun testAsync()&#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        var result1 = GlobalScope.async &#123;</span><br><span class="line">            getResult1()</span><br><span class="line">        &#125;</span><br><span class="line">        var result2 = GlobalScope.async &#123;</span><br><span class="line">            getResult2()</span><br><span class="line">        &#125;</span><br><span class="line">        val result = result1.await() + result2.await()</span><br><span class="line">        Log.e(TAG, &quot;testAsync: ThreadId =  $&#123;Thread.currentThread().id&#125; result = $&#123;result&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult1():Int &#123;</span><br><span class="line">    delay(3000)</span><br><span class="line">    Log.e(TAG, &quot;getResult1: ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private suspend fun getResult2():Int &#123;</span><br><span class="line">    delay(5000)</span><br><span class="line">    Log.e(TAG, &quot;getResult2:  ThreadId =  $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    return 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>E/MainActivity4: 线程main ：2<br>E/MainActivity4: getResult1: ThreadId =  7870<br>E/MainActivity4: getResult2:  ThreadId =  7870<br>E/MainActivity4: testAsync: ThreadId =  7870 result = 9</p><p> 其中当打印getResult2后就打印了testAsync: result = 9<br> 阻塞时间为5秒，而不是8秒，说明getResult1、getResult2是并行的。</p><p>而且发现 threadId都一样，说明处于同一个线程。<br>但是其实并不是一定处于同一个线程，如果多尝试几次，肯定也会出现完全不一样的结果。</p><ul><li>协程并不等于线程，协程内部会根据任务情况自动调度线程。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react 掉起摄像头</title>
      <link href="/blog/2020/05/react-%E6%8E%89%E8%B5%B7%E6%91%84%E5%83%8F%E5%A4%B4.html"/>
      <url>/blog/2020/05/react-%E6%8E%89%E8%B5%B7%E6%91%84%E5%83%8F%E5%A4%B4.html</url>
      
        <content type="html"><![CDATA[<p>在h5中掉起摄像头，<br>碰到一些问题，<br>无法切换到后置摄像头 —-&gt; 将本地http 改为https就可以了<br>chrome浏览器报错：不支持访问用户媒体 —》  将本地http 改为https就可以了</p><p>npm start默认采用的是http协议<br>而npm start其实执行的脚本是react-script/start.js文件<br>查看 79行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const protocol = process.env.HTTPS === &apos;true&apos; ? &apos;https&apos; : &apos;http&apos;;</span><br></pre></td></tr></table></figure></p><p>我们只要在环境变量中将HTTPS设置为true即可<br>在macos 执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">code .bash_profile</span><br><span class="line">添加一行 HTTPS=true</span><br><span class="line">source .bash_profile</span><br><span class="line"></span><br><span class="line">// 也可以在终端执行</span><br><span class="line">export PORT=8081</span><br></pre></td></tr></table></figure></p><p>在 window 新增环境变量 HTTPS true<br>或者在终端执行 set HTTPS=true</p><p>本地掉起的摄像头呈现镜像 —-》css 镜像翻转 transform: ‘rotateY(180deg)’ // 水平镜像翻转180</p><p>完整代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123;StyleSheet,css&#125; from &apos;aphrodite/no-important&apos;</span><br><span class="line">import &#123; dpw, dph &#125; from &apos;../../common/tool/ScreenFit&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class AliveCheck extends React.PureComponent &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">        this.video = document.getElementById(&apos;video&apos;);</span><br><span class="line">        this.canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">        this.context = this.canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">        const constraints = &#123;</span><br><span class="line">            audio: false,</span><br><span class="line">            video : &#123;</span><br><span class="line">                width: 480,</span><br><span class="line">                height: 320,</span><br><span class="line">                sourceId: &apos;default&apos;,</span><br><span class="line">                facingMode: &#123; exact: &quot;environment&quot; &#125;,</span><br><span class="line">                // facingMode:  &#123; exact: &quot;user&quot; &#125;,</span><br><span class="line">                permissions: &#123;</span><br><span class="line">                    &quot;audio-capture&quot;: &#123;</span><br><span class="line">                        &quot;description&quot;: &quot;Required to capture audio using getUserMedia()&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;video-capture&quot;: &#123;</span><br><span class="line">                        &quot;description&quot;: &quot;Required to capture video using getUserMedia()&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象</span><br><span class="line">        if (navigator.mediaDevices === undefined) &#123;</span><br><span class="line">            navigator.mediaDevices = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123;</span><br><span class="line">            //调用用户媒体设备, 访问摄像头</span><br><span class="line">            this.getUserMedia(constraints, this.success, this.error);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            alert(&apos;不支持访问用户媒体&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //访问用户媒体设备的兼容方法</span><br><span class="line">    getUserMedia =(constraints, success, error) =&gt; &#123;</span><br><span class="line">        if (navigator.mediaDevices.getUserMedia) &#123;</span><br><span class="line">          //最新的标准API</span><br><span class="line">          navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error);</span><br><span class="line">        &#125; else if (navigator.webkitGetUserMedia) &#123;</span><br><span class="line">          //webkit核心浏览器</span><br><span class="line">          navigator.webkitGetUserMedia(constraints,success, error)</span><br><span class="line">        &#125; else if (navigator.mozGetUserMedia) &#123;</span><br><span class="line">          //firfox浏览器</span><br><span class="line">          navigator.mozGetUserMedia(constraints, success, error);</span><br><span class="line">        &#125; else if (navigator.getUserMedia) &#123;</span><br><span class="line">          //旧版API</span><br><span class="line">          navigator.getUserMedia(constraints, success, error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    success =(stream) =&gt; &#123;</span><br><span class="line">        //兼容webkit核心浏览器</span><br><span class="line">        let CompatibleURL = window.URL || window.webkitURL;</span><br><span class="line">        //将视频流设置为video元素的源</span><br><span class="line">        console.log(stream);</span><br><span class="line">  </span><br><span class="line">        //video.src = CompatibleURL.createObjectURL(stream);</span><br><span class="line">        this.video.srcObject = stream;</span><br><span class="line">        this.video.play();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    error =(error)=&gt; &#123;</span><br><span class="line">        console.log(`访问用户媒体设备失败$&#123;error.name&#125;, $&#123;error.message&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    takePhoto =() =&gt; &#123;</span><br><span class="line">        alert(&apos;takePhoto&apos;)</span><br><span class="line">        this.context.drawImage(this.video, 0, 0, 480, 320); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopCamera =() =&gt; &#123;</span><br><span class="line">        if (!this.video.srcObject) return</span><br><span class="line">        let stream = this.video.srcObject</span><br><span class="line">        let tracks = stream.getTracks();</span><br><span class="line">        tracks.forEach(track =&gt; &#123;</span><br><span class="line">            track.stop()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div className=&#123;css(styles.box)&#125;&gt;</span><br><span class="line">                &lt;video className=&#123;css(styles.video)&#125; id=&quot;video&quot; width=&quot;480&quot; height=&quot;320&quot; controls&gt;&lt;/video&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;button id=&quot;capture&quot; onClick=&#123;this.takePhoto&#125;&gt;拍照&lt;/button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;canvas id=&quot;canvas&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">    box: &#123;</span><br><span class="line">        display: &apos;flex&apos;,</span><br><span class="line">        width: &apos;100%&apos;,</span><br><span class="line">        height: &apos;100%&apos;,</span><br><span class="line">        flexDirection: &apos;column&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    video: &#123;</span><br><span class="line">        // 水平镜像翻转180</span><br><span class="line">        transform: &apos;rotateY(180deg)&apos;, </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日常记录</title>
      <link href="/blog/2020/05/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95.html"/>
      <url>/blog/2020/05/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95.html</url>
      
        <content type="html"><![CDATA[<p>i++<br>++ 在后，先运算完当前结果，再给i赋值</p><p>ex：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object [] obj = new Object [16]</span><br><span class="line">i = 0；</span><br><span class="line">obj[i ++] = &quot;obj&quot;</span><br><span class="line">// 会先执行</span><br><span class="line">obj[0]=&quot;obj&quot;;</span><br><span class="line">// 再执行</span><br><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure></p><p>–i;<br>– 在前，则先给i赋值，再执行当前运算</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>位操作符</title>
      <link href="/blog/2020/05/%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.html"/>
      <url>/blog/2020/05/%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.html</url>
      
        <content type="html"><![CDATA[<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>逻辑 与<br>A &amp; B<br>将A、B都转化为二进制，同为均为1则为1，否则为0</p><p>ex：5 &amp; 8<br>0000 0101<br>&amp;<br>0000 1000</p><p>result ： 0000 0000 结果就是0</p><p>逻辑或<br>A | B<br>将A、B都转化为二进制，同为有一位为1则为1，否则为0<br>ex ： 5 &amp; 8<br>0000 0101<br>&amp;<br>0000 1000</p><p>result ： 0000 1101 结果就是13</p><p>逻辑非</p><p>逻辑异或</p><blockquote><blockquote></blockquote><p>5&gt;&gt;2</p></blockquote><p>0000 0101 &gt;&gt; 2  — 0000 0001  === 1</p><p>像右移2<br>左移运算符，&gt;&gt;&gt; </p><p>&lt;&lt; </p><p>5 &lt;&lt; 2<br>像左移2<br>0000 0101 &lt;&lt; 2 – 0001 0100 === 20<br>左移运算符，</p><blockquote><blockquote><blockquote><p>无符号移动 无符号右移，忽略符号位，空位都以0补齐</p></blockquote></blockquote></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 枚举</title>
      <link href="/blog/2020/05/java-%E6%9E%9A%E4%B8%BE.html"/>
      <url>/blog/2020/05/java-%E6%9E%9A%E4%B8%BE.html</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>enum 的全程事 Enumeration 是jdk1.5引进的</p><p>被enum 修饰的数据类型就是枚举类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Test &#123; TEST0, TEST1, TEST2 &#125;</span><br></pre></td></tr></table></figure></p><p>如果枚举不添加任何方法，枚举值默认为从0开始的递增数值，ru上面的： TEST0：0， TEST1：1，TEST2：2</p><p>枚举的好处：可以将常量组织起来，便于管理<br>应用场景：状态码：错误码</p><h2 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h2><p>枚举的本质是一个类，受限制的类</p><p>创建enum是，编译器会自动为你生成一个相关的类，这个类继承 <strong> java.lang.Enum </strong></p><p>b编译过后其实是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;</span><br><span class="line">        implements Comparable&lt;E&gt;, Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>是一个抽象类，并且继承了Comparable以及Serializable，也就是标记了序列化</p><p>而且枚举可以添加自己的方法、变量，但是不能为枚举常量用 “=”赋值，但不能继承其他类，因为已经继承了Enum类，也不能被继承。</p><p>枚举可以实现接口，像上面就是内部实现了两个接口，我们也可以自己实现其他接口</p><h2 id="枚举添加方法"><a href="#枚举添加方法" class="headerlink" title="枚举添加方法"></a>枚举添加方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public enum  TestEnum &#123;</span><br><span class="line"></span><br><span class="line">    //此处调用额其实就是下面写的构造函数</span><br><span class="line">     TEST(22),</span><br><span class="line">    TEST1(33),</span><br><span class="line">    TEST2(44),</span><br><span class="line">    TEST3(55);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private TestEnum(int num) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 泛型</title>
      <link href="/blog/2020/05/java-%E6%B3%9B%E5%9E%8B.html"/>
      <url>/blog/2020/05/java-%E6%B3%9B%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<p>声明中有一个或者多个类型化参数的类或者接口，叫做泛型类或者接口。泛型类和接口统称为泛型。</p><p>泛型是一种安全规范，帮助我们在编译前就发现类型安全问题，而不需要等到编译报错。泛型在编译时会被擦除。</p><p>关于使用泛型的几个规则：</p><ul><li>请不要使用原生态类型<br>如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势</li><li><p>消除非受检的警告</p></li><li><p>优先考虑泛型</p></li><li><p>优先考虑泛型方法</p></li></ul><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>无限通配符 ？<br>上界通配符 ？ extends T —&gt; T 以及 T 的子類 （子類的子類不行）<br>下界通配符 ? super T —-&gt; T 以及 T 的父類 （父類的父類不行）</p><h2 id="范型的好处"><a href="#范型的好处" class="headerlink" title="范型的好处"></a>范型的好处</h2><ul><li>更安全</li><li>更规范</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 集合</title>
      <link href="/blog/2020/05/java-%E9%9B%86%E5%90%88.html"/>
      <url>/blog/2020/05/java-%E9%9B%86%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<p>java中的集合包括map、set、list</p><p>collection</p><p>所有的linked 都是链表实现<br>所有的hash 都是hash表，存储的对象都需要重写hashcode、equas函数</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多进程通信 IBinder</title>
      <link href="/blog/2020/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-IBinder.html"/>
      <url>/blog/2020/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-IBinder.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wechat-app</title>
      <link href="/blog/2020/05/wechat-app.html"/>
      <url>/blog/2020/05/wechat-app.html</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> wechatApp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kotlin 类</title>
      <link href="/blog/2020/05/kotlin.html"/>
      <url>/blog/2020/05/kotlin.html</url>
      
        <content type="html"><![CDATA[<h1 id="kotlin-类"><a href="#kotlin-类" class="headerlink" title="kotlin 类"></a>kotlin 类</h1><p>kotlin中使用class申明类</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数分为主构造函数、次构造函数</p><h2 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h2><p>kotlin中可以在申明类时申明一个构造函数，并且次构造函数为 主构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 申明了主构造函数</span><br><span class="line">class Person constructor(var name: String, var age: Int ) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果主构造函数没有使用任何注解或者修饰符，则可以省略constructor关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person (var name: String, var age: Int ) &#123;&#125;</span><br></pre></td></tr></table></figure><p>主构造函数不能含有代码块，有需要初始化的代码可以放在以init关键字作为前缀的初始化块中。<br>其中init可以申明多个，会根据代码顺序来执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person (var name: String, var age: Int ) &#123;</span><br><span class="line">    var myName = name;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;this person&apos;s name was $&#123;myName&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot; test  &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有申明主构造函数，系统会自动创建一个无参的主构造函数。</p><h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>次构造函数必须要用constructor申明，<br>如果有主构造函数，必须将次构造函数委托给主构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyPerson(str: String, var age: Int) &#123;</span><br><span class="line"></span><br><span class="line">    var name = str;</span><br><span class="line">    var tall:Double? = null;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init test $&#123;name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(str: String, age: Int, tall: Double?):this(str, age) &#123;</span><br><span class="line">        this.tall = tall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化init代码块实际上会成为主构造函数的一部分。<br>当次级构造函数委托给主构造函数，init代码块会成为次级构造函数的第一句语句。<br>即使该类没有主构造函数，这种委托也会隐式发生，仍会执行初始化代码块。</p><p>如果一个非抽象类没有申明任何主、次构造函数，默认会生成一个不带参的主构造函数。<br>函数的可见性为public。如果不想类有一个公有构造函数，需要声明一个private的主构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class TestClass private constructor () &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在JVM上，如果主构造函数中的所有参数都有默认值，则会默认生成一个额外的无参构造函数，它将使用默认值。</p><h2 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h2><p>kotlin 在创建实例时，不需要new 关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyPerson(str: String, var age: Int) &#123;&#125;</span><br><span class="line">var person = MyPerson(&quot;jack&quot;, 11);</span><br></pre></td></tr></table></figure></p><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><ul><li>构造函数与初始化代码块</li><li>函数</li><li>属性</li><li>嵌套类、内部类</li><li>对象申明</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在kotlin中，所有类都有一个超类 Any，这对于没有超类型声明的类是默认超类：</p><p>var oneClass; // 从Any隐式继承</p><p>Any 类中有三个方法 equas()、 hashcode()、 toString(), 因此所有kotlin类都定义有这三个方法</p><p>默认情况下，kotlin中类都是final 的，不可被继承，如果需要声明该类可以被继承，需要使用关键字 open。</p><p>并且kotlin中是使用 : 来表示继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open class TestClassSuper &#123;&#125;</span><br><span class="line">class TestClassChild : TestClassSuper &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果超类中有声明主构造函数，<br>则子类可以声明主构造函数，则并必须用子类中主构造函数参数初始化超类。<br>如果子类没有声明主构造函数，则必须声明次级构造函数，并且使用super初始化基类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">open class MyPerson(str: String, var age: Int) &#123;</span><br><span class="line">    var name = str;</span><br><span class="line">    var tall:Double? = null;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init test $&#123;name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(str: String, age: Int, tall: Double?):this(str, age) &#123;</span><br><span class="line">        this.tall = tall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Test2 : MyPerson &#123;</span><br><span class="line">    constructor(str: String, age: Int):super(str, age);</span><br><span class="line">    constructor(str: String, age: Int, tall: Double?): super(str, age, tall);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="函数的重写"><a href="#函数的重写" class="headerlink" title="函数的重写"></a>函数的重写</h4><p>正如类的继承需要申明open标识该类开放继承，<br>类中的函数标识可以被重写也是需要使用open申明，如果没有函数没有申明open，<br>则在子类中不允许出现同名并且同参数类型的函数。<br>出现同名但不同参数的函数时允许的，正如java中的重载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">open class MyPerson(str: String, var age: Int) &#123;</span><br><span class="line">    var name = str;</span><br><span class="line">    var tall:Double? = null;</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init test $&#123;name&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(str: String, age: Int, tall: Double?):this(str, age) &#123;</span><br><span class="line">        this.tall = tall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open fun testMethod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun test1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  TestPerson(str: String, age: Int) : MyPerson(str, age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Test2 : MyPerson &#123;</span><br><span class="line">    constructor(str: String, age: Int):super(str, age);</span><br><span class="line">    constructor(str: String, age: Int, tall: Double?): super(str, age, tall);</span><br><span class="line"></span><br><span class="line">    override fun testMethod() &#123;</span><br><span class="line">        super.testMethod()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun test1(str:String) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性的重写"><a href="#属性的重写" class="headerlink" title="属性的重写"></a>属性的重写</h4><p>同函数的重写，属性的重写也是需要使用open标识，并在子类中使用override<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open var i = 2;</span><br><span class="line"></span><br><span class="line">// childClass</span><br><span class="line">override var i = 4;</span><br></pre></td></tr></table></figure></p><p>在属性的重写中，有一点需要注意，<br>可以用var 重写val，却不能用val重写var；这一点是和java不一样的。<br>因为用val申明的属性本质上申明了get方法，而将其重写为var只是在子类新增了一个set方法</p><h3 id="派生类的初始化顺序"><a href="#派生类的初始化顺序" class="headerlink" title="派生类的初始化顺序"></a>派生类的初始化顺序</h3><p>1、进入子类的构造函数<br>2、进入父类的构造函数并完成初始化<br>3、进入父类的init代码块<br>4、父类中属性的初始化<br>5、子类构造函数完成初始化<br>6、子类init代码块<br>7、子类属性初始化</p><h3 id="调用父类方法或属性"><a href="#调用父类方法或属性" class="headerlink" title="调用父类方法或属性"></a>调用父类方法或属性</h3><p>可以使用super关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 方法</span><br><span class="line">super.method();</span><br><span class="line">// 属性</span><br><span class="line">super.nema;</span><br></pre></td></tr></table></figure></p><p>内部类中调用外部类父类属性或方法，使用super@Outer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super@OutClass.method();</span><br></pre></td></tr></table></figure></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android dialog </title>
      <link href="/blog/2020/05/android-dialog.html"/>
      <url>/blog/2020/05/android-dialog.html</url>
      
        <content type="html"><![CDATA[<h1 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a>dialog</h1><p>在日常开发时会经常使用到弹窗dialog</p><p>针对自定义视图的弹窗使用方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder builder = new AlertDialog.Builder(context);</span><br><span class="line">LayoutInflater inflater = context.getLayoutInflater();</span><br><span class="line">View view = inflater.inflate(R.layout.view, null);</span><br><span class="line">build.setView(view);</span><br><span class="line"></span><br><span class="line">AlertDialog dialog = build.create();</span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure><p>上面就是一个AlertDialog实例的创建过程，其中AlertDialog使用了创建者模式。</p><p>关于点击弹窗其他部分、点击手机back而不关闭dialog的方法有如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dialog.setCancelable(false); // 点击back、其他部位都不关闭弹窗</span><br><span class="line">dialog.setCanceledOnTouchOutside(false);// 点击其他部位不关闭、点back关闭</span><br></pre></td></tr></table></figure></p><p>设置dialog弹窗的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在dialog.show() 之后</span><br><span class="line">Window window = dialog.getWindow();</span><br><span class="line">if(window != null) &#123;</span><br><span class="line">    WindowManager.LayoutParams attr = window.getAttributes();</span><br><span class="line">    if (attr != null) &#123;</span><br><span class="line">        attr.height = ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        attr.width = ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        window.setAttributes(attr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就将dialog窗口大小设置为了最大，但是可以发现我们的弹窗还是没有充满整个屏幕，因为dialog默认的主题theme就是偏距margin的，<br>所以如果我们想要充满整个屏幕的话，需要改变我们dialog的主题，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// AlertDialog.Builder builder = new AlertDialog.Builder(context);</span><br><span class="line">AlertDialog.Builder builder = new AlertDialog.Builder(context, R.style.AppTheme);</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java流</title>
      <link href="/blog/2020/05/java%E6%B5%81.html"/>
      <url>/blog/2020/05/java%E6%B5%81.html</url>
      
        <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java范型</title>
      <link href="/blog/2020/05/java%E8%8C%83%E5%9E%8B.html"/>
      <url>/blog/2020/05/java%E8%8C%83%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h1><p>上通配符 ? extends T —&gt; T 以及 T 的子类（子类的子类不行）—-&gt; 集合读取</p><p>下通配符 ? super T —-&gt; T 以及 T 的父类（父类的父类不行） —-&gt; 集合存放</p><p>通用通配符 ?</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm 线程私有区</title>
      <link href="/blog/2020/05/jvm-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA.html"/>
      <url>/blog/2020/05/jvm-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="jvm-线程私有区"><a href="#jvm-线程私有区" class="headerlink" title="jvm 线程私有区"></a>jvm 线程私有区</h1><p>jvm从多线程角度看，分为线程共享区、线程私有区</p><p>而在线程私有区中有：程序计数器、方法栈区（包括虚拟机栈、本地方法栈）</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响</p><p>jvm的多线程是通过cpu时间片轮转算法实现的，某个线程在执行过程中会因为时间片耗尽而被挂起，其他线程获得时间片开始执行。当被挂起的线程重新获取到<br>时间片，它要想从之前被挂起的地方开始执行，就需要知道之前执行到了哪里，在jvm中，通过程序计数器来记录字节码执行的位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。</p><h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><p>1、线程隔离：每个线程都有自己的程序计数器<br>2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址<br>3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。<br>4.程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。<br>5.程序计数器，是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域。</p><h2 id="方法栈区"><a href="#方法栈区" class="headerlink" title="方法栈区"></a>方法栈区</h2><p>线程在运行时，在执行每一个方法的时候都会打包成一个栈帧，然后将栈帧入栈，当方法执行完时，就会将该栈帧出栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。</p><p>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p><h2 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h2><p>栈帧中含有：局部变量表、操作数据栈、动态链接、返回地址</p><p>局部变量表:顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。<br>操作数据栈：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作<br>动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法），动态特性（Groovy、JS、动态代理）<br>返回地址:正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 锁</title>
      <link href="/blog/2020/05/java-%E9%94%81.html"/>
      <url>/blog/2020/05/java-%E9%94%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="java中使用锁，主要是用于解决多线程并发问题"><a href="#java中使用锁，主要是用于解决多线程并发问题" class="headerlink" title="java中使用锁，主要是用于解决多线程并发问题"></a>java中使用锁，主要是用于解决多线程并发问题</h1><p>多个线程对某个对象进行操作，就存在并发问题。</p><p>java内存规定了，所有变量都储存在主内存中，每个线程又有自己的工作内存</p><p>线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存</p><p>线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。</p><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>注意：锁作用的都是对象，在对象的内存空间中，有标志位标记是有有锁。</p><h2 id="并发三要素"><a href="#并发三要素" class="headerlink" title="并发三要素"></a>并发三要素</h2><p>原子性：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行。</p><p>可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行。</p><h2 id="解决并发问题"><a href="#解决并发问题" class="headerlink" title="解决并发问题"></a>解决并发问题</h2><h3 id="volatile：保证可见性，不保证原子性"><a href="#volatile：保证可见性，不保证原子性" class="headerlink" title="volatile：保证可见性，不保证原子性"></a>volatile：保证可见性，不保证原子性</h3><p>当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中</p><p>这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见</p><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>指令重排序是指编译器和处理器为了优化程序性能对指令进行排序的一种手段，需要遵守一定规则</p><p>不会对存在依赖关系的指令重排序，例如 a = 1;b = a; a 和b存在依赖关系，不会被重排序</p><p>不能影响单线程下的执行结果。比如：a=1;b=2;c=a+b这三个操作,前两个操作可以重排序，但是c=a+b不会被重排序，因为要保证结果是3</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对于一个变量，单个线程写，其他线程读，这个时候就可以使用volatile来修饰这个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Utils &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Utils instance;</span><br><span class="line"></span><br><span class="line">    public static Utils getInstance() &#123;         // 1</span><br><span class="line">        if(instance == null) &#123;                  // 2</span><br><span class="line">            synchronized(Utils.class) &#123;         // 3</span><br><span class="line">                if(instance == null) &#123;          // 4</span><br><span class="line">                    instance = new Utils();     // 5</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个对象有如下步骤：<br>分配内存，<br>初始化对象，<br>指向内存</p><p>如上代码，如果不使用volatile修饰，这时候如果发生指令重排，执行顺序是132，执行到第3的时候，线程B刚好进来了，<br>并且执行到注释2，这时候判断instance 不为空，直接使用一个未初始化的对象。所以使用volatile关键字来禁止指令重排序。</p><h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><p>在jvm底层，volatile是通过内存屏障来实现的，内存屏障会提供三个功能：</p><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>它会强制将缓存的修改操作立即写到主内存</p><p>写操作会导致其它CPU中的缓存行失效，写之后，其它线程的读操作会从主内存读。</p><h3 id="valatile局限性"><a href="#valatile局限性" class="headerlink" title="valatile局限性"></a>valatile局限性</h3><p>volatile 只能保证可见性，不能保证原子性，写操作对其它线程可见，但是不能解决多个线程同时写的问题</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>多个线程同时写一个变量<br>这个时候使用Synchronized，可以保证同一时刻，只有一个线程可执行某个方法或某个代码块</p><h3 id="Synchronized锁升级"><a href="#Synchronized锁升级" class="headerlink" title="Synchronized锁升级"></a>Synchronized锁升级</h3><p>Java1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁。</p><p><strong><em> 偏向锁 </em></strong>：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><pre><code>当一个线程A访问加了同步锁的代码块时，会在对象头中存 储当前线程的id，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。</code></pre><p><strong><em> 轻量级锁 </em></strong>：在偏向锁情况下，如果线程B也访问了同步代码块，比较对象头的线程id不一样，会升级为轻量级锁，并且通过自旋的方式来获取轻量级锁。</p><p><strong><em> 重量级锁 </em></strong>：如果线程A和线程B同时访问同步代码块，则轻量级锁会升级为重量级锁，线程A获取到重量级锁的情况下，线程B只能入队等待，进入BLOCK状态。</p><h3 id="Synchromized缺陷"><a href="#Synchromized缺陷" class="headerlink" title="Synchromized缺陷"></a>Synchromized缺陷</h3><p>不能设置锁超时时间<br>不能通过代码释放锁<br>容易造成死锁</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>上面说到Synchronized的缺点，不能设置锁超时时间和不能通过代码释放锁，ReentranLock就可以解决这个问题</p><p><strong><em> 在多个条件变量和高度竞争锁的地方 </em></strong> ，<br>用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性</p><p>原文地址(<a href="https://www.jianshu.com/p/4eec21c3338e" target="_blank" rel="noopener">https://www.jianshu.com/p/4eec21c3338e</a>)</p><p>JVM内存模型、指令重排、内存屏障概念解析(<a href="https://www.cnblogs.com/chenyangyao/p/5269622.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangyao/p/5269622.html</a>)</p><p>在java中有以下锁：</p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>互斥锁/读写锁</li><li>独享锁/共享锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java 内存结构</title>
      <link href="/blog/2020/01/java-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
      <url>/blog/2020/01/java-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<h1 id="java-内存结构"><a href="#java-内存结构" class="headerlink" title="java 内存结构"></a>java 内存结构</h1><p>首先 java程序是运行在jvm(java虚拟机)中，而jvm是跨平台的。<br><img src="../../../images/java.jpg" style="zoom:80%"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器： 主要功能是记录当前线程执行程序的位置，通过改变计数值来确定执行下一条指令。每个线程的创建，都会创建一个程序计数器，并且对于每个线程而言是互相独立的。比如我们在debuger模式下运行，for循环的停止，异常的抛出，都是通过改变该线程对应的计数值来确定下一个执行指令。</p><h2 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h2><p>java虚拟机栈：主要功能是临时存储线程执行到的每个方法需要的参数，其内存空间在编译时就已确定。与程序计数器一样，每创建一个线程，则创建一个虚拟机栈，线程每执行到一个方法，对应的栈里就会创建一个栈帧，栈帧会存储局部变量表、动态链接、操作数和方法出口等信息，执行方法，栈帧入栈，方法执行完，栈帧出栈。</p><p><img src="../../../images/gc_class.jpg" style="zoom:80%"></p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与java虚拟机栈一样，只是记录native方法执行。jni native调用的c、c++函数</p><h1 id="堆得内存结构"><a href="#堆得内存结构" class="headerlink" title="堆得内存结构"></a>堆得内存结构</h1><p>分为老年代、新生代，内存比为8:2<br>其中新生代分为: edan、from、to 内存分为8:1:1<br>直接new产生的对象被分配到edan（大对象会被直接分配到老年代），当发生GC时，会通过复制清除算法，清除edan+from区域可被回收的对象，<br>而不可被回收对象会被复制到to区，而在下一次GC时，会清除edan+to区可回收对象，将不可清楚的对象复制到from区，并且每次回收时，会整理碎片内存。<br>如此反复，GC15次后，会将对象放入到老年代。</p><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>针对于老年代内存<br>格局内存可达性分析，从GC Root 不可达时，会被第一次标记为清除对象，并执行对象的ﬁnalize()方法，<br>如果这个对象被判定为有必要执行ﬁnalize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它<br>ﬁnalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象在ﬁnalize()中成功拯救自己(只需要重新与引用链上的任何一个对象建立起关联关系即可)，那在第二次标记时它将会被移除出”即将回收”的集合；如果对象这时候还是没有逃脱，那基本上它就是真的被回收了。</p><ul><li>注意：对象的finalize()方法只会被系统执行一次。</li></ul><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>gc分为minor GC、full GC<br>minor 作用区域是新生代内存、算法：复制清除算法。会整理碎片<br>full GC作用区域是老年代内存，算法：标记清除算法，不会整理碎片。</p><p>GC时判断是否可回收的依据是：内存可达化：判断堆、方法栈、静态变量、静态方法区中是否有该对象的引用。</p><p>每次 gc时会 会stw（stop the world）,线程会被挂起两次</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>在jdk1.8以前，还存在方法区，<br>方法区同 Java 堆一样是被所有线程共享的区间，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。<br>更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。常量池是方法区的一部分</p><p> JDK1.8 使用元空间 MetaSpace 替代方法区，元空间并不在 JVM中，而是使用本地内存。元空间两个参数：</p><p> MetaSpaceSize：初始化元空间大小，控制发生GC阈值<br> MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法（1）简单算法</title>
      <link href="/blog/2020/01/%E7%AE%97%E6%B3%95.html"/>
      <url>/blog/2020/01/%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法（1）简单算法"><a href="#算法（1）简单算法" class="headerlink" title="算法（1）简单算法"></a>算法（1）简单算法</h1><p>简单常见算法</p><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>针对有序的数据集，每次查找时都取中间值，逐步缩小查找范围，最后获取到目标值</p><p>复杂度：$O(log_n)$</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是针对数组的一种排序算法。<br>过程：遍历数组，计算出最值，新建一个数组，将最值放入新数组,</p><p>复杂度：$O(n^2)$</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归指函数在内部调用本身，<br>使用递归注意两个条件：基线条件、递归条件。<br>基线条件：跳出递归的条件<br>递归条件：对递归元素逐步减少的条件，<br>要合理利用这两点，不然容易无限循环。</p><p>在数组中取最大值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function findMax(arr) &#123;</span><br><span class="line">    let max = 0;</span><br><span class="line">    if(arr.length === 0) &#123;</span><br><span class="line">        return max;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        max = arr[0] &gt; max ? arr[0] : max;</span><br><span class="line">        arr.splice(0, 1);</span><br><span class="line">        return findMax(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">findMax(arr);</span><br></pre></td></tr></table></figure></p><p>递归算法与数据结构中的 栈 是及其相似的。<br>已上面的算法为例，<br>调用findMax([1,2,3,4,5])时，将findMax([1,2,3,4,5])压入栈顶，<br>而findMax会调用findMax([2,3,4,5]),然后将findMax([2,3,4,5])压入栈,<br>如下图所示：<br><img src="../../../images/recursion.jpg" style="zoom:20%"></p><p>然后从栈顶依次得出计算结果出栈。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构 (1)</title>
      <link href="/blog/2020/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.html"/>
      <url>/blog/2020/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-1-简单数据"><a href="#数据结构-1-简单数据" class="headerlink" title="数据结构 (1) - 简单数据"></a>数据结构 (1) - 简单数据</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组：有序、内存连续的数据集，</p><p>数组是有序的，顺序就是插入的顺序，先插入的值排在前面，<br>内存连续：在内存分配时，数组中的值的内存空间是分配在一起的<br>所以在我们使用数组时，推荐在申明时申明数组的长度，不然在后续插入值时可能会导致之前的数据内存空间不够，需要重新分配整个数据内存空间</p><p>数组的索引就是数组中值的下标：从0开始计数。<br>数组的查找通过索引，所以快。<br>而增删、修改时，当插入一个值，则需要将后面的数据都后移，删除也是类似。</p><p>数组查询快，增删慢<br>查询：O(1)<br>增删：O(n)<br>修改：O(n)</p><h3 id="数组查询原理"><a href="#数组查询原理" class="headerlink" title="数组查询原理"></a>数组查询原理</h3><p>我们知道通过数组查询快，但是为何快呢。</p><p>因为数组是内存连续的，当我们通过下标查询时，<br>其实是通过数组0处内存地址+下标 得出该下标对应的内存地址，然后获取存储的对象。</p><p>所以查询会快。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表：无序、内存非连续、每个节点都具有下一个节点的地址</p><p>链表是无序的，内存非连续，因为每一个节点都含有下一个节点的地址，<br>相比于数组，内存非连续，则当数据增多，也不会存在内存空间的问题，因为只需随便分配下一个节点的内存，然后将上一个节点的中含有的下一个节点地址指向最新分配的地址即可。</p><p>链表数据第一个、最后一个节点的值是明确的。<br>因为链表是无序的。所以查询慢，因为想要获取一个节点的值，需要先获取上一个节点，通过上一个节点获取到下一个节点的地址。</p><p>查询：O(n)<br>增删：O(1)<br>修改：O(1)</p><p>链表分为：<br>单链表、双链表、循环链表</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种只允许在一端进行插入或删除的线性表</p><p>栈的操作只有两种：出栈、进栈<br>特点：先进后出(FILO:first in last out)</p><p>只允许对栈顶的元素操作。<br>最先进入的元素将会被压入栈底</p><p>栈可以通过数组实现，也可以通过链表实现</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>FIFO</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 贝塞尔曲线</title>
      <link href="/blog/2020/01/android-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF.html"/>
      <url>/blog/2020/01/android-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF.html</url>
      
        <content type="html"><![CDATA[<p>在自定义view中，绘制连续的曲线时，我们经常会使用到贝塞尔曲线。</p><p>贝塞尔曲线又分成几阶贝塞尔曲线，</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android-自定义View-继承EditText</title>
      <link href="/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFEditText.html"/>
      <url>/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFEditText.html</url>
      
        <content type="html"><![CDATA[<h1 id="android-自定义View-继承EditText"><a href="#android-自定义View-继承EditText" class="headerlink" title="android-自定义View-继承EditText"></a>android-自定义View-继承EditText</h1><p>一直觉得flutter中的输入框效果不错。<br>动画，提示标题都有。<br>这次要通过自定义View, 继承重写EditText来实现同样的输入框效果</p><p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>首先确定大致思路<br>两个元素：TextView、EditText，TextView为标题，EditText为输入框展示<br>当未获取焦点时：<br>1、输入框如果已经有输入的内容，则输入框展示已输入的内容，并且TextView缩小在输入框上部<br>2、输入框如果没有输入的内容，则输入框展示的提示文本<br>当获取焦点时：<br>不管有无输入内容，提示文本缩小在输入框上部</p><p>TextView并非实质组件，只是绘制Text，当作TextView。</p><h3 id="1、先写一个类继承AppCompatEditText，并实现构造函数"><a href="#1、先写一个类继承AppCompatEditText，并实现构造函数" class="headerlink" title="1、先写一个类继承AppCompatEditText，并实现构造函数"></a>1、先写一个类继承AppCompatEditText，并实现构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AnimatedInput extends AppCompatEditText &#123;</span><br><span class="line"></span><br><span class="line"> public AnimatedInput(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnimatedInput(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initView(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AnimatedInput(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initView(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、重写onFocusChanged函数"><a href="#2、重写onFocusChanged函数" class="headerlink" title="2、重写onFocusChanged函数"></a>2、重写onFocusChanged函数</h3><p>这样获取到 是否获取焦点的标识位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) &#123;</span><br><span class="line">        super.onFocusChanged(focused, direction, previouslyFocusedRect);</span><br><span class="line">        isFocus = focused;</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3、重写onTextChanged函数"><a href="#3、重写onTextChanged函数" class="headerlink" title="3、重写onTextChanged函数"></a>3、重写onTextChanged函数</h3><p>这样获取到输入框的内容value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123;</span><br><span class="line">        super.onTextChanged(text, start, lengthBefore, lengthAfter);</span><br><span class="line">        value = text.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="4、绘制提示文本"><a href="#4、绘制提示文本" class="headerlink" title="4、绘制提示文本"></a>4、绘制提示文本</h3><p>这时候要分情况，即是否获取焦点、输入框是否有内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    // onDraw中通过getMeasuredWidth 或者 getMeasuredHeight 获取到的尺寸，就是实际测量的尺寸</span><br><span class="line">    int width = getMeasuredWidth();</span><br><span class="line">    int height = getMeasuredHeight();</span><br><span class="line">    top = getPaddingTop();</span><br><span class="line">    left = getPaddingLeft();</span><br><span class="line">    right = width - left - getPaddingRight();</span><br><span class="line">    bottom = height - top;</span><br><span class="line">    drawTitle(canvas);</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 绘制标题</span><br><span class="line"> * @param canvas</span><br><span class="line"> */</span><br><span class="line">private void drawTitle(Canvas canvas) &#123;</span><br><span class="line">    if(TextUtils.isEmpty(value)) &#123;</span><br><span class="line">        if(isFocus) &#123;</span><br><span class="line">            canvas.drawText(title, left, top + 20, focusTitlePaint);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canvas.drawText(title, left, bottom - 5 , noFocusTitlePaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        canvas.drawText(title, left, top + 20, focusTitlePaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如此就基本实现了我们的预期目标。<br>这里没有重写onMeasure函数，没有对尺寸做要求，正确的操作时需要做处理的，具体操作可以参照之前的 自定义View。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android-自定义View 继承ViewGroup</title>
      <link href="/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFViewGroup.html"/>
      <url>/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFViewGroup.html</url>
      
        <content type="html"><![CDATA[<h1 id="android-自定义View-继承ViewGroup"><a href="#android-自定义View-继承ViewGroup" class="headerlink" title="android 自定义View 继承ViewGroup"></a>android 自定义View 继承ViewGroup</h1><p>自定义ViewGroup与自定义View不同.<br>自定义View主要侧重于实现如何绘制，而自定义ViewGroup主要侧重于如何布局。<br>所以自定义ViewGroup时，必须重写onMeasure、onLayout函数。<br>onMeasure测量每个子View的大小，最后得出容器的大小<br>onLayout上根据测量的每个子View，来对每个子View进行布局</p><h2 id="自定义FlowLayout"><a href="#自定义FlowLayout" class="headerlink" title="自定义FlowLayout"></a>自定义FlowLayout</h2><p>这里我们自定义一个自动换行的流式布局。<br>效果图：<br><img src="../../../images/flowlayout.jpeg" style="zoom:20%"></p><h3 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h3><p>1、默认横向布局、当横向布局宽度要超出容器宽度时，则自动换行，<br>2、将整个视图分割成多少行，而每行又能分割成多个视图<br>3、使用两个数组，一个记录单行视图，一个记录所有行（也就是前一个数组）<br>4、每次需要换行时，记录这行的高度，当前所有视图的高度，当所有子视图计算完毕，就能知道所有子视图一起需要的宽度与高度<br>5、根据ViewGroup使用时的SpecMode来得出最后实际的宽高,并将宽高设置上去，此处onMeasure函数完成<br>6、处理onLayout，遍历所有行，遍历每一行，得到每个View的left、top、right、bottom，调用View.layout函数，将每个View相对于父容器的位置设置上去，此时就完成了布局，整个FlowLayout的设计基本完成</p><p>关于第5点，与自定义View中是一样的</p><table><thead><tr><th></th><th>EXACTLY</th><th>AT_MOST</th><th>UNSPECIFIED</th><th>&lt;-MeasureSpec</th></tr></thead><tbody><tr><td>wrap_parnet</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>match_parent</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>50dp</td><td>50dp</td><td>50dp</td><td>50dp</td><td></td></tr><tr><td>^LayoutParams</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>所以onMeasure函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        recyle();</span><br><span class="line">        // 获取各个偏距</span><br><span class="line">        int paddingLeft = getPaddingLeft();</span><br><span class="line">        int paddingRight = getPaddingRight();</span><br><span class="line">        int paddingTop = getPaddingTop();</span><br><span class="line"></span><br><span class="line">        // 先获取父容器能给的尺寸大小</span><br><span class="line">        int selfWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int selfHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        // 获取子视图的数量</span><br><span class="line">        int childViewCount = getChildCount();</span><br><span class="line">        // 记录每行中的子view</span><br><span class="line">        List&lt;View&gt;lineViews = new ArrayList&lt;&gt;();</span><br><span class="line">        int lineWidthUsed = 0; // 每行已用宽度</span><br><span class="line">        int lineHeight = 0; // 行高</span><br><span class="line"></span><br><span class="line">        int parentNeededWidth = 0;  // measure过程中，子View要求的父ViewGroup的宽</span><br><span class="line">        int parentNeededHeight = 0; // measure过程中，子View要求的父ViewGroup的高</span><br><span class="line"></span><br><span class="line">        // 遍历所有的子View</span><br><span class="line">        for (int i = 0 ; i &lt; childViewCount; i ++) &#123;</span><br><span class="line">            View childView = getChildAt(i);</span><br><span class="line">            // 获取子视图的宽、高</span><br><span class="line">            LayoutParams lp = childView.getLayoutParams();</span><br><span class="line">            // 如果View存在 因为GONE的视图不占位置</span><br><span class="line">            if(childView.getVisibility() != GONE) &#123;</span><br><span class="line">                // 获取子视图的测量规格</span><br><span class="line">                int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        paddingLeft + paddingRight,</span><br><span class="line">                        lp.width);</span><br><span class="line">                int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        paddingTop+paddingTop,</span><br><span class="line">                        lp.height);</span><br><span class="line">                // 设置子View的尺寸</span><br><span class="line">                childView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                // 当执行完measure函数后，即可获取到该子view的尺寸</span><br><span class="line">                int childViewWidth = childView.getMeasuredWidth();</span><br><span class="line">                int childVieeHeight = childView.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                // 当所用宽度 + 宽度间隔 + 当前子视图宽度 &gt; 容器View的宽度，则需要换行</span><br><span class="line">                if(lineWidthUsed + mHorizontalSpacing + childViewWidth &gt; selfWidth) &#123;</span><br><span class="line">                    // 记录当前行的视图、高度</span><br><span class="line">                    allView.add(lineViews);</span><br><span class="line">                    lineHeights.add(lineHeight);</span><br><span class="line">                    // 父容器需要的宽、高</span><br><span class="line">                    parentNeededHeight = parentNeededHeight + lineHeight + mVerticalSpacing;</span><br><span class="line">                    parentNeededWidth = Math.max(parentNeededWidth, lineWidthUsed + mHorizontalSpacing);</span><br><span class="line"></span><br><span class="line">                    // 执行换行、清空当前行数据</span><br><span class="line">                    lineViews = new ArrayList&lt;&gt;();</span><br><span class="line">                    lineHeight = 0;</span><br><span class="line">                    lineWidthUsed = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    lineViews.add(childView);</span><br><span class="line">                    lineHeight = Math.max(lineHeight, childVieeHeight);</span><br><span class="line">                    lineWidthUsed = lineWidthUsed + childViewWidth + mHorizontalSpacing;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //处理最后一行数据 因为最后一行肯定不会触发上面的换行</span><br><span class="line">                if (i == childViewCount - 1) &#123;</span><br><span class="line">                    allView.add(lineViews);</span><br><span class="line">                    lineHeights.add(lineHeight);</span><br><span class="line">                    parentNeededHeight = parentNeededHeight + lineHeight + mVerticalSpacing;</span><br><span class="line">                    parentNeededWidth = Math.max(parentNeededWidth, lineWidthUsed + mHorizontalSpacing);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 通过子View的计算得出了需要的最小具体值 再根据spec一起得出最后应该的值 此处需要参考上面提到的第5点</span><br><span class="line">        // 根据mode以及lp获取实际值</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int realWidth = widthMode == MeasureSpec.EXACTLY ? selfWidth : parentNeededWidth;</span><br><span class="line">        int realHeight = heightMode == MeasureSpec.EXACTLY ? selfHeight : parentNeededHeight;</span><br><span class="line">        // 设置实际尺寸</span><br><span class="line">        setMeasuredDimension(realWidth, realHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就完成了整个ViewGroup的尺寸测量，ViewGroup的onMeasure过程其实就是遍历子View，测量各个子View的过程。<br>measure方法会调用到onMeasure函数，而在onMeasure中会测量到具体尺寸。</p><p>注意一下在onMeasure执行时，我们调用了一个recyle函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> private void recyle() &#123;</span><br><span class="line">    allView.clear();</span><br><span class="line">    lineHeights.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数作用就是将记录的每行view、行高信息清空。因为onMeasure函数会被调用多次，<br>上面说了，容器的测量就会遍历子View测量，因为上层View视图中，至少存在两层ViewGroup，所以最少会被执行两次。<br>所以每次执行此函数时，我们需要清空一下上一次的数据。</p><p>测量函数执行完毕，现在我们知道了每个view的大小，接下来我们就按照记录的View的排列、行高等信息，<br>来对每个子View做布局处理</p><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>在上面的话，我们已经获取到了每个view的行数排列，我们只需再遍历到所有行的View，<br>获取到每个view针对父容器的左偏距、上偏距就能够对view定位，再获取该view的宽高时，就能获取到右偏距、下偏距了。<br>注意在onMeasure执行完毕后，就能调用getMeasuredWidth，获取尺寸信息<br>而在onLayout执行完毕后，就能调用getWidth获取尺寸信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">    // 获取容器的左、上偏距</span><br><span class="line">    int left = getPaddingLeft();</span><br><span class="line">    int top = getPaddingTop();</span><br><span class="line"></span><br><span class="line">    Log.e(TAG, &quot;onLayout: top : &quot; + top);</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; allView.size(); i ++) &#123;</span><br><span class="line">        List&lt;View&gt; lineView = allView.get(i);</span><br><span class="line">        int lineHeight = lineHeights.get(i); // 该行的高度</span><br><span class="line">        for(int j = 0; j &lt; lineView.size(); j ++) &#123;</span><br><span class="line">            View childView = lineView.get(j);</span><br><span class="line">            // 右偏距等于左偏距加上自身宽度</span><br><span class="line">            int right = left + childView.getMeasuredWidth();</span><br><span class="line">            // 下偏距等于上偏距加上自身高度</span><br><span class="line">            int bottom = top + childView.getMeasuredHeight();</span><br><span class="line">            Log.d(TAG, &quot;onLayout: left = &quot; + left + &quot;  top = &quot; + top + &quot;  bottom = &quot; + bottom);</span><br><span class="line">            // 设置该view</span><br><span class="line">            childView.layout(left, top, right, bottom);</span><br><span class="line"></span><br><span class="line">            // 为下一个view准备</span><br><span class="line">            left = right + mHorizontalSpacing;</span><br><span class="line">        &#125;</span><br><span class="line">        // 为下一行准备</span><br><span class="line">        top = lineHeight + mVerticalSpacing + top;</span><br><span class="line">        left = getPaddingLeft();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们自定义一个ViewGroup就完成了，实现了一个自动换行的ViewGroup</p><p>项目源码地址：<a href="https://github.com/wangchongwei/customView/blob/master/app/src/main/java/com/justin/customview/customview/FlowLayout.java" target="_blank" rel="noopener">https://github.com/wangchongwei/customView/blob/master/app/src/main/java/com/justin/customview/customview/FlowLayout.java</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 自定义View 继承View</title>
      <link href="/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFView.html"/>
      <url>/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View-%E7%BB%A7%E6%89%BFView.html</url>
      
        <content type="html"><![CDATA[<h1 id="android-自定义View-继承View"><a href="#android-自定义View-继承View" class="headerlink" title="android 自定义View 继承View"></a>android 自定义View 继承View</h1><p><a href="android-自定义View.html">上篇关于自定义View的介绍</a><br>接下来将会针对自定义View三种情况一一实现。</p><p><a value="源码地址" target="_blank" href="https://github.com/wangchongwei/customView" style="font-size:25px; color:blue; font-weight:bold">源码地址</a></p><p>最后实现效果如下图：</p><p><img src="../../../images/custom_view_final.jpg" style="zoom:20%"></p><h2 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h2><p>创建一个class MyView 继承View</p><p>目标是写一个折线图</p><p>现在res/values下面新建一个attrs.xml文件，来申明我们需要的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line"></span><br><span class="line">    &lt;declare-styleable name=&quot;LineView&quot;&gt;</span><br><span class="line">        &lt;attr name=&quot;axieColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">        &lt;attr name=&quot;pointRadius&quot; format=&quot;dimension&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure><h3 id="先新建一个clas-继承View，-并初始化几个构造函数"><a href="#先新建一个clas-继承View，-并初始化几个构造函数" class="headerlink" title="先新建一个clas 继承View， 并初始化几个构造函数"></a>先新建一个clas 继承View， 并初始化几个构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyView extends View &#123;</span><br><span class="line">    // 代码生成时，才会调用该构造函数</span><br><span class="line">     public MyView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    // xml配置时，会调用这个生命周期</span><br><span class="line">    public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        this.context = context;</span><br><span class="line">        initData(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 做初始化配置 获取各种颜色、尺寸，还有自定义的一些属性。</span><br><span class="line">    private void initData(AttributeSet attrs) &#123;</span><br><span class="line">         Log.d(TAG, &quot;initData: &quot;);</span><br><span class="line">        // 获取xml中配置的数据</span><br><span class="line">        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.MyView);</span><br><span class="line">        paintColor = array.getColor(R.styleable.MyView_axieColor, context.getResources().getColor(R.color.black));</span><br><span class="line"></span><br><span class="line">        // 画笔初始化</span><br><span class="line">        paint = new Paint();</span><br><span class="line">        paint.setColor(context.getResources().getColor(R.color.black));</span><br><span class="line">        paint.setTextSize(40);</span><br><span class="line">        paint.setStrokeWidth(10); // 线条粗细</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在onMeasure函数中对尺寸做约束"><a href="#在onMeasure函数中对尺寸做约束" class="headerlink" title="在onMeasure函数中对尺寸做约束"></a>在onMeasure函数中对尺寸做约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    Log.d(TAG, &quot;onMeasure: &quot;);</span><br><span class="line">    int height = measuretDimension(defaultHeight, heightMeasureSpec);</span><br><span class="line">    int width = measuretDimension(0, widthMeasureSpec);</span><br><span class="line">    top = 0;</span><br><span class="line">    left = 0;</span><br><span class="line">    bottom = top + height;</span><br><span class="line">    right = left + width;</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测量实际尺寸</span><br><span class="line"> * @param defaultSize: 默认尺寸</span><br><span class="line"> * @param measureSpec: 测量规格</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int measureDimension(int defaultSize, int measureSpec) &#123;</span><br><span class="line">    int resultSize = defaultSize;</span><br><span class="line">    int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        // 没有做限制，取默认值</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            resultSize = defaultSize;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // WRAP</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            // 要取默认值和测量值中较小值</span><br><span class="line">            // 当默认值为0时，取最大值, 即宽充满屏幕</span><br><span class="line">            resultSize = defaultSize == 0 ？specSize : Math.min(defaultSize, specSize);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // 具体值 或 MATCH</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            resultSize = specSize;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先绘制两个轴线"><a href="#先绘制两个轴线" class="headerlink" title="先绘制两个轴线"></a>先绘制两个轴线</h3><p>注意canvas.draw..()方法，中的位置参数都是相对定位尺寸，都是相对于该视图左上角的坐标定位，而onLayout中的四个位置参数都是相对于屏幕左上角。<br>这两个里的坐标不要弄混。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制两条轴线 */</span><br><span class="line">private void drawXY(Canvas canvas) &#123;</span><br><span class="line">    Log.d(TAG, &quot;drawXY: &quot;);</span><br><span class="line">    // 绘制x轴</span><br><span class="line">    canvas.drawLine(left + 20, bottom, right, bottom, paint);</span><br><span class="line">    // 绘制y轴</span><br><span class="line">    canvas.drawLine(left + 20, top, left + 20, bottom, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity中配置该视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.justin.customview.MyView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf=&quot;@+id/text_hello&quot;</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        app:axieColor=&quot;@color/black&quot;</span><br><span class="line">        android:id=&quot;@+id/myView&quot;</span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p><p>我们直接运行,效果如下：<br><img src="../../../images/view.jpg" style="zoom:20%"></p><p>x,y轴就画好了。但很明显我们设置的padding没起作用，因为padding是需要我们自己处理的。<br>新增一个方法初始化这些尺寸数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 尺寸数据初始化</span><br><span class="line"> */</span><br><span class="line">private void initSize () &#123;</span><br><span class="line">    // 获取padding尺寸</span><br><span class="line">    paddingLeft = getPaddingLeft();</span><br><span class="line">    paddingTop = getPaddingTop();</span><br><span class="line">    paddingRight = getPaddingRight();</span><br><span class="line">    paddingBottom = getPaddingBottom();</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&quot;paddingLeft =&quot;).append(paddingLeft)</span><br><span class="line">            .append(&quot;paddingTop =&quot;).append(paddingTop)</span><br><span class="line">            .append(&quot;paddingRight =&quot;).append(paddingRight)</span><br><span class="line">            .append(&quot;paddingBottom =&quot;).append(paddingBottom);</span><br><span class="line">    Log.d(TAG, &quot;initSize: &quot;.concat(sb.toString()));</span><br><span class="line">    top = paddingTop;</span><br><span class="line">    left = paddingLeft;</span><br><span class="line">    bottom = height - top - paddingBottom;</span><br><span class="line">    right = width - left;</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就对padding做了处理，接下来接着绘制我们需要的图形。<br>我们之前绘制了两个轴，xy，但我们平常绘制的轴都会有箭头，我们再在x轴右侧、y轴上侧绘制两个箭头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void drawArrow(Canvas canvas) &#123;</span><br><span class="line">    Path path = new Path();</span><br><span class="line">    // 先绘制x轴三角</span><br><span class="line">    //先移动到三角形一个点</span><br><span class="line">    path.moveTo(right-20, bottom + 20);</span><br><span class="line">    path.lineTo(right-20, bottom - 20); // 画线</span><br><span class="line">    path.lineTo(right, bottom); // 画线</span><br><span class="line">    path.close(); // 图形闭合</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">    // 绘制y轴三角</span><br><span class="line">    path.moveTo(left - 20, top + 20);</span><br><span class="line">    path.lineTo(left + 20, top + 20);</span><br><span class="line">    path.lineTo(left, top);</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要用到了drawPath函数。其实canvas对象还有很多其他的绘制图形的方法。</p><h3 id="设置数据并绘制点"><a href="#设置数据并绘制点" class="headerlink" title="设置数据并绘制点"></a>设置数据并绘制点</h3><p>我们已经完成了绘制两条轴线，现在要开始绘制数据了。<br>首先我们要确认标准线，x轴的标准线肯定就是xValue的值，<br>但y轴的标准线是不定的，我们要先找出最大值，确定几条标准线，确定每条标准线的值。<br>我们先假设我们的值在0-100以内，取5条标准线，每条间距20.</p><p>先设置两个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 数据</span><br><span class="line">   private float[] yValue;</span><br><span class="line">   private String[] xValue;</span><br><span class="line">   private int lineNum = 5;</span><br><span class="line"></span><br><span class="line">   /** 设置数据并刷新 */</span><br><span class="line">   public void setData(float[]yValue, String[]xValue) &#123;</span><br><span class="line">       this.yValue = yValue;</span><br><span class="line">       this.xValue = xValue;</span><br><span class="line">       postInvalidate();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** 设置标准线数目 */</span><br><span class="line">   public void setData(int lineNum) &#123;</span><br><span class="line">       this.lineNum = lineNum;</span><br><span class="line">       postInvalidate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>然后我们开始绘制标准线、各个点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制各个点 */</span><br><span class="line">private void drawPoint(Canvas canvas) &#123;</span><br><span class="line">    if(xValue == null || yValue == null) return;</span><br><span class="line">    // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。</span><br><span class="line">    float maxHeight = (float)((bottom - top) * 0.9);</span><br><span class="line">    float itemHeight = maxHeight / 5;</span><br><span class="line">    for(int i = 1; i &lt;=5; i ++) &#123;</span><br><span class="line">        canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint);</span><br><span class="line">    &#125;</span><br><span class="line">    // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值</span><br><span class="line">    float maxWidth = (float)((right - left) * 0.9);</span><br><span class="line">    float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length;</span><br><span class="line">    for (int i = 1; i &lt;= xValue.length; i ++) &#123;</span><br><span class="line">        float x = left + itemWidth * i;</span><br><span class="line">                // 绘制轴线</span><br><span class="line">        canvas.drawLine(x, bottom, x, bottom - 15, paint);</span><br><span class="line">        // 绘制点</span><br><span class="line">        float y = bottom - maxHeight * yValue[i-1] / yMax;</span><br><span class="line">        canvas.drawCircle(x, y, 5, paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在MainActivity.kt中，我们可以这样使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// kotlin语法</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        var xValue = arrayOf(&quot;一&quot;, &quot;二&quot;, &quot;san&quot;)</span><br><span class="line">        var yValue = floatArrayOf(70f, 80f, 90f);</span><br><span class="line">        myView.setData(yValue, xValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的实现效果：</p><p><img src="../../../images/chat.jpg" style="zoom:20%"></p><p>现在我们完成了图形的大致绘制，但在x、y轴却没有一些文字说明，接下来我们就要加上这些</p><h3 id="绘制x、y轴标准线值，将各个点连接起来。"><a href="#绘制x、y轴标准线值，将各个点连接起来。" class="headerlink" title="绘制x、y轴标准线值，将各个点连接起来。"></a>绘制x、y轴标准线值，将各个点连接起来。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/** 绘制各个点 */</span><br><span class="line">    private void drawPoint(Canvas canvas) &#123;</span><br><span class="line">        if(xValue == null || yValue == null) return;</span><br><span class="line">        // 先绘制5条y轴标准线位置 取高度的90%作为图线的最高。</span><br><span class="line">        float maxHeight = (float)((bottom - top) * 0.9);</span><br><span class="line">        float itemHeight = maxHeight / 5;</span><br><span class="line">        int itemValue = yMax / 5;</span><br><span class="line">        for(int i = 1; i &lt;=5; i ++) &#123;</span><br><span class="line">            canvas.drawLine(left, bottom - itemHeight * i, left + 15, bottom - itemHeight * i, paint);</span><br><span class="line">            // 绘制y轴标准值</span><br><span class="line">            canvas.drawText(itemValue * i + &quot;&quot;, left - 90, bottom - itemHeight * i, paint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 再绘制x轴的数据， x轴线的标准值就是x轴的值，数目也是xValue的值</span><br><span class="line">        float maxWidth = (float)((right - left) * 0.9);</span><br><span class="line">        float itemWidth = ((float) (maxWidth * 1.0)) / xValue.length;</span><br><span class="line">        for (int i = 1; i &lt;= xValue.length; i ++) &#123;</span><br><span class="line">            float x = left + itemWidth * i;</span><br><span class="line">                    // 绘制轴线</span><br><span class="line">            canvas.drawLine(x, bottom, x, bottom - 15, paint);</span><br><span class="line">            // 绘制点</span><br><span class="line">            float y = bottom - maxHeight * yValue[i-1] / yMax;</span><br><span class="line">            canvas.drawCircle(x, y, 10, paint);</span><br><span class="line"></span><br><span class="line">            // 绘制点与点之间的连线</span><br><span class="line">            if(lastX &gt; 0f) &#123;</span><br><span class="line">                canvas.drawLine(lastX, lastY, x, y, paint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 绘制x轴标准值</span><br><span class="line">            canvas.drawText(xValue[i-1], x, bottom + 50, paint);</span><br><span class="line"></span><br><span class="line">            lastX = x;</span><br><span class="line">            lastY = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后实现效果如下图：</p><p><img src="../../../images/custom_view_final.jpg" style="zoom:20%"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 自定义View</title>
      <link href="/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View.html"/>
      <url>/blog/2019/12/android-%E8%87%AA%E5%AE%9A%E4%B9%89View.html</url>
      
        <content type="html"><![CDATA[<h1 id="Android-自定义View"><a href="#Android-自定义View" class="headerlink" title="Android 自定义View"></a>Android 自定义View</h1><p>自定义View主要用于：需要一些不规则的图形、事件冲突、特定的视图群组、扩展某些组件的功能。</p><p>首页android自定义View有三种类型，<br>1、继承View，多用于实现一些不规则的图形。</p><p>2、继承特定的组件，如TextView，</p><p>3、继承ViewGroup，用于视图组</p><p>在自定义View中有三个关键的方法：<br>onMeasure、onLayout、onDraw</p><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>测量，<br>ViewGroup 会遍历测量子视图的onMeasure方法。<br>一般view 则是在测量自身。</p><p>在这个方法中，一般是对视图的尺寸做一些要求。<br>如：处理padding、处理wrap_parent</p><p>margin是无需处理的，margin其实是在父容器的onMeasure时处理的。</p><p>在自定义view时，如果没有重写onMeasure方法，我们调用该组件时，除非制定尺寸，否则wrap_parent、match_parent表现一样，都是充满父容器-match_parent</p><p>onMeasure方法有两个参数(int widthMeasureSpec, int heightMeasureSpec); MeasureSpec时测量规格。<br>这两个参数都是父容器传递过来。</p><p>视图的测量大小由两个元素决定，视图本身的LayoutParams 以及 父容器的测量规格MeasureSpec</p><h3 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h3><p>我们在使用时，一般是在xml文件，配置某个组件，指定视图宽高：<br>android:layout_width = “wrap_parent | 50dp | match_parent”<br>存在三种情况，<br>wrap_parent： 自适应大小，<br>50dp: 具体尺寸<br>match_parent: 充满父容器-父容器大小</p><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>测量规格，MeasureSpec由size和mode组成</p><p>1.static int getMode(int measureSpec): // 获取mode<br>2.static int getSize(int measureSpec):// 获取size<br>3.static int makeMeasureSpec(int size,int mode):// 构造一个MeasureSpec</p><p>specMode存在三种情况:<br>EXACTLY:<br>具体尺寸、具体值<br>AT_MOST：<br>表示子视图最多只能是specSize中指定的大小<br>UNSPECIFIED：<br>可以将视图按照自己的意愿设置成任意的大小，没有任何限制，很少用到，主要是系统内部会用到。</p><p>size：<br>就是LayputParams中指定的大小</p><p>而子视图的大小也就是通过size和specMode获取的，具体关系如下图：</p><table><thead><tr><th></th><th>EXACTLY</th><th>AT_MOST</th><th>UNSPECIFIED</th><th>&lt;-MeasureSpec</th></tr></thead><tbody><tr><td>wrap_parnet</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>match_parent</td><td>EXACTLY</td><td>AT_MOST</td><td>AT_MOST</td><td></td></tr><tr><td>50dp</td><td>50dp</td><td>50dp</td><td>50dp</td><td></td></tr><tr><td>^LayoutParams</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>总结就是，设置了具体尺寸时，具体尺寸生效，未设置具体尺寸时，就会显示最大尺寸</p><p>下面会讲具体使用</p><h2 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h2><p>布局方法</p><p>在调用onLayout时，onMeasure已经完成，<br>子容器的onLyout是在父容器执行onLayout时调用，而自身的onLyout也会触发内部子容器的遍历onLayout。这样就完成了整个视图的布局过程。<br>在onLayout中，会计算该视图的 左上右下 四个顶点的坐标，就完成了该视图的布局。</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>绘制的方法<br>onDraw是在容器的draw方法时调用的。<br>而绘制的顺序为：<br>1.绘制背景<br>2.如果有必要，保存画布的图层，以准备失效<br>3.绘制视图的内容<br>4.绘制子控件<br>5.如果必要，绘制衰落边缘和恢复层<br>6.绘制装饰（比如滚动条）</p><p>onDraw 有一个参数(Canvas cancas),<br>canvas 就是画布，画布的范围就是onLayout布局后确定的区域<br>Paint 画笔</p><h3 id="Paint的常用配置"><a href="#Paint的常用配置" class="headerlink" title="Paint的常用配置"></a>Paint的常用配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Paint mPaint = new Paint();</span><br></pre></td></tr></table></figure><h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><p>画笔的样式分三种类型 Style是个枚举类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum Style &#123;</span><br><span class="line">    /**</span><br><span class="line">        * Geometry and text drawn with this style will be filled, ignoring all</span><br><span class="line">        * stroke-related settings in the paint.</span><br><span class="line">        */</span><br><span class="line">    FILL            (0),</span><br><span class="line">    /**</span><br><span class="line">        * Geometry and text drawn with this style will be stroked, respecting</span><br><span class="line">        * the stroke-related fields on the paint.</span><br><span class="line">        */</span><br><span class="line">    STROKE          (1),</span><br><span class="line">    /**</span><br><span class="line">        * Geometry and text drawn with this style will be both filled and</span><br><span class="line">        * stroked at the same time, respecting the stroke-related fields on</span><br><span class="line">        * the paint. This mode can give unexpected results if the geometry</span><br><span class="line">        * is oriented counter-clockwise. This restriction does not apply to</span><br><span class="line">        * either FILL or STROKE.</span><br><span class="line">        */</span><br><span class="line">    FILL_AND_STROKE (2);</span><br><span class="line"></span><br><span class="line">    Style(int nativeInt) &#123;</span><br><span class="line">        this.nativeInt = nativeInt;</span><br><span class="line">    &#125;</span><br><span class="line">    final int nativeInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="canvas的常用函数"><a href="#canvas的常用函数" class="headerlink" title="canvas的常用函数"></a>canvas的常用函数</h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react redux</title>
      <link href="/blog/2019/12/react-redux.html"/>
      <url>/blog/2019/12/react-redux.html</url>
      
        <content type="html"><![CDATA[<h1 id="在react-native中集成redux"><a href="#在react-native中集成redux" class="headerlink" title="在react-native中集成redux"></a>在react-native中集成redux</h1><p>对react框架而言，状态树、dom树是它的一大优势。<br>而redux就是对数据、状态进行管理。</p><h2 id="集成redux"><a href="#集成redux" class="headerlink" title="集成redux"></a>集成redux</h2><p>1、执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install redux --save</span><br><span class="line">npm install react-redux --save</span><br><span class="line">npm install redux-thunk --save</span><br><span class="line">npm i redux-logger --save</span><br></pre></td></tr></table></figure></p><p>以上命令下载关于redux的组件。</p><p>2、store的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// configStore.js</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">import rootReducer from &apos;./reducer&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default configStore =(initState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const store = createStoreWithMiddleware(rootReducer, initState);</span><br><span class="line"></span><br><span class="line">    return store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而rootReducer是根reducer，因为业务都是分模块的，我们对reducer也会分层，这样使用起来也更简洁、清晰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// rootReducer</span><br><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; reducer as test &#125; from &apos;../Home/store&apos;;</span><br><span class="line"></span><br><span class="line">const appReducer = combineReducers(&#123;</span><br><span class="line">    test,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const rootReducer =(state, action) =&gt; &#123;</span><br><span class="line">    return appReducer(state, action);</span><br><span class="line">&#125;</span><br><span class="line">export default rootReducer;</span><br></pre></td></tr></table></figure><p>test是一个测试的reducer。</p><p>在入口处，绑定store，在入口文件中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(<span class="string">'projectName'</span>, () =&gt; Root);</span><br><span class="line"><span class="comment">// 指向了root.js，在root.js中：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> configStore <span class="keyword">from</span> <span class="string">'./store/configStore'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = configStore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                &lt;View style=&#123;&#123; <span class="attr">flex</span>: <span class="number">1</span> &#125;&#125;&gt;</span><br><span class="line">                    &#123;...&#125;</span><br><span class="line">                &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// actionType.js</span><br><span class="line">export const TEST_REDUCE = &quot;TEST_REDUCE&quot;;</span><br><span class="line"></span><br><span class="line">// test action.js</span><br><span class="line">import &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const test =() =&gt; (&#123;</span><br><span class="line">    type: TEST_REDUCE,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    test,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test reducer.js</span><br><span class="line">import &#123; TEST_REDUCE &#125; from &apos;./ActionType&apos;;</span><br><span class="line"></span><br><span class="line">const initState = &#123;</span><br><span class="line">    num: 0,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default reducer = (state = initState, action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line"></span><br><span class="line">        case TEST_REDUCE:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                num: state.num + 1,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...initState,</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件component中使用<br>Test.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; bindActionCreators &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; action &#125; from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test extends Component &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    testFunction =() =&gt; &#123;</span><br><span class="line">        this.props.action.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; num &#125; = this.props;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;&#123;flex: 1, alignItems: &apos;center&apos;, justifyContent: &apos;center&apos;&#125;&#125;&gt;</span><br><span class="line">                &lt;TouchableOpacity</span><br><span class="line">                    onPress=&#123;this.testFunction&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;Text&gt;</span><br><span class="line">                        触发按钮</span><br><span class="line">                    &lt;/Text&gt;</span><br><span class="line">                    &lt;Text&gt;&#123;num&#125;&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = (state) =&gt; (&#123;</span><br><span class="line">    num: state.test.num,</span><br><span class="line">&#125;)</span><br><span class="line">const mapActionToProps = dispatch =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        action: bindActionCreators(action, dispatch),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps, mapActionToProps)(Test);</span><br></pre></td></tr></table></figure><p><strong><em> 具体的使用方法已在上面，下面再去讲解redux原理 </em></strong></p><h2 id="redux原理说明"><a href="#redux原理说明" class="headerlink" title="redux原理说明"></a>redux原理说明</h2><p>redux状态管理大致流程：</p><p>component -&gt;调用action -&gt; dispatch action -&gt; reducer -&gt; 纯函数数据改变 -&gt; state改变 -&gt; component props改变 -&gt; 回调到component componentWillReceiverProps生命周期 -&gt; render</p><p>reducer中数据改变即store中数据改变为何会导致 component props改变呢？<br>其实就是connect函数。</p><p>我们在组件中，<br>export default connect(mapStateToProps, mapActionToProps)(Test);<br>connet是一个柯里化函数。<br>第一组入参两个：<br>第一个mapStateToProps，其实就是将store中的数据绑定到props，<br>第二个mapActionToProps，是将action函数绑定到props，<br>所以我们在使用是，如取store中的值，<br>const { num } = this.props;<br>dispatch action：this.props.action.test();</p><p>第二组入参：当前的Test对象。</p><p>再往深考虑connect 函数</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android sqlite的使用</title>
      <link href="/blog/2019/11/android-sqlite%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
      <url>/blog/2019/11/android-sqlite%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="android-sqlite的使用"><a href="#android-sqlite的使用" class="headerlink" title="android sqlite的使用"></a>android sqlite的使用</h1><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><p>a.创建java类MyDatabase继承SQLiteOpenHelper 并需要实现下面上个方法</p><h4 id="onCreate（SQLiteDatabase）"><a href="#onCreate（SQLiteDatabase）" class="headerlink" title="onCreate（SQLiteDatabase）"></a>onCreate（SQLiteDatabase）</h4><p>在数据库第一次生成的时候会调用这个方法，也就是说，只有在创建数据库的时候才会调用，当然也有一些其它的情况，一般我们在这个方法里边生成数据库表。</p><h4 id="onUpgrade（SQLiteDatabase，int，int）"><a href="#onUpgrade（SQLiteDatabase，int，int）" class="headerlink" title="onUpgrade（SQLiteDatabase，int，int）"></a>onUpgrade（SQLiteDatabase，int，int）</h4><p>当数据库需要升级的时候，Android系统会主动的调用这个方法。一般我们在这个方法里边删除数据表，并建立新的数据表，当然是否还需要做其他的操作，完全取决于应用的需求。</p><h4 id="onOpen（SQLiteDatabase）"><a href="#onOpen（SQLiteDatabase）" class="headerlink" title="onOpen（SQLiteDatabase）"></a>onOpen（SQLiteDatabase）</h4><p>这是当打开数据库时的回调函数，一般在程序中不是很常使用。</p><p>在构造函数中创建数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 数据表名</span><br><span class="line">   private static final String TABLE_NAME = &quot;userlog.db&quot;;</span><br><span class="line"></span><br><span class="line">   public MyDatabase(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123;</span><br><span class="line">       super(context, name, factory, version);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public MyDatabase(Context context, int version) &#123;</span><br><span class="line">       this(context, TABLE_NAME, null, version);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在onCreate方法中创建数据表<br>数据库数据类型：<br>NULL：null值<br>INTEGER：整数，1、2、3、4、6、8字节<br>REAL：浮点值，8字节<br>TEXT：字符串<br>BLOB：blob数据<br>DATE：日期 年月日<br>TIME：时刻 时分秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">       Log.d(TAG, &quot;onCreate: onCreate&quot;);</span><br><span class="line">       String sql = &quot;create table t_log(userId text, weight text, content text, image text, date date, time time)&quot;;</span><br><span class="line">       db.execSQL(sql);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong><em> 然后在需要建表的实话，初始化一个该java类实例即可 </em></strong></p><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="增加-insert-一条数据"><a href="#增加-insert-一条数据" class="headerlink" title="增加 insert 一条数据"></a>增加 insert 一条数据</h4><p>1、使用sql语句插入一条数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;insert into table_name (userId, weight, content, image) values(&apos;userId&apos;,&apos;70.0&apos;, &apos;content&apos;, &apos;image_uri&apos;)&quot;;</span><br><span class="line">db.execSQL(sql);</span><br></pre></td></tr></table></figure></p><p>但使用上面这种时，字段如果含有某些特殊符号如： : ‘ / 等，时，则会报错。unexpect token ‘:’</p><p>此时应该使用 ? 替代符，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void insert(String userId, String weight, String content, String imageUrl, Date date, Time time ) &#123;</span><br><span class="line">    SQLiteDatabase db = getWritableDatabase();</span><br><span class="line">    StringBuilder sql = new StringBuilder();</span><br><span class="line">    sql.append(&quot;insert into &quot;)</span><br><span class="line">            .append(table_name)</span><br><span class="line">            .append(&quot;(userId, weight, content, image, date, time) values(?,?,?,?,?,?)&quot;);</span><br><span class="line">    Object []values = new Object[] &#123;userId, weight, content, imageUrl, date, time&#125;;</span><br><span class="line">    Log.d(TAG, &quot;insert ===&quot;.concat(sql.toString().concat(values.toString())));</span><br><span class="line">    db.execSQL(sql.toString(), values);</span><br><span class="line">    db.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ValueAnimator</title>
      <link href="/blog/2019/10/ValueAnimator.html"/>
      <url>/blog/2019/10/ValueAnimator.html</url>
      
        <content type="html"><![CDATA[<h1 id="属性动画-ValueAnimator"><a href="#属性动画-ValueAnimator" class="headerlink" title="属性动画 ValueAnimator"></a>属性动画 ValueAnimator</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canvas 中的方法</title>
      <link href="/blog/2019/10/canvas-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
      <url>/blog/2019/10/canvas-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="canvas-中的一些方法"><a href="#canvas-中的一些方法" class="headerlink" title="canvas 中的一些方法"></a>canvas 中的一些方法</h1><p>在canvas中一般使用的方法为<br>drawXXX(): 绘制的方法<br>clipXXX(): 裁剪的方法</p><h3 id="clipRect"><a href="#clipRect" class="headerlink" title="clipRect"></a>clipRect</h3><p>裁剪画布，clipRect(int left, top, right, bottom);<br>clipRectF(float left, top, right, bottom)</p><p>当执行了该方法，如clipRect(0,0,500,500);<br>则后面都只能在(0,0,500,500)区域绘制</p><h3 id="用Rect实现多区域裁剪"><a href="#用Rect实现多区域裁剪" class="headerlink" title="用Rect实现多区域裁剪"></a>用Rect实现多区域裁剪</h3><h4 id="intersect-交集】"><a href="#intersect-交集】" class="headerlink" title="intersect 交集】"></a>intersect 交集】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Rect rect = new Rect(0, 0, 500, 500);  </span><br><span class="line">          </span><br><span class="line">rect.intersect(250, 250, 750, 750); </span><br><span class="line">        </span><br><span class="line">canvas.clipRect(rect);</span><br><span class="line"></span><br><span class="line">// 取到区域(250, 250, 500, 500)</span><br></pre></td></tr></table></figure><p>绘制多个区域相交的区域</p><h4 id="union-合集"><a href="#union-合集" class="headerlink" title="union 合集"></a>union 合集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Rect rect = new Rect(0, 0, 500, 500);  </span><br><span class="line">      </span><br><span class="line">rect.union(250, 250, 750, 750);  </span><br><span class="line">    </span><br><span class="line">canvas.clipRect(rect);</span><br><span class="line"></span><br><span class="line">// 取到的区域为(0, 0, 750, 750)</span><br></pre></td></tr></table></figure><p>绘制多个区域之和</p><h3 id="clipPath-取出某个区域"><a href="#clipPath-取出某个区域" class="headerlink" title="clipPath 取出某个区域"></a>clipPath 取出某个区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 实例化路径</span><br><span class="line">mPath = new Path();</span><br><span class="line">// 移动起点至[50,50]</span><br><span class="line">mPath.moveTo(50, 50);  </span><br><span class="line">mPath.lineTo(75, 23);  </span><br><span class="line">mPath.lineTo(150, 100);  </span><br><span class="line">mPath.lineTo(80, 110);  </span><br><span class="line">// 闭合路径</span><br><span class="line">mPath.close();</span><br><span class="line"></span><br><span class="line">// 按照路径进行裁剪</span><br><span class="line">canvas.clipPath(mPath);</span><br></pre></td></tr></table></figure><p>即是将path区域裁剪出来<br>同样后面在能在该path区域绘制图形</p><h3 id="Region-Op"><a href="#Region-Op" class="headerlink" title="Region.Op"></a>Region.Op</h3><p>canvas.drawRect</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashMap解析</title>
      <link href="/blog/2019/09/hashMap%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2019/09/hashMap%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h1><h3 id="Hash-内部类-Node："><a href="#Hash-内部类-Node：" class="headerlink" title="Hash 内部类 Node："></a>Hash 内部类 Node：</h3><p>Node(节点)，链表中的节点，当 HashMap 数据少于 6 条时，为链表结构，Node 为其中的节点。<br>链表数据结构，每一个节点都记录下一个节点的地址。<br>在 Node 的构造函数中，直接包含了下一个节点，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将下一个节点作为入参放入构造函数中</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>获取某个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        Node&lt;K,V&gt; first, e;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当为树结构的时候</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 获取树形结构中某个节点</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 遍历链表结构</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashMap 底部是数组，数组中存放链表，当链表长度大于 6 时，转为红黑树</p><p>put：初始化 table[],使用时再初始化，避免内存。</p><p>根据 k 获取 hash，hash &amp; length 获取 index，放入数组指定下标的链表，头插法, 链表超长 6 时，转为红黑树</p><h2 id="jdk1-7-及以前采用的头插法，在-jdk1-8-及以后，为避免死锁，采用尾插法。"><a href="#jdk1-7-及以前采用的头插法，在-jdk1-8-及以后，为避免死锁，采用尾插法。" class="headerlink" title="jdk1.7 及以前采用的头插法，在 jdk1.8 及以后，为避免死锁，采用尾插法。"></a>jdk1.7 及以前采用的头插法，在 jdk1.8 及以后，为避免死锁，采用尾插法。</h2><p>hash &amp; length 使用位运算符，因为位运算符快，cpu 指令就是基于位运算符，</p><p>扩容：hashmap 的初识容量是 16，每次扩容 * 2， 为何容量取 2 的次方，因为这样在位运算时，让每一位都能使用到，效率最高，而且这样保证位运算结果与取模结果一致。</p><p>加载因子：默认 0.75，因为大量测试表明： 0.6-0.75 最佳，0.75 保证在该范围内存使用率最高。<br>加载因子过大时，会让 hash 碰撞概率增加，降低 hashmap 使用效率。</p><p>hashmap 使用缺点：内存使用率最高也只有 75%， hash 碰撞，极端情况退化为单链表。用空间换时间。</p><h2 id="可以使用其他数据类型替代："><a href="#可以使用其他数据类型替代：" class="headerlink" title="可以使用其他数据类型替代："></a>可以使用其他数据类型替代：</h2><p>SparseArray： 双数组结构，key，value 分别使用数组存储， 但 SparseArray 的 key 只能为 int，<br>有序，通过二分查找来定位元素。<br>用时间换空间。<br>缺点： key 值只能是 int 类型</p><p>ArrayMap：sdk 19 引入，双数组结果，key 值可以为任何类型，根据 key 获取 hash，就和 SparseArray 类型一致了。<br>Bundle 内部就是使用 ArrayMap</p><h2 id="HashMap-流程"><a href="#HashMap-流程" class="headerlink" title="HashMap 流程"></a>HashMap 流程</h2><h3 id="put："><a href="#put：" class="headerlink" title="put："></a>put：</h3><p>key -&gt; hashcode -&gt; hash -&gt; index</p><p>根据 key 获取 hashcode， 对 hashcode 进行多次位运算获取 hash 值 h，<br>再根据 h 对数组 size - 1 取余 （h &amp; （size - 1））</p><p>这样得出下标，然后遍历该下标对应链表，查询是否存在对应 key，如果存在则替换 e 对应 value，并 return oldValue<br>如果不存在，则在尾部插入一个新节点</p><p>tips：jdk1.7 之前是头插法，1.8 之后是尾插法</p><p>当 put 数据时，新增的话，size++，会判断是否大于临界值，大于则触发扩容</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>当容量&gt;=75 时，会触发重新排列，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当原数组长度已为最大值时，直接返回原数组<br>否则为之前数组长度的两倍，然后构建一个新的空数组 newTab，<br>遍历原数组，获取数组下标元素，判断下标元素类型，并会清除原数组中该下标对应值<br>a、原数组元素没有 next 指针，单个元素， 直接放入新数组，放入的下标会根据新数组长度重新计算：newTab[e.hash &amp; (newCap - 1)] = e;<br>b、原数组元素是红黑色节点、即红黑色根结点，调用 split 函数，将红黑树放入到新数组<br>c、原数组又 next 指针，说明是链表，遍历链表组成新链表，并将新链表放入新数组的新位置</p><p>最后返回新数组</p><h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><p>1、为何 hashmap 是非线程安全的</p><p>put 操作未加锁，在多线程时会存在异常<br>另外一个比较明显的线程不安全的问题是 HashMap 的 get 操作可能因为 resize 而引起死循环（cpu100%）</p><p>2、HashMap 不保证遍历的顺序和插入的顺序是一致的 为何</p><p>插入在不同的 index 时，取出的顺序与插入的顺序就不一致</p><p>3、hashmap 的效率</p><p>空间使用率最高为 75%，增删查询都是 O(1)，从空间换时间。</p><p>可以使用 SparseArray 、 ArrayMap 替代</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>升级rn版本适配android64</title>
      <link href="/blog/2019/08/%E5%8D%87%E7%BA%A7rn%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8Dandroid64.html"/>
      <url>/blog/2019/08/%E5%8D%87%E7%BA%A7rn%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8Dandroid64.html</url>
      
        <content type="html"><![CDATA[<p>google play在2019/08/01起实施强制支持64位手机的措施。</p><p>因为之前的version为0.55.4,到0.59.1版本更新太多，<br>采取的方案是：新建一个项目version为0.59.1，然后将之前的代码直接移入到新项目</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rxjava + Retrofit 实现BaseResult</title>
      <link href="/blog/2019/07/Rxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html"/>
      <url>/blog/2019/07/Rxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html</url>
      
        <content type="html"><![CDATA[<h1 id="Rxjava-Retrofit-实现BaseResult"><a href="#Rxjava-Retrofit-实现BaseResult" class="headerlink" title="Rxjava + Retrofit 实现BaseResult"></a>Rxjava + Retrofit 实现BaseResult</h1><p>最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。<br>答案肯定是可以的。本文只讲使用。</p><h4 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;</span><br><span class="line">implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;</span><br><span class="line">implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;</span><br><span class="line">implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;</span><br><span class="line">implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;</span><br></pre></td></tr></table></figure><h4 id="普通使用案例"><a href="#普通使用案例" class="headerlink" title="普通使用案例"></a>普通使用案例</h4><p>首先创建实体数据类Test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;=====TEST&quot;;</span><br><span class="line"></span><br><span class="line">    String key = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String test = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public void log() &#123;</span><br><span class="line">        Log.d(TAG,&quot;key=&quot;  + key);</span><br><span class="line">        Log.d(TAG, &quot;test=&quot; + test);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写一个接口TestServer，申明请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface TestService &#123;</span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Test&gt;getObJson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void testService() &#123;</span><br><span class="line">      // 实例化一个Retrofit 对象</span><br><span class="line">        Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">                .baseUrl(&quot;http://192.168.1.42:8080/&quot;)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        TestServer service = retrofit.create(TestService.class);</span><br><span class="line">         service.getObJson()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(new Observer&lt;Test&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onNext(Test test) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="开发考虑"><a href="#开发考虑" class="headerlink" title="开发考虑"></a>开发考虑</h3><p>我们不可能每个请求都重新创建一个Retrofit对象，<br>而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。<br>所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。</p><h5 id="1、写一个result实体类"><a href="#1、写一个result实体类" class="headerlink" title="1、写一个result实体类"></a>1、写一个result实体类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 因为每一个接口返回的数据结构都不同，肯定要用泛型。</span><br><span class="line">public class Result&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final String TAG = &quot;Result ====&quot;;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    private String code = &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public void logCode() &#123;</span><br><span class="line">        Log.d(TAG, code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getLongCode() &#123;</span><br><span class="line">        long resultCode = 0;</span><br><span class="line">        if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123;</span><br><span class="line">            resultCode = Long.parseLong(code);</span><br><span class="line">        &#125;</span><br><span class="line">        return resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log() &#123;</span><br><span class="line">        Log.d(TAG, &quot;msg:&quot; +msg + &quot;\n code:&quot; + code + &quot;\n data:&quot; + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getResultData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论</strong></p><p>然后需要写一个BaseObserver观察者基类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 这里还是因为接口返回数据格式问题，使用泛型。</span><br><span class="line">public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final String TAG = &quot;====BaseObserver===&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求成功</span><br><span class="line">     * @param t</span><br><span class="line">     */</span><br><span class="line">    public abstract void onSuccess(T t);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当返回的code值错误时的默认方法</span><br><span class="line">     * @param code</span><br><span class="line">     */</span><br><span class="line">    public void onResultCodeErr(long code) &#123;</span><br><span class="line">        Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onSubscribe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Result result) &#123;</span><br><span class="line">        if(result.getLongCode() != 200) &#123;</span><br><span class="line">            onResultCodeErr(result.getLongCode());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            onSuccess((T)result.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        result.log();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(TAG, &quot;onError&quot;);</span><br><span class="line">        Log.d(TAG, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        Log.d(TAG, &quot;onComplete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的Server类就变成了如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TestService &#123;</span><br><span class="line"></span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson();</span><br><span class="line"></span><br><span class="line">    @GET(&quot;test.json&quot;)</span><br><span class="line">    Observable&lt;Test&gt;getObJson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onSuccess(Test test) &#123;</span><br><span class="line">            Log.d(&quot;======&quot;, &quot;onSuccess&quot;);</span><br><span class="line">            test.log();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /** Retrofit + Rxjav */</span><br><span class="line">    private void testRxjavaService() &#123;</span><br><span class="line">        Retrofit retrofit = RetrofitUtil.getRetrofit();</span><br><span class="line">        TestService ts = retrofit.create(TestService.class);</span><br><span class="line">        ts.getTestRxjavaJson()</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(observer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flutter入门（三）布局组件</title>
      <link href="/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html"/>
      <url>/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter入门（三）布局组件"><a href="#Flutter入门（三）布局组件" class="headerlink" title="Flutter入门（三）布局组件"></a>Flutter入门（三）布局组件</h1><p>之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！</p><p><img src="../images/flutter1.png" alt="fluttercn.png"></p><p>查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍</p><h3 id="ui组件"><a href="#ui组件" class="headerlink" title="ui组件"></a>ui组件</h3><p>学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。</p><h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    <span class="string">'要显示的文本'</span>, </span><br><span class="line">    &#123;</span><br><span class="line">        textAlign: TextAlign.center, <span class="comment">// 文本横向对齐方式 居中</span></span><br><span class="line">        overflow: TextOverflow.ellipsis, <span class="comment">// 文本溢出处理方式</span></span><br><span class="line">        textDirection: TextDirection.ltr, <span class="comment">// 文本方向 ltr(left to right) rtl(right to left)</span></span><br><span class="line">        softWrap: <span class="keyword">true</span>, <span class="comment">// 是否自动换行</span></span><br><span class="line">        textScaleFactor: <span class="number">2.0</span>, <span class="comment">// 字体显示倍率</span></span><br><span class="line">        maxLines: <span class="number">1</span>, <span class="comment">// 文本最大行数</span></span><br><span class="line">        style: <span class="keyword">new</span> TextStyle(</span><br><span class="line">            color: Colors.purple,</span><br><span class="line">            fontSize: <span class="number">20.0</span>,</span><br><span class="line">        ), <span class="comment">// 文本样式</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flutter入门  vscode调试及查看日志</title>
      <link href="/blog/2019/07/flutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html"/>
      <url>/blog/2019/07/flutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="flutter入门-vscode调试及查看日志"><a href="#flutter入门-vscode调试及查看日志" class="headerlink" title="flutter入门  vscode调试及查看日志"></a>flutter入门  vscode调试及查看日志</h1><p>开发肯定需要调试应用，以及查看日志。</p><p>在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。</p><p>还有一个print()函数，最终发现这个是可以的。</p><h4 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h4><p>a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。</p><p>b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出</p><p>c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出</p><h4 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h4><p>print()日志输出函数<br>通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出</p><p>ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。</p><h4 id="用vscode调试flutetr"><a href="#用vscode调试flutetr" class="headerlink" title="用vscode调试flutetr"></a>用vscode调试flutetr</h4><p><img src="../images/log1.png" alt="fluttervscode.png"><br>一个正常的flutter项目用vscode应该是这样的。<br>之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。</p><p>点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目<br><img src="../images/log2.png" alt="run.png"></p><p>我打了一个断点，当项目运行起来，如下图。<br><img src="../images/log3.png" alt="debugger.png"></p><p>当我点击按钮，进入断点。如下图<br>可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。<br><img src="../images/log4.png" alt="indebugger.png"></p><p>添加断点点击代码左侧的红框区域即可（下图）。<br><img src="../images/log5.png" alt="adddebugger.png"></p><p>在左上角的调试/新建断点 也可以。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flutter入门（二） 使用vscode编写第一个Flutter应用</title>
      <link href="/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html"/>
      <url>/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter入门（二）-使用vscode编写第一个Flutter应用"><a href="#Flutter入门（二）-使用vscode编写第一个Flutter应用" class="headerlink" title="Flutter入门（二） 使用vscode编写第一个Flutter应用"></a>Flutter入门（二） 使用vscode编写第一个Flutter应用</h1><p>在上一篇中我们利用android studio运行了一个hello word项目。<br>作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。</p><p>###1、配置插件<br>需要在vscode中下载插件<br><img src="../images/dart1.png" alt="dartPlugin.png"><br><img src="../images/dart2.png" alt="flutterPlugin.png"><br>找到这两个插件下载好并重新加载vscode就可以了。</p><p>###2、运行<br>flutter项目的运行命令是 flutter run<br>但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。<br>你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。</p><p>在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。<br>还有有一些提示信息<br><img src="../images/dart3.png" alt="tips.png"></p><p>当你需要热加载的时候按 r，需要重启应用按R。<br>所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。</p><p>###3、写第一个flutter应用。<br>按照flutter中文网（<a href="https://flutterchina.club/get-started/codelab/）" target="_blank" rel="noopener">https://flutterchina.club/get-started/codelab/）</a><br>写我们第一个flutter应用。<br>其中我个人碰到一个问题。<br>就是在第2步、使用外部package中，<br><img src="../images/dart4.png" alt="package.png"></p><p>在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。<br>然后重新打开vscode才好，应该是vscode对这个以来的读取问题。</p><p>然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。</p><p>###个人体会</p><p><strong>flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼</strong></p><p>fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。<br>没有对state这个做解释、没有state的使用说明，然后那个路由也是。</p><p>##待续</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flutter入门（一）环境配置</title>
      <link href="/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
      <url>/blog/2019/07/Flutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter入门（一）环境配置"><a href="#Flutter入门（一）环境配置" class="headerlink" title="Flutter入门（一）环境配置"></a>Flutter入门（一）环境配置</h1><p>在/flutter/bin目录下执行 flutter doctor命令。</p><h3 id="3、android-studio插件"><a href="#3、android-studio插件" class="headerlink" title="3、android studio插件"></a>3、android studio插件</h3><p>下载android studio就不说了，打开android studio/file/setting/plugin/<br><img src="../images/image.png" alt="plugin.png"><br>输入 flutter查找并install。<br>第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。</p><p>在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project<br><img src="../images/image0.png" alt="flutter.png"></p><h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello word"></a>hello word</h2><p>按照惯例，接下来我们跑一个hello world。</p><p>照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。</p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p><img src="../images/image1.png" alt="flutterRun.png"></p><p>项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，<br>pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。<br>在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行</p><p><img src="../images/image2.png" alt="hello.png"></p><p>第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flutter数据持久化</title>
      <link href="/blog/2019/07/flutter%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
      <url>/blog/2019/07/flutter%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h3 id="flutter数据持久化"><a href="#flutter数据持久化" class="headerlink" title="flutter数据持久化"></a>flutter数据持久化</h3><h5 id="shared-preferences"><a href="#shared-preferences" class="headerlink" title="shared_preferences"></a>shared_preferences</h5><p>本地存储临时数据<br>此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。</p><p>添加插件依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在pubspec.yaml文件中添加依赖</span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  shared_preferences: &quot;&lt;newest version&gt;&quot;</span><br></pre></td></tr></table></figure><p>调用：</p><p>shared_preference 存储方式是根据key-value形式<br>使用便捷，但有限制：<br>    a: 只能使用原始类型: int，double，bool，string 和 string list。<br>    b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:shared_preferences/shared_preferences.dart'</span>;</span><br><span class="line"></span><br><span class="line">getAsyncData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 获取实例</span></span><br><span class="line">    <span class="keyword">var</span> prefs = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br><span class="line">    <span class="comment">// 获取存储数据</span></span><br><span class="line">    <span class="keyword">var</span> count = prefs.getInt(<span class="string">'count'</span>) ?? <span class="number">0</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置存储数据</span></span><br><span class="line">    <span class="keyword">await</span> prefs.setInt(<span class="string">'count'</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dart语言语法糖</title>
      <link href="/blog/2019/07/dart%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E7%B3%96.html"/>
      <url>/blog/2019/07/dart%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
      
        <content type="html"><![CDATA[<h3 id="dart语言语法糖"><a href="#dart语言语法糖" class="headerlink" title="dart语言语法糖"></a>dart语言语法糖</h3><p>a、 以 _命名的变量或函数为强制私有</p><p>var _num;</p><p>b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int getInt() =&gt; 2;</span><br><span class="line"></span><br><span class="line">int getInt() =&gt; isTrue ? 2 : 0;</span><br></pre></td></tr></table></figure><p>c、 运算符</p><p>aa ?? bb; ?? 为null 时</p><p>d、异步 </p><p>async await then</p><p>async、await使用与rn中使用方式一致</p><p>.then也是异步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/// 设置需要填写的内容</span><br><span class="line">    _setDefaultData(List&lt;dynamic&gt; list) &#123;</span><br><span class="line">      Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;);</span><br><span class="line">      List&lt;dynamic&gt; list1 = [];</span><br><span class="line"></span><br><span class="line">      /// 对jsonStr数据做解析</span><br><span class="line">      jsonStr.then((value) &#123;</span><br><span class="line">        var data = json.decode(value);</span><br><span class="line">        if(list != null || list.length &gt; 0) &#123;</span><br><span class="line">          data = list;</span><br><span class="line">        &#125;</span><br><span class="line">        print(&apos;data ====&apos; + data.toString());</span><br><span class="line">        data.forEach((item) &#123;</span><br><span class="line">          if(item[&apos;type&apos;] == &apos;1&apos;) &#123;</span><br><span class="line">            list1.add(item);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      print(&apos;list1======&apos; + list1.toString());</span><br><span class="line">      this.setState(() &#123;</span><br><span class="line">        this.saveList = list1;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如图这种代码会先输出list1的信息，然后在输出data的信息<br>说明jsonStr.then 为异步操作</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flutter android端 原理解析</title>
      <link href="/blog/2019/07/flutter-android%E7%AB%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html"/>
      <url>/blog/2019/07/flutter-android%E7%AB%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="flutter-android端-原理解析"><a href="#flutter-android端-原理解析" class="headerlink" title="flutter android端 原理解析"></a>flutter android端 原理解析</h1><p>首先看MainActivity，</p><p>继承FlutterActivity</p><p>再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);</span><br><span class="line">private final FlutterActivityEvents eventDelegate;</span><br><span class="line">private final Provider viewProvider;</span><br><span class="line">private final PluginRegistry pluginRegistry;</span><br><span class="line"></span><br><span class="line">public FlutterActivity() &#123;</span><br><span class="line">    this.eventDelegate = this.delegate;</span><br><span class="line">    this.viewProvider = this.delegate;</span><br><span class="line">    this.pluginRegistry = this.delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    this.eventDelegate.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看delegate就知道代理模式</p><p>在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值，</p><p>FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。</p><p>FlutterActivityDelegate 就是FlutterActivityEvents类的实现.</p><p>看FlutterActivityDelegate类中的onCreate函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        if (VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">            Window window = this.activity.getWindow();</span><br><span class="line">            window.addFlags(-2147483648);</span><br><span class="line">            window.setStatusBarColor(1073741824);</span><br><span class="line">            window.getDecorView().setSystemUiVisibility(1280);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] args = getArgsFromIntent(this.activity.getIntent());</span><br><span class="line">        FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args);</span><br><span class="line">        this.flutterView = this.viewFactory.createFlutterView(this.activity);</span><br><span class="line">        if (this.flutterView == null) &#123;</span><br><span class="line">            FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView();</span><br><span class="line">            this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView);</span><br><span class="line">            this.flutterView.setLayoutParams(matchParent);</span><br><span class="line">            this.activity.setContentView(this.flutterView);</span><br><span class="line">            this.launchView = this.createLaunchView();</span><br><span class="line">            if (this.launchView != null) &#123;</span><br><span class="line">                this.addLaunchView();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!this.loadIntent(this.activity.getIntent())) &#123;</span><br><span class="line">            String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext());</span><br><span class="line">            if (appBundlePath != null) &#123;</span><br><span class="line">                this.runBundle(appBundlePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。</p><h2 id="android端与dart端通信"><a href="#android端与dart端通信" class="headerlink" title="android端与dart端通信"></a>android端与dart端通信</h2><h3 id="1、dart端调用android端代码"><a href="#1、dart端调用android端代码" class="headerlink" title="1、dart端调用android端代码"></a>1、dart端调用android端代码</h3><h4 id="1、原生android代码"><a href="#1、原生android代码" class="headerlink" title="1、原生android代码"></a>1、原生android代码</h4><p>新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。</p><p>重写onMethodCall方法，在此处写需要实现的逻辑代码</p><p>最后是将插件绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TestPlugin implements MethodChannel.MethodCallHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static final String CHANNEL = &quot;plugin/test&quot;;</span><br><span class="line"></span><br><span class="line">    static MethodChannel channel;</span><br><span class="line"></span><br><span class="line">    // 上下文</span><br><span class="line">    private Activity activity;</span><br><span class="line"></span><br><span class="line">    private TestPlugin(Activity activity) &#123;</span><br><span class="line">        this.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void registerWith(PluginRegistry.Registrar registrar) &#123;</span><br><span class="line">        channel = new MethodChannel(registrar.messenger(), CHANNEL);</span><br><span class="line">        TestPlugin plugin = new TestPlugin(registrar.activity());</span><br><span class="line">        // 在此通道上接受方法调用的回调</span><br><span class="line">        channel.setMethodCallHandler(plugin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123;</span><br><span class="line"></span><br><span class="line">        if(methodCall.method.equals(&quot;test&quot;)) &#123;</span><br><span class="line">            Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">            result.success(&quot;调用成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 当未找到该函数</span><br><span class="line">        result.notImplemented();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MainActivity中绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MainActivity extends FlutterActivity &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    GeneratedPluginRegistrant.registerWith(this);</span><br><span class="line"></span><br><span class="line">    registerPlugin(this);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private void registerPlugin(PluginRegistry registry) &#123;</span><br><span class="line">    TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、在dart中调用该原生方法"><a href="#2、在dart中调用该原生方法" class="headerlink" title="2、在dart中调用该原生方法"></a>2、在dart中调用该原生方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static const _platform = const MethodChannel(&apos;plugin/test&apos;);</span><br><span class="line"></span><br><span class="line">_toast() &#123;</span><br><span class="line">    /// 调用原生的方法</span><br><span class="line">    _platform.invokeMethod(&apos;test&apos;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一个原生插件调用就完成了。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>facebook推广api 推广主页</title>
      <link href="/blog/2019/07/facebook%E6%8E%A8%E5%B9%BFapi-%E6%8E%A8%E5%B9%BF%E4%B8%BB%E9%A1%B5.html"/>
      <url>/blog/2019/07/facebook%E6%8E%A8%E5%B9%BFapi-%E6%8E%A8%E5%B9%BF%E4%B8%BB%E9%A1%B5.html</url>
      
        <content type="html"><![CDATA[<h1 id="主页推广"><a href="#主页推广" class="headerlink" title="主页推广"></a>主页推广</h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>maven</title>
      <link href="/blog/2019/07/maven.html"/>
      <url>/blog/2019/07/maven.html</url>
      
        <content type="html"><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><p>maven 查看依赖树<br>mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXX<br>code xxx // 打开xxx文件</p><p>// gradle 查看依赖树<br>gradle app:dependency // 查看依赖树关系</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>react发布到javaweb</title>
      <link href="/blog/2019/07/react%E5%8F%91%E5%B8%83%E5%88%B0javaweb.html"/>
      <url>/blog/2019/07/react%E5%8F%91%E5%B8%83%E5%88%B0javaweb.html</url>
      
        <content type="html"><![CDATA[<h1 id="react项目发布到javaweb中"><a href="#react项目发布到javaweb中" class="headerlink" title="react项目发布到javaweb中"></a>react项目发布到javaweb中</h1><h3 id="1、打包react"><a href="#1、打包react" class="headerlink" title="1、打包react"></a>1、打包react</h3><p>直接执行npm run build命令：发现在build目录下生成资源文件，<br>但是打开index.html发现报错，发现在生成的index.html中引入的文件路径有问题：/static</p><p>/多余，或者说少了.  正确的路径应该是：static 或者 ./static</p><p>发现是%PUBLIC_URL%问题，在构建时应该执行</p><p><strong><em> PUBLIC_URL=./ npm run build </em></strong></p><h3 id="2、集成到javaweb中"><a href="#2、集成到javaweb中" class="headerlink" title="2、集成到javaweb中"></a>2、集成到javaweb中</h3><p>将上一步生成build目录下的文件都复制放在webapp路径下，启动应用就能直接访问到index.html文件</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> react+spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>facebook 营销api集成</title>
      <link href="/blog/2019/06/facebook-%E8%90%A5%E9%94%80api%E9%9B%86%E6%88%90.html"/>
      <url>/blog/2019/06/facebook-%E8%90%A5%E9%94%80api%E9%9B%86%E6%88%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="facebook-营销api集成"><a href="#facebook-营销api集成" class="headerlink" title="facebook 营销api集成"></a>facebook 营销api集成</h1><p>营销api需要通过后端服务器与facebook服务器交互</p><h3 id="1、下载营销api-java代码"><a href="#1、下载营销api-java代码" class="headerlink" title="1、下载营销api java代码"></a>1、下载营销api java代码</h3><p>git clone <a href="https://github.com/facebook/facebook-java-business-sdk.git" target="_blank" rel="noopener">https://github.com/facebook/facebook-java-business-sdk.git</a></p><p>编辑器：IDEA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在pom.xml中添加依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.facebook.business.sdk&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;facebook-java-business-sdk&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">插件maven-source-plugin 无法下载因缺失版本号</span><br><span class="line">添加&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">// 解决idea报错</span><br><span class="line">在&lt;build&gt;&lt;/build&gt;标签内添加&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;</span><br><span class="line">在&lt;plugins&gt;&lt;/plugins&gt;标签外套一个标签&lt;pluginManagement&gt;&lt;/pluginManagement&gt;</span><br></pre></td></tr></table></figure><p>添加java文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.facebook.ads.sdk.APIContext;</span><br><span class="line">import com.facebook.ads.sdk.AdAccount;</span><br><span class="line">import com.facebook.ads.sdk.Campaign;</span><br><span class="line">import com.facebook.ads.sdk.APIException;</span><br><span class="line"></span><br><span class="line">public class QuickStartExample &#123;</span><br><span class="line"></span><br><span class="line">    public static final String ACCESS_TOKEN = &quot;[Your access token]&quot;;//Your access token</span><br><span class="line">    public static final Long ACCOUNT_ID = 123456789L; //Your account ID</span><br><span class="line">    public static final String APP_SECRET = &quot;[Your app secret]&quot;;//Your app secret</span><br><span class="line"></span><br><span class="line">    public static final APIContext context = new APIContext(ACCESS_TOKEN, APP_SECRET);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;==========&quot;);</span><br><span class="line">            AdAccount account = new AdAccount(ACCOUNT_ID, context);</span><br><span class="line"></span><br><span class="line">            Campaign campaign = account.createCampaign()</span><br><span class="line">                    .setName(&quot;Java SDK Test Campaign&quot;)</span><br><span class="line">                    .setObjective(Campaign.EnumObjective.VALUE_LINK_CLICKS)</span><br><span class="line">                    .setSpendCap(10000L)</span><br><span class="line">                    .setStatus(Campaign.EnumStatus.VALUE_PAUSED)</span><br><span class="line">                    .execute();</span><br><span class="line">            System.out.println(campaign.fetch());</span><br><span class="line">        &#125; catch (APIException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.facebook.ads.sdk.APIContext;</span><br><span class="line">import com.facebook.ads.sdk.APINodeList;</span><br><span class="line">import com.facebook.ads.sdk.AdAccount;</span><br><span class="line">import com.facebook.ads.sdk.Campaign;</span><br><span class="line"></span><br><span class="line">public class TestFBJavaSDK</span><br><span class="line">&#123;</span><br><span class="line">    public static final APIContext context = new APIContext(</span><br><span class="line">            &quot;your-access-token&quot;,</span><br><span class="line">            &quot;your-appsecret&quot;</span><br><span class="line">    );</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        AdAccount account = new AdAccount(&quot;act_&#123;your-adaccount-id&#125;&quot;, context);</span><br><span class="line">        try &#123;</span><br><span class="line">            APINodeList&lt;Campaign&gt; campaigns = account.getCampaigns().requestAllFields().execute();</span><br><span class="line">            for(Campaign campaign : campaigns) &#123;</span><br><span class="line">                System.out.println(campaign.getFieldName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>执行java文件既可发布请求到facebook服务器，<br><strong><em> 需要安全上网 </em></strong></p><h2 id="1、主页推广"><a href="#1、主页推广" class="headerlink" title="1、主页推广"></a>1、主页推广</h2><p>根据提示一步一步提交，到 沙盒账号，如果之前没有添加则新建，要推广的主页，如果无则新建</p><p>到下载示例代码，点下载，将会获得一个java文件，里面含有accessToken、appid、ad_account_id、app_secret等信息，<br>将该下载的SAMPLE_CODE.java文件放于与上面两个java文件同级目录，直接运行该java文件即可，<br>注意此时电脑需要科学上网，不然会报错<strong><em>Timeout</em></strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> facebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>facebook sdk 集成</title>
      <link href="/blog/2019/06/facebook-sdk-%E9%9B%86%E6%88%90.html"/>
      <url>/blog/2019/06/facebook-sdk-%E9%9B%86%E6%88%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="Facebook-sdk-集成"><a href="#Facebook-sdk-集成" class="headerlink" title="Facebook sdk 集成"></a>Facebook sdk 集成</h1><p>首先需要在facebook注册一个账号，<br>自通过账号进入facebook的开发者平台</p><p>创建应用，只需要填写应用名即可，回生成一个appid。</p><h2 id="集成事件功能"><a href="#集成事件功能" class="headerlink" title="集成事件功能"></a>集成事件功能</h2><p>1、配置远端maven仓库地址<br>    在项目android/build.gradle文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">buildscript&#123;</span><br><span class="line">    repositories&#123;</span><br><span class="line">        ...</span><br><span class="line">        mavenCentral(); // 添加这行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allprojects&#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        mavenCentral() // 添加这行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、添加依赖<br>在app/build.gradle文件中添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies&#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation &apos;com.facebook.android:facebook-android-sdk:[4,5)&apos; // 添加这行</span><br><span class="line">    // 最新sdk版本为 implementation &apos;com.facebook.android:facebook-android-sdk:[5,6)&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、添加facebook-app-id<br>在res/values/string.xml中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;string name=&quot;facebook_app_id&quot;&gt;462119014332748&lt;/string&gt; </span><br><span class="line">&lt;string name=&quot;fb_login_protocol_scheme&quot;&gt;fb462119014332748&lt;/string&gt;</span><br><span class="line">// 462119014332748为你在facebook应用的appid</span><br><span class="line">// fb_login_protocol_scheme应该是用于登陆的</span><br></pre></td></tr></table></figure></p><p>在/app/manifest/AndroidManifest.xml中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line">    &lt;meta-data android:name=&quot;com.facebook.sdk.ApplicationId&quot; android:value=&quot;@string/facebook_app_id&quot;/&gt; </span><br><span class="line">    &lt;activity android:name=&quot;com.facebook.FacebookActivity&quot;</span><br><span class="line">        android:configChanges= &quot;keyboard|keyboardHidden|screenLayout|screenSize|orientation&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot; /&gt; </span><br><span class="line">    &lt;activity android:name=&quot;com.facebook.CustomTabActivity&quot;</span><br><span class="line">        android:exported=&quot;true&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; </span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</span><br><span class="line">            &lt;data android:scheme=&quot;@string/fb_login_protocol_scheme&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure></p><p>4、在facebook开发者控制台配置analytics sdk<br>在facebook开发者官网，点击「我的应用」即可进入应用控制台，<br>可以创建应用，只需提供应用名，以及邮箱即可，</p><p>点击单个应用即可进入应用控制台进行编辑<br><img src="&#39;../images/facebook1.png&#39;" alt="images">;<br>上图是应用可添加的功能，</p><p>点击Analytics即将功能添加进应用，点设置，前几步都是提示，<br>第四步，填入应用id，app/build.gradle中的applicationid，以及应用默认启动的Actiivty，</p><p>第五步，填入密钥散列，注意应该要填入两个，一个开发、一个发布，即debug自带的、一个release时通过jks文件签名生成的。<br>获取方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// macos debug ，按下enter键需要输入开机密码</span><br><span class="line">keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64</span><br><span class="line"></span><br><span class="line">// release </span><br><span class="line">keytool -exportcert -alias YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl base64</span><br></pre></td></tr></table></figure></p><p>5、发送事件</p><p>上面的1、2、3都只是基本配置，下面是手动发送事件</p><p>在MainApplication.java中<br>FacebookSdk.sdkInitialize 四个初始化方法都已被遗弃， 看到说是不需要初始化了</p><p> 在MainApplication.java中<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line"></span><br><span class="line">        // facebook 初始化</span><br><span class="line">        FacebookSdk.setIsDebugEnabled(true);</span><br><span class="line">        AppEventsLogger.activateApp(MainApplication.this);</span><br><span class="line">        FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注意facebooksdk回自动收集一些事件,如果不需要自动收集功能需要在清单文件中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=&quot;com.facebook.sdk.AutoLogAppEventsEnabled&quot;</span><br><span class="line">    android:value=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure><p>在Actiivty中测试发送自定义事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onResume() &#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    logEvent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void logEvent() &#123;</span><br><span class="line">    Log.d(&quot;========&quot;, &quot;logEvent&quot;);</span><br><span class="line">    AppEventsLogger logger = AppEventsLogger.newLogger(this);</span><br><span class="line">    logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP);</span><br><span class="line">    logger.logEvent(&quot;Test Event&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试时发现，当打断点调试时发现，发送事件总是会失败，正常运行却可以在facebook分析工具中看得到提交的事件。</p><p>后续：<br>在sdk集成后，可以看到之前定义的事件数据。<br>但是在连接商务平台，想要发布广告时。<br>需要通过自己的事件来定义受众、或者定义类似受众时发现，在商务平台无法获取到自定义事件的数据。<br>甚至都无法获取到我们的应用。<br>后来看官方文档，发现出了自定义事件、自动收集的事件，还有一个标准事件。<br>在我添加了一个标准事件后，就在商务平台上能找到在开发平台提交的app了。<br>但是那些自定义受众、类似受众功能貌似只能绑定到 facebook定义的标准事件，而不能是我们自己的自定义事件</p><p><strong><em>注意，运行时手机需要能连接到facebook后台服务器，大陆用户需要科学上网。</em></strong></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> facebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android okHttp3</title>
      <link href="/blog/2019/06/android-okHttp3.html"/>
      <url>/blog/2019/06/android-okHttp3.html</url>
      
        <content type="html"><![CDATA[<h1 id="OkHttp3使用"><a href="#OkHttp3使用" class="headerlink" title="OkHttp3使用"></a>OkHttp3使用</h1><p>添加依赖，在app/build.gradle中添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.squareup.okhttp3:okhttp:3.10.0&apos;</span><br></pre></td></tr></table></figure></p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>一个普通的get请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void get() &#123;</span><br><span class="line">    OkHttpClient client = new  OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">            .addHeader(&quot;header_key&quot;, &quot;header_value&quot;)</span><br><span class="line">            .url(&quot;https://www.baidu.com&quot;)</span><br><span class="line">            .get()</span><br><span class="line">            .build();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 同步执行</span><br><span class="line">        client.newCall(request).execute();</span><br><span class="line">        // 异步执行</span><br><span class="line">        client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">                Log.d(TAG, &quot;onFailure: &quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">                Log.d(TAG, &quot;onResponse: &quot; + response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void post() &#123;</span><br><span class="line">    OkHttpClient client = new  OkHttpClient.Builder().build();</span><br><span class="line"></span><br><span class="line">    RequestBody body = new FormBody.Builder()</span><br><span class="line">            .add(&quot;content&quot;, &quot;content&quot;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">            .addHeader(&quot;header_key&quot;, &quot;header_value&quot;)</span><br><span class="line">            .post(body)</span><br><span class="line">            .url(&quot;https://www.baidu.com&quot;)</span><br><span class="line">            .build();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 同步执行</span><br><span class="line">        client.newCall(request).execute();</span><br><span class="line">        // 异步执行</span><br><span class="line">        client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call call, IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">                Log.d(TAG, &quot;onResponse: &quot; + response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的post与get请求，区别就是post会多一个RequestBody</p><p>而关于okhttp的使用还有很多其他的用户，如自定义分发器Dispatch、拦截器、缓存</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vscode的常用插件与插件开发</title>
      <link href="/blog/2019/04/vscode%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html"/>
      <url>/blog/2019/04/vscode%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html</url>
      
        <content type="html"><![CDATA[<p>Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。</p><a id="more"></a><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br><span class="line">. ~/.bashrc</span><br><span class="line"><span class="comment">#显示有远端的版本</span></span><br><span class="line">nvm ls-remote</span><br><span class="line"><span class="comment">#安装对应的版本</span></span><br><span class="line">nvm install 对应的版本</span><br></pre></td></tr></table></figure><p>安装常用工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install  hexo-cli -g</span><br><span class="line">npm install hexo-server -g</span><br><span class="line">npm install hexo-deployer-git -g</span><br><span class="line">npm install yarn -g</span><br><span class="line">npm install http-server -g</span><br><span class="line">yarn global add serve</span><br><span class="line"></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist --global</span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org --global</span><br><span class="line">yarn config <span class="built_in">set</span> disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><p>安装以下插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#javascript</span></span><br><span class="line">eslint</span><br><span class="line">Color Picker</span><br><span class="line">npm</span><br><span class="line">Debugger <span class="keyword">for</span> Chrome</span><br><span class="line">Eclipse Keymap</span><br><span class="line"><span class="comment">#react</span></span><br><span class="line">ES7 React/Redux/GraphQL/React-Native snippets</span><br><span class="line"><span class="comment">#vue</span></span><br><span class="line">Vetur</span><br><span class="line">Vue VSCode Snippets</span><br><span class="line"><span class="comment">#git</span></span><br><span class="line">GitLens</span><br><span class="line">zerofinance-git</span><br><span class="line"><span class="comment">#其他公共插件</span></span><br><span class="line">Local History</span><br><span class="line">XML Tools</span><br><span class="line">Prettier</span><br><span class="line"><span class="comment">#https://zhuanlan.zhihu.com/p/54031899</span></span><br><span class="line">koroFileHeader</span><br><span class="line">AutoFileName</span><br><span class="line">Import Cost</span><br><span class="line"></span><br><span class="line"><span class="comment">#java</span></span><br><span class="line">Java Extension Pack</span><br><span class="line">Spring Boot Extension Pack</span><br><span class="line">Java Code Generators</span><br><span class="line">Docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#android/ios plugin</span></span><br><span class="line">Android iOS Emulator</span><br><span class="line">React Native Tools</span><br><span class="line"><span class="comment">#see debug:https://github.com/Microsoft/vscode-react-native/blob/master/doc/debugging.md#debugging-on-ios-device</span></span><br><span class="line"><span class="comment">#Install ios-deploy: npm install -g ios-deploy</span></span><br></pre></td></tr></table></figure></p><h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>koroFileHeader添加注释，在全局的settings.json中添加：</p><p>参考：</p><ul><li><a href="https://code.visualstudio.com/docs/editor/emmet" target="_blank" rel="noopener">https://code.visualstudio.com/docs/editor/emmet</a></li><li><a href="https://www.cnblogs.com/summit7ca/p/6944215.html" target="_blank" rel="noopener">https://www.cnblogs.com/summit7ca/p/6944215.html</a></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">"editor.fontSize": 14,</span><br><span class="line">"terminal.integrated.fontSize": 14,</span><br><span class="line">"emmet.triggerExpansionOnTab": true,</span><br><span class="line">"emmet.includeLanguages": &#123;</span><br><span class="line">    "javascript": "javascriptreact",</span><br><span class="line">    "vue-html": "html",</span><br><span class="line">    "razor": "html",</span><br><span class="line">    "plaintext": "jade"</span><br><span class="line">&#125;,</span><br><span class="line">// 注释</span><br><span class="line">"fileheader.configObj": &#123;</span><br><span class="line">  // 将该选项设置为true即可开启</span><br><span class="line">  "autoAdd": false</span><br><span class="line">&#125;,</span><br><span class="line">// 头部注释</span><br><span class="line">"fileheader.customMade": &#123;</span><br><span class="line">    "Author": "dave.zhao",</span><br><span class="line">    "Date": "Do not edit",</span><br><span class="line">    "LastEditors": "dave.zhao",</span><br><span class="line">    "LastEditTime": "Do not edit",</span><br><span class="line">    "Description": ""</span><br><span class="line">&#125;,</span><br><span class="line">// 函数注释</span><br><span class="line">"fileheader.cursorMode": &#123;</span><br><span class="line">    "Date": "Do not edit",</span><br><span class="line">    "description": "",</span><br><span class="line">    "param": ""</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Author和LastEditors填写自己的名字</p><p>文件头注释快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i</p><p>函数注释快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>可以放在全局的settings.json中，也可以放在各个项目的settings.json中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"eslint.validate"</span>: [<span class="string">"javascript"</span>, <span class="string">"javascriptreact"</span>],</span><br><span class="line">    <span class="attr">"javascript.updateImportsOnFileMove.enabled"</span>: <span class="string">"always"</span>,</span><br><span class="line">    // 代码缩进修改成4个空格</span><br><span class="line">    "editor.detectIndentation": false,</span><br><span class="line">    "editor.tabSize": 4,</span><br><span class="line">    "editor.formatOnSave": true,</span><br><span class="line">    // 每次保存的时候将代码按eslint格式进行修复</span><br><span class="line">    "eslint.autoFixOnSave": true,</span><br><span class="line">    // 让prettier使用eslint的代码格式进行校验</span><br><span class="line">    "prettier.eslintIntegration": true,</span><br><span class="line">    // 去掉代码结尾的分号</span><br><span class="line">    "prettier.semi": false,</span><br><span class="line">    // 使用带引号替代双引号</span><br><span class="line">    "prettier.singleQuote": true,</span><br><span class="line">    "prettier.tabWidth": 4,</span><br><span class="line">    "prettier.printWidth": 250,</span><br><span class="line">    // 让函数(名)和后面的括号之间加个空格</span><br><span class="line">    "javascript.format.insertSpaceBeforeFunctionParenthesis": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><p>参考代码<a href="https://github.com/zhaoxunyong/vs-code-git-plugin" target="_blank" rel="noopener">https://github.com/zhaoxunyong/vs-code-git-plugin</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000008968904" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008968904</a></li><li><a href="https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html" target="_blank" rel="noopener">https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html</a></li><li><a href="https://github.com/steveukx/git-js" target="_blank" rel="noopener">https://github.com/steveukx/git-js</a></li><li><a href="https://www.jianshu.com/p/2b096d8ad9b8" target="_blank" rel="noopener">https://www.jianshu.com/p/2b096d8ad9b8</a></li><li><a href="https://github.com/Microsoft/vscode-extension-samples" target="_blank" rel="noopener">https://github.com/Microsoft/vscode-extension-samples</a></li><li><a href="https://www.jianshu.com/p/520c575e91c3" target="_blank" rel="noopener">https://www.jianshu.com/p/520c575e91c3</a></li><li><a href="https://segmentfault.com/a/1190000017279102" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017279102</a></li><li><a href="https://segmentfault.com/a/1190000014758981" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014758981</a></li><li><a href="https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq" target="_blank" rel="noopener">https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html</a></li><li><a href="https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html" target="_blank" rel="noopener">https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html</a></li><li><a href="https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html" target="_blank" rel="noopener">https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html</a></li><li><a href="http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
