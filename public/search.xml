<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rxjava + Retrofit 实现BaseResult]]></title>
    <url>%2Fblog%2F2019%2F07%2FRxjava-Retrofit-%E5%AE%9E%E7%8E%B0BaseResult.html</url>
    <content type="text"><![CDATA[Rxjava + Retrofit 实现BaseResult最近在学习Rxjava、Retrofit的使用，同时想到想一般项目中接口返回都是由特定格式，如java后端的Resultful风格，那我们能不能在请求时写一个基础的返回类，并统一对code判断，再来处理。答案肯定是可以的。本文只讲使用。 依赖：12345implementation &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;implementation &apos;io.reactivex.rxjava2:rxandroid:2.0.2&apos;implementation &apos;io.reactivex.rxjava2:rxjava:2.x.y&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos; 普通使用案例首先创建实体数据类Test 1234567891011121314public class Test &#123; private static final String TAG = &quot;=====TEST&quot;; String key = &quot;&quot;; String test = &quot;&quot;; public void log() &#123; Log.d(TAG,&quot;key=&quot; + key); Log.d(TAG, &quot;test=&quot; + test); &#125;&#125; 在写一个接口TestServer，申明请求 1234public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用请求1234567891011121314151617181920212223242526272829303132private void testService() &#123; // 实例化一个Retrofit 对象 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;http://192.168.1.42:8080/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); TestServer service = retrofit.create(TestService.class); service.getObJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Test&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Test test) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); &#125; 开发考虑我们不可能每个请求都重新创建一个Retrofit对象，而且要基于项目后端数据，例如resultful风格，不可能在每个请求都对code判断。所以我们要将返回的Call 对象封装，对code判断，并返回具体的数据结构。 1、写一个result实体类1234567891011121314151617181920212223242526272829303132// 因为每一个接口返回的数据结构都不同，肯定要用泛型。public class Result&lt;T&gt; &#123; private final String TAG = &quot;Result ====&quot;; private String msg; private String code = &quot;0&quot;; private T data; public void logCode() &#123; Log.d(TAG, code); &#125; public long getLongCode() &#123; long resultCode = 0; if(code != null &amp;&amp; !code.equals(&quot;&quot;)) &#123; resultCode = Long.parseLong(code); &#125; return resultCode; &#125; public void log() &#123; Log.d(TAG, &quot;msg:&quot; +msg + &quot;\n code:&quot; + code + &quot;\n data:&quot; + data); &#125; public T getResultData() &#123; return data; &#125;&#125; 注意，此处的get数据的方法不能直接用getCode，会报空指针异常，后续讨论 然后需要写一个BaseObserver观察者基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 这里还是因为接口返回数据格式问题，使用泛型。public abstract class BaseObserver&lt;T&gt; implements Observer&lt;Result&lt;T&gt;&gt; &#123; private final String TAG = &quot;====BaseObserver===&quot;; /** * 请求成功 * @param t */ public abstract void onSuccess(T t); /** * 当返回的code值错误时的默认方法 * @param code */ public void onResultCodeErr(long code) &#123; Log.d(TAG, &quot;状态码错误,错误码为：&quot; + code); &#125; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, &quot;onSubscribe&quot;); &#125; @Override public void onNext(Result result) &#123; if(result.getLongCode() != 200) &#123; onResultCodeErr(result.getLongCode()); &#125; else &#123; onSuccess((T)result.getResultData()); &#125; result.log(); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, &quot;onError&quot;); Log.d(TAG, e.getMessage()); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125;&#125; 然后我们的Server类就变成了如下：123456789public interface TestService &#123; @GET(&quot;test.json&quot;) Observable&lt;Result&lt;Test&gt;&gt; getTestRxjavaJson(); @GET(&quot;test.json&quot;) Observable&lt;Test&gt;getObJson();&#125; 调用就变成了这样： 1234567891011121314151617BaseObserver observer = new BaseObserver&lt;Test&gt;() &#123; @Override public void onSuccess(Test test) &#123; Log.d(&quot;======&quot;, &quot;onSuccess&quot;); test.log(); &#125; &#125;; /** Retrofit + Rxjav */ private void testRxjavaService() &#123; Retrofit retrofit = RetrofitUtil.getRetrofit(); TestService ts = retrofit.create(TestService.class); ts.getTestRxjavaJson() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 写的还比较粗糙，单个接口调用时可能效果还不明显。但大致思路是这样的。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（三）布局组件]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%83%E5%B1%80%E7%BB%84%E4%BB%B6.html</url>
    <content type="text"><![CDATA[Flutter入门（三）布局组件之前吐槽过flutter中文网文档写的不好，后来发现维护者更新的好快，而且也从各种开发的角度来介绍flutter，很skr，点赞！ 查看这些可以从这些角度去理解flutter开发，学起来也会事半功倍 ui组件学一个新的开发框架，当hello world运行起来后，接下来肯定是了解并使用一些基本的ui组件。 Text123456789101112131415Text( &apos;要显示的文本&apos;, &#123; textAlign: TextAlign.center, // 文本横向对齐方式 居中 overflow: TextOverflow.ellipsis, // 文本溢出处理方式 textDirection: TextDirection.ltr, // 文本方向 ltr(left to right) rtl(right to left) softWrap: true, // 是否自动换行 textScaleFactor: 2.0, // 字体显示倍率 maxLines: 1, // 文本最大行数 style: new TextStyle( color: Colors.purple, fontSize: 20.0, ), // 文本样式 &#125;)]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter入门 vscode调试及查看日志]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E5%85%A5%E9%97%A8-vscode%E8%B0%83%E8%AF%95%E5%8F%8A%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97.html</url>
    <content type="text"><![CDATA[flutter入门 vscode调试及查看日志开发肯定需要调试应用，以及查看日志。 在flutter中有logger包，调用未找到Log里的函数，只有Logger.root.info(‘’)等函数，运行时也不起作用。 还有一个print()函数，最终发现这个是可以的。 情景再现a、通过 flutter run方法启动应用，通过flutter logs查看日志，发现并没有日志输出。 b、通过flutter run方法启动应用，在 调试控制台 也没看到日志输出 c、通过vscode 自带的调试台启动启用，flutter logs，也没有日志输出 正确方法print()日志输出函数通过vscode 自带的调试台启动应用， 查看调试控制台，有日志输出 ps: 我重启应用后发现，在终端cmd 通过flutter 也能看到日志输出了。 用vscode调试flutetr一个正常的flutter项目用vscode应该是这样的。之前有说过可以用flutter run命令运行，还有android studio运行。在vscode中也有按钮运行调试。 点击调试按钮/启动调试按钮，就相当于flutter run运行该flutter项目 我打了一个断点，当项目运行起来，如下图。 当我点击按钮，进入断点。如下图可以看到左上角的操作按钮，其实跟android studio调试原生代码，以及浏览器调试rn一样。 添加断点点击代码左侧的红框区域即可（下图）。 在左上角的调试/新建断点 也可以。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[Flutter入门（二） 使用vscode编写第一个Flutter应用在上一篇中我们利用android studio运行了一个hello word项目。作为我个人而言最喜欢的编辑器是vscode，肯定要能在vscode中写代码并运行flutter项目才行。 ###1、配置插件需要在vscode中下载插件找到这两个插件下载好并重新加载vscode就可以了。 ###2、运行flutter项目的运行命令是 flutter run但是flutter和react-native不同的是，flutter run之后会检测是否连接设备，如果没有已连接的设备会不往下运行。你可以通 flutter devices, 当然你配置了android的环境的话，也可以用dab命令， adb devices。 在项目运行起来后，在下方的终端会有一些输出信息，编译耗时、打debug包、安装等。还有有一些提示信息 当你需要热加载的时候按 r，需要重启应用按R。所以当我们每一次写好代码保存后，只要再按一下r，就可以看到最新的效果，而且flutter的热加载比rn的更快。 ###3、写第一个flutter应用。按照flutter中文网（https://flutterchina.club/get-started/codelab/）写我们第一个flutter应用。其中我个人碰到一个问题。就是在第2步、使用外部package中， 在pubspec.yaml文件中申明了插件依赖，保存之后自动下载了，然后在main.dart文件中引用该插件，发现没有自动补全提示，我手写全部路径，提示找不到。然后重新打开vscode才好，应该是vscode对这个以来的读取问题。 然后是接着照着中文的代码写。flutter的也有state，据说是根据react中的state来的想法加入的。 ###个人体会 flutter项目比rn流畅，编译快，热加载快，应用运行也更流畅，但dart语法是真蛋疼 fluuter中文网写的文档感觉也不是很友好，很多关键的东西写的不够具体、甚至没写。没有对state这个做解释、没有state的使用说明，然后那个路由也是。 ##待续]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门（一）环境配置]]></title>
    <url>%2Fblog%2F2019%2F07%2FFlutter%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Flutter入门（一）环境配置在/flutter/bin目录下执行 flutter doctor命令。 3、android studio插件下载android studio就不说了，打开android studio/file/setting/plugin/输入 flutter查找并install。第一次可能下不下来。我的电脑第一次就没下下来，是回家后打开电脑重新下载才下下来的，猜测可能是下载完flutter sdk、或者配置flutter环境变量后需要重启电脑。 在安装完插件并重新启动android studio就可以在 file/new/中看到一个新选项 New Flutter Project hello word按照惯例，接下来我们跑一个hello world。 照上面的new/new Flutter Project 然后 next、next、next一个新项目就建好了。 项目目录 项目目录和rn目录类似，android、ios原生工程。lib放混合开发的dart文件，pubspec.yaml项目的配置文件，类似于rn、react中的package.json，声明项目版本、依赖等。在运行后如android，会在项目根目录的build（和android同目录）下生成构建之后的文件，这一点和rn以及之前的android项目很不一样，之前的androidbuild都是在/app/build/目录下。 运行点击上面截图右上角绿三角run，第一次运行会比较慢。main.dart是主入口的混合文件。我们可以修改截图中间的文本内容，再运行 第一次运行结束，后面就需要熟悉dart语法，查看原生里的源码看实现原理。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter数据持久化]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
    <content type="text"><![CDATA[flutter数据持久化shared_preferences本地存储临时数据此插件在 iOS 上使用 NSUserDefaults，在 Android 上使用 SharedPreferences，为简单数据提供持久存储。 添加插件依赖： 123456// 在pubspec.yaml文件中添加依赖dependencies: flutter: sdk: flutter shared_preferences: &quot;&lt;newest version&gt;&quot; 调用： shared_preference 存储方式是根据key-value形式使用便捷，但有限制： a: 只能使用原始类型: int，double，bool，string 和 string list。 b: 它不是用来存储大量数据，因此不适合作为应用程序缓存。 1234567891011import &apos;package:shared_preferences/shared_preferences.dart&apos;;getAsyncData() async &#123; // 获取实例 var prefs = await SharedPreferences.getInstance(); // 获取存储数据 var count = prefs.getInt(&apos;count&apos;) ?? 0 + 1; // 设置存储数据 await prefs.setInt(&apos;count&apos;, count);&#125;]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dart语言语法糖]]></title>
    <url>%2Fblog%2F2019%2F07%2Fdart%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
    <content type="text"><![CDATA[dart语言语法糖a、 以 _命名的变量或函数为强制私有 var _num; b、 支持箭头函数,但后面不能接代码段，只能接受返回值 和 表达式 1234int getInt() =&gt; 2;int getInt() =&gt; isTrue ? 2 : 0; c、 运算符 aa ?? bb; ?? 为null 时 d、异步 async await then async、await使用与rn中使用方式一致 .then也是异步操作 12345678910111213141516171819202122232425/// 设置需要填写的内容 _setDefaultData(List&lt;dynamic&gt; list) &#123; Future&lt;String&gt; jsonStr = DefaultAssetBundle.of(context).loadString(&quot;json/billcontent.json&quot;); List&lt;dynamic&gt; list1 = []; /// 对jsonStr数据做解析 jsonStr.then((value) &#123; var data = json.decode(value); if(list != null || list.length &gt; 0) &#123; data = list; &#125; print(&apos;data ====&apos; + data.toString()); data.forEach((item) &#123; if(item[&apos;type&apos;] == &apos;1&apos;) &#123; list1.add(item); &#125; &#125;); &#125;); print(&apos;list1======&apos; + list1.toString()); this.setState(() &#123; this.saveList = list1; &#125;); &#125; 如图这种代码会先输出list1的信息，然后在输出data的信息说明jsonStr.then 为异步操作]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter android端 原理解析]]></title>
    <url>%2Fblog%2F2019%2F07%2Fflutter-android%E7%AB%AF-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[flutter android端 原理解析首先看MainActivity， 继承FlutterActivity 再看FlutterActivity代码，继承Activity，实现Provider、PluginRegistry、ViewFactory 12345678910111213141516private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this);private final FlutterActivityEvents eventDelegate;private final Provider viewProvider;private final PluginRegistry pluginRegistry;public FlutterActivity() &#123; this.eventDelegate = this.delegate; this.viewProvider = this.delegate; this.pluginRegistry = this.delegate;&#125;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.eventDelegate.onCreate(savedInstanceState);&#125; 一看delegate就知道代理模式 在生命周期onCrreate中，视图由eventDelegate创建，而该对象在构造函数中被初始化赋值， FlutterActivityEvents 是一个接口类 继承了ActivityResultListener生命周期、RequestPermissionsResultListener权限请求、ComponentCallbacks2这个类先不管。 FlutterActivityDelegate 就是FlutterActivityEvents类的实现. 看FlutterActivityDelegate类中的onCreate函数 123456789101112131415161718192021222324252627282930public void onCreate(Bundle savedInstanceState) &#123; if (VERSION.SDK_INT &gt;= 21) &#123; Window window = this.activity.getWindow(); window.addFlags(-2147483648); window.setStatusBarColor(1073741824); window.getDecorView().setSystemUiVisibility(1280); &#125; String[] args = getArgsFromIntent(this.activity.getIntent()); FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args); this.flutterView = this.viewFactory.createFlutterView(this.activity); if (this.flutterView == null) &#123; FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView(); this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView); this.flutterView.setLayoutParams(matchParent); this.activity.setContentView(this.flutterView); this.launchView = this.createLaunchView(); if (this.launchView != null) &#123; this.addLaunchView(); &#125; &#125; if (!this.loadIntent(this.activity.getIntent())) &#123; String appBundlePath = FlutterMain.findAppBundlePath(this.activity.getApplicationContext()); if (appBundlePath != null) &#123; this.runBundle(appBundlePath); &#125; &#125; &#125; 首先对android版本做了一个判断，当大于6.0，设置了状态栏颜色，和窗口模式。 android端与dart端通信1、dart端调用android端代码1、原生android代码新建一个类TestPlugin 实现MethodChannel类里的内部接口类MethodCallHandler。 重写onMethodCall方法，在此处写需要实现的逻辑代码 最后是将插件绑定。 12345678910111213141516171819202122232425262728293031323334public class TestPlugin implements MethodChannel.MethodCallHandler &#123; public static final String CHANNEL = &quot;plugin/test&quot;; static MethodChannel channel; // 上下文 private Activity activity; private TestPlugin(Activity activity) &#123; this.activity = activity; &#125; public static void registerWith(PluginRegistry.Registrar registrar) &#123; channel = new MethodChannel(registrar.messenger(), CHANNEL); TestPlugin plugin = new TestPlugin(registrar.activity()); // 在此通道上接受方法调用的回调 channel.setMethodCallHandler(plugin); &#125; @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) &#123; if(methodCall.method.equals(&quot;test&quot;)) &#123; Toast.makeText(activity.getApplicationContext(), &quot;测试dart调用android原生插件&quot;, Toast.LENGTH_SHORT).show(); result.success(&quot;调用成功&quot;); &#125; // 当未找到该函数 result.notImplemented(); &#125;&#125; 在MainActivity中绑定 1234567891011121314151617public class MainActivity extends FlutterActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); registerPlugin(this); &#125; private void registerPlugin(PluginRegistry registry) &#123; TestPlugin.registerWith(registry.registrarFor(TestPlugin.CHANNEL)); &#125;&#125; 2、在dart中调用该原生方法1234567static const _platform = const MethodChannel(&apos;plugin/test&apos;);_toast() &#123; /// 调用原生的方法 _platform.invokeMethod(&apos;test&apos;); &#125; 一个原生插件调用就完成了。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook推广api 推广主页]]></title>
    <url>%2Fblog%2F2019%2F07%2Ffacebook%E6%8E%A8%E5%B9%BFapi-%E6%8E%A8%E5%B9%BF%E4%B8%BB%E9%A1%B5.html</url>
    <content type="text"><![CDATA[主页推广]]></content>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2Fblog%2F2019%2F07%2Fmaven.html</url>
    <content type="text"><![CDATA[mavenmaven 查看依赖树mvn dependency:tree &gt; xxx // 将maven依赖树关系导入到文件 XXXcode xxx // 打开xxx文件 gradle 查看依赖树gradle app:dependency // 查看依赖树关系]]></content>
  </entry>
  <entry>
    <title><![CDATA[react发布到javaweb]]></title>
    <url>%2Fblog%2F2019%2F07%2Freact%E5%8F%91%E5%B8%83%E5%88%B0javaweb.html</url>
    <content type="text"><![CDATA[react项目发布到javaweb中1、打包react直接执行npm run build命令：发现在build目录下生成资源文件，但是打开index.html发现报错，发现在生成的index.html中引入的文件路径有问题：/static /多余，或者说少了. 正确的路径应该是：static 或者 ./static 发现是%PUBLIC_URL%问题，在构建时应该执行 PUBLIC_URL=./ npm run build 2、集成到javaweb中将上一步生成build目录下的文件都复制放在webapp路径下，启动应用就能直接访问到index.html文件]]></content>
      <tags>
        <tag>react+spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook 营销api集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-%E8%90%A5%E9%94%80api%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[facebook 营销api集成营销api需要通过后端服务器与facebook服务器交互 1、下载营销api java代码git clone https://github.com/facebook/facebook-java-business-sdk.git 编辑器：IDEA 123456789101112// 在pom.xml中添加依赖&lt;dependency&gt; &lt;groupId&gt;com.facebook.business.sdk&lt;/groupId&gt; &lt;artifactId&gt;facebook-java-business-sdk&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;插件maven-source-plugin 无法下载因缺失版本号添加&lt;version&gt;3.1.0&lt;/version&gt;// 解决idea报错在&lt;build&gt;&lt;/build&gt;标签内添加&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;在&lt;plugins&gt;&lt;/plugins&gt;标签外套一个标签&lt;pluginManagement&gt;&lt;/pluginManagement&gt; 添加java文件123456789101112131415161718192021222324252627282930import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;import com.facebook.ads.sdk.APIException;public class QuickStartExample &#123; public static final String ACCESS_TOKEN = &quot;[Your access token]&quot;;//Your access token public static final Long ACCOUNT_ID = 123456789L; //Your account ID public static final String APP_SECRET = &quot;[Your app secret]&quot;;//Your app secret public static final APIContext context = new APIContext(ACCESS_TOKEN, APP_SECRET); public static void main(String[] args) &#123; try &#123; System.out.println(&quot;==========&quot;); AdAccount account = new AdAccount(ACCOUNT_ID, context); Campaign campaign = account.createCampaign() .setName(&quot;Java SDK Test Campaign&quot;) .setObjective(Campaign.EnumObjective.VALUE_LINK_CLICKS) .setSpendCap(10000L) .setStatus(Campaign.EnumStatus.VALUE_PAUSED) .execute(); System.out.println(campaign.fetch()); &#125; catch (APIException e) &#123; e.printStackTrace(); &#125; &#125;&#125; or 123456789101112131415161718192021222324import com.facebook.ads.sdk.APIContext;import com.facebook.ads.sdk.APINodeList;import com.facebook.ads.sdk.AdAccount;import com.facebook.ads.sdk.Campaign;public class TestFBJavaSDK&#123; public static final APIContext context = new APIContext( &quot;your-access-token&quot;, &quot;your-appsecret&quot; ); public static void main(String[] args) &#123; AdAccount account = new AdAccount(&quot;act_&#123;your-adaccount-id&#125;&quot;, context); try &#123; APINodeList&lt;Campaign&gt; campaigns = account.getCampaigns().requestAllFields().execute(); for(Campaign campaign : campaigns) &#123; System.out.println(campaign.getFieldName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行java文件既可发布请求到facebook服务器， 需要安全上网 1、主页推广根据提示一步一步提交，到 沙盒账号，如果之前没有添加则新建，要推广的主页，如果无则新建 到下载示例代码，点下载，将会获得一个java文件，里面含有accessToken、appid、ad_account_id、app_secret等信息，将该下载的SAMPLE_CODE.java文件放于与上面两个java文件同级目录，直接运行该java文件即可，注意此时电脑需要科学上网，不然会报错Timeout]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[facebook sdk 集成]]></title>
    <url>%2Fblog%2F2019%2F06%2Ffacebook-sdk-%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[Facebook sdk 集成首先需要在facebook注册一个账号，自通过账号进入facebook的开发者平台 创建应用，只需要填写应用名即可，回生成一个appid。 集成事件功能1、配置远端maven仓库地址 在项目android/build.gradle文件123456789101112131415buildscript&#123; repositories&#123; ... mavenCentral(); // 添加这行 &#125;&#125;allprojects&#123; repositories &#123; ... mavenCentral() // 添加这行 &#125;&#125; 2、添加依赖在app/build.gradle文件中添加依赖123456dependencies&#123; ... implementation &apos;com.facebook.android:facebook-android-sdk:[4,5)&apos; // 添加这行 // 最新sdk版本为 implementation &apos;com.facebook.android:facebook-android-sdk:[5,6)&apos; &#125; 3、添加facebook-app-id在res/values/string.xml中1234&lt;string name=&quot;facebook_app_id&quot;&gt;462119014332748&lt;/string&gt; &lt;string name=&quot;fb_login_protocol_scheme&quot;&gt;fb462119014332748&lt;/string&gt;// 462119014332748为你在facebook应用的appid// fb_login_protocol_scheme应该是用于登陆的 在/app/manifest/AndroidManifest.xml中12345678910111213141516&lt;application&gt; &lt;meta-data android:name=&quot;com.facebook.sdk.ApplicationId&quot; android:value=&quot;@string/facebook_app_id&quot;/&gt; &lt;activity android:name=&quot;com.facebook.FacebookActivity&quot; android:configChanges= &quot;keyboard|keyboardHidden|screenLayout|screenSize|orientation&quot; android:label=&quot;@string/app_name&quot; /&gt; &lt;activity android:name=&quot;com.facebook.CustomTabActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;@string/fb_login_protocol_scheme&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 4、在facebook开发者控制台配置analytics sdk在facebook开发者官网，点击「我的应用」即可进入应用控制台，可以创建应用，只需提供应用名，以及邮箱即可， 点击单个应用即可进入应用控制台进行编辑;上图是应用可添加的功能， 点击Analytics即将功能添加进应用，点设置，前几步都是提示，第四步，填入应用id，app/build.gradle中的applicationid，以及应用默认启动的Actiivty， 第五步，填入密钥散列，注意应该要填入两个，一个开发、一个发布，即debug自带的、一个release时通过jks文件签名生成的。获取方法12345// macos debug ，按下enter键需要输入开机密码keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64// release keytool -exportcert -alias YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl base64 5、发送事件 上面的1、2、3都只是基本配置，下面是手动发送事件 在MainApplication.java中FacebookSdk.sdkInitialize 四个初始化方法都已被遗弃， 看到说是不需要初始化了 在MainApplication.java中 12345678910@Override public void onCreate() &#123; super.onCreate(); // facebook 初始化 FacebookSdk.setIsDebugEnabled(true); AppEventsLogger.activateApp(MainApplication.this); FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS); &#125; 注意facebooksdk回自动收集一些事件,如果不需要自动收集功能需要在清单文件中配置 1234&lt;meta-data android:name=&quot;com.facebook.sdk.AutoLogAppEventsEnabled&quot; android:value=&quot;false&quot;/&gt; 在Actiivty中测试发送自定义事件 123456789101112@Overrideprotected void onResume() &#123; super.onResume(); logEvent();&#125;private void logEvent() &#123; Log.d(&quot;========&quot;, &quot;logEvent&quot;); AppEventsLogger logger = AppEventsLogger.newLogger(this); logger.logEvent(AppEventsConstants.EVENT_NAME_ACTIVATED_APP); logger.logEvent(&quot;Test Event&quot;);&#125; 在测试时发现，当打断点调试时发现，发送事件总是会失败，正常运行却可以在facebook分析工具中看得到提交的事件。 注意，运行时手机需要能连接到facebook后台服务器，大陆用户需要科学上网。]]></content>
      <tags>
        <tag>facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android okHttp3]]></title>
    <url>%2Fblog%2F2019%2F06%2Fandroid-okHttp3.html</url>
    <content type="text"><![CDATA[OkHttp3使用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode的常用插件与插件开发]]></title>
    <url>%2Fblog%2F2019%2F04%2Fvscode%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[Visual Studio Code（VS code）是开发神器，通过插件配置不仅可以开发前端，还可以开发后端(java/go等)，下面介绍一下vscode的常用插件与插件如何开发一个自己的插件。 nodejs123456curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash. ~/.bashrc#显示有远端的版本nvm ls-remote#安装对应的版本nvm install 对应的版本 安装常用工具： 1234567891011npm install hexo-cli -gnpm install hexo-server -gnpm install hexo-deployer-git -gnpm install yarn -gnpm install http-server -gyarn global add servenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --globalyarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 常用插件安装以下插件：12345678910111213141516171819202122232425262728293031323334#javascripteslintColor PickernpmDebugger for ChromeEclipse Keymap#reactES7 React/Redux/GraphQL/React-Native snippets#vueVeturVue VSCode Snippets#gitGitLenszerofinance-git#其他公共插件Local HistoryXML ToolsPrettier#https://zhuanlan.zhihu.com/p/54031899koroFileHeaderAutoFileNameImport Cost#javaJava Extension PackSpring Boot Extension PackJava Code GeneratorsDocker#android/ios pluginAndroid iOS EmulatorReact Native Tools#see debug:https://github.com/Microsoft/vscode-react-native/blob/master/doc/debugging.md#debugging-on-ios-device#Install ios-deploy: npm install -g ios-deploy 代码注释koroFileHeader添加注释，在全局的settings.json中添加： 参考： https://code.visualstudio.com/docs/editor/emmet https://www.cnblogs.com/summit7ca/p/6944215.html 12345678910111213141516171819202122232425262728"editor.fontSize": 14,"terminal.integrated.fontSize": 14,"emmet.triggerExpansionOnTab": true,"emmet.includeLanguages": &#123; "javascript": "javascriptreact", "vue-html": "html", "razor": "html", "plaintext": "jade"&#125;,// 注释"fileheader.configObj": &#123; // 将该选项设置为true即可开启 "autoAdd": false&#125;,// 头部注释"fileheader.customMade": &#123; "Author": "dave.zhao", "Date": "Do not edit", "LastEditors": "dave.zhao", "LastEditTime": "Do not edit", "Description": ""&#125;,// 函数注释"fileheader.cursorMode": &#123; "Date": "Do not edit", "description": "", "param": ""&#125; 注意：Author和LastEditors填写自己的名字 文件头注释快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i 函数注释快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t 常用配置可以放在全局的settings.json中，也可以放在各个项目的settings.json中： 1234567891011121314151617181920&#123; "eslint.validate": ["javascript", "javascriptreact"], "javascript.updateImportsOnFileMove.enabled": "always", // 代码缩进修改成4个空格 "editor.detectIndentation": false, "editor.tabSize": 4, "editor.formatOnSave": true, // 每次保存的时候将代码按eslint格式进行修复 "eslint.autoFixOnSave": true, // 让prettier使用eslint的代码格式进行校验 "prettier.eslintIntegration": true, // 去掉代码结尾的分号 "prettier.semi": false, // 使用带引号替代双引号 "prettier.singleQuote": true, "prettier.tabWidth": 4, "prettier.printWidth": 250, // 让函数(名)和后面的括号之间加个空格 "javascript.format.insertSpaceBeforeFunctionParenthesis": true&#125; 插件开发参考代码https://github.com/zhaoxunyong/vs-code-git-plugin 参考 https://segmentfault.com/a/1190000008968904 https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://github.com/steveukx/git-js https://www.jianshu.com/p/2b096d8ad9b8 https://github.com/Microsoft/vscode-extension-samples https://www.jianshu.com/p/520c575e91c3 https://segmentfault.com/a/1190000017279102 https://segmentfault.com/a/1190000014758981 https://dev.azure.com/it0815/_usersSettings/tokensteh2foynynfdqzxhwe3xqchgkno42yz7h4ergheqhjushrnqtfnq https://www.cnblogs.com/liuxianan/p/vscode-plugin-publish.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html https://www.cnblogs.com/virde/p/vscode-extension-input-and-output.html http://nodejs.cn/api/fs.html#fs_fs_unlinksync_path]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
